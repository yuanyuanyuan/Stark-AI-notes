# 水印产品开发启动指南

## 🚀 立即开始开发

基于PRD澄清和技术可行性验证，现在可以立即启动水印产品开发。本指南提供从零到MVP的完整启动方案。

---

## 📋 开发前准备清单

### ✅ 已完成工作
- [x] PRD澄清问题全部解决
- [x] 技术可行性100%验证通过
- [x] 技术架构方案确定
- [x] 性能基准测试完成
- [x] 风险评估和应对策略

### 🎯 立即启动条件
- [x] 技术方案已确认可行
- [x] 开发时间线已制定
- [x] 验收标准已明确
- [x] 风险缓解措施已准备

---

## 🏗️ 项目初始化

### 1. 项目结构创建
```bash
# 创建项目目录
mkdir watermark-app
cd watermark-app

# 基础结构
mkdir -p src/{core,ui,utils,workers}
mkdir -p tests/{unit,integration}
mkdir -p docs/{api,user}
```

### 2. 基础文件创建
```
watermark-app/
├── index.html              # 主入口
├── src/
│   ├── core/
│   │   ├── FileProcessor.js   # 文件处理
│   │   ├── WatermarkEngine.js # 水印引擎
│   │   └── CertificateManager.js # 证书管理
│   ├── ui/
│   │   ├── UploadInterface.js  # 上传界面
│   │   ├── PreviewInterface.js # 预览界面
│   │   └── DownloadInterface.js # 下载界面
│   ├── utils/
│   │   ├── PerformanceMonitor.js # 性能监控
│   │   └── BrowserCompat.js      # 兼容性处理
│   └── workers/
│       └── WatermarkWorker.js    # Web Worker
├── tests/
│   ├── unit/
│   └── integration/
├── docs/
│   ├── api.md
│   └── user-guide.md
└── package.json
```

### 3. 基础HTML模板
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>本地水印工具</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .upload-area { border: 2px dashed #ccc; padding: 40px; text-align: center; border-radius: 8px; }
        .result-area { margin-top: 20px; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>本地水印工具</h1>
        <div class="upload-area" id="uploadArea">
            <p>拖拽文件到这里或点击选择</p>
            <input type="file" id="fileInput" multiple accept="image/*,.pdf" style="display: none;">
        </div>
        <div class="result-area hidden" id="resultArea">
            <!-- 结果展示区域 -->
        </div>
    </div>
    <script type="module" src="src/main.js"></script>
</body>
</html>
```

---

## 📁 核心代码框架

### 1. 主入口文件 (src/main.js)
```javascript
import { FileProcessor } from './core/FileProcessor.js';
import { WatermarkEngine } from './core/WatermarkEngine.js';
import { CertificateManager } from './core/CertificateManager.js';
import { PerformanceMonitor } from './utils/PerformanceMonitor.js';

class WatermarkApp {
    constructor() {
        this.fileProcessor = new FileProcessor();
        this.watermarkEngine = new WatermarkEngine();
        this.certificateManager = new CertificateManager();
        this.monitor = new PerformanceMonitor();
    }

    async init() {
        await this.checkBrowserCompatibility();
        this.setupEventListeners();
    }

    async checkBrowserCompatibility() {
        const requiredAPIs = [
            'FileReader',
            'CanvasRenderingContext2D', 
            'crypto.subtle',
            'indexedDB'
        ];

        const unsupported = requiredAPIs.filter(api => 
            !window[api] && !window.crypto?.subtle
        );

        if (unsupported.length > 0) {
            this.showError('浏览器不支持必要功能，请升级浏览器');
            return false;
        }
        return true;
    }

    setupEventListeners() {
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => e.preventDefault());
        uploadArea.addEventListener('drop', (e) => this.handleFileDrop(e));
        fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
    }

    async handleFileDrop(e) {
        e.preventDefault();
        const files = Array.from(e.dataTransfer.files);
        await this.processFiles(files);
    }

    async handleFileSelect(e) {
        const files = Array.from(e.target.files);
        await this.processFiles(files);
    }

    async processFiles(files) {
        this.monitor.start();
        
        try {
            const results = await Promise.all(
                files.map(file => this.processSingleFile(file))
            );
            
            this.displayResults(results);
        } catch (error) {
            console.error('处理文件时出错:', error);
            this.showError('处理文件失败，请重试');
        } finally {
            this.monitor.end();
        }
    }

    async processSingleFile(file) {
        const processed = await this.fileProcessor.process(file);
        const watermarked = await this.watermarkEngine.addWatermark(processed);
        const certificate = await this.certificateManager.generate(watermarked);
        
        return { file, watermarked, certificate };
    }

    displayResults(results) {
        const resultArea = document.getElementById('resultArea');
        resultArea.classList.remove('hidden');
        
        // 结果展示逻辑
        resultArea.innerHTML = results.map(result => `
            <div class="result-item">
                <h3>${result.file.name}</h3>
                <img src="${result.watermarked.dataUrl}" style="max-width: 300px;">
                <p>证书: ${result.certificate.hash}</p>
                <a href="${result.watermarked.downloadUrl}" download="watermarked_${result.file.name}">下载</a>
            </div>
        `).join('');
    }

    showError(message) {
        alert(message);
    }
}

// 初始化应用
const app = new WatermarkApp();
app.init();
```

### 2. 文件处理器 (src/core/FileProcessor.js)
```javascript
export class FileProcessor {
    async process(file) {
        const startTime = performance.now();
        
        try {
            // 文件验证
            this.validateFile(file);
            
            // 读取文件
            const arrayBuffer = await this.readFile(file);
            
            // 根据文件类型处理
            let processed;
            if (file.type.startsWith('image/')) {
                processed = await this.processImage(arrayBuffer, file.type);
            } else if (file.type === 'application/pdf') {
                processed = await this.processPDF(arrayBuffer);
            }
            
            return {
                original: file,
                data: processed,
                metadata: {
                    size: file.size,
                    type: file.type,
                    lastModified: file.lastModified,
                    processingTime: performance.now() - startTime
                }
            };
        } catch (error) {
            throw new Error(`文件处理失败: ${error.message}`);
        }
    }

    validateFile(file) {
        const maxSize = 50 * 1024 * 1024; // 50MB
        const supportedTypes = [
            'image/jpeg', 'image/png', 'image/gif', 'image/webp',
            'application/pdf'
        ];

        if (file.size > maxSize) {
            throw new Error('文件过大，最大支持50MB');
        }

        if (!supportedTypes.includes(file.type)) {
            throw new Error('不支持的文件格式');
        }
    }

    async readFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsArrayBuffer(file);
        });
    }

    async processImage(arrayBuffer, mimeType) {
        const blob = new Blob([arrayBuffer], { type: mimeType });
        const img = new Image();
        
        return new Promise((resolve, reject) => {
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                resolve({
                    canvas,
                    originalImage: img,
                    mimeType
                });
            };
            img.onerror = reject;
            img.src = URL.createObjectURL(blob);
        });
    }

    async processPDF(arrayBuffer) {
        // 简化版PDF处理，实际项目中可使用pdf.js
        throw new Error('PDF处理功能将在后续版本支持');
    }
}
```

### 3. 水印引擎 (src/core/WatermarkEngine.js)
```javascript
export class WatermarkEngine {
    constructor() {
        this.defaultSettings = {
            text: '水印保护',
            fontSize: 48,
            fontFamily: 'Arial',
            color: 'rgba(255, 255, 255, 0.5)',
            position: 'center',
            rotation: -45
        };
    }

    async addWatermark(processedFile, settings = {}) {
        const config = { ...this.defaultSettings, ...settings };
        const { canvas, originalImage } = processedFile.data;
        
        const watermarkedCanvas = this.createWatermarkedCanvas(
            canvas, 
            config, 
            originalImage.width, 
            originalImage.height
        );
        
        return {
            canvas: watermarkedCanvas,
            dataUrl: watermarkedCanvas.toDataURL('image/jpeg', 0.9),
            downloadUrl: watermarkedCanvas.toDataURL('image/jpeg', 1.0)
        };
    }

    createWatermarkedCanvas(canvas, config, width, height) {
        const newCanvas = document.createElement('canvas');
        newCanvas.width = width;
        newCanvas.height = height;
        
        const ctx = newCanvas.getContext('2d');
        
        // 复制原图
        ctx.drawImage(canvas, 0, 0);
        
        // 添加水印
        ctx.font = `${config.fontSize}px ${config.fontFamily}`;
        ctx.fillStyle = config.color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // 旋转和定位
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.rotate(config.rotation * Math.PI / 180);
        ctx.fillText(config.text, 0, 0);
        ctx.restore();
        
        return newCanvas;
    }
}
```

### 4. 证书管理器 (src/core/CertificateManager.js)
```javascript
export class CertificateManager {
    constructor() {
        this.dbName = 'WatermarkCertificates';
        this.storeName = 'certificates';
        this.initDB();
    }

    async initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
                }
            };
        });
    }

    async generate(watermarkedFile, originalFile) {
        const metadata = {
            originalName: originalFile.name,
            originalSize: originalFile.size,
            originalType: originalFile.type,
            processedTime: new Date().toISOString(),
            watermarkText: '水印保护',
            algorithm: 'SHA-256'
        };

        const dataToHash = JSON.stringify(metadata) + watermarkedFile.dataUrl;
        const hashBuffer = await crypto.subtle.digest('SHA-256', 
            new TextEncoder().encode(dataToHash));
        
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

        const certificate = {
            id: crypto.randomUUID(),
            metadata,
            hash: hashHex,
            timestamp: Date.now(),
            createdAt: new Date().toISOString()
        };

        await this.saveCertificate(certificate);
        return certificate;
    }

    async saveCertificate(certificate) {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        return store.add(certificate);
    }

    async getCertificate(id) {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        return store.get(id);
    }

    async getAllCertificates() {
        const transaction = this.db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        return store.getAll();
    }
}
```

---

## 🧪 测试框架

### 1. 单元测试模板 (tests/unit/WatermarkEngine.test.js)
```javascript
import { WatermarkEngine } from '../../src/core/WatermarkEngine.js';

describe('WatermarkEngine', () => {
    let engine;

    beforeEach(() => {
        engine = new WatermarkEngine();
    });

    test('应该正确添加文字水印', async () => {
        // 测试代码
    });

    test('应该处理不同尺寸的图片', async () => {
        // 测试代码
    });

    test('应该保持图片质量', async () => {
        // 测试代码
    });
});
```

### 2. 性能测试 (tests/integration/Performance.test.js)
```javascript
import { PerformanceMonitor } from '../../src/utils/PerformanceMonitor.js';

describe('Performance Tests', () => {
    test('1MB文件处理时间应小于3秒', async () => {
        const file = createTestFile(1024 * 1024); // 1MB
        const startTime = performance.now();
        
        await processFile(file);
        
        const duration = performance.now() - startTime;
        expect(duration).toBeLessThan(3000);
    });

    test('50MB文件处理时间应小于15秒', async () => {
        const file = createTestFile(50 * 1024 * 1024); // 50MB
        const startTime = performance.now();
        
        await processFile(file);
        
        const duration = performance.now() - startTime;
        expect(duration).toBeLessThan(15000);
    });
});
```

---

## 📈 开发进度跟踪

### 每日开发检查表

**第1天：项目初始化**
- [ ] 创建项目目录结构
- [ ] 搭建基础HTML框架
- [ ] 实现文件选择和拖拽
- [ ] 验证浏览器兼容性

**第2-3天：核心功能**
- [ ] 完成FileProcessor.js
- [ ] 实现基础水印添加
- [ ] 添加性能监控
- [ ] 单元测试编写

**第4-5天：证书系统**
- [ ] 完成CertificateManager.js
- [ ] 实现SHA-256哈希
- [ ] IndexedDB集成
- [ ] 证书验证功能

**第6-7天：UI完善**
- [ ] 完成UI界面
- [ ] 响应式设计
- [ ] 用户体验优化
- [ ] 集成测试

### 周度评审检查点

**第1周结束检查**:
- [ ] 核心功能100%可用
- [ ] 性能测试通过
- [ ] 浏览器兼容性验证
- [ ] 代码审查完成

**第2周结束检查**:
- [ ] UI界面完成
- [ ] 性能优化完成
- [ ] 最终测试通过
- [ ] 文档更新完成

---

## 🎯 成功标准

### 功能完成标准
- [ ] 支持JPEG、PNG格式
- [ ] 文字水印可自定义
- [ ] 证书自动生成
- [ ] 本地存储证书
- [ ] 一键下载处理结果

### 性能标准
- [ ] 1MB文件≤3秒处理
- [ ] 50MB文件≤15秒处理
- [ ] 内存使用≤1GB峰值
- [ ] 浏览器兼容性≥95%

### 质量标准
- [ ] 代码覆盖率≥80%
- [ ] 零崩溃率
- [ ] 用户界面友好
- [ ] 错误处理完善

---

## 🆘 开发支持资源

### 快速参考
- **技术文档**：prd-feasibility-check.md
- **需求文档**：prd-clarified.md
- **测试方案**：prd-questionnaire.md
- **性能基准**：已验证数据

### 技术支持
- **浏览器API文档**：MDN Web Docs
- **Canvas教程**：HTML5 Canvas教程
- **Web Crypto指南**：W3C规范
- **性能优化**：Chrome DevTools指南

### 应急联系
- **技术难题**：查看prd-feasibility-check.md中的解决方案
- **性能问题**：参考性能基准测试数据
- **浏览器兼容**：使用降级方案模板

---

**🚀 现在可以立即开始开发！所有技术验证完成，方案就绪。**