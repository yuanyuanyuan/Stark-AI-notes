# æ°´å°äº§å“å®æ–½è·¯çº¿å›¾ ğŸ—ºï¸

## ğŸ¯ é¡¹ç›®é‡Œç¨‹ç¢‘

### é‡Œç¨‹ç¢‘1: ç¯å¢ƒå‡†å¤‡ (ç¬¬1å¤©)
**æ—¶é—´**: 2025-08-25 ä¸Šåˆ
**ç›®æ ‡**: å®Œæ•´çš„å¼€å‘ç¯å¢ƒæ­å»º
**éªŒæ”¶æ ‡å‡†**: å›¢é˜Ÿå¯åœ¨æœ¬åœ°è¿è¡Œé¡¹ç›®

#### å…·ä½“ä»»åŠ¡
```bash
# 1. é¡¹ç›®åˆå§‹åŒ–
npm create vite@latest watermark-app --template react-ts
cd watermark-app
npm install

# 2. æ ¸å¿ƒä¾èµ–å®‰è£…
npm install -D typescript @types/react @types/node
npm install -D tailwindcss postcss autoprefixer
npm install -D @vitejs/plugin-react
npm install -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm install -D prettier eslint-config-prettier

# 3. é…ç½®åˆå§‹åŒ–
npx tailwindcss init -p
npx eslint --init
```

#### é¡¹ç›®ç»“æ„å»ºç«‹
```
watermark-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ WatermarkPanel/
â”‚   â”‚   â”œâ”€â”€ ImagePreview/
â”‚   â”‚   â”œâ”€â”€ FileUploader/
â”‚   â”‚   â””â”€â”€ CertificateValidator/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ WatermarkEngine.ts
â”‚   â”‚   â”œâ”€â”€ CertificateService.ts
â”‚   â”‚   â””â”€â”€ PerformanceService.ts
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ fileUtils.ts
â”‚   â”‚   â”œâ”€â”€ canvasUtils.ts
â”‚   â”‚   â””â”€â”€ validation.ts
â”‚   â”œâ”€â”€ workers/
â”‚   â”‚   â””â”€â”€ watermark.worker.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ watermark.types.ts
â”‚   â”œâ”€â”€ styles/
â”‚   â”‚   â””â”€â”€ globals.css
â”‚   â””â”€â”€ App.tsx
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â””â”€â”€ e2e/
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ API.md
â”‚   â””â”€â”€ DEPLOYMENT.md
â””â”€â”€ .github/workflows/
    â”œâ”€â”€ ci.yml
    â””â”€â”€ deploy.yml
```

### é‡Œç¨‹ç¢‘2: æ ¸å¿ƒå¼•æ“å¼€å‘ (ç¬¬1-3å¤©)
**æ—¶é—´**: 2025-08-25 ä¸‹åˆ - 2025-08-27
**ç›®æ ‡**: å®Œæˆæ°´å°æ¸²æŸ“å¼•æ“
**éªŒæ”¶æ ‡å‡†**: æ”¯æŒæ–‡å­—å’Œå›¾ç‰‡æ°´å°æ¸²æŸ“

#### ç¬¬1å¤©ä¸‹åˆï¼šæ–‡å­—æ°´å°å¼•æ“
```typescript
// services/TextWatermarkEngine.ts
export class TextWatermarkEngine {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;

  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d')!;
  }

  async renderTextWatermark(
    image: HTMLImageElement,
    config: TextWatermarkConfig
  ): Promise<Blob> {
    this.canvas.width = image.width;
    this.canvas.height = image.height;
    
    // ç»˜åˆ¶åŸå›¾
    this.ctx.drawImage(image, 0, 0);
    
    // é…ç½®æ–‡å­—æ ·å¼
    this.ctx.font = `${config.fontSize}px ${config.fontFamily}`;
    this.ctx.fillStyle = config.color;
    this.ctx.globalAlpha = config.opacity / 100;
    
    // è®¡ç®—ä½ç½®å¹¶ç»˜åˆ¶
    const position = this.calculatePosition(config.position, image.width, image.height);
    this.ctx.fillText(config.text, position.x, position.y);
    
    return new Promise(resolve => {
      this.canvas.toBlob(resolve, 'image/jpeg', 0.9);
    });
  }
}
```

#### ç¬¬2å¤©ï¼šå›¾ç‰‡æ°´å°å¼•æ“
```typescript
// services/ImageWatermarkEngine.ts
export class ImageWatermarkEngine {
  async renderImageWatermark(
    baseImage: HTMLImageElement,
    watermarkImage: HTMLImageElement,
    config: ImageWatermarkConfig
  ): Promise<Blob> {
    const canvas = new OffscreenCanvas(baseImage.width, baseImage.height);
    const ctx = canvas.getContext('2d')!;
    
    // ç»˜åˆ¶åŸºç¡€å›¾ç‰‡
    ctx.drawImage(baseImage, 0, 0);
    
    // è®¡ç®—æ°´å°å°ºå¯¸å’Œä½ç½®
    const { width, height, x, y } = this.calculateWatermarkDimensions(
      baseImage,
      watermarkImage,
      config
    );
    
    // è®¾ç½®åˆæˆæ¨¡å¼
    ctx.globalAlpha = config.opacity / 100;
    ctx.globalCompositeOperation = config.blendMode;
    
    // ç»˜åˆ¶æ°´å°
    ctx.drawImage(watermarkImage, x, y, width, height);
    
    return canvas.convertToBlob({ type: 'image/jpeg', quality: 0.9 });
  }
}
```

#### ç¬¬3å¤©ï¼šå¼•æ“é›†æˆæµ‹è¯•
```typescript
// tests/unit/watermark-engine.test.ts
describe('WatermarkEngine', () => {
  let textEngine: TextWatermarkEngine;
  let imageEngine: ImageWatermarkEngine;

  beforeEach(() => {
    textEngine = new TextWatermarkEngine();
    imageEngine = new ImageWatermarkEngine();
  });

  it('should render text watermark correctly', async () => {
    const result = await textEngine.renderTextWatermark(testImage, {
      text: 'Test Watermark',
      fontSize: 24,
      color: '#000000',
      opacity: 50,
      position: 'bottom-right'
    });
    
    expect(result).toBeInstanceOf(Blob);
    expect(result.type).toBe('image/jpeg');
  });
});
```

### é‡Œç¨‹ç¢‘3: ç”¨æˆ·ç•Œé¢å¼€å‘ (ç¬¬4-5å¤©)
**æ—¶é—´**: 2025-08-28 - 2025-08-29
**ç›®æ ‡**: å®Œæ•´çš„ç”¨æˆ·æ“ä½œç•Œé¢
**éªŒæ”¶æ ‡å‡†**: ç›´è§‚æ˜“ç”¨çš„äº¤äº’ä½“éªŒ

#### ç¬¬4å¤©ï¼šæ ¸å¿ƒç•Œé¢ç»„ä»¶
```typescript
// components/WatermarkPanel.tsx
export const WatermarkPanel: React.FC = () => {
  const [image, setImage] = useState<HTMLImageElement | null>(null);
  const [config, setConfig] = useState<WatermarkConfig>(defaultConfig);
  const [preview, setPreview] = useState<string | null>(null);

  const handleImageUpload = async (file: File) => {
    const img = await loadImage(file);
    setImage(img);
    generatePreview(img, config);
  };

  const generatePreview = useCallback(async (img: HTMLImageElement, cfg: WatermarkConfig) => {
    const blob = await watermarkEngine.render(img, cfg);
    const url = URL.createObjectURL(blob);
    setPreview(url);
  }, [image, config]);

  return (
    <div className="watermark-panel">
      <FileUploader onUpload={handleImageUpload} />
      <ConfigPanel config={config} onChange={setConfig} />
      <ImagePreview src={preview} />
      <DownloadButton onDownload={handleDownload} />
    </div>
  );
};
```

### é‡Œç¨‹ç¢‘4: è¯ä¹¦ç³»ç»Ÿå¼€å‘ (ç¬¬1å¤©)
**æ—¶é—´**: 2025-09-01
**ç›®æ ‡**: SHA-256è¯ä¹¦ç”Ÿæˆä¸éªŒè¯
**éªŒæ”¶æ ‡å‡†**: å¯é çš„æ°´å°éªŒè¯æœºåˆ¶

#### è¯ä¹¦ç”ŸæˆæœåŠ¡
```typescript
// services/CertificateService.ts
export class CertificateService {
  async generateCertificate(
    originalFile: File,
    watermarkConfig: WatermarkConfig
  ): Promise<Certificate> {
    const fileBuffer = await originalFile.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', fileBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    return {
      fileHash: hashHex,
      watermarkConfig: watermarkConfig,
      timestamp: Date.now(),
      version: '1.0.0'
    };
  }

  async verifyCertificate(
    file: File,
    certificate: Certificate
  ): Promise<VerificationResult> {
    const currentHash = await this.calculateFileHash(file);
    
    return {
      isValid: currentHash === certificate.fileHash,
      originalHash: certificate.fileHash,
      currentHash: currentHash,
      timestamp: certificate.timestamp,
      message: currentHash === certificate.fileHash 
        ? 'æ–‡ä»¶éªŒè¯é€šè¿‡' 
        : 'æ–‡ä»¶å·²è¢«ä¿®æ”¹'
    };
  }
}
```

### é‡Œç¨‹ç¢‘5: æ€§èƒ½ä¼˜åŒ– (ç¬¬2å¤©)
**æ—¶é—´**: 2025-09-02
**ç›®æ ‡**: æ€§èƒ½è¾¾åˆ°éªŒæ”¶æ ‡å‡†
**éªŒæ”¶æ ‡å‡†**: 1MBæ–‡ä»¶å¤„ç†â‰¤3ç§’

#### WebWorkerå®ç°
```typescript
// workers/watermark.worker.ts
self.onmessage = async (e) => {
  const { imageData, config } = e.data;
  
  try {
    const processedImage = await processImageInWorker(imageData, config);
    self.postMessage({ success: true, data: processedImage });
  } catch (error) {
    self.postMessage({ success: false, error: error.message });
  }
};

async function processImageInWorker(imageData: ImageData, config: any) {
  const canvas = new OffscreenCanvas(imageData.width, imageData.height);
  const ctx = canvas.getContext('2d')!;
  
  ctx.putImageData(imageData, 0, 0);
  
  // åº”ç”¨æ°´å°é€»è¾‘...
  
  return await canvas.convertToBlob({ type: 'image/jpeg', quality: 0.9 });
}
```

#### å†…å­˜ç®¡ç†
```typescript
// utils/MemoryManager.ts
export class MemoryManager {
  private static canvasPool: OffscreenCanvas[] = [];
  private static maxPoolSize = 5;

  static getCanvas(width: number, height: number): OffscreenCanvas {
    const canvas = this.canvasPool.pop() || new OffscreenCanvas(width, height);
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }

  static releaseCanvas(canvas: OffscreenCanvas) {
    const ctx = canvas.getContext('2d');
    ctx?.clearRect(0, 0, canvas.width, canvas.height);
    
    if (this.canvasPool.length < this.maxPoolSize) {
      this.canvasPool.push(canvas);
    }
  }
}
```

### é‡Œç¨‹ç¢‘6: å…¼å®¹æ€§æµ‹è¯• (ç¬¬3-4å¤©)
**æ—¶é—´**: 2025-09-03 - 2025-09-04
**ç›®æ ‡**: ç¡®ä¿è·¨æµè§ˆå™¨ä¸€è‡´æ€§
**éªŒæ”¶æ ‡å‡†**: 3å¤§æµè§ˆå™¨100%åŠŸèƒ½é€šè¿‡

#### Playwrightæµ‹è¯•é…ç½®
```typescript
// tests/e2e/compatibility.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Watermark App Compatibility', () => {
  test('should work on Chrome', async ({ page }) => {
    await page.goto('/');
    
    await page.setInputFiles('input[type="file"]', 'test-image.jpg');
    await page.fill('input[placeholder="æ°´å°æ–‡å­—"]', 'Test Watermark');
    await page.click('button:has-text("ç”Ÿæˆæ°´å°")');
    
    await expect(page.locator('.preview-image')).toBeVisible();
  });

  test('should work on Firefox', async ({ page }) => {
    // ç›¸åŒçš„æµ‹è¯•é€»è¾‘ï¼ŒéªŒè¯Firefoxå…¼å®¹æ€§
  });

  test('should work on Safari', async ({ page }) => {
    // ç›¸åŒçš„æµ‹è¯•é€»è¾‘ï¼ŒéªŒè¯Safariå…¼å®¹æ€§
  });
});
```

### é‡Œç¨‹ç¢‘7: è´¨é‡ä¿éšœä¸å‘å¸ƒ (ç¬¬5å¤©)
**æ—¶é—´**: 2025-09-05
**ç›®æ ‡**: é¡¹ç›®äº¤ä»˜å°±ç»ª
**éªŒæ”¶æ ‡å‡†**: æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼Œæ–‡æ¡£å®Œæ•´

#### æµ‹è¯•å¥—ä»¶
```typescript
// tests/unit/performance.test.ts
describe('Performance Tests', () => {
  it('should process 1MB image within 3 seconds', async () => {
    const startTime = Date.now();
    const result = await watermarkEngine.process(testImage1MB, config);
    const processTime = Date.now() - startTime;
    
    expect(processTime).toBeLessThan(3000);
  });

  it('should use less than 100MB memory', async () => {
    const initialMemory = performance.memory.usedJSHeapSize;
    await watermarkEngine.process(testImage1MB, config);
    const finalMemory = performance.memory.usedJSHeapSize;
    
    expect(finalMemory - initialMemory).toBeLessThan(100 * 1024 * 1024);
  });
});
```

#### éƒ¨ç½²é…ç½®
```yaml
# .github/workflows/deploy.yml
name: Deploy to GitHub Pages
on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run test
      - run: npm run build
      - uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
```

## ğŸ“Š é£é™©æ§åˆ¶ç‚¹

### é«˜é£é™©è¯†åˆ«
1. **WebWorkerå…¼å®¹æ€§** (æ¦‚ç‡: 20%)
   - ç¼“è§£æªæ–½ï¼šä¸»çº¿ç¨‹é™çº§æ–¹æ¡ˆ
   - ç›‘æ§æŒ‡æ ‡ï¼šæµè§ˆå™¨æ”¯æŒç‡

2. **å¤§æ–‡ä»¶å†…å­˜æ³„æ¼** (æ¦‚ç‡: 15%)
   - ç¼“è§£æªæ–½ï¼šå†…å­˜æ± ç®¡ç†
   - ç›‘æ§æŒ‡æ ‡ï¼šå†…å­˜ä½¿ç”¨ç‡

3. **Canvasæ€§èƒ½ç“¶é¢ˆ** (æ¦‚ç‡: 10%)
   - ç¼“è§£æªæ–½ï¼šåˆ†å—å¤„ç†ç®—æ³•
   - ç›‘æ§æŒ‡æ ‡ï¼šå¤„ç†æ—¶é—´

### æ¯æ—¥æ£€æŸ¥ç‚¹
- **ä¸Šåˆ10:00**: å›¢é˜Ÿç«™ä¼šï¼Œé˜»å¡é—®é¢˜è¯†åˆ«
- **ä¸‹åˆ16:00**: è¿›åº¦å®¡æŸ¥ï¼Œé£é™©é¢„è­¦
- **æ™šä¸Š18:00**: ä»£ç æäº¤ï¼ŒCI/CDéªŒè¯

## ğŸš€ å¯åŠ¨æ£€æŸ¥æ¸…å•

### å¼€å‘ç¯å¢ƒå‡†å¤‡
- [ ] Node.js 18+ å·²å®‰è£…
- [ ] Gitä»“åº“å·²å…‹éš†
- [ ] ä¾èµ–åŒ…å·²å®‰è£… (`npm install`)
- [ ] å¼€å‘æœåŠ¡å™¨å·²å¯åŠ¨ (`npm run dev`)

### ç¬¬ä¸€å¤©å¯åŠ¨ä»»åŠ¡
1. **9:00-9:30**: ç¯å¢ƒéªŒè¯å’Œé¡¹ç›®åˆå§‹åŒ–
2. **9:30-10:00**: å›¢é˜ŸæŠ€æœ¯æ–¹æ¡ˆç¡®è®¤
3. **10:00-12:00**: åŸºç¡€æ¡†æ¶æ­å»ºå®Œæˆ
4. **14:00-18:00**: ç¬¬ä¸€ä¸ªåŠŸèƒ½æ¨¡å—å¼€å‘

---

**ğŸ¯ ç«‹å³è¡ŒåŠ¨æŒ‡å—**
1. ç¡®è®¤å›¢é˜Ÿæˆå‘˜å’Œè§’è‰²åˆ†é…
2. éªŒè¯æ‰€æœ‰å¼€å‘ç¯å¢ƒä¾èµ–
3. å¼€å§‹ç¬¬ä¸€å¤©çš„å¼€å‘ä»»åŠ¡
4. å»ºç«‹æ¯æ—¥è¿›åº¦è¿½è¸ªæœºåˆ¶

**ğŸ“ é¡¹ç›®æ”¯æŒ**
- æŠ€æœ¯è´Ÿè´£äººï¼š[å¾…åˆ†é…]
- é¡¹ç›®åè°ƒï¼š[å¾…åˆ†é…]
- ç´§æ€¥è”ç³»ï¼š[å¾…æ·»åŠ ]
- çŠ¶æ€æ›´æ–°ï¼šæ¯æ—¥18:00è‡ªåŠ¨åŒæ­¥