# 水印产品技术规格说明书

## 🏗️ 系统架构设计

### 整体架构图
```
┌─────────────────────────────────────────────────────────┐
│                    用户界面层                              │
│  React 18 + TypeScript + TailwindCSS                    │
├─────────────────────────────────────────────────────────┤
│                    业务逻辑层                              │
│  水印引擎 → 证书系统 → 性能优化 → 兼容性处理              │
├─────────────────────────────────────────────────────────┤
│                    核心算法层                              │
│  Canvas API + Web Crypto API + File API + Web Workers    │
├─────────────────────────────────────────────────────────┤
│                    浏览器兼容性层                          │
│  特性检测 + Polyfill + 降级策略                          │
└─────────────────────────────────────────────────────────┘
```

## 🔧 详细技术规格

### 1. 水印渲染引擎

#### 1.1 文字水印引擎
```typescript
interface TextWatermarkConfig {
  text: string;
  fontSize: number;        // 8-72px
  fontFamily: string;      // 系统字体列表
  color: string;          // RGB/RGBA格式
  opacity: number;        // 0-100%
  position: PositionType; // 9宫格位置
  rotation: number;       // -180° to 180°
  stroke?: {
    color: string;
    width: number;
  };
  shadow?: {
    color: string;
    blur: number;
    offset: { x: number; y: number };
  };
}
```

**渲染算法**：
- 使用Canvas 2D Context的`fillText()`和`strokeText()`
- 文字抗锯齿：`ctx.imageSmoothingEnabled = true`
- 性能优化：离屏Canvas预渲染
- 内存管理：使用后立即清理Canvas引用

#### 1.2 图片水印引擎
```typescript
interface ImageWatermarkConfig {
  image: HTMLImageElement;
  scale: number;          // 10-200%
  opacity: number;        // 0-100%
  position: PositionType;
  rotation: number;
  blendMode: BlendMode;   // 正常/叠加/柔光等
}
```

**合成算法**：
```typescript
// 核心合成逻辑
ctx.globalAlpha = opacity;
ctx.globalCompositeOperation = blendMode;
ctx.drawImage(watermarkImage, x, y, width, height);
```

### 2. 证书验证系统

#### 2.1 SHA-256哈希计算
```typescript
class CertificateGenerator {
  async generateCertificate(
    originalFile: File,
    watermarkConfig: WatermarkConfig
  ): Promise<Certificate> {
    const fileBuffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', fileBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    return {
      fileHash: hashHex,
      watermarkConfig: watermarkConfig,
      timestamp: Date.now(),
      version: '1.0.0'
    };
  }
}
```

#### 2.2 证书数据结构
```typescript
interface Certificate {
  fileHash: string;           // SHA-256哈希值
  watermarkConfig: any;       // 水印配置快照
  timestamp: number;          // Unix时间戳
  version: string;           // 证书格式版本
  signature?: string;        // 可选的RSA签名
}

interface VerificationResult {
  isValid: boolean;
  originalHash: string;
  currentHash: string;
  timestamp: number;
  message: string;
}
```

### 3. 性能优化策略

#### 3.1 WebWorker实现
```typescript
// worker.ts
self.onmessage = async (e) => {
  const { imageData, watermarkConfig } = e.data;
  
  // 在Worker中处理图片，避免阻塞主线程
  const processedImage = await processImage(imageData, watermarkConfig);
  
  self.postMessage({ processedImage });
};

// 主线程使用
const worker = new Worker('/watermark-worker.js');
worker.postMessage({ imageData, config });
```

#### 3.2 内存优化
```typescript
class MemoryManager {
  private canvasPool: OffscreenCanvas[] = [];
  
  getCanvas(width: number, height: number): OffscreenCanvas {
    // 从池子中获取或创建新的Canvas
    const canvas = this.canvasPool.pop() || new OffscreenCanvas(width, height);
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
  
  releaseCanvas(canvas: OffscreenCanvas) {
    // 清理并重置Canvas
    const ctx = canvas.getContext('2d');
    ctx?.clearRect(0, 0, canvas.width, canvas.height);
    this.canvasPool.push(canvas);
  }
}
```

### 4. 浏览器兼容性

#### 4.1 特性检测矩阵
```typescript
interface BrowserSupport {
  canvas: boolean;
  webCrypto: boolean;
  fileApi: boolean;
  webWorkers: boolean;
  offscreenCanvas: boolean;
}

const checkBrowserSupport = (): BrowserSupport => {
  return {
    canvas: !!window.HTMLCanvasElement,
    webCrypto: !!window.crypto?.subtle,
    fileApi: !!(window.File && window.FileReader && window.FileList && window.Blob),
    webWorkers: !!window.Worker,
    offscreenCanvas: typeof OffscreenCanvas !== 'undefined'
  };
};
```

#### 4.2 降级策略
```typescript
class CompatibilityManager {
  private supports = checkBrowserSupport();
  
  async processImage(file: File, config: WatermarkConfig): Promise<Blob> {
    if (this.supports.offscreenCanvas && this.supports.webWorkers) {
      return this.processWithWorker(file, config);
    } else {
      return this.processWithMainThread(file, config);
    }
  }
  
  private processWithMainThread(file: File, config: WatermarkConfig): Promise<Blob> {
    // 主线程处理，适合不支持Worker的浏览器
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        // 处理逻辑...
        resolve(canvas.toBlob()!);
      };
      img.src = URL.createObjectURL(file);
    });
  }
}
```

## 📊 性能基准

### 性能指标
| 指标 | 目标值 | 测试方法 |
|------|--------|----------|
| 1MB文件处理时间 | ≤3秒 | Chrome DevTools Performance |
| 内存峰值使用 | ≤100MB | Chrome DevTools Memory |
| 首次加载时间 | ≤1秒 | Lighthouse |
| 并发处理能力 | 5个文件同时处理 | 自定义测试 |

### 测试场景
```typescript
const performanceTests = [
  {
    name: '1MB JPEG处理',
    fileSize: 1024 * 1024,
    format: 'image/jpeg',
    expectedTime: 3000 // 毫秒
  },
  {
    name: '5MB PNG处理',
    fileSize: 5 * 1024 * 1024,
    format: 'image/png',
    expectedTime: 8000 // 毫秒
  },
  {
    name: '批量处理',
    files: 5,
    size: 1024 * 1024,
    expectedTime: 15000 // 毫秒
  }
];
```

## 🔐 安全考虑

### 1. 数据安全
- **零服务器传输**：所有处理在浏览器端完成
- **内存清理**：处理后立即释放敏感数据
- **证书验证**：防止证书伪造和篡改

### 2. 输入验证
```typescript
class InputValidator {
  static validateFile(file: File): ValidationResult {
    const maxSize = 10 * 1024 * 1024; // 10MB
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    
    if (file.size > maxSize) {
      return { valid: false, error: '文件大小超过10MB限制' };
    }
    
    if (!allowedTypes.includes(file.type)) {
      return { valid: false, error: '不支持的文件格式' };
    }
    
    return { valid: true };
  }
  
  static validateWatermarkConfig(config: any): ValidationResult {
    // 验证配置参数范围
    if (config.opacity < 0 || config.opacity > 100) {
      return { valid: false, error: '透明度必须在0-100之间' };
    }
    
    return { valid: true };
  }
}
```

## 📁 文件结构规范

### 项目结构
```
src/
├── components/          # React组件
│   ├── WatermarkPanel/
│   ├── ImagePreview/
│   └── CertificateViewer/
├── services/           # 核心服务
│   ├── WatermarkEngine.ts
│   ├── CertificateService.ts
│   └── PerformanceService.ts
├── utils/              # 工具函数
│   ├── fileUtils.ts
│   ├── canvasUtils.ts
│   └── validation.ts
├── workers/            # Web Workers
│   └── watermark.worker.ts
└── types/              # TypeScript类型定义
    └── watermark.types.ts
```

### 命名规范
- **组件**：PascalCase (WatermarkPanel)
- **函数**：camelCase (processImage)
- **常量**：UPPER_SNAKE_CASE (MAX_FILE_SIZE)
- **文件**：kebab-case (watermark-engine.ts)

## 🚀 部署配置

### 构建配置
```javascript
// vite.config.ts
export default defineConfig({
  build: {
    target: ['chrome80', 'firefox75', 'safari13'],
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          utils: ['canvas-utils', 'file-utils']
        }
      }
    }
  },
  worker: {
    format: 'es'
  }
});
```

### CDN配置
```html
<!-- index.html -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="preload" href="/watermark-worker.js" as="worker">
<link rel="preload" href="/fonts/system-fonts.css" as="style">
```

---

**📋 开发检查清单**
- [ ] TypeScript类型定义完整
- [ ] 单元测试覆盖率≥80%
- [ ] 浏览器兼容性测试通过
- [ ] 性能基准测试达标
- [ ] 安全审查无漏洞
- [ ] 代码审查完成
- [ ] 文档编写完整

**🎯 技术栈确认**
- React 18.2.0
- TypeScript 5.0+
- Vite 4.0+
- TailwindCSS 3.0+
- 浏览器支持：Chrome 80+, Firefox 75+, Safari 13+