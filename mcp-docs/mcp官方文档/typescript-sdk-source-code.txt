{
  "size": {
    "tokens": 356413,
    "totalTokens": 356459,
    "characters": 1782295,
    "lines": 46521
  },
  "tree": {
    ".git-blame-ignore-revs": null,
    ".gitattributes": null,
    ".github": {
      "CODEOWNERS": null,
      "workflows": {
        "main.yml": null
      }
    },
    ".gitignore": null,
    ".npmrc": null,
    "CLAUDE.md": null,
    "CODE_OF_CONDUCT.md": null,
    "CONTRIBUTING.md": null,
    "LICENSE": null,
    "README.md": null,
    "SECURITY.md": null,
    "eslint.config.mjs": null,
    "jest.config.js": null,
    "package-lock.json": null,
    "package.json": null,
    "src": {
      "__mocks__": {
        "pkce-challenge.ts": null
      },
      "cli.ts": null,
      "client": {
        "auth.test.ts": null,
        "auth.ts": null,
        "cross-spawn.test.ts": null,
        "index.test.ts": null,
        "index.ts": null,
        "middleware.test.ts": null,
        "middleware.ts": null,
        "sse.test.ts": null,
        "sse.ts": null,
        "stdio.test.ts": null,
        "stdio.ts": null,
        "streamableHttp.test.ts": null,
        "streamableHttp.ts": null,
        "websocket.ts": null
      },
      "examples": {
        "README.md": null,
        "client": {
          "multipleClientsParallel.ts": null,
          "parallelToolCallsClient.ts": null,
          "simpleOAuthClient.ts": null,
          "simpleStreamableHttp.ts": null,
          "streamableHttpWithSseFallbackClient.ts": null
        },
        "server": {
          "demoInMemoryOAuthProvider.ts": null,
          "jsonResponseStreamableHttp.ts": null,
          "mcpServerOutputSchema.ts": null,
          "simpleSseServer.ts": null,
          "simpleStatelessStreamableHttp.ts": null,
          "simpleStreamableHttp.ts": null,
          "sseAndStreamableHttpCompatibleServer.ts": null,
          "standaloneSseWithGetStreamableHttp.ts": null,
          "toolWithSampleServer.ts": null
        },
        "shared": {
          "inMemoryEventStore.ts": null
        }
      },
      "inMemory.test.ts": null,
      "inMemory.ts": null,
      "integration-tests": {
        "process-cleanup.test.ts": null,
        "stateManagementStreamableHttp.test.ts": null,
        "taskResumability.test.ts": null
      },
      "server": {
        "auth": {
          "clients.ts": null,
          "errors.ts": null,
          "handlers": {
            "authorize.test.ts": null,
            "authorize.ts": null,
            "metadata.test.ts": null,
            "metadata.ts": null,
            "register.test.ts": null,
            "register.ts": null,
            "revoke.test.ts": null,
            "revoke.ts": null,
            "token.test.ts": null,
            "token.ts": null
          },
          "middleware": {
            "allowedMethods.test.ts": null,
            "allowedMethods.ts": null,
            "bearerAuth.test.ts": null,
            "bearerAuth.ts": null,
            "clientAuth.test.ts": null,
            "clientAuth.ts": null
          },
          "provider.ts": null,
          "providers": {
            "proxyProvider.test.ts": null,
            "proxyProvider.ts": null
          },
          "router.test.ts": null,
          "router.ts": null,
          "types.ts": null
        },
        "completable.test.ts": null,
        "completable.ts": null,
        "index.test.ts": null,
        "index.ts": null,
        "mcp.test.ts": null,
        "mcp.ts": null,
        "sse.test.ts": null,
        "sse.ts": null,
        "stdio.test.ts": null,
        "stdio.ts": null,
        "streamableHttp.test.ts": null,
        "streamableHttp.ts": null,
        "title.test.ts": null
      },
      "shared": {
        "auth-utils.test.ts": null,
        "auth-utils.ts": null,
        "auth.test.ts": null,
        "auth.ts": null,
        "metadataUtils.ts": null,
        "protocol-transport-handling.test.ts": null,
        "protocol.test.ts": null,
        "protocol.ts": null,
        "stdio.test.ts": null,
        "stdio.ts": null,
        "transport.ts": null,
        "uriTemplate.test.ts": null,
        "uriTemplate.ts": null
      },
      "spec.types.test.ts": null,
      "types.test.ts": null,
      "types.ts": null
    },
    "tsconfig.cjs.json": null,
    "tsconfig.json": null,
    "tsconfig.prod.json": null
  },
  "files": {
    "/.git-blame-ignore-revs": {
      "type": "binary",
      "hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "size": 0,
      "url": "https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/3bc2235d747c320dfa0b6227cc84414c6d0add89/.git-blame-ignore-revs"
    },
    "/.gitattributes": {
      "type": "content",
      "content": "package-lock.json linguist-generated=true\n",
      "hash": "6f190896ad466cdeb275063c52df6f748785a3887f64ac8d754838f78acbd991",
      "size": 42
    },
    "/.github/CODEOWNERS": {
      "type": "content",
      "content": "# TypeScript SDK Code Owners\n\n# Default owners for everything in the repo\n* @modelcontextprotocol/typescript-sdk\n\n# Auth team owns all auth-related code\n/src/server/auth/ @modelcontextprotocol/typescript-sdk-auth\n/src/client/auth* @modelcontextprotocol/typescript-sdk-auth\n/src/shared/auth* @modelcontextprotocol/typescript-sdk-auth\n/src/examples/client/simpleOAuthClient.ts @modelcontextprotocol/typescript-sdk-auth\n/src/examples/server/demoInMemoryOAuthProvider.ts @modelcontextprotocol/typescript-sdk-auth",
      "hash": "6a166c1e14bd1a331f8399638486e5d83fddbe45c60b7cfa67d8a93acc67f06a",
      "size": 508
    },
    "/.github/workflows/main.yml": {
      "type": "content",
      "content": "on:\n  push:\n    branches:\n      - main\n  pull_request:\n  release:\n    types: [published]\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 18\n          cache: npm\n\n      - run: npm ci\n      - run: npm run build\n      - run: npm test\n      - run: npm run lint\n\n  publish:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'release'\n    environment: release\n    needs: build\n\n    permissions:\n      contents: read\n      id-token: write\n\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 18\n          cache: npm\n          registry-url: 'https://registry.npmjs.org'\n\n      - run: npm ci\n\n      - run: npm publish --provenance --access public\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n",
      "hash": "33298bd2c19176e3249ee3b153aab7da6af337edb3913be687e5b4daa1c73bb7",
      "size": 982,
      "json": {
        "on": {
          "push": {
            "branches": [
              "main"
            ]
          },
          "pull_request": null,
          "release": {
            "types": [
              "published"
            ]
          }
        },
        "concurrency": {
          "group": "${{ github.workflow }}-${{ github.ref }}",
          "cancel-in-progress": true
        },
        "jobs": {
          "build": {
            "runs-on": "ubuntu-latest",
            "steps": [
              {
                "uses": "actions/checkout@v4"
              },
              {
                "uses": "actions/setup-node@v4",
                "with": {
                  "node-version": 18,
                  "cache": "npm"
                }
              },
              {
                "run": "npm ci"
              },
              {
                "run": "npm run build"
              },
              {
                "run": "npm test"
              },
              {
                "run": "npm run lint"
              }
            ]
          },
          "publish": {
            "runs-on": "ubuntu-latest",
            "if": "github.event_name == 'release'",
            "environment": "release",
            "needs": "build",
            "permissions": {
              "contents": "read",
              "id-token": "write"
            },
            "steps": [
              {
                "uses": "actions/checkout@v4"
              },
              {
                "uses": "actions/setup-node@v4",
                "with": {
                  "node-version": 18,
                  "cache": "npm",
                  "registry-url": "https://registry.npmjs.org"
                }
              },
              {
                "run": "npm ci"
              },
              {
                "run": "npm publish --provenance --access public",
                "env": {
                  "NODE_AUTH_TOKEN": "${{ secrets.NPM_TOKEN }}"
                }
              }
            ]
          }
        }
      }
    },
    "/.gitignore": {
      "type": "content",
      "content": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\nlerna-debug.log*\n.pnpm-debug.log*\n\n# Diagnostic reports (https://nodejs.org/api/report.html)\nreport.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n*.lcov\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Bower dependency directory (https://bower.io/)\nbower_components\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (https://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules/\njspm_packages/\n\n# Snowpack dependency directory (https://snowpack.dev/)\nweb_modules/\n\n# TypeScript cache\n*.tsbuildinfo\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Optional stylelint cache\n.stylelintcache\n\n# Microbundle cache\n.rpt2_cache/\n.rts2_cache_cjs/\n.rts2_cache_es/\n.rts2_cache_umd/\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Output of 'npm run fetch:spec-types'\nspec.types.ts\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variable files\n.env\n.env.development.local\n.env.test.local\n.env.production.local\n.env.local\n\n# parcel-bundler cache (https://parceljs.org/)\n.cache\n.parcel-cache\n\n# Next.js build output\n.next\nout\n\n# Nuxt.js build / generate output\n.nuxt\n\n# Gatsby files\n.cache/\n# Comment in the public line in if your project uses Gatsby and not Next.js\n# https://nextjs.org/blog/next-9-1#public-directory-support\n# public\n\n# vuepress build output\n.vuepress/dist\n\n# vuepress v2.x temp and cache directory\n.temp\n.cache\n\n# Docusaurus cache and generated files\n.docusaurus\n\n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n# DynamoDB Local files\n.dynamodb/\n\n# TernJS port file\n.tern-port\n\n# Stores VSCode versions used for testing VSCode extensions\n.vscode-test\n\n# yarn v2\n.yarn/cache\n.yarn/unplugged\n.yarn/build-state.yml\n.yarn/install-state.gz\n.pnp.*\n\n.DS_Store\ndist/\n",
      "hash": "a30e0697ef85c0a329c01878190ea277d76d057575490991f60b07d36543f887",
      "size": 2113
    },
    "/.npmrc": {
      "type": "content",
      "content": "registry = \"https://registry.npmjs.org/\"\n",
      "hash": "33769117081377bc5ffb26dc13ab06941d23af8246a9fec3e2c3ca5b1d1dd56e",
      "size": 41
    },
    "/CLAUDE.md": {
      "type": "content",
      "content": "# MCP TypeScript SDK Guide\n\n## Build & Test Commands\n\n```sh\nnpm run build        # Build ESM and CJS versions\nnpm run lint         # Run ESLint\nnpm test             # Run all tests\nnpx jest path/to/file.test.ts  # Run specific test file\nnpx jest -t \"test name\"        # Run tests matching pattern\n```\n\n## Code Style Guidelines\n\n- **TypeScript**: Strict type checking, ES modules, explicit return types\n- **Naming**: PascalCase for classes/types, camelCase for functions/variables\n- **Files**: Lowercase with hyphens, test files with `.test.ts` suffix\n- **Imports**: ES module style, include `.js` extension, group imports logically\n- **Error Handling**: Use TypeScript's strict mode, explicit error checking in tests\n- **Formatting**: 2-space indentation, semicolons required, single quotes preferred\n- **Testing**: Co-locate tests with source files, use descriptive test names\n- **Comments**: JSDoc for public APIs, inline comments for complex logic\n\n## Project Structure\n\n- `/src`: Source code with client, server, and shared modules\n- Tests alongside source files with `.test.ts` suffix\n- Node.js \u003E= 18 required\n",
      "hash": "f922bac0402c291de8558a8e14b0e044ef48571db7919d75100847a825c5362a",
      "size": 1115
    },
    "/CODE_OF_CONDUCT.md": {
      "type": "content",
      "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\n\u003Cmcp-coc@anthropic.com\u003E.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\n\u003Chttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html\u003E.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\n\u003Chttps://www.contributor-covenant.org/faq\u003E. Translations are available at\n\u003Chttps://www.contributor-covenant.org/translations\u003E.\n",
      "hash": "edc7cdb1bd8e7ba5912b76876950116a73a0f5c084c809f704c9e2795eec805e",
      "size": 5231
    },
    "/CONTRIBUTING.md": {
      "type": "content",
      "content": "# Contributing to MCP TypeScript SDK\n\nWe welcome contributions to the Model Context Protocol TypeScript SDK! This document outlines the process for contributing to the project.\n\n## Getting Started\n\n1. Fork the repository\n2. Clone your fork: `git clone https://github.com/YOUR-USERNAME/typescript-sdk.git`\n3. Install dependencies: `npm install`\n4. Build the project: `npm run build`\n5. Run tests: `npm test`\n\n## Development Process\n\n1. Create a new branch for your changes\n2. Make your changes\n3. Run `npm run lint` to ensure code style compliance\n4. Run `npm test` to verify all tests pass\n5. Submit a pull request\n\n## Pull Request Guidelines\n\n- Follow the existing code style\n- Include tests for new functionality\n- Update documentation as needed\n- Keep changes focused and atomic\n- Provide a clear description of changes\n\n## Running Examples\n\n- Start the server: `npm run server`\n- Run the client: `npm run client`\n\n## Code of Conduct\n\nThis project follows our [Code of Conduct](CODE_OF_CONDUCT.md). Please review it before contributing.\n\n## Reporting Issues\n\n- Use the [GitHub issue tracker](https://github.com/modelcontextprotocol/typescript-sdk/issues)\n- Search existing issues before creating a new one\n- Provide clear reproduction steps\n\n## Security Issues\n\nPlease review our [Security Policy](SECURITY.md) for reporting security vulnerabilities.\n\n## License\n\nBy contributing, you agree that your contributions will be licensed under the MIT License.\n",
      "hash": "f55a4650a4100f5c5d31a4900f497b55854a7ba5ac8fc47ffe8072d9e9d34078",
      "size": 1458
    },
    "/LICENSE": {
      "type": "content",
      "content": "MIT License\n\nCopyright (c) 2024 Anthropic, PBC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "hash": "5e13dbbc1d120fc2a03cecde7c91424ae2d7de11b63d58ded2f4431e261ee50d",
      "size": 1071
    },
    "/README.md": {
      "type": "content",
      "content": "# MCP TypeScript SDK ![NPM Version](https://img.shields.io/npm/v/%40modelcontextprotocol%2Fsdk) ![MIT licensed](https://img.shields.io/npm/l/%40modelcontextprotocol%2Fsdk)\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Installation](#installation)\n- [Quickstart](#quick-start)\n- [What is MCP?](#what-is-mcp)\n- [Core Concepts](#core-concepts)\n  - [Server](#server)\n  - [Resources](#resources)\n  - [Tools](#tools)\n  - [Prompts](#prompts)\n  - [Completions](#completions)\n  - [Sampling](#sampling)\n- [Running Your Server](#running-your-server)\n  - [stdio](#stdio)\n  - [Streamable HTTP](#streamable-http)\n  - [Testing and Debugging](#testing-and-debugging)\n- [Examples](#examples)\n  - [Echo Server](#echo-server)\n  - [SQLite Explorer](#sqlite-explorer)\n- [Advanced Usage](#advanced-usage)\n  - [Dynamic Servers](#dynamic-servers)\n  - [Low-Level Server](#low-level-server)\n  - [Writing MCP Clients](#writing-mcp-clients)\n  - [Proxy Authorization Requests Upstream](#proxy-authorization-requests-upstream)\n  - [Backwards Compatibility](#backwards-compatibility)\n- [Documentation](#documentation)\n- [Contributing](#contributing)\n- [License](#license)\n\n## Overview\n\nThe Model Context Protocol allows applications to provide context for LLMs in a standardized way, separating the concerns of providing context from the actual LLM interaction. This TypeScript SDK implements the full MCP specification, making it easy to:\n\n- Build MCP clients that can connect to any MCP server\n- Create MCP servers that expose resources, prompts and tools\n- Use standard transports like stdio and Streamable HTTP\n- Handle all MCP protocol messages and lifecycle events\n\n## Installation\n\n```bash\nnpm install @modelcontextprotocol/sdk\n```\n\n\u003E ⚠️ MCP requires Node.js v18.x or higher to work fine.\n\n## Quick Start\n\nLet's create a simple MCP server that exposes a calculator tool and some data:\n\n```typescript\nimport { McpServer, ResourceTemplate } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\n// Create an MCP server\nconst server = new McpServer({\n  name: \"demo-server\",\n  version: \"1.0.0\"\n});\n\n// Add an addition tool\nserver.registerTool(\"add\",\n  {\n    title: \"Addition Tool\",\n    description: \"Add two numbers\",\n    inputSchema: { a: z.number(), b: z.number() }\n  },\n  async ({ a, b }) =\u003E ({\n    content: [{ type: \"text\", text: String(a + b) }]\n  })\n);\n\n// Add a dynamic greeting resource\nserver.registerResource(\n  \"greeting\",\n  new ResourceTemplate(\"greeting://{name}\", { list: undefined }),\n  { \n    title: \"Greeting Resource\",      // Display name for UI\n    description: \"Dynamic greeting generator\"\n  },\n  async (uri, { name }) =\u003E ({\n    contents: [{\n      uri: uri.href,\n      text: `Hello, ${name}!`\n    }]\n  })\n);\n\n// Start receiving messages on stdin and sending messages on stdout\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n## What is MCP?\n\nThe [Model Context Protocol (MCP)](https://modelcontextprotocol.io) lets you build servers that expose data and functionality to LLM applications in a secure, standardized way. Think of it like a web API, but specifically designed for LLM interactions. MCP servers can:\n\n- Expose data through **Resources** (think of these sort of like GET endpoints; they are used to load information into the LLM's context)\n- Provide functionality through **Tools** (sort of like POST endpoints; they are used to execute code or otherwise produce a side effect)\n- Define interaction patterns through **Prompts** (reusable templates for LLM interactions)\n- And more!\n\n## Core Concepts\n\n### Server\n\nThe McpServer is your core interface to the MCP protocol. It handles connection management, protocol compliance, and message routing:\n\n```typescript\nconst server = new McpServer({\n  name: \"my-app\",\n  version: \"1.0.0\"\n});\n```\n\n### Resources\n\nResources are how you expose data to LLMs. They're similar to GET endpoints in a REST API - they provide data but shouldn't perform significant computation or have side effects:\n\n```typescript\n// Static resource\nserver.registerResource(\n  \"config\",\n  \"config://app\",\n  {\n    title: \"Application Config\",\n    description: \"Application configuration data\",\n    mimeType: \"text/plain\"\n  },\n  async (uri) =\u003E ({\n    contents: [{\n      uri: uri.href,\n      text: \"App configuration here\"\n    }]\n  })\n);\n\n// Dynamic resource with parameters\nserver.registerResource(\n  \"user-profile\",\n  new ResourceTemplate(\"users://{userId}/profile\", { list: undefined }),\n  {\n    title: \"User Profile\",\n    description: \"User profile information\"\n  },\n  async (uri, { userId }) =\u003E ({\n    contents: [{\n      uri: uri.href,\n      text: `Profile data for user ${userId}`\n    }]\n  })\n);\n\n// Resource with context-aware completion\nserver.registerResource(\n  \"repository\",\n  new ResourceTemplate(\"github://repos/{owner}/{repo}\", {\n    list: undefined,\n    complete: {\n      // Provide intelligent completions based on previously resolved parameters\n      repo: (value, context) =\u003E {\n        if (context?.arguments?.[\"owner\"] === \"org1\") {\n          return [\"project1\", \"project2\", \"project3\"].filter(r =\u003E r.startsWith(value));\n        }\n        return [\"default-repo\"].filter(r =\u003E r.startsWith(value));\n      }\n    }\n  }),\n  {\n    title: \"GitHub Repository\",\n    description: \"Repository information\"\n  },\n  async (uri, { owner, repo }) =\u003E ({\n    contents: [{\n      uri: uri.href,\n      text: `Repository: ${owner}/${repo}`\n    }]\n  })\n);\n```\n\n### Tools\n\nTools let LLMs take actions through your server. Unlike resources, tools are expected to perform computation and have side effects:\n\n```typescript\n// Simple tool with parameters\nserver.registerTool(\n  \"calculate-bmi\",\n  {\n    title: \"BMI Calculator\",\n    description: \"Calculate Body Mass Index\",\n    inputSchema: {\n      weightKg: z.number(),\n      heightM: z.number()\n    }\n  },\n  async ({ weightKg, heightM }) =\u003E ({\n    content: [{\n      type: \"text\",\n      text: String(weightKg / (heightM * heightM))\n    }]\n  })\n);\n\n// Async tool with external API call\nserver.registerTool(\n  \"fetch-weather\",\n  {\n    title: \"Weather Fetcher\",\n    description: \"Get weather data for a city\",\n    inputSchema: { city: z.string() }\n  },\n  async ({ city }) =\u003E {\n    const response = await fetch(`https://api.weather.com/${city}`);\n    const data = await response.text();\n    return {\n      content: [{ type: \"text\", text: data }]\n    };\n  }\n);\n\n// Tool that returns ResourceLinks\nserver.registerTool(\n  \"list-files\",\n  {\n    title: \"List Files\",\n    description: \"List project files\",\n    inputSchema: { pattern: z.string() }\n  },\n  async ({ pattern }) =\u003E ({\n    content: [\n      { type: \"text\", text: `Found files matching \"${pattern}\":` },\n      // ResourceLinks let tools return references without file content\n      {\n        type: \"resource_link\",\n        uri: \"file:///project/README.md\",\n        name: \"README.md\",\n        mimeType: \"text/markdown\",\n        description: 'A README file'\n      },\n      {\n        type: \"resource_link\",\n        uri: \"file:///project/src/index.ts\",\n        name: \"index.ts\",\n        mimeType: \"text/typescript\",\n        description: 'An index file'\n      }\n    ]\n  })\n);\n```\n\n#### ResourceLinks\n\nTools can return `ResourceLink` objects to reference resources without embedding their full content. This is essential for performance when dealing with large files or many resources - clients can then selectively read only the resources they need using the provided URIs.\n\n### Prompts\n\nPrompts are reusable templates that help LLMs interact with your server effectively:\n\n```typescript\nimport { completable } from \"@modelcontextprotocol/sdk/server/completable.js\";\n\nserver.registerPrompt(\n  \"review-code\",\n  {\n    title: \"Code Review\",\n    description: \"Review code for best practices and potential issues\",\n    argsSchema: { code: z.string() }\n  },\n  ({ code }) =\u003E ({\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: `Please review this code:\\n\\n${code}`\n      }\n    }]\n  })\n);\n\n// Prompt with context-aware completion\nserver.registerPrompt(\n  \"team-greeting\",\n  {\n    title: \"Team Greeting\",\n    description: \"Generate a greeting for team members\",\n    argsSchema: {\n      department: completable(z.string(), (value) =\u003E {\n        // Department suggestions\n        return [\"engineering\", \"sales\", \"marketing\", \"support\"].filter(d =\u003E d.startsWith(value));\n      }),\n      name: completable(z.string(), (value, context) =\u003E {\n        // Name suggestions based on selected department\n        const department = context?.arguments?.[\"department\"];\n        if (department === \"engineering\") {\n          return [\"Alice\", \"Bob\", \"Charlie\"].filter(n =\u003E n.startsWith(value));\n        } else if (department === \"sales\") {\n          return [\"David\", \"Eve\", \"Frank\"].filter(n =\u003E n.startsWith(value));\n        } else if (department === \"marketing\") {\n          return [\"Grace\", \"Henry\", \"Iris\"].filter(n =\u003E n.startsWith(value));\n        }\n        return [\"Guest\"].filter(n =\u003E n.startsWith(value));\n      })\n    }\n  },\n  ({ department, name }) =\u003E ({\n    messages: [{\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: `Hello ${name}, welcome to the ${department} team!`\n      }\n    }]\n  })\n);\n```\n\n### Completions\n\nMCP supports argument completions to help users fill in prompt arguments and resource template parameters. See the examples above for [resource completions](#resources) and [prompt completions](#prompts).\n\n#### Client Usage\n\n```typescript\n// Request completions for any argument\nconst result = await client.complete({\n  ref: {\n    type: \"ref/prompt\",  // or \"ref/resource\"\n    name: \"example\"      // or uri: \"template://...\"\n  },\n  argument: {\n    name: \"argumentName\",\n    value: \"partial\"     // What the user has typed so far\n  },\n  context: {             // Optional: Include previously resolved arguments\n    arguments: {\n      previousArg: \"value\"\n    }\n  }\n});\n\n```\n\n### Display Names and Metadata\n\nAll resources, tools, and prompts support an optional `title` field for better UI presentation. The `title` is used as a display name, while `name` remains the unique identifier.\n\n**Note:** The `register*` methods (`registerTool`, `registerPrompt`, `registerResource`) are the recommended approach for new code. The older methods (`tool`, `prompt`, `resource`) remain available for backwards compatibility.\n\n#### Title Precedence for Tools\n\nFor tools specifically, there are two ways to specify a title:\n- `title` field in the tool configuration\n- `annotations.title` field (when using the older `tool()` method with annotations)\n\nThe precedence order is: `title` → `annotations.title` → `name`\n\n```typescript\n// Using registerTool (recommended)\nserver.registerTool(\"my_tool\", {\n  title: \"My Tool\",              // This title takes precedence\n  annotations: {\n    title: \"Annotation Title\"    // This is ignored if title is set\n  }\n}, handler);\n\n// Using tool with annotations (older API)\nserver.tool(\"my_tool\", \"description\", {\n  title: \"Annotation Title\"      // This is used as title\n}, handler);\n```\n\nWhen building clients, use the provided utility to get the appropriate display name:\n\n```typescript\nimport { getDisplayName } from \"@modelcontextprotocol/sdk/shared/metadataUtils.js\";\n\n// Automatically handles the precedence: title → annotations.title → name\nconst displayName = getDisplayName(tool);\n```\n\n### Sampling\n\nMCP servers can request LLM completions from connected clients that support sampling.\n\n```typescript\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst mcpServer = new McpServer({\n  name: \"tools-with-sample-server\",\n  version: \"1.0.0\",\n});\n\n// Tool that uses LLM sampling to summarize any text\nmcpServer.registerTool(\n  \"summarize\",\n  {\n    description: \"Summarize any text using an LLM\",\n    inputSchema: {\n      text: z.string().describe(\"Text to summarize\"),\n    },\n  },\n  async ({ text }) =\u003E {\n    // Call the LLM through MCP sampling\n    const response = await mcpServer.server.createMessage({\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Please summarize the following text concisely:\\n\\n${text}`,\n          },\n        },\n      ],\n      maxTokens: 500,\n    });\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: response.content.type === \"text\" ? response.content.text : \"Unable to generate summary\",\n        },\n      ],\n    };\n  }\n);\n\nasync function main() {\n  const transport = new StdioServerTransport();\n  await mcpServer.connect(transport);\n  console.log(\"MCP server is running...\");\n}\n\nmain().catch((error) =\u003E {\n  console.error(\"Server error:\", error);\n  process.exit(1);\n});\n```\n\n\n## Running Your Server\n\nMCP servers in TypeScript need to be connected to a transport to communicate with clients. How you start the server depends on the choice of transport:\n\n### stdio\n\nFor command-line tools and direct integrations:\n\n```typescript\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nconst server = new McpServer({\n  name: \"example-server\",\n  version: \"1.0.0\"\n});\n\n// ... set up server resources, tools, and prompts ...\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n### Streamable HTTP\n\nFor remote servers, set up a Streamable HTTP transport that handles both client requests and server-to-client notifications.\n\n#### With Session Management\n\nIn some cases, servers need to be stateful. This is achieved by [session management](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#session-management).\n\n```typescript\nimport express from \"express\";\nimport { randomUUID } from \"node:crypto\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { isInitializeRequest } from \"@modelcontextprotocol/sdk/types.js\"\n\n\n\nconst app = express();\napp.use(express.json());\n\n// Map to store transports by session ID\nconst transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};\n\n// Handle POST requests for client-to-server communication\napp.post('/mcp', async (req, res) =\u003E {\n  // Check for existing session ID\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  let transport: StreamableHTTPServerTransport;\n\n  if (sessionId && transports[sessionId]) {\n    // Reuse existing transport\n    transport = transports[sessionId];\n  } else if (!sessionId && isInitializeRequest(req.body)) {\n    // New initialization request\n    transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessioninitialized: (sessionId) =\u003E {\n        // Store the transport by session ID\n        transports[sessionId] = transport;\n      },\n      // DNS rebinding protection is disabled by default for backwards compatibility. If you are running this server\n      // locally, make sure to set:\n      // enableDnsRebindingProtection: true,\n      // allowedHosts: ['127.0.0.1'],\n    });\n\n    // Clean up transport when closed\n    transport.onclose = () =\u003E {\n      if (transport.sessionId) {\n        delete transports[transport.sessionId];\n      }\n    };\n    const server = new McpServer({\n      name: \"example-server\",\n      version: \"1.0.0\"\n    });\n\n    // ... set up server resources, tools, and prompts ...\n\n    // Connect to the MCP server\n    await server.connect(transport);\n  } else {\n    // Invalid request\n    res.status(400).json({\n      jsonrpc: '2.0',\n      error: {\n        code: -32000,\n        message: 'Bad Request: No valid session ID provided',\n      },\n      id: null,\n    });\n    return;\n  }\n\n  // Handle the request\n  await transport.handleRequest(req, res, req.body);\n});\n\n// Reusable handler for GET and DELETE requests\nconst handleSessionRequest = async (req: express.Request, res: express.Response) =\u003E {\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  if (!sessionId || !transports[sessionId]) {\n    res.status(400).send('Invalid or missing session ID');\n    return;\n  }\n  \n  const transport = transports[sessionId];\n  await transport.handleRequest(req, res);\n};\n\n// Handle GET requests for server-to-client notifications via SSE\napp.get('/mcp', handleSessionRequest);\n\n// Handle DELETE requests for session termination\napp.delete('/mcp', handleSessionRequest);\n\napp.listen(3000);\n```\n\n\u003E [!TIP]\n\u003E When using this in a remote environment, make sure to allow the header parameter `mcp-session-id` in CORS. Otherwise, it may result in a `Bad Request: No valid session ID provided` error. Read the following section for examples.\n\n\n#### CORS Configuration for Browser-Based Clients\n\nIf you'd like your server to be accessible by browser-based MCP clients, you'll need to configure CORS headers. The `Mcp-Session-Id` header must be exposed for browser clients to access it:\n\n```typescript\nimport cors from 'cors';\n\n// Add CORS middleware before your MCP routes\napp.use(cors({\n  origin: '*', // Configure appropriately for production, for example:\n  // origin: ['https://your-remote-domain.com', 'https://your-other-remote-domain.com'],\n  exposedHeaders: ['Mcp-Session-Id'],\n  allowedHeaders: ['Content-Type', 'mcp-session-id'],\n}));\n```\n\nThis configuration is necessary because:\n- The MCP streamable HTTP transport uses the `Mcp-Session-Id` header for session management\n- Browsers restrict access to response headers unless explicitly exposed via CORS\n- Without this configuration, browser-based clients won't be able to read the session ID from initialization responses\n\n#### Without Session Management (Stateless)\n\nFor simpler use cases where session management isn't needed:\n\n```typescript\nconst app = express();\napp.use(express.json());\n\napp.post('/mcp', async (req: Request, res: Response) =\u003E {\n  // In stateless mode, create a new instance of transport and server for each request\n  // to ensure complete isolation. A single instance would cause request ID collisions\n  // when multiple clients connect concurrently.\n  \n  try {\n    const server = getServer(); \n    const transport: StreamableHTTPServerTransport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: undefined,\n    });\n    res.on('close', () =\u003E {\n      console.log('Request closed');\n      transport.close();\n      server.close();\n    });\n    await server.connect(transport);\n    await transport.handleRequest(req, res, req.body);\n  } catch (error) {\n    console.error('Error handling MCP request:', error);\n    if (!res.headersSent) {\n      res.status(500).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32603,\n          message: 'Internal server error',\n        },\n        id: null,\n      });\n    }\n  }\n});\n\n// SSE notifications not supported in stateless mode\napp.get('/mcp', async (req: Request, res: Response) =\u003E {\n  console.log('Received GET MCP request');\n  res.writeHead(405).end(JSON.stringify({\n    jsonrpc: \"2.0\",\n    error: {\n      code: -32000,\n      message: \"Method not allowed.\"\n    },\n    id: null\n  }));\n});\n\n// Session termination not needed in stateless mode\napp.delete('/mcp', async (req: Request, res: Response) =\u003E {\n  console.log('Received DELETE MCP request');\n  res.writeHead(405).end(JSON.stringify({\n    jsonrpc: \"2.0\",\n    error: {\n      code: -32000,\n      message: \"Method not allowed.\"\n    },\n    id: null\n  }));\n});\n\n\n// Start the server\nconst PORT = 3000;\nsetupServer().then(() =\u003E {\n  app.listen(PORT, (error) =\u003E {\n    if (error) {\n      console.error('Failed to start server:', error);\n      process.exit(1);\n    }\n    console.log(`MCP Stateless Streamable HTTP Server listening on port ${PORT}`);\n  });\n}).catch(error =\u003E {\n  console.error('Failed to set up the server:', error);\n  process.exit(1);\n});\n\n```\n\nThis stateless approach is useful for:\n\n- Simple API wrappers\n- RESTful scenarios where each request is independent\n- Horizontally scaled deployments without shared session state\n\n#### DNS Rebinding Protection\n\nThe Streamable HTTP transport includes DNS rebinding protection to prevent security vulnerabilities. By default, this protection is **disabled** for backwards compatibility.\n\n**Important**: If you are running this server locally, enable DNS rebinding protection:\n\n```typescript\nconst transport = new StreamableHTTPServerTransport({\n  sessionIdGenerator: () =\u003E randomUUID(),\n  enableDnsRebindingProtection: true,\n\n  allowedHosts: ['127.0.0.1', ...],\n  allowedOrigins: ['https://yourdomain.com', 'https://www.yourdomain.com']\n});\n```\n\n### Testing and Debugging\n\nTo test your server, you can use the [MCP Inspector](https://github.com/modelcontextprotocol/inspector). See its README for more information.\n\n## Examples\n\n### Echo Server\n\nA simple server demonstrating resources, tools, and prompts:\n\n```typescript\nimport { McpServer, ResourceTemplate } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({\n  name: \"echo-server\",\n  version: \"1.0.0\"\n});\n\nserver.registerResource(\n  \"echo\",\n  new ResourceTemplate(\"echo://{message}\", { list: undefined }),\n  {\n    title: \"Echo Resource\",\n    description: \"Echoes back messages as resources\"\n  },\n  async (uri, { message }) =\u003E ({\n    contents: [{\n      uri: uri.href,\n      text: `Resource echo: ${message}`\n    }]\n  })\n);\n\nserver.registerTool(\n  \"echo\",\n  {\n    title: \"Echo Tool\",\n    description: \"Echoes back the provided message\",\n    inputSchema: { message: z.string() }\n  },\n  async ({ message }) =\u003E ({\n    content: [{ type: \"text\", text: `Tool echo: ${message}` }]\n  })\n);\n\nserver.registerPrompt(\n  \"echo\",\n  {\n    title: \"Echo Prompt\",\n    description: \"Creates a prompt to process a message\",\n    argsSchema: { message: z.string() }\n  },\n  ({ message }) =\u003E ({\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: `Please process this message: ${message}`\n      }\n    }]\n  })\n);\n```\n\n### SQLite Explorer\n\nA more complex example showing database integration:\n\n```typescript\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport sqlite3 from \"sqlite3\";\nimport { promisify } from \"util\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({\n  name: \"sqlite-explorer\",\n  version: \"1.0.0\"\n});\n\n// Helper to create DB connection\nconst getDb = () =\u003E {\n  const db = new sqlite3.Database(\"database.db\");\n  return {\n    all: promisify\u003Cstring, any[]\u003E(db.all.bind(db)),\n    close: promisify(db.close.bind(db))\n  };\n};\n\nserver.registerResource(\n  \"schema\",\n  \"schema://main\",\n  {\n    title: \"Database Schema\",\n    description: \"SQLite database schema\",\n    mimeType: \"text/plain\"\n  },\n  async (uri) =\u003E {\n    const db = getDb();\n    try {\n      const tables = await db.all(\n        \"SELECT sql FROM sqlite_master WHERE type='table'\"\n      );\n      return {\n        contents: [{\n          uri: uri.href,\n          text: tables.map((t: {sql: string}) =\u003E t.sql).join(\"\\n\")\n        }]\n      };\n    } finally {\n      await db.close();\n    }\n  }\n);\n\nserver.registerTool(\n  \"query\",\n  {\n    title: \"SQL Query\",\n    description: \"Execute SQL queries on the database\",\n    inputSchema: { sql: z.string() }\n  },\n  async ({ sql }) =\u003E {\n    const db = getDb();\n    try {\n      const results = await db.all(sql);\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(results, null, 2)\n        }]\n      };\n    } catch (err: unknown) {\n      const error = err as Error;\n      return {\n        content: [{\n          type: \"text\",\n          text: `Error: ${error.message}`\n        }],\n        isError: true\n      };\n    } finally {\n      await db.close();\n    }\n  }\n);\n```\n\n## Advanced Usage\n\n### Dynamic Servers\n\nIf you want to offer an initial set of tools/prompts/resources, but later add additional ones based on user action or external state change, you can add/update/remove them _after_ the Server is connected. This will automatically emit the corresponding `listChanged` notifications:\n\n```ts\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({\n  name: \"Dynamic Example\",\n  version: \"1.0.0\"\n});\n\nconst listMessageTool = server.tool(\n  \"listMessages\",\n  { channel: z.string() },\n  async ({ channel }) =\u003E ({\n    content: [{ type: \"text\", text: await listMessages(channel) }]\n  })\n);\n\nconst putMessageTool = server.tool(\n  \"putMessage\",\n  { channel: z.string(), message: z.string() },\n  async ({ channel, message }) =\u003E ({\n    content: [{ type: \"text\", text: await putMessage(channel, message) }]\n  })\n);\n// Until we upgrade auth, `putMessage` is disabled (won't show up in listTools)\nputMessageTool.disable()\n\nconst upgradeAuthTool = server.tool(\n  \"upgradeAuth\",\n  { permission: z.enum([\"write\", \"admin\"])},\n  // Any mutations here will automatically emit `listChanged` notifications\n  async ({ permission }) =\u003E {\n    const { ok, err, previous } = await upgradeAuthAndStoreToken(permission)\n    if (!ok) return {content: [{ type: \"text\", text: `Error: ${err}` }]}\n\n    // If we previously had read-only access, 'putMessage' is now available\n    if (previous === \"read\") {\n      putMessageTool.enable()\n    }\n\n    if (permission === 'write') {\n      // If we've just upgraded to 'write' permissions, we can still call 'upgradeAuth' \n      // but can only upgrade to 'admin'. \n      upgradeAuthTool.update({\n        paramsSchema: { permission: z.enum([\"admin\"]) }, // change validation rules\n      })\n    } else {\n      // If we're now an admin, we no longer have anywhere to upgrade to, so fully remove that tool\n      upgradeAuthTool.remove()\n    }\n  }\n)\n\n// Connect as normal\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n### Improving Network Efficiency with Notification Debouncing\n\nWhen performing bulk updates that trigger notifications (e.g., enabling or disabling multiple tools in a loop), the SDK can send a large number of messages in a short period. To improve performance and reduce network traffic, you can enable notification debouncing.\n\nThis feature coalesces multiple, rapid calls for the same notification type into a single message. For example, if you disable five tools in a row, only one `notifications/tools/list_changed` message will be sent instead of five.\n\n\u003E [!IMPORTANT]\n\u003E This feature is designed for \"simple\" notifications that do not carry unique data in their parameters. To prevent silent data loss, debouncing is **automatically bypassed** for any notification that contains a `params` object or a `relatedRequestId`. Such notifications will always be sent immediately.\n\nThis is an opt-in feature configured during server initialization.\n\n```typescript\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\n\nconst server = new McpServer(\n  {\n    name: \"efficient-server\",\n    version: \"1.0.0\"\n  },\n  {\n    // Enable notification debouncing for specific methods\n    debouncedNotificationMethods: [\n      'notifications/tools/list_changed',\n      'notifications/resources/list_changed',\n      'notifications/prompts/list_changed'\n    ]\n  }\n);\n\n// Now, any rapid changes to tools, resources, or prompts will result\n// in a single, consolidated notification for each type.\nserver.registerTool(\"tool1\", ...).disable();\nserver.registerTool(\"tool2\", ...).disable();\nserver.registerTool(\"tool3\", ...).disable();\n// Only one 'notifications/tools/list_changed' is sent.\n```\n\n### Low-Level Server\n\nFor more control, you can use the low-level Server class directly:\n\n```typescript\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nconst server = new Server(\n  {\n    name: \"example-server\",\n    version: \"1.0.0\"\n  },\n  {\n    capabilities: {\n      prompts: {}\n    }\n  }\n);\n\nserver.setRequestHandler(ListPromptsRequestSchema, async () =\u003E {\n  return {\n    prompts: [{\n      name: \"example-prompt\",\n      description: \"An example prompt template\",\n      arguments: [{\n        name: \"arg1\",\n        description: \"Example argument\",\n        required: true\n      }]\n    }]\n  };\n});\n\nserver.setRequestHandler(GetPromptRequestSchema, async (request) =\u003E {\n  if (request.params.name !== \"example-prompt\") {\n    throw new Error(\"Unknown prompt\");\n  }\n  return {\n    description: \"Example prompt\",\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: \"Example prompt text\"\n      }\n    }]\n  };\n});\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n### Eliciting User Input\n\nMCP servers can request additional information from users through the elicitation feature. This is useful for interactive workflows where the server needs user input or confirmation:\n\n```typescript\n// Server-side: Restaurant booking tool that asks for alternatives\nserver.tool(\n  \"book-restaurant\",\n  { \n    restaurant: z.string(),\n    date: z.string(),\n    partySize: z.number()\n  },\n  async ({ restaurant, date, partySize }) =\u003E {\n    // Check availability\n    const available = await checkAvailability(restaurant, date, partySize);\n    \n    if (!available) {\n      // Ask user if they want to try alternative dates\n      const result = await server.server.elicitInput({\n        message: `No tables available at ${restaurant} on ${date}. Would you like to check alternative dates?`,\n        requestedSchema: {\n          type: \"object\",\n          properties: {\n            checkAlternatives: {\n              type: \"boolean\",\n              title: \"Check alternative dates\",\n              description: \"Would you like me to check other dates?\"\n            },\n            flexibleDates: {\n              type: \"string\",\n              title: \"Date flexibility\",\n              description: \"How flexible are your dates?\",\n              enum: [\"next_day\", \"same_week\", \"next_week\"],\n              enumNames: [\"Next day\", \"Same week\", \"Next week\"]\n            }\n          },\n          required: [\"checkAlternatives\"]\n        }\n      });\n\n      if (result.action === \"accept\" && result.content?.checkAlternatives) {\n        const alternatives = await findAlternatives(\n          restaurant, \n          date, \n          partySize, \n          result.content.flexibleDates as string\n        );\n        return {\n          content: [{\n            type: \"text\",\n            text: `Found these alternatives: ${alternatives.join(\", \")}`\n          }]\n        };\n      }\n      \n      return {\n        content: [{\n          type: \"text\",\n          text: \"No booking made. Original date not available.\"\n        }]\n      };\n    }\n    \n    // Book the table\n    await makeBooking(restaurant, date, partySize);\n    return {\n      content: [{\n        type: \"text\",\n        text: `Booked table for ${partySize} at ${restaurant} on ${date}`\n      }]\n    };\n  }\n);\n```\n\nClient-side: Handle elicitation requests\n\n```typescript\n// This is a placeholder - implement based on your UI framework\nasync function getInputFromUser(message: string, schema: any): Promise\u003C{\n  action: \"accept\" | \"decline\" | \"cancel\";\n  data?: Record\u003Cstring, any\u003E;\n}\u003E {\n  // This should be implemented depending on the app\n  throw new Error(\"getInputFromUser must be implemented for your platform\");\n}\n\nclient.setRequestHandler(ElicitRequestSchema, async (request) =\u003E {\n  const userResponse = await getInputFromUser(\n    request.params.message, \n    request.params.requestedSchema\n  );\n  \n  return {\n    action: userResponse.action,\n    content: userResponse.action === \"accept\" ? userResponse.data : undefined\n  };\n});\n```\n\n**Note**: Elicitation requires client support. Clients must declare the `elicitation` capability during initialization.\n\n### Writing MCP Clients\n\nThe SDK provides a high-level client interface:\n\n```typescript\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\n\nconst transport = new StdioClientTransport({\n  command: \"node\",\n  args: [\"server.js\"]\n});\n\nconst client = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\"\n  }\n);\n\nawait client.connect(transport);\n\n// List prompts\nconst prompts = await client.listPrompts();\n\n// Get a prompt\nconst prompt = await client.getPrompt({\n  name: \"example-prompt\",\n  arguments: {\n    arg1: \"value\"\n  }\n});\n\n// List resources\nconst resources = await client.listResources();\n\n// Read a resource\nconst resource = await client.readResource({\n  uri: \"file:///example.txt\"\n});\n\n// Call a tool\nconst result = await client.callTool({\n  name: \"example-tool\",\n  arguments: {\n    arg1: \"value\"\n  }\n});\n\n```\n\n### Proxy Authorization Requests Upstream\n\nYou can proxy OAuth requests to an external authorization provider:\n\n```typescript\nimport express from 'express';\nimport { ProxyOAuthServerProvider } from '@modelcontextprotocol/sdk/server/auth/providers/proxyProvider.js';\nimport { mcpAuthRouter } from '@modelcontextprotocol/sdk/server/auth/router.js';\n\nconst app = express();\n\nconst proxyProvider = new ProxyOAuthServerProvider({\n    endpoints: {\n        authorizationUrl: \"https://auth.external.com/oauth2/v1/authorize\",\n        tokenUrl: \"https://auth.external.com/oauth2/v1/token\",\n        revocationUrl: \"https://auth.external.com/oauth2/v1/revoke\",\n    },\n    verifyAccessToken: async (token) =\u003E {\n        return {\n            token,\n            clientId: \"123\",\n            scopes: [\"openid\", \"email\", \"profile\"],\n        }\n    },\n    getClient: async (client_id) =\u003E {\n        return {\n            client_id,\n            redirect_uris: [\"http://localhost:3000/callback\"],\n        }\n    }\n})\n\napp.use(mcpAuthRouter({\n    provider: proxyProvider,\n    issuerUrl: new URL(\"http://auth.external.com\"),\n    baseUrl: new URL(\"http://mcp.example.com\"),\n    serviceDocumentationUrl: new URL(\"https://docs.example.com/\"),\n}))\n```\n\nThis setup allows you to:\n\n- Forward OAuth requests to an external provider\n- Add custom token validation logic\n- Manage client registrations\n- Provide custom documentation URLs\n- Maintain control over the OAuth flow while delegating to an external provider\n\n### Backwards Compatibility\n\nClients and servers with StreamableHttp transport can maintain [backwards compatibility](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#backwards-compatibility) with the deprecated HTTP+SSE transport (from protocol version 2024-11-05) as follows\n\n#### Client-Side Compatibility\n\nFor clients that need to work with both Streamable HTTP and older SSE servers:\n\n```typescript\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nlet client: Client|undefined = undefined\nconst baseUrl = new URL(url);\ntry {\n  client = new Client({\n    name: 'streamable-http-client',\n    version: '1.0.0'\n  });\n  const transport = new StreamableHTTPClientTransport(\n    new URL(baseUrl)\n  );\n  await client.connect(transport);\n  console.log(\"Connected using Streamable HTTP transport\");\n} catch (error) {\n  // If that fails with a 4xx error, try the older SSE transport\n  console.log(\"Streamable HTTP connection failed, falling back to SSE transport\");\n  client = new Client({\n    name: 'sse-client',\n    version: '1.0.0'\n  });\n  const sseTransport = new SSEClientTransport(baseUrl);\n  await client.connect(sseTransport);\n  console.log(\"Connected using SSE transport\");\n}\n```\n\n#### Server-Side Compatibility\n\nFor servers that need to support both Streamable HTTP and older clients:\n\n```typescript\nimport express from \"express\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { SSEServerTransport } from \"@modelcontextprotocol/sdk/server/sse.js\";\n\nconst server = new McpServer({\n  name: \"backwards-compatible-server\",\n  version: \"1.0.0\"\n});\n\n// ... set up server resources, tools, and prompts ...\n\nconst app = express();\napp.use(express.json());\n\n// Store transports for each session type\nconst transports = {\n  streamable: {} as Record\u003Cstring, StreamableHTTPServerTransport\u003E,\n  sse: {} as Record\u003Cstring, SSEServerTransport\u003E\n};\n\n// Modern Streamable HTTP endpoint\napp.all('/mcp', async (req, res) =\u003E {\n  // Handle Streamable HTTP transport for modern clients\n  // Implementation as shown in the \"With Session Management\" example\n  // ...\n});\n\n// Legacy SSE endpoint for older clients\napp.get('/sse', async (req, res) =\u003E {\n  // Create SSE transport for legacy clients\n  const transport = new SSEServerTransport('/messages', res);\n  transports.sse[transport.sessionId] = transport;\n  \n  res.on(\"close\", () =\u003E {\n    delete transports.sse[transport.sessionId];\n  });\n  \n  await server.connect(transport);\n});\n\n// Legacy message endpoint for older clients\napp.post('/messages', async (req, res) =\u003E {\n  const sessionId = req.query.sessionId as string;\n  const transport = transports.sse[sessionId];\n  if (transport) {\n    await transport.handlePostMessage(req, res, req.body);\n  } else {\n    res.status(400).send('No transport found for sessionId');\n  }\n});\n\napp.listen(3000);\n```\n\n**Note**: The SSE transport is now deprecated in favor of Streamable HTTP. New implementations should use Streamable HTTP, and existing SSE implementations should plan to migrate.\n\n## Documentation\n\n- [Model Context Protocol documentation](https://modelcontextprotocol.io)\n- [MCP Specification](https://spec.modelcontextprotocol.io)\n- [Example Servers](https://github.com/modelcontextprotocol/servers)\n\n## Contributing\n\nIssues and pull requests are welcome on GitHub at \u003Chttps://github.com/modelcontextprotocol/typescript-sdk\u003E.\n\n## License\n\nThis project is licensed under the MIT License—see the [LICENSE](LICENSE) file for details.\n",
      "hash": "5447f2293d02781a937c85c381e416d85f5b47fce84a80447403fd58a83bba9e",
      "size": 38166
    },
    "/SECURITY.md": {
      "type": "content",
      "content": "# Security Policy\n\nThank you for helping us keep the SDKs and systems they interact with secure.\n\n## Reporting Security Issues\n\nThis SDK is maintained by [Anthropic](https://www.anthropic.com/) as part of the Model Context Protocol project.\n\nThe security of our systems and user data is Anthropic’s top priority. We appreciate the work of security researchers acting in good faith in identifying and reporting potential vulnerabilities.\n\nOur security program is managed on HackerOne and we ask that any validated vulnerability in this functionality be reported through their [submission form](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\n## Vulnerability Disclosure Program\n\nOur Vulnerability Program Guidelines are defined on our [HackerOne program page](https://hackerone.com/anthropic-vdp).\n",
      "hash": "4e9bd21a3b8cbb8c45418242b50083ec8018aa5c7cb3fca0f139733613202cff",
      "size": 838
    },
    "/eslint.config.mjs": {
      "type": "content",
      "content": "// @ts-check\n\nimport eslint from '@eslint/js';\nimport tseslint from 'typescript-eslint';\n\nexport default tseslint.config(\n    eslint.configs.recommended,\n    ...tseslint.configs.recommended,\n    {\n        linterOptions: {\n            reportUnusedDisableDirectives: false,\n        },\n        rules: {\n            \"@typescript-eslint/no-unused-vars\": [\"error\",\n                { \"argsIgnorePattern\": \"^_\" }\n            ]\n        }\n    },\n    {\n        files: [\"src/client/**/*.ts\", \"src/server/**/*.ts\"],\n        ignores: [\"**/*.test.ts\"],\n        rules: {\n            \"no-console\": \"error\"\n        }\n    }\n);\n",
      "hash": "c21baa525e70eacdafe613d1816922f8cbea54521a770b280c6bff6d654aa9ec",
      "size": 608
    },
    "/jest.config.js": {
      "type": "content",
      "content": "import { createDefaultEsmPreset } from \"ts-jest\";\n\nconst defaultEsmPreset = createDefaultEsmPreset();\n\n/** @type {import('ts-jest').JestConfigWithTsJest} **/\nexport default {\n  ...defaultEsmPreset,\n  moduleNameMapper: {\n    \"^(\\\\.{1,2}/.*)\\\\.js$\": \"$1\",\n    \"^pkce-challenge$\": \"\u003CrootDir\u003E/src/__mocks__/pkce-challenge.ts\"\n  },\n  transformIgnorePatterns: [\n    \"/node_modules/(?!eventsource)/\"\n  ],\n  testPathIgnorePatterns: [\"/node_modules/\", \"/dist/\"],\n};\n",
      "hash": "802093cc30f1379047a8670c5493c8bf54e710de249370b58f9ccc6c16384e0e",
      "size": 457
    },
    "/package-lock.json": {
      "type": "content",
      "content": "{\n  \"name\": \"@modelcontextprotocol/sdk\",\n  \"version\": \"1.17.4\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"@modelcontextprotocol/sdk\",\n      \"version\": \"1.17.4\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ajv\": \"^6.12.6\",\n        \"content-type\": \"^1.0.5\",\n        \"cors\": \"^2.8.5\",\n        \"cross-spawn\": \"^7.0.5\",\n        \"eventsource\": \"^3.0.2\",\n        \"eventsource-parser\": \"^3.0.0\",\n        \"express\": \"^5.0.1\",\n        \"express-rate-limit\": \"^7.5.0\",\n        \"pkce-challenge\": \"^5.0.0\",\n        \"raw-body\": \"^3.0.0\",\n        \"zod\": \"^3.23.8\",\n        \"zod-to-json-schema\": \"^3.24.1\"\n      },\n      \"devDependencies\": {\n        \"@eslint/js\": \"^9.8.0\",\n        \"@jest-mock/express\": \"^3.0.0\",\n        \"@types/content-type\": \"^1.1.8\",\n        \"@types/cors\": \"^2.8.17\",\n        \"@types/cross-spawn\": \"^6.0.6\",\n        \"@types/eslint__js\": \"^8.42.3\",\n        \"@types/eventsource\": \"^1.1.15\",\n        \"@types/express\": \"^5.0.0\",\n        \"@types/jest\": \"^29.5.12\",\n        \"@types/node\": \"^22.0.2\",\n        \"@types/supertest\": \"^6.0.2\",\n        \"@types/ws\": \"^8.5.12\",\n        \"eslint\": \"^9.8.0\",\n        \"jest\": \"^29.7.0\",\n        \"supertest\": \"^7.0.0\",\n        \"ts-jest\": \"^29.2.4\",\n        \"tsx\": \"^4.16.5\",\n        \"typescript\": \"^5.5.4\",\n        \"typescript-eslint\": \"^8.0.0\",\n        \"ws\": \"^8.18.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@ampproject/remapping\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz\",\n      \"integrity\": \"sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jridgewell/gen-mapping\": \"^0.3.5\",\n        \"@jridgewell/trace-mapping\": \"^0.3.24\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.0.0\"\n      }\n    },\n    \"node_modules/@babel/code-frame\": {\n      \"version\": \"7.26.2\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.26.2.tgz\",\n      \"integrity\": \"sha512-RJlIHRueQgwWitWgF8OdFYGZX328Ax5BCemNGlqHfplnRT9ESi8JkFlvaVYbS+UubVY6dpv87Fs2u5M29iNFVQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@babel/helper-validator-identifier\": \"^7.25.9\",\n        \"js-tokens\": \"^4.0.0\",\n        \"picocolors\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/compat-data\": {\n      \"version\": \"7.26.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.26.0.tgz\",\n      \"integrity\": \"sha512-qETICbZSLe7uXv9VE8T/RWOdIE5qqyTucOt4zLYMafj2MRO271VGgLd4RACJMeBO37UPWhXiKMBk7YlJ0fOzQA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/core\": {\n      \"version\": \"7.26.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/core/-/core-7.26.0.tgz\",\n      \"integrity\": \"sha512-i1SLeK+DzNnQ3LL/CswPCa/E5u4lh1k6IAEphON8F+cXt0t9euTshDru0q7/IqMa1PMPz5RnHuHscF8/ZJsStg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@ampproject/remapping\": \"^2.2.0\",\n        \"@babel/code-frame\": \"^7.26.0\",\n        \"@babel/generator\": \"^7.26.0\",\n        \"@babel/helper-compilation-targets\": \"^7.25.9\",\n        \"@babel/helper-module-transforms\": \"^7.26.0\",\n        \"@babel/helpers\": \"^7.26.0\",\n        \"@babel/parser\": \"^7.26.0\",\n        \"@babel/template\": \"^7.25.9\",\n        \"@babel/traverse\": \"^7.25.9\",\n        \"@babel/types\": \"^7.26.0\",\n        \"convert-source-map\": \"^2.0.0\",\n        \"debug\": \"^4.1.0\",\n        \"gensync\": \"^1.0.0-beta.2\",\n        \"json5\": \"^2.2.3\",\n        \"semver\": \"^6.3.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/babel\"\n      }\n    },\n    \"node_modules/@babel/generator\": {\n      \"version\": \"7.26.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/generator/-/generator-7.26.0.tgz\",\n      \"integrity\": \"sha512-/AIkAmInnWwgEAJGQr9vY0c66Mj6kjkE2ZPB1PurTRaRAh3U+J45sAQMjQDJdh4WbR3l0x5xkimXBKyBXXAu2w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/parser\": \"^7.26.0\",\n        \"@babel/types\": \"^7.26.0\",\n        \"@jridgewell/gen-mapping\": \"^0.3.5\",\n        \"@jridgewell/trace-mapping\": \"^0.3.25\",\n        \"jsesc\": \"^3.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/helper-compilation-targets\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.25.9.tgz\",\n      \"integrity\": \"sha512-j9Db8Suy6yV/VHa4qzrj9yZfZxhLWQdVnRlXxmKLYlhWUVB1sB2G5sxuWYXk/whHD9iW76PmNzxZ4UCnTQTVEQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/compat-data\": \"^7.25.9\",\n        \"@babel/helper-validator-option\": \"^7.25.9\",\n        \"browserslist\": \"^4.24.0\",\n        \"lru-cache\": \"^5.1.1\",\n        \"semver\": \"^6.3.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/helper-module-imports\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.25.9.tgz\",\n      \"integrity\": \"sha512-tnUA4RsrmflIM6W6RFTLFSXITtl0wKjgpnLgXyowocVPrbYrLUXSBXDgTs8BlbmIzIdlBySRQjINYs2BAkiLtw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/traverse\": \"^7.25.9\",\n        \"@babel/types\": \"^7.25.9\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/helper-module-transforms\": {\n      \"version\": \"7.26.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.26.0.tgz\",\n      \"integrity\": \"sha512-xO+xu6B5K2czEnQye6BHA7DolFFmS3LB7stHZFaOLb1pAwO1HWLS8fXA+eh0A2yIvltPVmx3eNNDBJA2SLHXFw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-module-imports\": \"^7.25.9\",\n        \"@babel/helper-validator-identifier\": \"^7.25.9\",\n        \"@babel/traverse\": \"^7.25.9\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0\"\n      }\n    },\n    \"node_modules/@babel/helper-plugin-utils\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.25.9.tgz\",\n      \"integrity\": \"sha512-kSMlyUVdWe25rEsRGviIgOWnoT/nfABVWlqt9N19/dIPWViAOW2s9wznP5tURbs/IDuNk4gPy3YdYRgH3uxhBw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/helper-string-parser\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.25.9.tgz\",\n      \"integrity\": \"sha512-4A/SCr/2KLd5jrtOMFzaKjVtAei3+2r/NChoBNoZ3EyP/+GlhoaEGoWOZUmFmoITP7zOJyHIMm+DYRd8o3PvHA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/helper-validator-identifier\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.25.9.tgz\",\n      \"integrity\": \"sha512-Ed61U6XJc3CVRfkERJWDz4dJwKe7iLmmJsbOGu9wSloNSFttHV0I8g6UAgb7qnK5ly5bGLPd4oXZlxCdANBOWQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/helper-validator-option\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.25.9.tgz\",\n      \"integrity\": \"sha512-e/zv1co8pp55dNdEcCynfj9X7nyUKUXoUEwfXqaZt0omVOmDe9oOTdKStH4GmAw6zxMFs50ZayuMfHDKlO7Tfw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/helpers\": {\n      \"version\": \"7.27.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helpers/-/helpers-7.27.0.tgz\",\n      \"integrity\": \"sha512-U5eyP/CTFPuNE3qk+WZMxFkp/4zUzdceQlfzf7DdGdhp+Fezd7HD+i8Y24ZuTMKX3wQBld449jijbGq6OdGNQg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@babel/template\": \"^7.27.0\",\n        \"@babel/types\": \"^7.27.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/parser\": {\n      \"version\": \"7.27.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/parser/-/parser-7.27.0.tgz\",\n      \"integrity\": \"sha512-iaepho73/2Pz7w2eMS0Q5f83+0RKI7i4xmiYeBmDzfRVbQtTOG7Ts0S4HzJVsTMGI9keU8rNfuZr8DKfSt7Yyg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@babel/types\": \"^7.27.0\"\n      },\n      \"bin\": {\n        \"parser\": \"bin/babel-parser.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.0.0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-async-generators\": {\n      \"version\": \"7.8.4\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-async-generators/-/plugin-syntax-async-generators-7.8.4.tgz\",\n      \"integrity\": \"sha512-tycmZxkGfZaxhMRbXlPXuVFpdWlXpir2W4AMhSJgRKzk/eDlIXOhb2LHWoLpDF7TEHylV5zNhykX6KAgHJmTNw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.8.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-bigint\": {\n      \"version\": \"7.8.3\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-bigint/-/plugin-syntax-bigint-7.8.3.tgz\",\n      \"integrity\": \"sha512-wnTnFlG+YxQm3vDxpGE57Pj0srRU4sHE/mDkt1qv2YJJSeUAec2ma4WLUnUPeKjyrfntVwe/N6dCXpU+zL3Npg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.8.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-class-properties\": {\n      \"version\": \"7.12.13\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-class-properties/-/plugin-syntax-class-properties-7.12.13.tgz\",\n      \"integrity\": \"sha512-fm4idjKla0YahUNgFNLCB0qySdsoPiZP3iQE3rky0mBUtMZ23yDJ9SJdg6dXTSDnulOVqiF3Hgr9nbXvXTQZYA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.12.13\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-class-static-block\": {\n      \"version\": \"7.14.5\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-class-static-block/-/plugin-syntax-class-static-block-7.14.5.tgz\",\n      \"integrity\": \"sha512-b+YyPmr6ldyNnM6sqYeMWE+bgJcJpO6yS4QD7ymxgH34GBPNDM/THBh8iunyvKIZztiwLH4CJZ0RxTk9emgpjw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.14.5\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-import-attributes\": {\n      \"version\": \"7.26.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-import-attributes/-/plugin-syntax-import-attributes-7.26.0.tgz\",\n      \"integrity\": \"sha512-e2dttdsJ1ZTpi3B9UYGLw41hifAubg19AtCu/2I/F1QNVclOBr1dYpTdmdyZ84Xiz43BS/tCUkMAZNLv12Pi+A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.25.9\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-import-meta\": {\n      \"version\": \"7.10.4\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-import-meta/-/plugin-syntax-import-meta-7.10.4.tgz\",\n      \"integrity\": \"sha512-Yqfm+XDx0+Prh3VSeEQCPU81yC+JWZ2pDPFSS4ZdpfZhp4MkFMaDC1UqseovEKwSUpnIL7+vK+Clp7bfh0iD7g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.10.4\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-json-strings\": {\n      \"version\": \"7.8.3\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-json-strings/-/plugin-syntax-json-strings-7.8.3.tgz\",\n      \"integrity\": \"sha512-lY6kdGpWHvjoe2vk4WrAapEuBR69EMxZl+RoGRhrFGNYVK8mOPAW8VfbT/ZgrFbXlDNiiaxQnAtgVCZ6jv30EA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.8.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-jsx\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-jsx/-/plugin-syntax-jsx-7.25.9.tgz\",\n      \"integrity\": \"sha512-ld6oezHQMZsZfp6pWtbjaNDF2tiiCYYDqQszHt5VV437lewP9aSi2Of99CK0D0XB21k7FLgnLcmQKyKzynfeAA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.25.9\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-logical-assignment-operators\": {\n      \"version\": \"7.10.4\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.10.4.tgz\",\n      \"integrity\": \"sha512-d8waShlpFDinQ5MtvGU9xDAOzKH47+FFoney2baFIoMr952hKOLp1HR7VszoZvOsV/4+RRszNY7D17ba0te0ig==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.10.4\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-nullish-coalescing-operator\": {\n      \"version\": \"7.8.3\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-nullish-coalescing-operator/-/plugin-syntax-nullish-coalescing-operator-7.8.3.tgz\",\n      \"integrity\": \"sha512-aSff4zPII1u2QD7y+F8oDsz19ew4IGEJg9SVW+bqwpwtfFleiQDMdzA/R+UlWDzfnHFCxxleFT0PMIrR36XLNQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.8.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-numeric-separator\": {\n      \"version\": \"7.10.4\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-numeric-separator/-/plugin-syntax-numeric-separator-7.10.4.tgz\",\n      \"integrity\": \"sha512-9H6YdfkcK/uOnY/K7/aA2xpzaAgkQn37yzWUMRK7OaPOqOpGS1+n0H5hxT9AUw9EsSjPW8SVyMJwYRtWs3X3ug==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.10.4\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-object-rest-spread\": {\n      \"version\": \"7.8.3\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-object-rest-spread/-/plugin-syntax-object-rest-spread-7.8.3.tgz\",\n      \"integrity\": \"sha512-XoqMijGZb9y3y2XskN+P1wUGiVwWZ5JmoDRwx5+3GmEplNyVM2s2Dg8ILFQm8rWM48orGy5YpI5Bl8U1y7ydlA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.8.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-optional-catch-binding\": {\n      \"version\": \"7.8.3\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-optional-catch-binding/-/plugin-syntax-optional-catch-binding-7.8.3.tgz\",\n      \"integrity\": \"sha512-6VPD0Pc1lpTqw0aKoeRTMiB+kWhAoT24PA+ksWSBrFtl5SIRVpZlwN3NNPQjehA2E/91FV3RjLWoVTglWcSV3Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.8.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-optional-chaining\": {\n      \"version\": \"7.8.3\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-optional-chaining/-/plugin-syntax-optional-chaining-7.8.3.tgz\",\n      \"integrity\": \"sha512-KoK9ErH1MBlCPxV0VANkXW2/dw4vlbGDrFgz8bmUsBGYkFRcbRwMh6cIJubdPrkxRwuGdtCk0v/wPTKbQgBjkg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.8.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-private-property-in-object\": {\n      \"version\": \"7.14.5\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-private-property-in-object/-/plugin-syntax-private-property-in-object-7.14.5.tgz\",\n      \"integrity\": \"sha512-0wVnp9dxJ72ZUJDV27ZfbSj6iHLoytYZmh3rFcxNnvsJF3ktkzLDZPy/mA17HGsaQT3/DQsWYX1f1QGWkCoVUg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.14.5\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-top-level-await\": {\n      \"version\": \"7.14.5\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-top-level-await/-/plugin-syntax-top-level-await-7.14.5.tgz\",\n      \"integrity\": \"sha512-hx++upLv5U1rgYfwe1xBQUhRmU41NEvpUvrp8jkrSCdvGSnM5/qdRMtylJ6PG5OFkBaHkbTAKTnd3/YyESRHFw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.14.5\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/plugin-syntax-typescript\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/plugin-syntax-typescript/-/plugin-syntax-typescript-7.25.9.tgz\",\n      \"integrity\": \"sha512-hjMgRy5hb8uJJjUcdWunWVcoi9bGpJp8p5Ol1229PoN6aytsLwNMgmdftO23wnCLMfVmTwZDWMPNq/D1SY60JQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.25.9\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0-0\"\n      }\n    },\n    \"node_modules/@babel/template\": {\n      \"version\": \"7.27.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/template/-/template-7.27.0.tgz\",\n      \"integrity\": \"sha512-2ncevenBqXI6qRMukPlXwHKHchC7RyMuu4xv5JBXRfOGVcTy1mXCD12qrp7Jsoxll1EV3+9sE4GugBVRjT2jFA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@babel/code-frame\": \"^7.26.2\",\n        \"@babel/parser\": \"^7.27.0\",\n        \"@babel/types\": \"^7.27.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/traverse\": {\n      \"version\": \"7.25.9\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/traverse/-/traverse-7.25.9.tgz\",\n      \"integrity\": \"sha512-ZCuvfwOwlz/bawvAuvcj8rrithP2/N55Tzz342AkTvq4qaWbGfmCk/tKhNaV2cthijKrPAA8SRJV5WWe7IBMJw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/code-frame\": \"^7.25.9\",\n        \"@babel/generator\": \"^7.25.9\",\n        \"@babel/parser\": \"^7.25.9\",\n        \"@babel/template\": \"^7.25.9\",\n        \"@babel/types\": \"^7.25.9\",\n        \"debug\": \"^4.3.1\",\n        \"globals\": \"^11.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/traverse/node_modules/globals\": {\n      \"version\": \"11.12.0\",\n      \"resolved\": \"https://registry.npmjs.org/globals/-/globals-11.12.0.tgz\",\n      \"integrity\": \"sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=4\"\n      }\n    },\n    \"node_modules/@babel/types\": {\n      \"version\": \"7.27.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/types/-/types-7.27.0.tgz\",\n      \"integrity\": \"sha512-H45s8fVLYjbhFH62dIJ3WtmJ6RSPt/3DRO0ZcT2SUiYiQyz3BLVb9ADEnLl91m74aQPS3AzzeajZHYOalWe3bg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@babel/helper-string-parser\": \"^7.25.9\",\n        \"@babel/helper-validator-identifier\": \"^7.25.9\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/@bcoe/v8-coverage\": {\n      \"version\": \"0.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz\",\n      \"integrity\": \"sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==\",\n      \"dev\": true\n    },\n    \"node_modules/@esbuild/aix-ppc64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.0.tgz\",\n      \"integrity\": \"sha512-O7vun9Sf8DFjH2UtqK8Ku3LkquL9SZL8OLY1T5NZkA34+wG3OQF7cl4Ql8vdNzM6fzBbYfLaiRLIOZ+2FOCgBQ==\",\n      \"cpu\": [\n        \"ppc64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"aix\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/android-arm\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.0.tgz\",\n      \"integrity\": \"sha512-PTyWCYYiU0+1eJKmw21lWtC+d08JDZPQ5g+kFyxP0V+es6VPPSUhM6zk8iImp2jbV6GwjX4pap0JFbUQN65X1g==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/android-arm64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.0.tgz\",\n      \"integrity\": \"sha512-grvv8WncGjDSyUBjN9yHXNt+cq0snxXbDxy5pJtzMKGmmpPxeAmAhWxXI+01lU5rwZomDgD3kJwulEnhTRUd6g==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/android-x64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.0.tgz\",\n      \"integrity\": \"sha512-m/ix7SfKG5buCnxasr52+LI78SQ+wgdENi9CqyCXwjVR2X4Jkz+BpC3le3AoBPYTC9NHklwngVXvbJ9/Akhrfg==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/darwin-arm64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.0.tgz\",\n      \"integrity\": \"sha512-mVwdUb5SRkPayVadIOI78K7aAnPamoeFR2bT5nszFUZ9P8UpK4ratOdYbZZXYSqPKMHfS1wdHCJk1P1EZpRdvw==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/darwin-x64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.0.tgz\",\n      \"integrity\": \"sha512-DgDaYsPWFTS4S3nWpFcMn/33ZZwAAeAFKNHNa1QN0rI4pUjgqf0f7ONmXf6d22tqTY+H9FNdgeaAa+YIFUn2Rg==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/freebsd-arm64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.0.tgz\",\n      \"integrity\": \"sha512-VN4ocxy6dxefN1MepBx/iD1dH5K8qNtNe227I0mnTRjry8tj5MRk4zprLEdG8WPyAPb93/e4pSgi1SoHdgOa4w==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"freebsd\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/freebsd-x64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.0.tgz\",\n      \"integrity\": \"sha512-mrSgt7lCh07FY+hDD1TxiTyIHyttn6vnjesnPoVDNmDfOmggTLXRv8Id5fNZey1gl/V2dyVK1VXXqVsQIiAk+A==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"freebsd\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-arm\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.0.tgz\",\n      \"integrity\": \"sha512-vkB3IYj2IDo3g9xX7HqhPYxVkNQe8qTK55fraQyTzTX/fxaDtXiEnavv9geOsonh2Fd2RMB+i5cbhu2zMNWJwg==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-arm64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.0.tgz\",\n      \"integrity\": \"sha512-9QAQjTWNDM/Vk2bgBl17yWuZxZNQIF0OUUuPZRKoDtqF2k4EtYbpyiG5/Dk7nqeK6kIJWPYldkOcBqjXjrUlmg==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-ia32\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.0.tgz\",\n      \"integrity\": \"sha512-43ET5bHbphBegyeqLb7I1eYn2P/JYGNmzzdidq/w0T8E2SsYL1U6un2NFROFRg1JZLTzdCoRomg8Rvf9M6W6Gg==\",\n      \"cpu\": [\n        \"ia32\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-loong64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.0.tgz\",\n      \"integrity\": \"sha512-fC95c/xyNFueMhClxJmeRIj2yrSMdDfmqJnyOY4ZqsALkDrrKJfIg5NTMSzVBr5YW1jf+l7/cndBfP3MSDpoHw==\",\n      \"cpu\": [\n        \"loong64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-mips64el\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.0.tgz\",\n      \"integrity\": \"sha512-nkAMFju7KDW73T1DdH7glcyIptm95a7Le8irTQNO/qtkoyypZAnjchQgooFUDQhNAy4iu08N79W4T4pMBwhPwQ==\",\n      \"cpu\": [\n        \"mips64el\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-ppc64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.0.tgz\",\n      \"integrity\": \"sha512-NhyOejdhRGS8Iwv+KKR2zTq2PpysF9XqY+Zk77vQHqNbo/PwZCzB5/h7VGuREZm1fixhs4Q/qWRSi5zmAiO4Fw==\",\n      \"cpu\": [\n        \"ppc64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-riscv64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.0.tgz\",\n      \"integrity\": \"sha512-5S/rbP5OY+GHLC5qXp1y/Mx//e92L1YDqkiBbO9TQOvuFXM+iDqUNG5XopAnXoRH3FjIUDkeGcY1cgNvnXp/kA==\",\n      \"cpu\": [\n        \"riscv64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-s390x\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.0.tgz\",\n      \"integrity\": \"sha512-XM2BFsEBz0Fw37V0zU4CXfcfuACMrppsMFKdYY2WuTS3yi8O1nFOhil/xhKTmE1nPmVyvQJjJivgDT+xh8pXJA==\",\n      \"cpu\": [\n        \"s390x\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/linux-x64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.0.tgz\",\n      \"integrity\": \"sha512-9yl91rHw/cpwMCNytUDxwj2XjFpxML0y9HAOH9pNVQDpQrBxHy01Dx+vaMu0N1CKa/RzBD2hB4u//nfc+Sd3Cw==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/netbsd-arm64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.0.tgz\",\n      \"integrity\": \"sha512-RuG4PSMPFfrkH6UwCAqBzauBWTygTvb1nxWasEJooGSJ/NwRw7b2HOwyRTQIU97Hq37l3npXoZGYMy3b3xYvPw==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"netbsd\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/netbsd-x64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.0.tgz\",\n      \"integrity\": \"sha512-jl+qisSB5jk01N5f7sPCsBENCOlPiS/xptD5yxOx2oqQfyourJwIKLRA2yqWdifj3owQZCL2sn6o08dBzZGQzA==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"netbsd\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/openbsd-arm64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.0.tgz\",\n      \"integrity\": \"sha512-21sUNbq2r84YE+SJDfaQRvdgznTD8Xc0oc3p3iW/a1EVWeNj/SdUCbm5U0itZPQYRuRTW20fPMWMpcrciH2EJw==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"openbsd\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/openbsd-x64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.0.tgz\",\n      \"integrity\": \"sha512-2gwwriSMPcCFRlPlKx3zLQhfN/2WjJ2NSlg5TKLQOJdV0mSxIcYNTMhk3H3ulL/cak+Xj0lY1Ym9ysDV1igceg==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"openbsd\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/sunos-x64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.0.tgz\",\n      \"integrity\": \"sha512-bxI7ThgLzPrPz484/S9jLlvUAHYMzy6I0XiU1ZMeAEOBcS0VePBFxh1JjTQt3Xiat5b6Oh4x7UC7IwKQKIJRIg==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"sunos\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/win32-arm64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.0.tgz\",\n      \"integrity\": \"sha512-ZUAc2YK6JW89xTbXvftxdnYy3m4iHIkDtK3CLce8wg8M2L+YZhIvO1DKpxrd0Yr59AeNNkTiic9YLf6FTtXWMw==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/win32-ia32\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.0.tgz\",\n      \"integrity\": \"sha512-eSNxISBu8XweVEWG31/JzjkIGbGIJN/TrRoiSVZwZ6pkC6VX4Im/WV2cz559/TXLcYbcrDN8JtKgd9DJVIo8GA==\",\n      \"cpu\": [\n        \"ia32\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@esbuild/win32-x64\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.0.tgz\",\n      \"integrity\": \"sha512-ZENoHJBxA20C2zFzh6AI4fT6RraMzjYw4xKWemRTRmRVtN9c5DcH9r/f2ihEkMjOW5eGgrwCslG/+Y/3bL+DHQ==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/@eslint-community/eslint-utils\": {\n      \"version\": \"4.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.4.1.tgz\",\n      \"integrity\": \"sha512-s3O3waFUrMV8P/XaF/+ZTp1X9XBZW1a4B97ZnjQF2KYWaFD2A8KyFBsrsfSjEmjn3RGWAIuvlneuZm3CUK3jbA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"eslint-visitor-keys\": \"^3.4.3\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || \u003E=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/eslint\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^6.0.0 || ^7.0.0 || \u003E=8.0.0\"\n      }\n    },\n    \"node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys\": {\n      \"version\": \"3.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz\",\n      \"integrity\": \"sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || \u003E=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/eslint\"\n      }\n    },\n    \"node_modules/@eslint-community/regexpp\": {\n      \"version\": \"4.12.1\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.1.tgz\",\n      \"integrity\": \"sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^12.0.0 || ^14.0.0 || \u003E=16.0.0\"\n      }\n    },\n    \"node_modules/@eslint/config-array\": {\n      \"version\": \"0.18.0\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint/config-array/-/config-array-0.18.0.tgz\",\n      \"integrity\": \"sha512-fTxvnS1sRMu3+JjXwJG0j/i4RT9u4qJ+lqS/yCGap4lH4zZGzQ7tu+xZqQmcMZq5OBZDL4QRxQzRjkWcGt8IVw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@eslint/object-schema\": \"^2.1.4\",\n        \"debug\": \"^4.3.1\",\n        \"minimatch\": \"^3.1.2\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      }\n    },\n    \"node_modules/@eslint/core\": {\n      \"version\": \"0.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint/core/-/core-0.7.0.tgz\",\n      \"integrity\": \"sha512-xp5Jirz5DyPYlPiKat8jaq0EmYvDXKKpzTbxXMpT9eqlRJkRKIz9AGMdlvYjih+im+QlhWrpvVjl8IPC/lHlUw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      }\n    },\n    \"node_modules/@eslint/eslintrc\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.1.0.tgz\",\n      \"integrity\": \"sha512-4Bfj15dVJdoy3RfZmmo86RK1Fwzn6SstsvK9JS+BaVKqC6QQQQyXekNaC+g+LKNgkQ+2VhGAzm6hO40AhMR3zQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ajv\": \"^6.12.4\",\n        \"debug\": \"^4.3.2\",\n        \"espree\": \"^10.0.1\",\n        \"globals\": \"^14.0.0\",\n        \"ignore\": \"^5.2.0\",\n        \"import-fresh\": \"^3.2.1\",\n        \"js-yaml\": \"^4.1.0\",\n        \"minimatch\": \"^3.1.2\",\n        \"strip-json-comments\": \"^3.1.1\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/eslint\"\n      }\n    },\n    \"node_modules/@eslint/js\": {\n      \"version\": \"9.13.0\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint/js/-/js-9.13.0.tgz\",\n      \"integrity\": \"sha512-IFLyoY4d72Z5y/6o/BazFBezupzI/taV8sGumxTAVw3lXG9A6md1Dc34T9s1FoD/an9pJH8RHbAxsaEbBed9lA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      }\n    },\n    \"node_modules/@eslint/object-schema\": {\n      \"version\": \"2.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.4.tgz\",\n      \"integrity\": \"sha512-BsWiH1yFGjXXS2yvrf5LyuoSIIbPrGUWob917o+BTKuZ7qJdxX8aJLRxs1fS9n6r7vESrq1OUqb68dANcFXuQQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      }\n    },\n    \"node_modules/@eslint/plugin-kit\": {\n      \"version\": \"0.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.2.3.tgz\",\n      \"integrity\": \"sha512-2b/g5hRmpbb1o4GnTZax9N9m0FXzz9OV42ZzI4rDDMDuHUqigAiQCEWChBWCY4ztAGVRjoWT19v0yMmc5/L5kA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"levn\": \"^0.4.1\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      }\n    },\n    \"node_modules/@humanfs/core\": {\n      \"version\": \"0.19.0\",\n      \"resolved\": \"https://registry.npmjs.org/@humanfs/core/-/core-0.19.0.tgz\",\n      \"integrity\": \"sha512-2cbWIHbZVEweE853g8jymffCA+NCMiuqeECeBBLm8dg2oFdjuGJhgN4UAbI+6v0CKbbhvtXA4qV8YR5Ji86nmw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=18.18.0\"\n      }\n    },\n    \"node_modules/@humanfs/node\": {\n      \"version\": \"0.16.5\",\n      \"resolved\": \"https://registry.npmjs.org/@humanfs/node/-/node-0.16.5.tgz\",\n      \"integrity\": \"sha512-KSPA4umqSG4LHYRodq31VDwKAvaTF4xmVlzM8Aeh4PlU1JQ3IG0wiA8C25d3RQ9nJyM3mBHyI53K06VVL/oFFg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@humanfs/core\": \"^0.19.0\",\n        \"@humanwhocodes/retry\": \"^0.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=18.18.0\"\n      }\n    },\n    \"node_modules/@humanwhocodes/module-importer\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz\",\n      \"integrity\": \"sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=12.22\"\n      },\n      \"funding\": {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/nzakas\"\n      }\n    },\n    \"node_modules/@humanwhocodes/retry\": {\n      \"version\": \"0.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.3.1.tgz\",\n      \"integrity\": \"sha512-JBxkERygn7Bv/GbN5Rv8Ul6LVknS+5Bp6RgDC/O8gEBU/yeH5Ui5C/OlWrTb6qct7LjjfT6Re2NxB0ln0yYybA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=18.18\"\n      },\n      \"funding\": {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/nzakas\"\n      }\n    },\n    \"node_modules/@istanbuljs/load-nyc-config\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/@istanbuljs/load-nyc-config/-/load-nyc-config-1.1.0.tgz\",\n      \"integrity\": \"sha512-VjeHSlIzpv/NyD3N0YuHfXOPDIixcA1q2ZV98wsMqcYlPmv2n3Yb2lYP9XMElnaFVXg5A7YLTeLu6V84uQDjmQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"camelcase\": \"^5.3.1\",\n        \"find-up\": \"^4.1.0\",\n        \"get-package-type\": \"^0.1.0\",\n        \"js-yaml\": \"^3.13.1\",\n        \"resolve-from\": \"^5.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/@istanbuljs/load-nyc-config/node_modules/argparse\": {\n      \"version\": \"1.0.10\",\n      \"resolved\": \"https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz\",\n      \"integrity\": \"sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"sprintf-js\": \"~1.0.2\"\n      }\n    },\n    \"node_modules/@istanbuljs/load-nyc-config/node_modules/find-up\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz\",\n      \"integrity\": \"sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"locate-path\": \"^5.0.0\",\n        \"path-exists\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/@istanbuljs/load-nyc-config/node_modules/js-yaml\": {\n      \"version\": \"3.14.1\",\n      \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz\",\n      \"integrity\": \"sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"argparse\": \"^1.0.7\",\n        \"esprima\": \"^4.0.0\"\n      },\n      \"bin\": {\n        \"js-yaml\": \"bin/js-yaml.js\"\n      }\n    },\n    \"node_modules/@istanbuljs/load-nyc-config/node_modules/locate-path\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz\",\n      \"integrity\": \"sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"p-locate\": \"^4.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/@istanbuljs/load-nyc-config/node_modules/p-limit\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz\",\n      \"integrity\": \"sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"p-try\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/@istanbuljs/load-nyc-config/node_modules/p-locate\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz\",\n      \"integrity\": \"sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"p-limit\": \"^2.2.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/@istanbuljs/load-nyc-config/node_modules/resolve-from\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz\",\n      \"integrity\": \"sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/@istanbuljs/schema\": {\n      \"version\": \"0.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz\",\n      \"integrity\": \"sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/@jest-mock/express\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest-mock/express/-/express-3.0.0.tgz\",\n      \"integrity\": \"sha512-omOl6bh4EOUbp9bvcPSBZKaG8nAtBlhVSUhLx0brHrNpEDn+fMtQp58NkhdY3OoUfXjb7go/EcSYwk+H1BVLdg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/express\": \"^5.0.0\"\n      }\n    },\n    \"node_modules/@jest/console\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/console/-/console-29.7.0.tgz\",\n      \"integrity\": \"sha512-5Ni4CU7XHQi32IJ398EEP4RrB8eV09sXP2ROqD4bksHrnTree52PsxvX8tpL8LvTZ3pFzXyPbNQReSN41CAhOg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"chalk\": \"^4.0.0\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"slash\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/core\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/core/-/core-29.7.0.tgz\",\n      \"integrity\": \"sha512-n7aeXWKMnGtDA48y8TLWJPJmLmmZ642Ceo78cYWEpiD7FzDgmNDV/GCVRorPABdXLJZ/9wzzgZAlHjXjxDHGsg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/console\": \"^29.7.0\",\n        \"@jest/reporters\": \"^29.7.0\",\n        \"@jest/test-result\": \"^29.7.0\",\n        \"@jest/transform\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"ansi-escapes\": \"^4.2.1\",\n        \"chalk\": \"^4.0.0\",\n        \"ci-info\": \"^3.2.0\",\n        \"exit\": \"^0.1.2\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-changed-files\": \"^29.7.0\",\n        \"jest-config\": \"^29.7.0\",\n        \"jest-haste-map\": \"^29.7.0\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-regex-util\": \"^29.6.3\",\n        \"jest-resolve\": \"^29.7.0\",\n        \"jest-resolve-dependencies\": \"^29.7.0\",\n        \"jest-runner\": \"^29.7.0\",\n        \"jest-runtime\": \"^29.7.0\",\n        \"jest-snapshot\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"jest-validate\": \"^29.7.0\",\n        \"jest-watcher\": \"^29.7.0\",\n        \"micromatch\": \"^4.0.4\",\n        \"pretty-format\": \"^29.7.0\",\n        \"slash\": \"^3.0.0\",\n        \"strip-ansi\": \"^6.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      },\n      \"peerDependencies\": {\n        \"node-notifier\": \"^8.0.1 || ^9.0.0 || ^10.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"node-notifier\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@jest/environment\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/environment/-/environment-29.7.0.tgz\",\n      \"integrity\": \"sha512-aQIfHDq33ExsN4jP1NWGXhxgQ/wixs60gDiKO+XVMd8Mn0NWPWgc34ZQDTb2jKaUWQ7MuwoitXAsN2XVXNMpAw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/fake-timers\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"jest-mock\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/expect\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/expect/-/expect-29.7.0.tgz\",\n      \"integrity\": \"sha512-8uMeAMycttpva3P1lBHB8VciS9V0XAr3GymPpipdyQXbBcuhkLQOSe8E/p92RyAdToS6ZD1tFkX+CkhoECE0dQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"expect\": \"^29.7.0\",\n        \"jest-snapshot\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/expect-utils\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/expect-utils/-/expect-utils-29.7.0.tgz\",\n      \"integrity\": \"sha512-GlsNBWiFQFCVi9QVSx7f5AgMeLxe9YCCs5PuP2O2LdjDAA8Jh9eX7lA1Jq/xdXw3Wb3hyvlFNfZIfcRetSzYcA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"jest-get-type\": \"^29.6.3\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/fake-timers\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/fake-timers/-/fake-timers-29.7.0.tgz\",\n      \"integrity\": \"sha512-q4DH1Ha4TTFPdxLsqDXK1d3+ioSL7yL5oCMJZgDYm6i+6CygW5E5xVr/D1HdsGxjt1ZWSfUAs9OxSB/BNelWrQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/types\": \"^29.6.3\",\n        \"@sinonjs/fake-timers\": \"^10.0.2\",\n        \"@types/node\": \"*\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-mock\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/globals\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/globals/-/globals-29.7.0.tgz\",\n      \"integrity\": \"sha512-mpiz3dutLbkW2MNFubUGUEVLkTGiqW6yLVTA+JbP6fI6J5iL9Y0Nlg8k95pcF8ctKwCS7WVxteBs29hhfAotzQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/environment\": \"^29.7.0\",\n        \"@jest/expect\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"jest-mock\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/reporters\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/reporters/-/reporters-29.7.0.tgz\",\n      \"integrity\": \"sha512-DApq0KJbJOEzAFYjHADNNxAE3KbhxQB1y5Kplb5Waqw6zVbuWatSnMjE5gs8FUgEPmNsnZA3NCWl9NG0ia04Pg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@bcoe/v8-coverage\": \"^0.2.3\",\n        \"@jest/console\": \"^29.7.0\",\n        \"@jest/test-result\": \"^29.7.0\",\n        \"@jest/transform\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@jridgewell/trace-mapping\": \"^0.3.18\",\n        \"@types/node\": \"*\",\n        \"chalk\": \"^4.0.0\",\n        \"collect-v8-coverage\": \"^1.0.0\",\n        \"exit\": \"^0.1.2\",\n        \"glob\": \"^7.1.3\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"istanbul-lib-coverage\": \"^3.0.0\",\n        \"istanbul-lib-instrument\": \"^6.0.0\",\n        \"istanbul-lib-report\": \"^3.0.0\",\n        \"istanbul-lib-source-maps\": \"^4.0.0\",\n        \"istanbul-reports\": \"^3.1.3\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"jest-worker\": \"^29.7.0\",\n        \"slash\": \"^3.0.0\",\n        \"string-length\": \"^4.0.1\",\n        \"strip-ansi\": \"^6.0.0\",\n        \"v8-to-istanbul\": \"^9.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      },\n      \"peerDependencies\": {\n        \"node-notifier\": \"^8.0.1 || ^9.0.0 || ^10.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"node-notifier\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@jest/schemas\": {\n      \"version\": \"29.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/schemas/-/schemas-29.6.3.tgz\",\n      \"integrity\": \"sha512-mo5j5X+jIZmJQveBKeS/clAueipV7KgiX1vMgCxam1RNYiqE1w62n0/tJJnHtjW8ZHcQco5gY85jA3mi0L+nSA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@sinclair/typebox\": \"^0.27.8\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/source-map\": {\n      \"version\": \"29.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/source-map/-/source-map-29.6.3.tgz\",\n      \"integrity\": \"sha512-MHjT95QuipcPrpLM+8JMSzFx6eHp5Bm+4XeFDJlwsvVBjmKNiIAvasGK2fxz2WbGRlnvqehFbh07MMa7n3YJnw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jridgewell/trace-mapping\": \"^0.3.18\",\n        \"callsites\": \"^3.0.0\",\n        \"graceful-fs\": \"^4.2.9\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/test-result\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/test-result/-/test-result-29.7.0.tgz\",\n      \"integrity\": \"sha512-Fdx+tv6x1zlkJPcWXmMDAG2HBnaR9XPSd5aDWQVsfrZmLVT3lU1cwyxLgRmXR9yrq4NBoEm9BMsfgFzTQAbJYA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/console\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/istanbul-lib-coverage\": \"^2.0.0\",\n        \"collect-v8-coverage\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/test-sequencer\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/test-sequencer/-/test-sequencer-29.7.0.tgz\",\n      \"integrity\": \"sha512-GQwJ5WZVrKnOJuiYiAF52UNUJXgTZx1NHjFSEB0qEMmSZKAkdMoIzw/Cj6x6NF4AvV23AUqDpFzQkN/eYCYTxw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/test-result\": \"^29.7.0\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-haste-map\": \"^29.7.0\",\n        \"slash\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/transform\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/transform/-/transform-29.7.0.tgz\",\n      \"integrity\": \"sha512-ok/BTPFzFKVMwO5eOHRrvnBVHdRy9IrsrW1GpMaQ9MCnilNLXQKmAX8s1YXDFaai9xJpac2ySzV0YeRRECr2Vw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/core\": \"^7.11.6\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@jridgewell/trace-mapping\": \"^0.3.18\",\n        \"babel-plugin-istanbul\": \"^6.1.1\",\n        \"chalk\": \"^4.0.0\",\n        \"convert-source-map\": \"^2.0.0\",\n        \"fast-json-stable-stringify\": \"^2.1.0\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-haste-map\": \"^29.7.0\",\n        \"jest-regex-util\": \"^29.6.3\",\n        \"jest-util\": \"^29.7.0\",\n        \"micromatch\": \"^4.0.4\",\n        \"pirates\": \"^4.0.4\",\n        \"slash\": \"^3.0.0\",\n        \"write-file-atomic\": \"^4.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jest/types\": {\n      \"version\": \"29.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/@jest/types/-/types-29.6.3.tgz\",\n      \"integrity\": \"sha512-u3UPsIilWKOM3F9CXtrG8LEJmNxwoCQC/XVj4IKYXvvpx7QIi/Kg1LI5uDmDpKlac62NUtX7eLjRh+jVZcLOzw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/schemas\": \"^29.6.3\",\n        \"@types/istanbul-lib-coverage\": \"^2.0.0\",\n        \"@types/istanbul-reports\": \"^3.0.0\",\n        \"@types/node\": \"*\",\n        \"@types/yargs\": \"^17.0.8\",\n        \"chalk\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/@jridgewell/gen-mapping\": {\n      \"version\": \"0.3.5\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.5.tgz\",\n      \"integrity\": \"sha512-IzL8ZoEDIBRWEzlCcRhOaCupYyN5gdIK+Q6fbFdPDg6HqX6jpkItn7DFIpW9LQzXG6Df9sA7+OKnq0qlz/GaQg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jridgewell/set-array\": \"^1.2.1\",\n        \"@jridgewell/sourcemap-codec\": \"^1.4.10\",\n        \"@jridgewell/trace-mapping\": \"^0.3.24\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.0.0\"\n      }\n    },\n    \"node_modules/@jridgewell/resolve-uri\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz\",\n      \"integrity\": \"sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6.0.0\"\n      }\n    },\n    \"node_modules/@jridgewell/set-array\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.2.1.tgz\",\n      \"integrity\": \"sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6.0.0\"\n      }\n    },\n    \"node_modules/@jridgewell/sourcemap-codec\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz\",\n      \"integrity\": \"sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==\",\n      \"dev\": true\n    },\n    \"node_modules/@jridgewell/trace-mapping\": {\n      \"version\": \"0.3.25\",\n      \"resolved\": \"https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.25.tgz\",\n      \"integrity\": \"sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jridgewell/resolve-uri\": \"^3.1.0\",\n        \"@jridgewell/sourcemap-codec\": \"^1.4.14\"\n      }\n    },\n    \"node_modules/@noble/hashes\": {\n      \"version\": \"1.8.0\",\n      \"resolved\": \"https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz\",\n      \"integrity\": \"sha512-jCs9ldd7NwzpgXDIf6P3+NrHh9/sD6CQdxHyjQI+h/6rDNo88ypBxxz45UDuZHz9r3tNz7N/VInSVoVdtXEI4A==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"^14.21.3 || \u003E=16\"\n      },\n      \"funding\": {\n        \"url\": \"https://paulmillr.com/funding/\"\n      }\n    },\n    \"node_modules/@nodelib/fs.scandir\": {\n      \"version\": \"2.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz\",\n      \"integrity\": \"sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@nodelib/fs.stat\": \"2.0.5\",\n        \"run-parallel\": \"^1.1.9\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 8\"\n      }\n    },\n    \"node_modules/@nodelib/fs.stat\": {\n      \"version\": \"2.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz\",\n      \"integrity\": \"sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E= 8\"\n      }\n    },\n    \"node_modules/@nodelib/fs.walk\": {\n      \"version\": \"1.2.8\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz\",\n      \"integrity\": \"sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@nodelib/fs.scandir\": \"2.1.5\",\n        \"fastq\": \"^1.6.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 8\"\n      }\n    },\n    \"node_modules/@paralleldrive/cuid2\": {\n      \"version\": \"2.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz\",\n      \"integrity\": \"sha512-ZOBkgDwEdoYVlSeRbYYXs0S9MejQofiVYoTbKzy/6GQa39/q5tQU2IX46+shYnUkpEl3wc+J6wRlar7r2EK2xA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@noble/hashes\": \"^1.1.5\"\n      }\n    },\n    \"node_modules/@sinclair/typebox\": {\n      \"version\": \"0.27.8\",\n      \"resolved\": \"https://registry.npmjs.org/@sinclair/typebox/-/typebox-0.27.8.tgz\",\n      \"integrity\": \"sha512-+Fj43pSMwJs4KRrH/938Uf+uAELIgVBmQzg/q1YG10djyfA3TnrU8N8XzqCh/okZdszqBQTZf96idMfE5lnwTA==\",\n      \"dev\": true\n    },\n    \"node_modules/@sinonjs/commons\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/@sinonjs/commons/-/commons-3.0.1.tgz\",\n      \"integrity\": \"sha512-K3mCHKQ9sVh8o1C9cxkwxaOmXoAMlDxC1mYyHrjqOWEcBjYr76t96zL2zlj5dUGZ3HSw240X1qgH3Mjf1yJWpQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"type-detect\": \"4.0.8\"\n      }\n    },\n    \"node_modules/@sinonjs/fake-timers\": {\n      \"version\": \"10.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/@sinonjs/fake-timers/-/fake-timers-10.3.0.tgz\",\n      \"integrity\": \"sha512-V4BG07kuYSUkTCSBHG8G8TNhM+F19jXFWnQtzj+we8DrkpSBCee9Z3Ms8yiGer/dlmhe35/Xdgyo3/0rQKg7YA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@sinonjs/commons\": \"^3.0.0\"\n      }\n    },\n    \"node_modules/@types/babel__core\": {\n      \"version\": \"7.20.5\",\n      \"resolved\": \"https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz\",\n      \"integrity\": \"sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/parser\": \"^7.20.7\",\n        \"@babel/types\": \"^7.20.7\",\n        \"@types/babel__generator\": \"*\",\n        \"@types/babel__template\": \"*\",\n        \"@types/babel__traverse\": \"*\"\n      }\n    },\n    \"node_modules/@types/babel__generator\": {\n      \"version\": \"7.6.8\",\n      \"resolved\": \"https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.6.8.tgz\",\n      \"integrity\": \"sha512-ASsj+tpEDsEiFr1arWrlN6V3mdfjRMZt6LtK/Vp/kreFLnr5QH5+DhvD5nINYZXzwJvXeGq+05iUXcAzVrqWtw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/types\": \"^7.0.0\"\n      }\n    },\n    \"node_modules/@types/babel__template\": {\n      \"version\": \"7.4.4\",\n      \"resolved\": \"https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz\",\n      \"integrity\": \"sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/parser\": \"^7.1.0\",\n        \"@babel/types\": \"^7.0.0\"\n      }\n    },\n    \"node_modules/@types/babel__traverse\": {\n      \"version\": \"7.20.6\",\n      \"resolved\": \"https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.20.6.tgz\",\n      \"integrity\": \"sha512-r1bzfrm0tomOI8g1SzvCaQHo6Lcv6zu0EA+W2kHrt8dyrHQxGzBBL4kdkzIS+jBMV+EYcMAEAqXqYaLJq5rOZg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/types\": \"^7.20.7\"\n      }\n    },\n    \"node_modules/@types/body-parser\": {\n      \"version\": \"1.19.5\",\n      \"resolved\": \"https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz\",\n      \"integrity\": \"sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/connect\": \"*\",\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@types/connect\": {\n      \"version\": \"3.4.38\",\n      \"resolved\": \"https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz\",\n      \"integrity\": \"sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@types/content-type\": {\n      \"version\": \"1.1.8\",\n      \"resolved\": \"https://registry.npmjs.org/@types/content-type/-/content-type-1.1.8.tgz\",\n      \"integrity\": \"sha512-1tBhmVUeso3+ahfyaKluXe38p+94lovUZdoVfQ3OnJo9uJC42JT7CBoN3k9HYhAae+GwiBYmHu+N9FZhOG+2Pg==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/cookiejar\": {\n      \"version\": \"2.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/@types/cookiejar/-/cookiejar-2.1.5.tgz\",\n      \"integrity\": \"sha512-he+DHOWReW0nghN24E1WUqM0efK4kI9oTqDm6XmK8ZPe2djZ90BSNdGnIyCLzCPw7/pogPlGbzI2wHGGmi4O/Q==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@types/cors\": {\n      \"version\": \"2.8.17\",\n      \"resolved\": \"https://registry.npmjs.org/@types/cors/-/cors-2.8.17.tgz\",\n      \"integrity\": \"sha512-8CGDvrBj1zgo2qE+oS3pOCyYNqCPryMWY2bGfwA0dcfopWGgxs+78df0Rs3rc9THP4JkOhLsAa+15VdpAqkcUA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@types/cross-spawn\": {\n      \"version\": \"6.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/@types/cross-spawn/-/cross-spawn-6.0.6.tgz\",\n      \"integrity\": \"sha512-fXRhhUkG4H3TQk5dBhQ7m/JDdSNHKwR2BBia62lhwEIq9xGiQKLxd6LymNhn47SjXhsUEPmxi+PKw2OkW4LLjA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@types/eslint\": {\n      \"version\": \"9.6.1\",\n      \"resolved\": \"https://registry.npmjs.org/@types/eslint/-/eslint-9.6.1.tgz\",\n      \"integrity\": \"sha512-FXx2pKgId/WyYo2jXw63kk7/+TY7u7AziEJxJAnSFzHlqTAS3Ync6SvgYAN/k4/PQpnnVuzoMuVnByKK2qp0ag==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/estree\": \"*\",\n        \"@types/json-schema\": \"*\"\n      }\n    },\n    \"node_modules/@types/eslint__js\": {\n      \"version\": \"8.42.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/eslint__js/-/eslint__js-8.42.3.tgz\",\n      \"integrity\": \"sha512-alfG737uhmPdnvkrLdZLcEKJ/B8s9Y4hrZ+YAdzUeoArBlSUERA2E87ROfOaS4jd/C45fzOoZzidLc1IPwLqOw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/eslint\": \"*\"\n      }\n    },\n    \"node_modules/@types/estree\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/@types/estree/-/estree-1.0.6.tgz\",\n      \"integrity\": \"sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/eventsource\": {\n      \"version\": \"1.1.15\",\n      \"resolved\": \"https://registry.npmjs.org/@types/eventsource/-/eventsource-1.1.15.tgz\",\n      \"integrity\": \"sha512-XQmGcbnxUNa06HR3VBVkc9+A2Vpi9ZyLJcdS5dwaQQ/4ZMWFO+5c90FnMUpbtMZwB/FChoYHwuVg8TvkECacTA==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/express\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/@types/express/-/express-5.0.0.tgz\",\n      \"integrity\": \"sha512-DvZriSMehGHL1ZNLzi6MidnsDhUZM/x2pRdDIKdwbUNqqwHxMlRdkxtn6/EPKyqKpHqTl/4nRZsRNLpZxZRpPQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/body-parser\": \"*\",\n        \"@types/express-serve-static-core\": \"^5.0.0\",\n        \"@types/qs\": \"*\",\n        \"@types/serve-static\": \"*\"\n      }\n    },\n    \"node_modules/@types/express-serve-static-core\": {\n      \"version\": \"5.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-5.0.6.tgz\",\n      \"integrity\": \"sha512-3xhRnjJPkULekpSzgtoNYYcTWgEZkp4myc+Saevii5JPnHNvHMRlBSHDbs7Bh1iPPoVTERHEZXyhyLbMEsExsA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/node\": \"*\",\n        \"@types/qs\": \"*\",\n        \"@types/range-parser\": \"*\",\n        \"@types/send\": \"*\"\n      }\n    },\n    \"node_modules/@types/graceful-fs\": {\n      \"version\": \"4.1.9\",\n      \"resolved\": \"https://registry.npmjs.org/@types/graceful-fs/-/graceful-fs-4.1.9.tgz\",\n      \"integrity\": \"sha512-olP3sd1qOEe5dXTSaFvQG+02VdRXcdytWLAZsAq1PecU8uqQAhkrnbli7DagjtXKW/Bl7YJbUsa8MPcuc8LHEQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@types/http-errors\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz\",\n      \"integrity\": \"sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/istanbul-lib-coverage\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/@types/istanbul-lib-coverage/-/istanbul-lib-coverage-2.0.6.tgz\",\n      \"integrity\": \"sha512-2QF/t/auWm0lsy8XtKVPG19v3sSOQlJe/YHZgfjb/KBBHOGSV+J2q/S671rcq9uTBrLAXmZpqJiaQbMT+zNU1w==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/istanbul-lib-report\": {\n      \"version\": \"3.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/istanbul-lib-report/-/istanbul-lib-report-3.0.3.tgz\",\n      \"integrity\": \"sha512-NQn7AHQnk/RSLOxrBbGyJM/aVQ+pjj5HCgasFxc0K/KhoATfQ/47AyUl15I2yBUpihjmas+a+VJBOqecrFH+uA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/istanbul-lib-coverage\": \"*\"\n      }\n    },\n    \"node_modules/@types/istanbul-reports\": {\n      \"version\": \"3.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/@types/istanbul-reports/-/istanbul-reports-3.0.4.tgz\",\n      \"integrity\": \"sha512-pk2B1NWalF9toCRu6gjBzR69syFjP4Od8WRAX+0mmf9lAjCRicLOWc+ZrxZHx/0XRjotgkF9t6iaMJ+aXcOdZQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/istanbul-lib-report\": \"*\"\n      }\n    },\n    \"node_modules/@types/jest\": {\n      \"version\": \"29.5.14\",\n      \"resolved\": \"https://registry.npmjs.org/@types/jest/-/jest-29.5.14.tgz\",\n      \"integrity\": \"sha512-ZN+4sdnLUbo8EVvVc2ao0GFW6oVrQRPn4K2lglySj7APvSrgzxHiNNK99us4WDMi57xxA2yggblIAMNhXOotLQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"expect\": \"^29.0.0\",\n        \"pretty-format\": \"^29.0.0\"\n      }\n    },\n    \"node_modules/@types/json-schema\": {\n      \"version\": \"7.0.15\",\n      \"resolved\": \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz\",\n      \"integrity\": \"sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/methods\": {\n      \"version\": \"1.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/@types/methods/-/methods-1.1.4.tgz\",\n      \"integrity\": \"sha512-ymXWVrDiCxTBE3+RIrrP533E70eA+9qu7zdWoHuOmGujkYtzf4HQF96b8nwHLqhuf4ykX61IGRIB38CC6/sImQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@types/mime\": {\n      \"version\": \"1.3.5\",\n      \"resolved\": \"https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz\",\n      \"integrity\": \"sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/node\": {\n      \"version\": \"22.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-22.8.1.tgz\",\n      \"integrity\": \"sha512-k6Gi8Yyo8EtrNtkHXutUu2corfDf9su95VYVP10aGYMMROM6SAItZi0w1XszA6RtWTHSVp5OeFof37w0IEqCQg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"undici-types\": \"~6.19.8\"\n      }\n    },\n    \"node_modules/@types/qs\": {\n      \"version\": \"6.9.18\",\n      \"resolved\": \"https://registry.npmjs.org/@types/qs/-/qs-6.9.18.tgz\",\n      \"integrity\": \"sha512-kK7dgTYDyGqS+e2Q4aK9X3D7q234CIZ1Bv0q/7Z5IwRDoADNU81xXJK/YVyLbLTZCoIwUoDoffFeF+p/eIklAA==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@types/range-parser\": {\n      \"version\": \"1.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz\",\n      \"integrity\": \"sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/@types/send\": {\n      \"version\": \"0.17.4\",\n      \"resolved\": \"https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz\",\n      \"integrity\": \"sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/mime\": \"^1\",\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@types/serve-static\": {\n      \"version\": \"1.15.7\",\n      \"resolved\": \"https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz\",\n      \"integrity\": \"sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/http-errors\": \"*\",\n        \"@types/node\": \"*\",\n        \"@types/send\": \"*\"\n      }\n    },\n    \"node_modules/@types/stack-utils\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/stack-utils/-/stack-utils-2.0.3.tgz\",\n      \"integrity\": \"sha512-9aEbYZ3TbYMznPdcdr3SmIrLXwC/AKZXQeCf9Pgao5CKb8CyHuEX5jzWPTkvregvhRJHcpRO6BFoGW9ycaOkYw==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/superagent\": {\n      \"version\": \"8.1.9\",\n      \"resolved\": \"https://registry.npmjs.org/@types/superagent/-/superagent-8.1.9.tgz\",\n      \"integrity\": \"sha512-pTVjI73witn+9ILmoJdajHGW2jkSaOzhiFYF1Rd3EQ94kymLqB9PjD9ISg7WaALC7+dCHT0FGe9T2LktLq/3GQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/cookiejar\": \"^2.1.5\",\n        \"@types/methods\": \"^1.1.4\",\n        \"@types/node\": \"*\",\n        \"form-data\": \"^4.0.0\"\n      }\n    },\n    \"node_modules/@types/supertest\": {\n      \"version\": \"6.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/@types/supertest/-/supertest-6.0.2.tgz\",\n      \"integrity\": \"sha512-137ypx2lk/wTQbW6An6safu9hXmajAifU/s7szAHLN/FeIm5w7yR0Wkl9fdJMRSHwOn4HLAI0DaB2TOORuhPDg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@types/methods\": \"^1.1.4\",\n        \"@types/superagent\": \"^8.1.0\"\n      }\n    },\n    \"node_modules/@types/ws\": {\n      \"version\": \"8.5.12\",\n      \"resolved\": \"https://registry.npmjs.org/@types/ws/-/ws-8.5.12.tgz\",\n      \"integrity\": \"sha512-3tPRkv1EtkDpzlgyKyI8pGsGZAGPEaXeu0DOj5DI25Ja91bdAYddYHbADRYVrZMRbfW+1l5YwXVDKohDJNQxkQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@types/yargs\": {\n      \"version\": \"17.0.33\",\n      \"resolved\": \"https://registry.npmjs.org/@types/yargs/-/yargs-17.0.33.tgz\",\n      \"integrity\": \"sha512-WpxBCKWPLr4xSsHgz511rFJAM+wS28w2zEO1QDNY5zM/S8ok70NNfztH0xwhqKyaK0OHCbN98LDAZuy1ctxDkA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/yargs-parser\": \"*\"\n      }\n    },\n    \"node_modules/@types/yargs-parser\": {\n      \"version\": \"21.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/yargs-parser/-/yargs-parser-21.0.3.tgz\",\n      \"integrity\": \"sha512-I4q9QU9MQv4oEOz4tAHJtNz1cwuLxn2F3xcc2iV5WdqLPpUnj30aUuxt1mAxYTG+oe8CZMV/+6rU4S4gRDzqtQ==\",\n      \"dev\": true\n    },\n    \"node_modules/@typescript-eslint/eslint-plugin\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-8.11.0.tgz\",\n      \"integrity\": \"sha512-KhGn2LjW1PJT2A/GfDpiyOfS4a8xHQv2myUagTM5+zsormOmBlYsnQ6pobJ8XxJmh6hnHwa2Mbe3fPrDJoDhbA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@eslint-community/regexpp\": \"^4.10.0\",\n        \"@typescript-eslint/scope-manager\": \"8.11.0\",\n        \"@typescript-eslint/type-utils\": \"8.11.0\",\n        \"@typescript-eslint/utils\": \"8.11.0\",\n        \"@typescript-eslint/visitor-keys\": \"8.11.0\",\n        \"graphemer\": \"^1.4.0\",\n        \"ignore\": \"^5.3.1\",\n        \"natural-compare\": \"^1.4.0\",\n        \"ts-api-utils\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependencies\": {\n        \"@typescript-eslint/parser\": \"^8.0.0 || ^8.0.0-alpha.0\",\n        \"eslint\": \"^8.57.0 || ^9.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/parser\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.11.0.tgz\",\n      \"integrity\": \"sha512-lmt73NeHdy1Q/2ul295Qy3uninSqi6wQI18XwSpm8w0ZbQXUpjCAWP1Vlv/obudoBiIjJVjlztjQ+d/Md98Yxg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/scope-manager\": \"8.11.0\",\n        \"@typescript-eslint/types\": \"8.11.0\",\n        \"@typescript-eslint/typescript-estree\": \"8.11.0\",\n        \"@typescript-eslint/visitor-keys\": \"8.11.0\",\n        \"debug\": \"^4.3.4\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^8.57.0 || ^9.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/scope-manager\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.11.0.tgz\",\n      \"integrity\": \"sha512-Uholz7tWhXmA4r6epo+vaeV7yjdKy5QFCERMjs1kMVsLRKIrSdM6o21W2He9ftp5PP6aWOVpD5zvrvuHZC0bMQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/types\": \"8.11.0\",\n        \"@typescript-eslint/visitor-keys\": \"8.11.0\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      }\n    },\n    \"node_modules/@typescript-eslint/type-utils\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-8.11.0.tgz\",\n      \"integrity\": \"sha512-ItiMfJS6pQU0NIKAaybBKkuVzo6IdnAhPFZA/2Mba/uBjuPQPet/8+zh5GtLHwmuFRShZx+8lhIs7/QeDHflOg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/typescript-estree\": \"8.11.0\",\n        \"@typescript-eslint/utils\": \"8.11.0\",\n        \"debug\": \"^4.3.4\",\n        \"ts-api-utils\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/types\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/types/-/types-8.11.0.tgz\",\n      \"integrity\": \"sha512-tn6sNMHf6EBAYMvmPUaKaVeYvhUsrE6x+bXQTxjQRp360h1giATU0WvgeEys1spbvb5R+VpNOZ+XJmjD8wOUHw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      }\n    },\n    \"node_modules/@typescript-eslint/typescript-estree\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.11.0.tgz\",\n      \"integrity\": \"sha512-yHC3s1z1RCHoCz5t06gf7jH24rr3vns08XXhfEqzYpd6Hll3z/3g23JRi0jM8A47UFKNc3u/y5KIMx8Ynbjohg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/types\": \"8.11.0\",\n        \"@typescript-eslint/visitor-keys\": \"8.11.0\",\n        \"debug\": \"^4.3.4\",\n        \"fast-glob\": \"^3.3.2\",\n        \"is-glob\": \"^4.0.3\",\n        \"minimatch\": \"^9.0.4\",\n        \"semver\": \"^7.6.0\",\n        \"ts-api-utils\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/typescript-estree/node_modules/brace-expansion\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz\",\n      \"integrity\": \"sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\"\n      }\n    },\n    \"node_modules/@typescript-eslint/typescript-estree/node_modules/minimatch\": {\n      \"version\": \"9.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz\",\n      \"integrity\": \"sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=16 || 14 \u003E=14.17\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/@typescript-eslint/typescript-estree/node_modules/semver\": {\n      \"version\": \"7.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.6.3.tgz\",\n      \"integrity\": \"sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/@typescript-eslint/utils\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/utils/-/utils-8.11.0.tgz\",\n      \"integrity\": \"sha512-CYiX6WZcbXNJV7UNB4PLDIBtSdRmRI/nb0FMyqHPTQD1rMjA0foPLaPUV39C/MxkTd/QKSeX+Gb34PPsDVC35g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@eslint-community/eslint-utils\": \"^4.4.0\",\n        \"@typescript-eslint/scope-manager\": \"8.11.0\",\n        \"@typescript-eslint/types\": \"8.11.0\",\n        \"@typescript-eslint/typescript-estree\": \"8.11.0\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^8.57.0 || ^9.0.0\"\n      }\n    },\n    \"node_modules/@typescript-eslint/visitor-keys\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.11.0.tgz\",\n      \"integrity\": \"sha512-EaewX6lxSjRJnc+99+dqzTeoDZUfyrA52d2/HRrkI830kgovWsmIiTfmr0NZorzqic7ga+1bS60lRBUgR3n/Bw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/types\": \"8.11.0\",\n        \"eslint-visitor-keys\": \"^3.4.3\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      }\n    },\n    \"node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys\": {\n      \"version\": \"3.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz\",\n      \"integrity\": \"sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || \u003E=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/eslint\"\n      }\n    },\n    \"node_modules/accepts\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz\",\n      \"integrity\": \"sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-types\": \"^3.0.0\",\n        \"negotiator\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/acorn\": {\n      \"version\": \"8.14.0\",\n      \"resolved\": \"https://registry.npmjs.org/acorn/-/acorn-8.14.0.tgz\",\n      \"integrity\": \"sha512-cl669nCJTZBsL97OF4kUQm5g5hC2uihk0NxY3WENAC0TYdILVkAyHymAntgxGkl7K+t0cXIrH5siy5S4XkFycA==\",\n      \"dev\": true,\n      \"bin\": {\n        \"acorn\": \"bin/acorn\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=0.4.0\"\n      }\n    },\n    \"node_modules/acorn-jsx\": {\n      \"version\": \"5.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz\",\n      \"integrity\": \"sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==\",\n      \"dev\": true,\n      \"peerDependencies\": {\n        \"acorn\": \"^6.0.0 || ^7.0.0 || ^8.0.0\"\n      }\n    },\n    \"node_modules/ajv\": {\n      \"version\": \"6.12.6\",\n      \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz\",\n      \"integrity\": \"sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"fast-deep-equal\": \"^3.1.1\",\n        \"fast-json-stable-stringify\": \"^2.0.0\",\n        \"json-schema-traverse\": \"^0.4.1\",\n        \"uri-js\": \"^4.2.2\"\n      },\n      \"funding\": {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/epoberezkin\"\n      }\n    },\n    \"node_modules/ansi-escapes\": {\n      \"version\": \"4.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz\",\n      \"integrity\": \"sha512-gKXj5ALrKWQLsYG9jlTRmR/xKluxHV+Z9QEwNIgCfM1/uwPMCuzVVnh5mwTd+OuBZcwSIMbqssNWRm1lE51QaQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"type-fest\": \"^0.21.3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\",\n      \"integrity\": \"sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/ansi-styles\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz\",\n      \"integrity\": \"sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"color-convert\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-styles?sponsor=1\"\n      }\n    },\n    \"node_modules/anymatch\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz\",\n      \"integrity\": \"sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"normalize-path\": \"^3.0.0\",\n        \"picomatch\": \"^2.0.4\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 8\"\n      }\n    },\n    \"node_modules/argparse\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz\",\n      \"integrity\": \"sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==\",\n      \"dev\": true\n    },\n    \"node_modules/asap\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/asap/-/asap-2.0.6.tgz\",\n      \"integrity\": \"sha512-BSHWgDSAiKs50o2Re8ppvp3seVHXSRM44cdSsT9FfNEUUZLOGWVCsiWaRPWM1Znn+mqZ1OfVZ3z3DWEzSp7hRA==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/async\": {\n      \"version\": \"3.2.6\",\n      \"resolved\": \"https://registry.npmjs.org/async/-/async-3.2.6.tgz\",\n      \"integrity\": \"sha512-htCUDlxyyCLMgaM3xXg0C0LW2xqfuQ6p05pCEIsXuyQ+a1koYKTuBMzRNwmybfLgvJDMd0r1LTn4+E0Ti6C2AA==\",\n      \"dev\": true\n    },\n    \"node_modules/asynckit\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz\",\n      \"integrity\": \"sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/babel-jest\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/babel-jest/-/babel-jest-29.7.0.tgz\",\n      \"integrity\": \"sha512-BrvGY3xZSwEcCzKvKsCi2GgHqDqsYkOP4/by5xCgIwGXQxIEh+8ew3gmrE1y7XRR6LHZIj6yLYnUi/mm2KXKBg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/transform\": \"^29.7.0\",\n        \"@types/babel__core\": \"^7.1.14\",\n        \"babel-plugin-istanbul\": \"^6.1.1\",\n        \"babel-preset-jest\": \"^29.6.3\",\n        \"chalk\": \"^4.0.0\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"slash\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.8.0\"\n      }\n    },\n    \"node_modules/babel-plugin-istanbul\": {\n      \"version\": \"6.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/babel-plugin-istanbul/-/babel-plugin-istanbul-6.1.1.tgz\",\n      \"integrity\": \"sha512-Y1IQok9821cC9onCx5otgFfRm7Lm+I+wwxOx738M/WLPZ9Q42m4IG5W0FNX8WLL2gYMZo3JkuXIH2DOpWM+qwA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-plugin-utils\": \"^7.0.0\",\n        \"@istanbuljs/load-nyc-config\": \"^1.0.0\",\n        \"@istanbuljs/schema\": \"^0.1.2\",\n        \"istanbul-lib-instrument\": \"^5.0.4\",\n        \"test-exclude\": \"^6.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/babel-plugin-istanbul/node_modules/istanbul-lib-instrument\": {\n      \"version\": \"5.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/istanbul-lib-instrument/-/istanbul-lib-instrument-5.2.1.tgz\",\n      \"integrity\": \"sha512-pzqtp31nLv/XFOzXGuvhCb8qhjmTVo5vjVk19XE4CRlSWz0KoeJ3bw9XsA7nOp9YBf4qHjwBxkDzKcME/J29Yg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/core\": \"^7.12.3\",\n        \"@babel/parser\": \"^7.14.7\",\n        \"@istanbuljs/schema\": \"^0.1.2\",\n        \"istanbul-lib-coverage\": \"^3.2.0\",\n        \"semver\": \"^6.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/babel-plugin-jest-hoist\": {\n      \"version\": \"29.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/babel-plugin-jest-hoist/-/babel-plugin-jest-hoist-29.6.3.tgz\",\n      \"integrity\": \"sha512-ESAc/RJvGTFEzRwOTT4+lNDk/GNHMkKbNzsvT0qKRfDyyYTskxB5rnU2njIDYVxXCBHHEI1c0YwHob3WaYujOg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/template\": \"^7.3.3\",\n        \"@babel/types\": \"^7.3.3\",\n        \"@types/babel__core\": \"^7.1.14\",\n        \"@types/babel__traverse\": \"^7.0.6\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/babel-preset-current-node-syntax\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/babel-preset-current-node-syntax/-/babel-preset-current-node-syntax-1.1.0.tgz\",\n      \"integrity\": \"sha512-ldYss8SbBlWva1bs28q78Ju5Zq1F+8BrqBZZ0VFhLBvhh6lCpC2o3gDJi/5DRLs9FgYZCnmPYIVFU4lRXCkyUw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/plugin-syntax-async-generators\": \"^7.8.4\",\n        \"@babel/plugin-syntax-bigint\": \"^7.8.3\",\n        \"@babel/plugin-syntax-class-properties\": \"^7.12.13\",\n        \"@babel/plugin-syntax-class-static-block\": \"^7.14.5\",\n        \"@babel/plugin-syntax-import-attributes\": \"^7.24.7\",\n        \"@babel/plugin-syntax-import-meta\": \"^7.10.4\",\n        \"@babel/plugin-syntax-json-strings\": \"^7.8.3\",\n        \"@babel/plugin-syntax-logical-assignment-operators\": \"^7.10.4\",\n        \"@babel/plugin-syntax-nullish-coalescing-operator\": \"^7.8.3\",\n        \"@babel/plugin-syntax-numeric-separator\": \"^7.10.4\",\n        \"@babel/plugin-syntax-object-rest-spread\": \"^7.8.3\",\n        \"@babel/plugin-syntax-optional-catch-binding\": \"^7.8.3\",\n        \"@babel/plugin-syntax-optional-chaining\": \"^7.8.3\",\n        \"@babel/plugin-syntax-private-property-in-object\": \"^7.14.5\",\n        \"@babel/plugin-syntax-top-level-await\": \"^7.14.5\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0\"\n      }\n    },\n    \"node_modules/babel-preset-jest\": {\n      \"version\": \"29.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/babel-preset-jest/-/babel-preset-jest-29.6.3.tgz\",\n      \"integrity\": \"sha512-0B3bhxR6snWXJZtR/RliHTDPRgn1sNHOR0yVtq/IiQFyuOVjFS+wuio/R4gSNkyYmKmJB4wGZv2NZanmKmTnNA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"babel-plugin-jest-hoist\": \"^29.6.3\",\n        \"babel-preset-current-node-syntax\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"^7.0.0\"\n      }\n    },\n    \"node_modules/balanced-match\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\",\n      \"integrity\": \"sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\",\n      \"dev\": true\n    },\n    \"node_modules/body-parser\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/body-parser/-/body-parser-2.1.0.tgz\",\n      \"integrity\": \"sha512-/hPxh61E+ll0Ujp24Ilm64cykicul1ypfwjVttduAiEdtnJFvLePSrIPk+HMImtNv5270wOGCb1Tns2rybMkoQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"bytes\": \"^3.1.2\",\n        \"content-type\": \"^1.0.5\",\n        \"debug\": \"^4.4.0\",\n        \"http-errors\": \"^2.0.0\",\n        \"iconv-lite\": \"^0.5.2\",\n        \"on-finished\": \"^2.4.1\",\n        \"qs\": \"^6.14.0\",\n        \"raw-body\": \"^3.0.0\",\n        \"type-is\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      }\n    },\n    \"node_modules/body-parser/node_modules/debug\": {\n      \"version\": \"4.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-4.4.0.tgz\",\n      \"integrity\": \"sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ms\": \"^2.1.3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"supports-color\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/body-parser/node_modules/qs\": {\n      \"version\": \"6.14.0\",\n      \"resolved\": \"https://registry.npmjs.org/qs/-/qs-6.14.0.tgz\",\n      \"integrity\": \"sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==\",\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"side-channel\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=0.6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"node_modules/braces\": {\n      \"version\": \"3.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/braces/-/braces-3.0.3.tgz\",\n      \"integrity\": \"sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"fill-range\": \"^7.1.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/browserslist\": {\n      \"version\": \"4.24.2\",\n      \"resolved\": \"https://registry.npmjs.org/browserslist/-/browserslist-4.24.2.tgz\",\n      \"integrity\": \"sha512-ZIc+Q62revdMcqC6aChtW4jz3My3klmCO1fEmINZY/8J3EpBg5/A/D0AKmBveUh6pgoeycoMkVMko84tuYS+Gg==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"opencollective\",\n          \"url\": \"https://opencollective.com/browserslist\"\n        },\n        {\n          \"type\": \"tidelift\",\n          \"url\": \"https://tidelift.com/funding/github/npm/browserslist\"\n        },\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/ai\"\n        }\n      ],\n      \"dependencies\": {\n        \"caniuse-lite\": \"^1.0.30001669\",\n        \"electron-to-chromium\": \"^1.5.41\",\n        \"node-releases\": \"^2.0.18\",\n        \"update-browserslist-db\": \"^1.1.1\"\n      },\n      \"bin\": {\n        \"browserslist\": \"cli.js\"\n      },\n      \"engines\": {\n        \"node\": \"^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || \u003E=13.7\"\n      }\n    },\n    \"node_modules/bs-logger\": {\n      \"version\": \"0.2.6\",\n      \"resolved\": \"https://registry.npmjs.org/bs-logger/-/bs-logger-0.2.6.tgz\",\n      \"integrity\": \"sha512-pd8DCoxmbgc7hyPKOvxtqNcjYoOsABPQdcCUjGp3d42VR2CX1ORhk2A87oqqu5R1kk+76nsxZupkmyd+MVtCog==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"fast-json-stable-stringify\": \"2.x\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 6\"\n      }\n    },\n    \"node_modules/bser\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/bser/-/bser-2.1.1.tgz\",\n      \"integrity\": \"sha512-gQxTNE/GAfIIrmHLUE3oJyp5FO6HRBfhjnw4/wMmA63ZGDJnWBmgY/lyQBpnDUkGmAhbSe39tx2d/iTOAfglwQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"node-int64\": \"^0.4.0\"\n      }\n    },\n    \"node_modules/buffer-from\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz\",\n      \"integrity\": \"sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==\",\n      \"dev\": true\n    },\n    \"node_modules/bytes\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz\",\n      \"integrity\": \"sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/call-bind-apply-helpers\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz\",\n      \"integrity\": \"sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"function-bind\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/call-bound\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/call-bound/-/call-bound-1.0.3.tgz\",\n      \"integrity\": \"sha512-YTd+6wGlNlPxSuri7Y6X8tY2dmm12UMH66RpKMhiX6rsk5wXXnYgbUcOt8kiS31/AjfoTOvCsE+w8nZQLQnzHA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.1\",\n        \"get-intrinsic\": \"^1.2.6\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/callsites\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz\",\n      \"integrity\": \"sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/camelcase\": {\n      \"version\": \"5.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz\",\n      \"integrity\": \"sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/caniuse-lite\": {\n      \"version\": \"1.0.30001673\",\n      \"resolved\": \"https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001673.tgz\",\n      \"integrity\": \"sha512-WTrjUCSMp3LYX0nE12ECkV0a+e6LC85E0Auz75555/qr78Oc8YWhEPNfDd6SHdtlCMSzqtuXY0uyEMNRcsKpKw==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"opencollective\",\n          \"url\": \"https://opencollective.com/browserslist\"\n        },\n        {\n          \"type\": \"tidelift\",\n          \"url\": \"https://tidelift.com/funding/github/npm/caniuse-lite\"\n        },\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/ai\"\n        }\n      ]\n    },\n    \"node_modules/chalk\": {\n      \"version\": \"4.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz\",\n      \"integrity\": \"sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ansi-styles\": \"^4.1.0\",\n        \"supports-color\": \"^7.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/chalk?sponsor=1\"\n      }\n    },\n    \"node_modules/char-regex\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/char-regex/-/char-regex-1.0.2.tgz\",\n      \"integrity\": \"sha512-kWWXztvZ5SBQV+eRgKFeh8q5sLuZY2+8WUIzlxWVTg+oGwY14qylx1KbKzHd8P6ZYkAg0xyIDU9JMHhyJMZ1jw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/ci-info\": {\n      \"version\": \"3.9.0\",\n      \"resolved\": \"https://registry.npmjs.org/ci-info/-/ci-info-3.9.0.tgz\",\n      \"integrity\": \"sha512-NIxF55hv4nSqQswkAeiOi1r83xy8JldOFDTWiug55KBu9Jnblncd2U6ViHmYgHf01TPZS77NJBhBMKdWj9HQMQ==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/sibiraj-s\"\n        }\n      ],\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/cjs-module-lexer\": {\n      \"version\": \"1.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/cjs-module-lexer/-/cjs-module-lexer-1.4.1.tgz\",\n      \"integrity\": \"sha512-cuSVIHi9/9E/+821Qjdvngor+xpnlwnuwIyZOaLmHBVdXL+gP+I6QQB9VkO7RI77YIcTV+S1W9AreJ5eN63JBA==\",\n      \"dev\": true\n    },\n    \"node_modules/cliui\": {\n      \"version\": \"8.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/cliui/-/cliui-8.0.1.tgz\",\n      \"integrity\": \"sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"string-width\": \"^4.2.0\",\n        \"strip-ansi\": \"^6.0.1\",\n        \"wrap-ansi\": \"^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=12\"\n      }\n    },\n    \"node_modules/co\": {\n      \"version\": \"4.6.0\",\n      \"resolved\": \"https://registry.npmjs.org/co/-/co-4.6.0.tgz\",\n      \"integrity\": \"sha512-QVb0dM5HvG+uaxitm8wONl7jltx8dqhfU33DcqtOZcLSVIKSDDLDi7+0LbAKiyI8hD9u42m2YxXSkMGWThaecQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"iojs\": \"\u003E= 1.0.0\",\n        \"node\": \"\u003E= 0.12.0\"\n      }\n    },\n    \"node_modules/collect-v8-coverage\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/collect-v8-coverage/-/collect-v8-coverage-1.0.2.tgz\",\n      \"integrity\": \"sha512-lHl4d5/ONEbLlJvaJNtsF/Lz+WvB07u2ycqTYbdrq7UypDXailES4valYb2eWiJFxZlVmpGekfqoxQhzyFdT4Q==\",\n      \"dev\": true\n    },\n    \"node_modules/color-convert\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\",\n      \"integrity\": \"sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"color-name\": \"~1.1.4\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=7.0.0\"\n      }\n    },\n    \"node_modules/color-name\": {\n      \"version\": \"1.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\",\n      \"integrity\": \"sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==\",\n      \"dev\": true\n    },\n    \"node_modules/combined-stream\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz\",\n      \"integrity\": \"sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"delayed-stream\": \"~1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/component-emitter\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/component-emitter/-/component-emitter-1.3.1.tgz\",\n      \"integrity\": \"sha512-T0+barUSQRTUQASh8bx02dl+DhF54GtIDY13Y3m9oWTklKbb3Wv974meRpeZ3lp1JpLVECWWNHC4vaG2XHXouQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/concat-map\": {\n      \"version\": \"0.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n      \"integrity\": \"sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==\",\n      \"dev\": true\n    },\n    \"node_modules/content-disposition\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.0.tgz\",\n      \"integrity\": \"sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safe-buffer\": \"5.2.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/content-type\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz\",\n      \"integrity\": \"sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/convert-source-map\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz\",\n      \"integrity\": \"sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==\",\n      \"dev\": true\n    },\n    \"node_modules/cookie\": {\n      \"version\": \"0.7.1\",\n      \"resolved\": \"https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz\",\n      \"integrity\": \"sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/cookie-signature\": {\n      \"version\": \"1.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz\",\n      \"integrity\": \"sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E=6.6.0\"\n      }\n    },\n    \"node_modules/cookiejar\": {\n      \"version\": \"2.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/cookiejar/-/cookiejar-2.1.4.tgz\",\n      \"integrity\": \"sha512-LDx6oHrK+PhzLKJU9j5S7/Y3jM/mUHvD/DeI1WQmJn652iPC5Y4TBzC9l+5OMOXlyTTA+SmVUPm0HQUwpD5Jqw==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/cors\": {\n      \"version\": \"2.8.5\",\n      \"resolved\": \"https://registry.npmjs.org/cors/-/cors-2.8.5.tgz\",\n      \"integrity\": \"sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"object-assign\": \"^4\",\n        \"vary\": \"^1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.10\"\n      }\n    },\n    \"node_modules/create-jest\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/create-jest/-/create-jest-29.7.0.tgz\",\n      \"integrity\": \"sha512-Adz2bdH0Vq3F53KEMJOoftQFutWCukm6J24wbPWRO4k1kMY7gS7ds/uoJkNuV8wDCtWWnuwGcJwpWcih+zEW1Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/types\": \"^29.6.3\",\n        \"chalk\": \"^4.0.0\",\n        \"exit\": \"^0.1.2\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-config\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"prompts\": \"^2.0.1\"\n      },\n      \"bin\": {\n        \"create-jest\": \"bin/create-jest.js\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/cross-spawn\": {\n      \"version\": \"7.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.5.tgz\",\n      \"integrity\": \"sha512-ZVJrKKYunU38/76t0RMOulHOnUcbU9GbpWKAOZ0mhjr7CX6FVrH+4FrAapSOekrgFQ3f/8gwMEuIft0aKq6Hug==\",\n      \"dependencies\": {\n        \"path-key\": \"^3.1.0\",\n        \"shebang-command\": \"^2.0.0\",\n        \"which\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 8\"\n      }\n    },\n    \"node_modules/debug\": {\n      \"version\": \"4.3.7\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-4.3.7.tgz\",\n      \"integrity\": \"sha512-Er2nc/H7RrMXZBFCEim6TCmMk02Z8vLC2Rbi1KEBggpo0fS6l0S1nnapwmIi3yW/+GOJap1Krg4w0Hg80oCqgQ==\",\n      \"dependencies\": {\n        \"ms\": \"^2.1.3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"supports-color\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/dedent\": {\n      \"version\": \"1.5.3\",\n      \"resolved\": \"https://registry.npmjs.org/dedent/-/dedent-1.5.3.tgz\",\n      \"integrity\": \"sha512-NHQtfOOW68WD8lgypbLA5oT+Bt0xXJhiYvoR6SmmNXZfpzOGXwdKWmcwG8N7PwVVWV3eF/68nmD9BaJSsTBhyQ==\",\n      \"dev\": true,\n      \"peerDependencies\": {\n        \"babel-plugin-macros\": \"^3.1.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"babel-plugin-macros\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/deep-is\": {\n      \"version\": \"0.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz\",\n      \"integrity\": \"sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==\",\n      \"dev\": true\n    },\n    \"node_modules/deepmerge\": {\n      \"version\": \"4.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/deepmerge/-/deepmerge-4.3.1.tgz\",\n      \"integrity\": \"sha512-3sUqbMEc77XqpdNO7FRyRog+eW3ph+GYCbj+rK+uYyRMuwsVy0rMiVtPn+QJlKFvWP/1PYpapqYn0Me2knFn+A==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/delayed-stream\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz\",\n      \"integrity\": \"sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E=0.4.0\"\n      }\n    },\n    \"node_modules/depd\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/depd/-/depd-2.0.0.tgz\",\n      \"integrity\": \"sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/destroy\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz\",\n      \"integrity\": \"sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\",\n        \"npm\": \"1.2.8000 || \u003E= 1.4.16\"\n      }\n    },\n    \"node_modules/detect-newline\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/detect-newline/-/detect-newline-3.1.0.tgz\",\n      \"integrity\": \"sha512-TLz+x/vEXm/Y7P7wn1EJFNLxYpUD4TgMosxY6fAVJUnJMbupHBOncxyWUG9OpTaH9EBD7uFI5LfEgmMOc54DsA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/dezalgo\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/dezalgo/-/dezalgo-1.0.4.tgz\",\n      \"integrity\": \"sha512-rXSP0bf+5n0Qonsb+SVVfNfIsimO4HEtmnIpPHY8Q1UCzKlQrDMfdobr8nJOOsRgWCyMRqeSBQzmWUMq7zvVig==\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"asap\": \"^2.0.0\",\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/diff-sequences\": {\n      \"version\": \"29.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/diff-sequences/-/diff-sequences-29.6.3.tgz\",\n      \"integrity\": \"sha512-EjePK1srD3P08o2j4f0ExnylqRs5B9tJjcp9t1krH2qRi8CCdsYfwe9JgSLurFBWwq4uOlipzfk5fHNvwFKr8Q==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/dunder-proto\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz\",\n      \"integrity\": \"sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.1\",\n        \"es-errors\": \"^1.3.0\",\n        \"gopd\": \"^1.2.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/ee-first\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz\",\n      \"integrity\": \"sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/ejs\": {\n      \"version\": \"3.1.10\",\n      \"resolved\": \"https://registry.npmjs.org/ejs/-/ejs-3.1.10.tgz\",\n      \"integrity\": \"sha512-UeJmFfOrAQS8OJWPZ4qtgHyWExa088/MtK5UEyoJGFH67cDEXkZSviOiKRCZ4Xij0zxI3JECgYs3oKx+AizQBA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"jake\": \"^10.8.5\"\n      },\n      \"bin\": {\n        \"ejs\": \"bin/cli.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/electron-to-chromium\": {\n      \"version\": \"1.5.47\",\n      \"resolved\": \"https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.47.tgz\",\n      \"integrity\": \"sha512-zS5Yer0MOYw4rtK2iq43cJagHZ8sXN0jDHDKzB+86gSBSAI4v07S97mcq+Gs2vclAxSh1j7vOAHxSVgduiiuVQ==\",\n      \"dev\": true\n    },\n    \"node_modules/emittery\": {\n      \"version\": \"0.13.1\",\n      \"resolved\": \"https://registry.npmjs.org/emittery/-/emittery-0.13.1.tgz\",\n      \"integrity\": \"sha512-DeWwawk6r5yR9jFgnDKYt4sLS0LmHJJi3ZOnb5/JdbYwj3nW+FxQnHIjhBKz8YLC7oRNPVM9NQ47I3CVx34eqQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sindresorhus/emittery?sponsor=1\"\n      }\n    },\n    \"node_modules/emoji-regex\": {\n      \"version\": \"8.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz\",\n      \"integrity\": \"sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==\",\n      \"dev\": true\n    },\n    \"node_modules/encodeurl\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz\",\n      \"integrity\": \"sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/error-ex\": {\n      \"version\": \"1.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz\",\n      \"integrity\": \"sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-arrayish\": \"^0.2.1\"\n      }\n    },\n    \"node_modules/es-define-property\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz\",\n      \"integrity\": \"sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/es-errors\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz\",\n      \"integrity\": \"sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/es-object-atoms\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz\",\n      \"integrity\": \"sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/es-set-tostringtag\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz\",\n      \"integrity\": \"sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.6\",\n        \"has-tostringtag\": \"^1.0.2\",\n        \"hasown\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/esbuild\": {\n      \"version\": \"0.25.0\",\n      \"resolved\": \"https://registry.npmjs.org/esbuild/-/esbuild-0.25.0.tgz\",\n      \"integrity\": \"sha512-BXq5mqc8ltbaN34cDqWuYKyNhX8D/Z0J1xdtdQ8UcIIIyJyz+ZMKUt58tF3SrZ85jcfN/PZYhjR5uDQAYNVbuw==\",\n      \"dev\": true,\n      \"hasInstallScript\": true,\n      \"license\": \"MIT\",\n      \"bin\": {\n        \"esbuild\": \"bin/esbuild\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      },\n      \"optionalDependencies\": {\n        \"@esbuild/aix-ppc64\": \"0.25.0\",\n        \"@esbuild/android-arm\": \"0.25.0\",\n        \"@esbuild/android-arm64\": \"0.25.0\",\n        \"@esbuild/android-x64\": \"0.25.0\",\n        \"@esbuild/darwin-arm64\": \"0.25.0\",\n        \"@esbuild/darwin-x64\": \"0.25.0\",\n        \"@esbuild/freebsd-arm64\": \"0.25.0\",\n        \"@esbuild/freebsd-x64\": \"0.25.0\",\n        \"@esbuild/linux-arm\": \"0.25.0\",\n        \"@esbuild/linux-arm64\": \"0.25.0\",\n        \"@esbuild/linux-ia32\": \"0.25.0\",\n        \"@esbuild/linux-loong64\": \"0.25.0\",\n        \"@esbuild/linux-mips64el\": \"0.25.0\",\n        \"@esbuild/linux-ppc64\": \"0.25.0\",\n        \"@esbuild/linux-riscv64\": \"0.25.0\",\n        \"@esbuild/linux-s390x\": \"0.25.0\",\n        \"@esbuild/linux-x64\": \"0.25.0\",\n        \"@esbuild/netbsd-arm64\": \"0.25.0\",\n        \"@esbuild/netbsd-x64\": \"0.25.0\",\n        \"@esbuild/openbsd-arm64\": \"0.25.0\",\n        \"@esbuild/openbsd-x64\": \"0.25.0\",\n        \"@esbuild/sunos-x64\": \"0.25.0\",\n        \"@esbuild/win32-arm64\": \"0.25.0\",\n        \"@esbuild/win32-ia32\": \"0.25.0\",\n        \"@esbuild/win32-x64\": \"0.25.0\"\n      }\n    },\n    \"node_modules/escalade\": {\n      \"version\": \"3.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz\",\n      \"integrity\": \"sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/escape-html\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz\",\n      \"integrity\": \"sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/escape-string-regexp\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz\",\n      \"integrity\": \"sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/eslint\": {\n      \"version\": \"9.13.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint/-/eslint-9.13.0.tgz\",\n      \"integrity\": \"sha512-EYZK6SX6zjFHST/HRytOdA/zE72Cq/bfw45LSyuwrdvcclb/gqV8RRQxywOBEWO2+WDpva6UZa4CcDeJKzUCFA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@eslint-community/eslint-utils\": \"^4.2.0\",\n        \"@eslint-community/regexpp\": \"^4.11.0\",\n        \"@eslint/config-array\": \"^0.18.0\",\n        \"@eslint/core\": \"^0.7.0\",\n        \"@eslint/eslintrc\": \"^3.1.0\",\n        \"@eslint/js\": \"9.13.0\",\n        \"@eslint/plugin-kit\": \"^0.2.0\",\n        \"@humanfs/node\": \"^0.16.5\",\n        \"@humanwhocodes/module-importer\": \"^1.0.1\",\n        \"@humanwhocodes/retry\": \"^0.3.1\",\n        \"@types/estree\": \"^1.0.6\",\n        \"@types/json-schema\": \"^7.0.15\",\n        \"ajv\": \"^6.12.4\",\n        \"chalk\": \"^4.0.0\",\n        \"cross-spawn\": \"^7.0.2\",\n        \"debug\": \"^4.3.2\",\n        \"escape-string-regexp\": \"^4.0.0\",\n        \"eslint-scope\": \"^8.1.0\",\n        \"eslint-visitor-keys\": \"^4.1.0\",\n        \"espree\": \"^10.2.0\",\n        \"esquery\": \"^1.5.0\",\n        \"esutils\": \"^2.0.2\",\n        \"fast-deep-equal\": \"^3.1.3\",\n        \"file-entry-cache\": \"^8.0.0\",\n        \"find-up\": \"^5.0.0\",\n        \"glob-parent\": \"^6.0.2\",\n        \"ignore\": \"^5.2.0\",\n        \"imurmurhash\": \"^0.1.4\",\n        \"is-glob\": \"^4.0.0\",\n        \"json-stable-stringify-without-jsonify\": \"^1.0.1\",\n        \"lodash.merge\": \"^4.6.2\",\n        \"minimatch\": \"^3.1.2\",\n        \"natural-compare\": \"^1.4.0\",\n        \"optionator\": \"^0.9.3\",\n        \"text-table\": \"^0.2.0\"\n      },\n      \"bin\": {\n        \"eslint\": \"bin/eslint.js\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://eslint.org/donate\"\n      },\n      \"peerDependencies\": {\n        \"jiti\": \"*\"\n      },\n      \"peerDependenciesMeta\": {\n        \"jiti\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/eslint-scope\": {\n      \"version\": \"8.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.1.0.tgz\",\n      \"integrity\": \"sha512-14dSvlhaVhKKsa9Fx1l8A17s7ah7Ef7wCakJ10LYk6+GYmP9yDti2oq2SEwcyndt6knfcZyhyxwY3i9yL78EQw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"esrecurse\": \"^4.3.0\",\n        \"estraverse\": \"^5.2.0\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/eslint\"\n      }\n    },\n    \"node_modules/eslint-visitor-keys\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.1.0.tgz\",\n      \"integrity\": \"sha512-Q7lok0mqMUSf5a/AdAZkA5a/gHcO6snwQClVNNvFKCAVlxXucdU8pKydU5ZVZjBx5xr37vGbFFWtLQYreLzrZg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/eslint\"\n      }\n    },\n    \"node_modules/espree\": {\n      \"version\": \"10.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/espree/-/espree-10.2.0.tgz\",\n      \"integrity\": \"sha512-upbkBJbckcCNBDBDXEbuhjbP68n+scUd3k/U2EkyM9nw+I/jPiL4cLF/Al06CF96wRltFda16sxDFrxsI1v0/g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"acorn\": \"^8.12.0\",\n        \"acorn-jsx\": \"^5.3.2\",\n        \"eslint-visitor-keys\": \"^4.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/eslint\"\n      }\n    },\n    \"node_modules/esprima\": {\n      \"version\": \"4.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz\",\n      \"integrity\": \"sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==\",\n      \"dev\": true,\n      \"bin\": {\n        \"esparse\": \"bin/esparse.js\",\n        \"esvalidate\": \"bin/esvalidate.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=4\"\n      }\n    },\n    \"node_modules/esquery\": {\n      \"version\": \"1.6.0\",\n      \"resolved\": \"https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz\",\n      \"integrity\": \"sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"estraverse\": \"^5.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=0.10\"\n      }\n    },\n    \"node_modules/esrecurse\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz\",\n      \"integrity\": \"sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"estraverse\": \"^5.2.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=4.0\"\n      }\n    },\n    \"node_modules/estraverse\": {\n      \"version\": \"5.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n      \"integrity\": \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=4.0\"\n      }\n    },\n    \"node_modules/esutils\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz\",\n      \"integrity\": \"sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/etag\": {\n      \"version\": \"1.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/etag/-/etag-1.8.1.tgz\",\n      \"integrity\": \"sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/eventsource\": {\n      \"version\": \"3.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/eventsource/-/eventsource-3.0.2.tgz\",\n      \"integrity\": \"sha512-YolzkJNxsTL3tCJMWFxpxtG2sCjbZ4LQUBUrkdaJK0ub0p6lmJt+2+1SwhKjLc652lpH9L/79Ptez972H9tphw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"eventsource-parser\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=18.0.0\"\n      }\n    },\n    \"node_modules/eventsource-parser\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-3.0.0.tgz\",\n      \"integrity\": \"sha512-T1C0XCUimhxVQzW4zFipdx0SficT651NnkR0ZSH3yQwh+mFMdLfgjABVi4YtMTtaL4s168593DaoaRLMqryavA==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E=18.0.0\"\n      }\n    },\n    \"node_modules/execa\": {\n      \"version\": \"5.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/execa/-/execa-5.1.1.tgz\",\n      \"integrity\": \"sha512-8uSpZZocAZRBAPIEINJj3Lo9HyGitllczc27Eh5YYojjMFMn8yHMDMaUHE2Jqfq05D/wucwI4JGURyXt1vchyg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"cross-spawn\": \"^7.0.3\",\n        \"get-stream\": \"^6.0.0\",\n        \"human-signals\": \"^2.1.0\",\n        \"is-stream\": \"^2.0.0\",\n        \"merge-stream\": \"^2.0.0\",\n        \"npm-run-path\": \"^4.0.1\",\n        \"onetime\": \"^5.1.2\",\n        \"signal-exit\": \"^3.0.3\",\n        \"strip-final-newline\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sindresorhus/execa?sponsor=1\"\n      }\n    },\n    \"node_modules/exit\": {\n      \"version\": \"0.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/exit/-/exit-0.1.2.tgz\",\n      \"integrity\": \"sha512-Zk/eNKV2zbjpKzrsQ+n1G6poVbErQxJ0LBOJXaKZ1EViLzH+hrLu9cdXI4zw9dBQJslwBEpbQ2P1oS7nDxs6jQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E= 0.8.0\"\n      }\n    },\n    \"node_modules/expect\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/expect/-/expect-29.7.0.tgz\",\n      \"integrity\": \"sha512-2Zks0hf1VLFYI1kbh0I5jP3KHHyCHpkfyHBzsSXRFgl/Bg9mWYfMW8oD+PdMPlEwy5HNsR9JutYy6pMeOh61nw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/expect-utils\": \"^29.7.0\",\n        \"jest-get-type\": \"^29.6.3\",\n        \"jest-matcher-utils\": \"^29.7.0\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/express\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/express/-/express-5.0.1.tgz\",\n      \"integrity\": \"sha512-ORF7g6qGnD+YtUG9yx4DFoqCShNMmUKiXuT5oWMHiOvt/4WFbHC6yCwQMTSBMno7AqntNCAzzcnnjowRkTL9eQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"accepts\": \"^2.0.0\",\n        \"body-parser\": \"^2.0.1\",\n        \"content-disposition\": \"^1.0.0\",\n        \"content-type\": \"~1.0.4\",\n        \"cookie\": \"0.7.1\",\n        \"cookie-signature\": \"^1.2.1\",\n        \"debug\": \"4.3.6\",\n        \"depd\": \"2.0.0\",\n        \"encodeurl\": \"~2.0.0\",\n        \"escape-html\": \"~1.0.3\",\n        \"etag\": \"~1.8.1\",\n        \"finalhandler\": \"^2.0.0\",\n        \"fresh\": \"2.0.0\",\n        \"http-errors\": \"2.0.0\",\n        \"merge-descriptors\": \"^2.0.0\",\n        \"methods\": \"~1.1.2\",\n        \"mime-types\": \"^3.0.0\",\n        \"on-finished\": \"2.4.1\",\n        \"once\": \"1.4.0\",\n        \"parseurl\": \"~1.3.3\",\n        \"proxy-addr\": \"~2.0.7\",\n        \"qs\": \"6.13.0\",\n        \"range-parser\": \"~1.2.1\",\n        \"router\": \"^2.0.0\",\n        \"safe-buffer\": \"5.2.1\",\n        \"send\": \"^1.1.0\",\n        \"serve-static\": \"^2.1.0\",\n        \"setprototypeof\": \"1.2.0\",\n        \"statuses\": \"2.0.1\",\n        \"type-is\": \"^2.0.0\",\n        \"utils-merge\": \"1.0.1\",\n        \"vary\": \"~1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 18\"\n      }\n    },\n    \"node_modules/express-rate-limit\": {\n      \"version\": \"7.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-7.5.0.tgz\",\n      \"integrity\": \"sha512-eB5zbQh5h+VenMPM3fh+nw1YExi5nMr6HUCR62ELSP11huvxm/Uir1H1QEyTkk5QX6A58pX6NmaTMceKZ0Eodg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 16\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/express-rate-limit\"\n      },\n      \"peerDependencies\": {\n        \"express\": \"^4.11 || 5 || ^5.0.0-beta.1\"\n      }\n    },\n    \"node_modules/express/node_modules/debug\": {\n      \"version\": \"4.3.6\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-4.3.6.tgz\",\n      \"integrity\": \"sha512-O/09Bd4Z1fBrU4VzkhFqVgpPzaGbw6Sm9FEkBT1A/YBXQFGuuSxa1dN2nxgxS34JmKXqYx8CZAwEVoJFImUXIg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ms\": \"2.1.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"supports-color\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/express/node_modules/ms\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.2.tgz\",\n      \"integrity\": \"sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/fast-deep-equal\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz\",\n      \"integrity\": \"sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==\"\n    },\n    \"node_modules/fast-glob\": {\n      \"version\": \"3.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.2.tgz\",\n      \"integrity\": \"sha512-oX2ruAFQwf/Orj8m737Y5adxDQO0LAB7/S5MnxCdTNDd4p6BsyIVsv9JQsATbTSq8KHRpLwIHbVlUNatxd+1Ow==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@nodelib/fs.stat\": \"^2.0.2\",\n        \"@nodelib/fs.walk\": \"^1.2.3\",\n        \"glob-parent\": \"^5.1.2\",\n        \"merge2\": \"^1.3.0\",\n        \"micromatch\": \"^4.0.4\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8.6.0\"\n      }\n    },\n    \"node_modules/fast-glob/node_modules/glob-parent\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz\",\n      \"integrity\": \"sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-glob\": \"^4.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 6\"\n      }\n    },\n    \"node_modules/fast-json-stable-stringify\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz\",\n      \"integrity\": \"sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==\"\n    },\n    \"node_modules/fast-levenshtein\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz\",\n      \"integrity\": \"sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==\",\n      \"dev\": true\n    },\n    \"node_modules/fast-safe-stringify\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/fast-safe-stringify/-/fast-safe-stringify-2.1.1.tgz\",\n      \"integrity\": \"sha512-W+KJc2dmILlPplD/H4K9l9LcAHAfPtP6BY84uVLXQ6Evcz9Lcg33Y2z1IVblT6xdY54PXYVHEv+0Wpq8Io6zkA==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/fastq\": {\n      \"version\": \"1.17.1\",\n      \"resolved\": \"https://registry.npmjs.org/fastq/-/fastq-1.17.1.tgz\",\n      \"integrity\": \"sha512-sRVD3lWVIXWg6By68ZN7vho9a1pQcN/WBFaAAsDDFzlJjvoGx0P8z7V1t72grFJfJhu3YPZBuu25f7Kaw2jN1w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"reusify\": \"^1.0.4\"\n      }\n    },\n    \"node_modules/fb-watchman\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/fb-watchman/-/fb-watchman-2.0.2.tgz\",\n      \"integrity\": \"sha512-p5161BqbuCaSnB8jIbzQHOlpgsPmK5rJVDfDKO91Axs5NC1uu3HRQm6wt9cd9/+GtQQIO53JdGXXoyDpTAsgYA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"bser\": \"2.1.1\"\n      }\n    },\n    \"node_modules/file-entry-cache\": {\n      \"version\": \"8.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz\",\n      \"integrity\": \"sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"flat-cache\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=16.0.0\"\n      }\n    },\n    \"node_modules/filelist\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/filelist/-/filelist-1.0.4.tgz\",\n      \"integrity\": \"sha512-w1cEuf3S+DrLCQL7ET6kz+gmlJdbq9J7yXCSjK/OZCPA+qEN1WyF4ZAf0YYJa4/shHJra2t/d/r8SV4Ji+x+8Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"minimatch\": \"^5.0.1\"\n      }\n    },\n    \"node_modules/filelist/node_modules/brace-expansion\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz\",\n      \"integrity\": \"sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\"\n      }\n    },\n    \"node_modules/filelist/node_modules/minimatch\": {\n      \"version\": \"5.1.6\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-5.1.6.tgz\",\n      \"integrity\": \"sha512-lKwV/1brpG6mBUFHtb7NUmtABCb2WZZmm2wNiOA5hAb8VdCS4B3dtMWyvcoViccwAW/COERjXLt0zP1zXUN26g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/fill-range\": {\n      \"version\": \"7.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz\",\n      \"integrity\": \"sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"to-regex-range\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/finalhandler\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/finalhandler/-/finalhandler-2.0.0.tgz\",\n      \"integrity\": \"sha512-MX6Zo2adDViYh+GcxxB1dpO43eypOGUOL12rLCOTMQv/DfIbpSJUy4oQIIZhVZkH9e+bZWKMon0XHFEju16tkQ==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"2.6.9\",\n        \"encodeurl\": \"~1.0.2\",\n        \"escape-html\": \"~1.0.3\",\n        \"on-finished\": \"2.4.1\",\n        \"parseurl\": \"~1.3.3\",\n        \"statuses\": \"2.0.1\",\n        \"unpipe\": \"~1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/finalhandler/node_modules/debug\": {\n      \"version\": \"2.6.9\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-2.6.9.tgz\",\n      \"integrity\": \"sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ms\": \"2.0.0\"\n      }\n    },\n    \"node_modules/finalhandler/node_modules/encodeurl\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz\",\n      \"integrity\": \"sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/finalhandler/node_modules/ms\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.0.0.tgz\",\n      \"integrity\": \"sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/find-up\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz\",\n      \"integrity\": \"sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"locate-path\": \"^6.0.0\",\n        \"path-exists\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/flat-cache\": {\n      \"version\": \"4.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz\",\n      \"integrity\": \"sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"flatted\": \"^3.2.9\",\n        \"keyv\": \"^4.5.4\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=16\"\n      }\n    },\n    \"node_modules/flatted\": {\n      \"version\": \"3.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/flatted/-/flatted-3.3.1.tgz\",\n      \"integrity\": \"sha512-X8cqMLLie7KsNUDSdzeN8FYK9rEt4Dt67OsG/DNGnYTSDBG4uFAJFBnUeiV+zCVAvwFy56IjM9sH51jVaEhNxw==\",\n      \"dev\": true\n    },\n    \"node_modules/form-data\": {\n      \"version\": \"4.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/form-data/-/form-data-4.0.4.tgz\",\n      \"integrity\": \"sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"asynckit\": \"^0.4.0\",\n        \"combined-stream\": \"^1.0.8\",\n        \"es-set-tostringtag\": \"^2.1.0\",\n        \"hasown\": \"^2.0.2\",\n        \"mime-types\": \"^2.1.12\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 6\"\n      }\n    },\n    \"node_modules/form-data/node_modules/mime-db\": {\n      \"version\": \"1.52.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz\",\n      \"integrity\": \"sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/form-data/node_modules/mime-types\": {\n      \"version\": \"2.1.35\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz\",\n      \"integrity\": \"sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"1.52.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/formidable\": {\n      \"version\": \"3.5.4\",\n      \"resolved\": \"https://registry.npmjs.org/formidable/-/formidable-3.5.4.tgz\",\n      \"integrity\": \"sha512-YikH+7CUTOtP44ZTnUhR7Ic2UASBPOqmaRkRKxRbywPTe5VxF7RRCck4af9wutiZ/QKM5nME9Bie2fFaPz5Gug==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@paralleldrive/cuid2\": \"^2.2.2\",\n        \"dezalgo\": \"^1.0.4\",\n        \"once\": \"^1.4.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=14.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://ko-fi.com/tunnckoCore/commissions\"\n      }\n    },\n    \"node_modules/forwarded\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz\",\n      \"integrity\": \"sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/fresh\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz\",\n      \"integrity\": \"sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/fs.realpath\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n      \"integrity\": \"sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==\",\n      \"dev\": true\n    },\n    \"node_modules/fsevents\": {\n      \"version\": \"2.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz\",\n      \"integrity\": \"sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==\",\n      \"dev\": true,\n      \"hasInstallScript\": true,\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \"^8.16.0 || ^10.6.0 || \u003E=11.0.0\"\n      }\n    },\n    \"node_modules/function-bind\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz\",\n      \"integrity\": \"sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/gensync\": {\n      \"version\": \"1.0.0-beta.2\",\n      \"resolved\": \"https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz\",\n      \"integrity\": \"sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6.9.0\"\n      }\n    },\n    \"node_modules/get-caller-file\": {\n      \"version\": \"2.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz\",\n      \"integrity\": \"sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"6.* || 8.* || \u003E= 10.*\"\n      }\n    },\n    \"node_modules/get-intrinsic\": {\n      \"version\": \"1.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.2.7.tgz\",\n      \"integrity\": \"sha512-VW6Pxhsrk0KAOqs3WEd0klDiF/+V7gQOpAvY1jVU/LHmaD/kQO4523aiJuikX/QAKYiW6x8Jh+RJej1almdtCA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bind-apply-helpers\": \"^1.0.1\",\n        \"es-define-property\": \"^1.0.1\",\n        \"es-errors\": \"^1.3.0\",\n        \"es-object-atoms\": \"^1.0.0\",\n        \"function-bind\": \"^1.1.2\",\n        \"get-proto\": \"^1.0.0\",\n        \"gopd\": \"^1.2.0\",\n        \"has-symbols\": \"^1.1.0\",\n        \"hasown\": \"^2.0.2\",\n        \"math-intrinsics\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-package-type\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-package-type/-/get-package-type-0.1.0.tgz\",\n      \"integrity\": \"sha512-pjzuKtY64GYfWizNAJ0fr9VqttZkNiK2iS430LtIHzjBEr6bX8Am2zm4sW4Ro5wjWW5cAlRL1qAMTcXbjNAO2Q==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8.0.0\"\n      }\n    },\n    \"node_modules/get-proto\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz\",\n      \"integrity\": \"sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"dunder-proto\": \"^1.0.1\",\n        \"es-object-atoms\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/get-stream\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz\",\n      \"integrity\": \"sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/get-tsconfig\": {\n      \"version\": \"4.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.8.1.tgz\",\n      \"integrity\": \"sha512-k9PN+cFBmaLWtVz29SkUoqU5O0slLuHJXt/2P+tMVFT+phsSGXGkp9t3rQIqdz0e+06EHNGs3oM6ZX1s2zHxRg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"resolve-pkg-maps\": \"^1.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/privatenumber/get-tsconfig?sponsor=1\"\n      }\n    },\n    \"node_modules/glob\": {\n      \"version\": \"7.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.2.3.tgz\",\n      \"integrity\": \"sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==\",\n      \"deprecated\": \"Glob versions prior to v9 are no longer supported\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"fs.realpath\": \"^1.0.0\",\n        \"inflight\": \"^1.0.4\",\n        \"inherits\": \"2\",\n        \"minimatch\": \"^3.1.1\",\n        \"once\": \"^1.3.0\",\n        \"path-is-absolute\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/glob-parent\": {\n      \"version\": \"6.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz\",\n      \"integrity\": \"sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-glob\": \"^4.0.3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10.13.0\"\n      }\n    },\n    \"node_modules/globals\": {\n      \"version\": \"14.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/globals/-/globals-14.0.0.tgz\",\n      \"integrity\": \"sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/gopd\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz\",\n      \"integrity\": \"sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/graceful-fs\": {\n      \"version\": \"4.2.11\",\n      \"resolved\": \"https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz\",\n      \"integrity\": \"sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==\",\n      \"dev\": true\n    },\n    \"node_modules/graphemer\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/graphemer/-/graphemer-1.4.0.tgz\",\n      \"integrity\": \"sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==\",\n      \"dev\": true\n    },\n    \"node_modules/has-flag\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\",\n      \"integrity\": \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/has-symbols\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz\",\n      \"integrity\": \"sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-tostringtag\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz\",\n      \"integrity\": \"sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"has-symbols\": \"^1.0.3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/hasown\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz\",\n      \"integrity\": \"sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==\",\n      \"dependencies\": {\n        \"function-bind\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/html-escaper\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz\",\n      \"integrity\": \"sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==\",\n      \"dev\": true\n    },\n    \"node_modules/http-errors\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz\",\n      \"integrity\": \"sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==\",\n      \"dependencies\": {\n        \"depd\": \"2.0.0\",\n        \"inherits\": \"2.0.4\",\n        \"setprototypeof\": \"1.2.0\",\n        \"statuses\": \"2.0.1\",\n        \"toidentifier\": \"1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/human-signals\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/human-signals/-/human-signals-2.1.0.tgz\",\n      \"integrity\": \"sha512-B4FFZ6q/T2jhhksgkbEW3HBvWIfDW85snkQgawt07S7J5QXTk6BkNV+0yAeZrM5QpMAdYlocGoljn0sJ/WQkFw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10.17.0\"\n      }\n    },\n    \"node_modules/iconv-lite\": {\n      \"version\": \"0.5.2\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.5.2.tgz\",\n      \"integrity\": \"sha512-kERHXvpSaB4aU3eANwidg79K8FlrN77m8G9V+0vOR3HYaRifrlwMEpT7ZBJqLSEIHnEgJTHcWK82wwLwwKwtag==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"safer-buffer\": \"\u003E= 2.1.2 \u003C 3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/ignore\": {\n      \"version\": \"5.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz\",\n      \"integrity\": \"sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E= 4\"\n      }\n    },\n    \"node_modules/import-fresh\": {\n      \"version\": \"3.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz\",\n      \"integrity\": \"sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"parent-module\": \"^1.0.0\",\n        \"resolve-from\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/import-local\": {\n      \"version\": \"3.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/import-local/-/import-local-3.2.0.tgz\",\n      \"integrity\": \"sha512-2SPlun1JUPWoM6t3F0dw0FkCF/jWY8kttcY4f599GLTSjh2OCuuhdTkJQsEcZzBqbXZGKMK2OqW1oZsjtf/gQA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"pkg-dir\": \"^4.2.0\",\n        \"resolve-cwd\": \"^3.0.0\"\n      },\n      \"bin\": {\n        \"import-local-fixture\": \"fixtures/cli.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/imurmurhash\": {\n      \"version\": \"0.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz\",\n      \"integrity\": \"sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.8.19\"\n      }\n    },\n    \"node_modules/inflight\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n      \"integrity\": \"sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==\",\n      \"deprecated\": \"This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"once\": \"^1.3.0\",\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/inherits\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\"\n    },\n    \"node_modules/ipaddr.js\": {\n      \"version\": \"1.9.1\",\n      \"resolved\": \"https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz\",\n      \"integrity\": \"sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.10\"\n      }\n    },\n    \"node_modules/is-arrayish\": {\n      \"version\": \"0.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz\",\n      \"integrity\": \"sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==\",\n      \"dev\": true\n    },\n    \"node_modules/is-core-module\": {\n      \"version\": \"2.15.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-core-module/-/is-core-module-2.15.1.tgz\",\n      \"integrity\": \"sha512-z0vtXSwucUJtANQWldhbtbt7BnL0vxiFjIdDLAatwhDYty2bad6s+rijD6Ri4YuYJubLzIJLUidCh09e1djEVQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"hasown\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-extglob\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz\",\n      \"integrity\": \"sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/is-fullwidth-code-point\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz\",\n      \"integrity\": \"sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/is-generator-fn\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-generator-fn/-/is-generator-fn-2.1.0.tgz\",\n      \"integrity\": \"sha512-cTIB4yPYL/Grw0EaSzASzg6bBy9gqCofvWN8okThAYIxKJZC+udlRAmGbM0XLeniEJSs8uEgHPGuHSe1XsOLSQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/is-glob\": {\n      \"version\": \"4.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz\",\n      \"integrity\": \"sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-extglob\": \"^2.1.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/is-number\": {\n      \"version\": \"7.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz\",\n      \"integrity\": \"sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.12.0\"\n      }\n    },\n    \"node_modules/is-promise\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz\",\n      \"integrity\": \"sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/is-stream\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz\",\n      \"integrity\": \"sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/isexe\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",\n      \"integrity\": \"sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==\"\n    },\n    \"node_modules/istanbul-lib-coverage\": {\n      \"version\": \"3.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz\",\n      \"integrity\": \"sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/istanbul-lib-instrument\": {\n      \"version\": \"6.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/istanbul-lib-instrument/-/istanbul-lib-instrument-6.0.3.tgz\",\n      \"integrity\": \"sha512-Vtgk7L/R2JHyyGW07spoFlB8/lpjiOLTjMdms6AFMraYt3BaJauod/NGrfnVG/y4Ix1JEuMRPDPEj2ua+zz1/Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/core\": \"^7.23.9\",\n        \"@babel/parser\": \"^7.23.9\",\n        \"@istanbuljs/schema\": \"^0.1.3\",\n        \"istanbul-lib-coverage\": \"^3.2.0\",\n        \"semver\": \"^7.5.4\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/istanbul-lib-instrument/node_modules/semver\": {\n      \"version\": \"7.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.6.3.tgz\",\n      \"integrity\": \"sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/istanbul-lib-report\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz\",\n      \"integrity\": \"sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"istanbul-lib-coverage\": \"^3.0.0\",\n        \"make-dir\": \"^4.0.0\",\n        \"supports-color\": \"^7.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/istanbul-lib-source-maps\": {\n      \"version\": \"4.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-4.0.1.tgz\",\n      \"integrity\": \"sha512-n3s8EwkdFIJCG3BPKBYvskgXGoy88ARzvegkitk60NxRdwltLOTaH7CUiMRXvwYorl0Q712iEjcWB+fK/MrWVw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"debug\": \"^4.1.1\",\n        \"istanbul-lib-coverage\": \"^3.0.0\",\n        \"source-map\": \"^0.6.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/istanbul-reports\": {\n      \"version\": \"3.1.7\",\n      \"resolved\": \"https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.1.7.tgz\",\n      \"integrity\": \"sha512-BewmUXImeuRk2YY0PVbxgKAysvhRPUQE0h5QRM++nVWyubKGV0l8qQ5op8+B2DOmwSe63Jivj0BjkPQVf8fP5g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"html-escaper\": \"^2.0.0\",\n        \"istanbul-lib-report\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/jake\": {\n      \"version\": \"10.9.2\",\n      \"resolved\": \"https://registry.npmjs.org/jake/-/jake-10.9.2.tgz\",\n      \"integrity\": \"sha512-2P4SQ0HrLQ+fw6llpLnOaGAvN2Zu6778SJMrCUwns4fOoG9ayrTiZk3VV8sCPkVZF8ab0zksVpS8FDY5pRCNBA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"async\": \"^3.2.3\",\n        \"chalk\": \"^4.0.2\",\n        \"filelist\": \"^1.0.4\",\n        \"minimatch\": \"^3.1.2\"\n      },\n      \"bin\": {\n        \"jake\": \"bin/cli.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/jest\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest/-/jest-29.7.0.tgz\",\n      \"integrity\": \"sha512-NIy3oAFp9shda19hy4HK0HRTWKtPJmGdnvywu01nOqNC2vZg+Z+fvJDxpMQA88eb2I9EcafcdjYgsDthnYTvGw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/core\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"import-local\": \"^3.0.2\",\n        \"jest-cli\": \"^29.7.0\"\n      },\n      \"bin\": {\n        \"jest\": \"bin/jest.js\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      },\n      \"peerDependencies\": {\n        \"node-notifier\": \"^8.0.1 || ^9.0.0 || ^10.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"node-notifier\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/jest-changed-files\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-changed-files/-/jest-changed-files-29.7.0.tgz\",\n      \"integrity\": \"sha512-fEArFiwf1BpQ+4bXSprcDc3/x4HSzL4al2tozwVpDFpsxALjLYdyiIK4e5Vz66GQJIbXJ82+35PtysofptNX2w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"execa\": \"^5.0.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"p-limit\": \"^3.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-circus\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-circus/-/jest-circus-29.7.0.tgz\",\n      \"integrity\": \"sha512-3E1nCMgipcTkCocFwM90XXQab9bS+GMsjdpmPrlelaxwD93Ad8iVEjX/vvHPdLPnFf+L40u+5+iutRdA1N9myw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/environment\": \"^29.7.0\",\n        \"@jest/expect\": \"^29.7.0\",\n        \"@jest/test-result\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"chalk\": \"^4.0.0\",\n        \"co\": \"^4.6.0\",\n        \"dedent\": \"^1.0.0\",\n        \"is-generator-fn\": \"^2.0.0\",\n        \"jest-each\": \"^29.7.0\",\n        \"jest-matcher-utils\": \"^29.7.0\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-runtime\": \"^29.7.0\",\n        \"jest-snapshot\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"p-limit\": \"^3.1.0\",\n        \"pretty-format\": \"^29.7.0\",\n        \"pure-rand\": \"^6.0.0\",\n        \"slash\": \"^3.0.0\",\n        \"stack-utils\": \"^2.0.3\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-cli\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-cli/-/jest-cli-29.7.0.tgz\",\n      \"integrity\": \"sha512-OVVobw2IubN/GSYsxETi+gOe7Ka59EFMR/twOU3Jb2GnKKeMGJB5SGUUrEz3SFVmJASUdZUzy83sLNNQ2gZslg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/core\": \"^29.7.0\",\n        \"@jest/test-result\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"chalk\": \"^4.0.0\",\n        \"create-jest\": \"^29.7.0\",\n        \"exit\": \"^0.1.2\",\n        \"import-local\": \"^3.0.2\",\n        \"jest-config\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"jest-validate\": \"^29.7.0\",\n        \"yargs\": \"^17.3.1\"\n      },\n      \"bin\": {\n        \"jest\": \"bin/jest.js\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      },\n      \"peerDependencies\": {\n        \"node-notifier\": \"^8.0.1 || ^9.0.0 || ^10.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"node-notifier\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/jest-config\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-config/-/jest-config-29.7.0.tgz\",\n      \"integrity\": \"sha512-uXbpfeQ7R6TZBqI3/TxCU4q4ttk3u0PJeC+E0zbfSoSjq6bJ7buBPxzQPL0ifrkY4DNu4JUdk0ImlBUYi840eQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/core\": \"^7.11.6\",\n        \"@jest/test-sequencer\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"babel-jest\": \"^29.7.0\",\n        \"chalk\": \"^4.0.0\",\n        \"ci-info\": \"^3.2.0\",\n        \"deepmerge\": \"^4.2.2\",\n        \"glob\": \"^7.1.3\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-circus\": \"^29.7.0\",\n        \"jest-environment-node\": \"^29.7.0\",\n        \"jest-get-type\": \"^29.6.3\",\n        \"jest-regex-util\": \"^29.6.3\",\n        \"jest-resolve\": \"^29.7.0\",\n        \"jest-runner\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"jest-validate\": \"^29.7.0\",\n        \"micromatch\": \"^4.0.4\",\n        \"parse-json\": \"^5.2.0\",\n        \"pretty-format\": \"^29.7.0\",\n        \"slash\": \"^3.0.0\",\n        \"strip-json-comments\": \"^3.1.1\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      },\n      \"peerDependencies\": {\n        \"@types/node\": \"*\",\n        \"ts-node\": \"\u003E=9.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"@types/node\": {\n          \"optional\": true\n        },\n        \"ts-node\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/jest-diff\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-diff/-/jest-diff-29.7.0.tgz\",\n      \"integrity\": \"sha512-LMIgiIrhigmPrs03JHpxUh2yISK3vLFPkAodPeo0+BuF7wA2FoQbkEg1u8gBYBThncu7e1oEDUfIXVuTqLRUjw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"chalk\": \"^4.0.0\",\n        \"diff-sequences\": \"^29.6.3\",\n        \"jest-get-type\": \"^29.6.3\",\n        \"pretty-format\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-docblock\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-docblock/-/jest-docblock-29.7.0.tgz\",\n      \"integrity\": \"sha512-q617Auw3A612guyaFgsbFeYpNP5t2aoUNLwBUbc/0kD1R4t9ixDbyFTHd1nok4epoVFpr7PmeWHrhvuV3XaJ4g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"detect-newline\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-each\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-each/-/jest-each-29.7.0.tgz\",\n      \"integrity\": \"sha512-gns+Er14+ZrEoC5fhOfYCY1LOHHr0TI+rQUHZS8Ttw2l7gl+80eHc/gFf2Ktkw0+SIACDTeWvpFcv3B04VembQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/types\": \"^29.6.3\",\n        \"chalk\": \"^4.0.0\",\n        \"jest-get-type\": \"^29.6.3\",\n        \"jest-util\": \"^29.7.0\",\n        \"pretty-format\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-environment-node\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-environment-node/-/jest-environment-node-29.7.0.tgz\",\n      \"integrity\": \"sha512-DOSwCRqXirTOyheM+4d5YZOrWcdu0LNZ87ewUoywbcb2XR4wKgqiG8vNeYwhjFMbEkfju7wx2GYH0P2gevGvFw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/environment\": \"^29.7.0\",\n        \"@jest/fake-timers\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"jest-mock\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-get-type\": {\n      \"version\": \"29.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/jest-get-type/-/jest-get-type-29.6.3.tgz\",\n      \"integrity\": \"sha512-zrteXnqYxfQh7l5FHyL38jL39di8H8rHoecLH3JNxH3BwOrBsNeabdap5e0I23lD4HHI8W5VFBZqG4Eaq5LNcw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-haste-map\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-haste-map/-/jest-haste-map-29.7.0.tgz\",\n      \"integrity\": \"sha512-fP8u2pyfqx0K1rGn1R9pyE0/KTn+G7PxktWidOBTqFPLYX0b9ksaMFkhK5vrS3DVun09pckLdlx90QthlW7AmA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/graceful-fs\": \"^4.1.3\",\n        \"@types/node\": \"*\",\n        \"anymatch\": \"^3.0.3\",\n        \"fb-watchman\": \"^2.0.0\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-regex-util\": \"^29.6.3\",\n        \"jest-util\": \"^29.7.0\",\n        \"jest-worker\": \"^29.7.0\",\n        \"micromatch\": \"^4.0.4\",\n        \"walker\": \"^1.0.8\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      },\n      \"optionalDependencies\": {\n        \"fsevents\": \"^2.3.2\"\n      }\n    },\n    \"node_modules/jest-leak-detector\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-leak-detector/-/jest-leak-detector-29.7.0.tgz\",\n      \"integrity\": \"sha512-kYA8IJcSYtST2BY9I+SMC32nDpBT3J2NvWJx8+JCuCdl/CR1I4EKUJROiP8XtCcxqgTTBGJNdbB1A8XRKbTetw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"jest-get-type\": \"^29.6.3\",\n        \"pretty-format\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-matcher-utils\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-matcher-utils/-/jest-matcher-utils-29.7.0.tgz\",\n      \"integrity\": \"sha512-sBkD+Xi9DtcChsI3L3u0+N0opgPYnCRPtGcQYrgXmR+hmt/fYfWAL0xRXYU8eWOdfuLgBe0YCW3AFtnRLagq/g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"chalk\": \"^4.0.0\",\n        \"jest-diff\": \"^29.7.0\",\n        \"jest-get-type\": \"^29.6.3\",\n        \"pretty-format\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-message-util\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-message-util/-/jest-message-util-29.7.0.tgz\",\n      \"integrity\": \"sha512-GBEV4GRADeP+qtB2+6u61stea8mGcOT4mCtrYISZwfu9/ISHFJ/5zOMXYbpBE9RsS5+Gb63DW4FgmnKJ79Kf6w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/code-frame\": \"^7.12.13\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/stack-utils\": \"^2.0.0\",\n        \"chalk\": \"^4.0.0\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"micromatch\": \"^4.0.4\",\n        \"pretty-format\": \"^29.7.0\",\n        \"slash\": \"^3.0.0\",\n        \"stack-utils\": \"^2.0.3\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-mock\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-mock/-/jest-mock-29.7.0.tgz\",\n      \"integrity\": \"sha512-ITOMZn+UkYS4ZFh83xYAOzWStloNzJFO2s8DWrE4lhtGD+AorgnbkiKERe4wQVBydIGPx059g6riW5Btp6Llnw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"jest-util\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-pnp-resolver\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/jest-pnp-resolver/-/jest-pnp-resolver-1.2.3.tgz\",\n      \"integrity\": \"sha512-+3NpwQEnRoIBtx4fyhblQDPgJI0H1IEIkX7ShLUjPGA7TtUTvI1oiKi3SR4oBR0hQhQR80l4WAe5RrXBwWMA8w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      },\n      \"peerDependencies\": {\n        \"jest-resolve\": \"*\"\n      },\n      \"peerDependenciesMeta\": {\n        \"jest-resolve\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/jest-regex-util\": {\n      \"version\": \"29.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/jest-regex-util/-/jest-regex-util-29.6.3.tgz\",\n      \"integrity\": \"sha512-KJJBsRCyyLNWCNBOvZyRDnAIfUiRJ8v+hOBQYGn8gDyF3UegwiP4gwRR3/SDa42g1YbVycTidUF3rKjyLFDWbg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-resolve\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-resolve/-/jest-resolve-29.7.0.tgz\",\n      \"integrity\": \"sha512-IOVhZSrg+UvVAshDSDtHyFCCBUl/Q3AAJv8iZ6ZjnZ74xzvwuzLXid9IIIPgTnY62SJjfuupMKZsZQRsCvxEgA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"chalk\": \"^4.0.0\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-haste-map\": \"^29.7.0\",\n        \"jest-pnp-resolver\": \"^1.2.2\",\n        \"jest-util\": \"^29.7.0\",\n        \"jest-validate\": \"^29.7.0\",\n        \"resolve\": \"^1.20.0\",\n        \"resolve.exports\": \"^2.0.0\",\n        \"slash\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-resolve-dependencies\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-resolve-dependencies/-/jest-resolve-dependencies-29.7.0.tgz\",\n      \"integrity\": \"sha512-un0zD/6qxJ+S0et7WxeI3H5XSe9lTBBR7bOHCHXkKR6luG5mwDDlIzVQ0V5cZCuoTgEdcdwzTghYkTWfubi+nA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"jest-regex-util\": \"^29.6.3\",\n        \"jest-snapshot\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-runner\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-runner/-/jest-runner-29.7.0.tgz\",\n      \"integrity\": \"sha512-fsc4N6cPCAahybGBfTRcq5wFR6fpLznMg47sY5aDpsoejOcVYFb07AHuSnR0liMcPTgBsA3ZJL6kFOjPdoNipQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/console\": \"^29.7.0\",\n        \"@jest/environment\": \"^29.7.0\",\n        \"@jest/test-result\": \"^29.7.0\",\n        \"@jest/transform\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"chalk\": \"^4.0.0\",\n        \"emittery\": \"^0.13.1\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-docblock\": \"^29.7.0\",\n        \"jest-environment-node\": \"^29.7.0\",\n        \"jest-haste-map\": \"^29.7.0\",\n        \"jest-leak-detector\": \"^29.7.0\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-resolve\": \"^29.7.0\",\n        \"jest-runtime\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"jest-watcher\": \"^29.7.0\",\n        \"jest-worker\": \"^29.7.0\",\n        \"p-limit\": \"^3.1.0\",\n        \"source-map-support\": \"0.5.13\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-runtime\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-runtime/-/jest-runtime-29.7.0.tgz\",\n      \"integrity\": \"sha512-gUnLjgwdGqW7B4LvOIkbKs9WGbn+QLqRQQ9juC6HndeDiezIwhDP+mhMwHWCEcfQ5RUXa6OPnFF8BJh5xegwwQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/environment\": \"^29.7.0\",\n        \"@jest/fake-timers\": \"^29.7.0\",\n        \"@jest/globals\": \"^29.7.0\",\n        \"@jest/source-map\": \"^29.6.3\",\n        \"@jest/test-result\": \"^29.7.0\",\n        \"@jest/transform\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"chalk\": \"^4.0.0\",\n        \"cjs-module-lexer\": \"^1.0.0\",\n        \"collect-v8-coverage\": \"^1.0.0\",\n        \"glob\": \"^7.1.3\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-haste-map\": \"^29.7.0\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-mock\": \"^29.7.0\",\n        \"jest-regex-util\": \"^29.6.3\",\n        \"jest-resolve\": \"^29.7.0\",\n        \"jest-snapshot\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"slash\": \"^3.0.0\",\n        \"strip-bom\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-snapshot\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-snapshot/-/jest-snapshot-29.7.0.tgz\",\n      \"integrity\": \"sha512-Rm0BMWtxBcioHr1/OX5YCP8Uov4riHvKPknOGs804Zg9JGZgmIBkbtlxJC/7Z4msKYVbIJtfU+tKb8xlYNfdkw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/core\": \"^7.11.6\",\n        \"@babel/generator\": \"^7.7.2\",\n        \"@babel/plugin-syntax-jsx\": \"^7.7.2\",\n        \"@babel/plugin-syntax-typescript\": \"^7.7.2\",\n        \"@babel/types\": \"^7.3.3\",\n        \"@jest/expect-utils\": \"^29.7.0\",\n        \"@jest/transform\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"babel-preset-current-node-syntax\": \"^1.0.0\",\n        \"chalk\": \"^4.0.0\",\n        \"expect\": \"^29.7.0\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"jest-diff\": \"^29.7.0\",\n        \"jest-get-type\": \"^29.6.3\",\n        \"jest-matcher-utils\": \"^29.7.0\",\n        \"jest-message-util\": \"^29.7.0\",\n        \"jest-util\": \"^29.7.0\",\n        \"natural-compare\": \"^1.4.0\",\n        \"pretty-format\": \"^29.7.0\",\n        \"semver\": \"^7.5.3\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-snapshot/node_modules/semver\": {\n      \"version\": \"7.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.6.3.tgz\",\n      \"integrity\": \"sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/jest-util\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-util/-/jest-util-29.7.0.tgz\",\n      \"integrity\": \"sha512-z6EbKajIpqGKU56y5KBUgy1dt1ihhQJgWzUlZHArA/+X2ad7Cb5iF+AK1EWVL/Bo7Rz9uurpqw6SiBCefUbCGA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"chalk\": \"^4.0.0\",\n        \"ci-info\": \"^3.2.0\",\n        \"graceful-fs\": \"^4.2.9\",\n        \"picomatch\": \"^2.2.3\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-validate\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-validate/-/jest-validate-29.7.0.tgz\",\n      \"integrity\": \"sha512-ZB7wHqaRGVw/9hST/OuFUReG7M8vKeq0/J2egIGLdvjHCmYqGARhzXmtgi+gVeZ5uXFF219aOc3Ls2yLg27tkw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/types\": \"^29.6.3\",\n        \"camelcase\": \"^6.2.0\",\n        \"chalk\": \"^4.0.0\",\n        \"jest-get-type\": \"^29.6.3\",\n        \"leven\": \"^3.1.0\",\n        \"pretty-format\": \"^29.7.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-validate/node_modules/camelcase\": {\n      \"version\": \"6.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/camelcase/-/camelcase-6.3.0.tgz\",\n      \"integrity\": \"sha512-Gmy6FhYlCY7uOElZUSbxo2UCDH8owEk996gkbrpsgGtrJLM3J7jGxl9Ic7Qwwj4ivOE5AWZWRMecDdF7hqGjFA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/jest-watcher\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-watcher/-/jest-watcher-29.7.0.tgz\",\n      \"integrity\": \"sha512-49Fg7WXkU3Vl2h6LbLtMQ/HyB6rXSIX7SqvBLQmssRBGN9I0PNvPmAmCWSOY6SOvrjhI/F7/bGAv9RtnsPA03g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/test-result\": \"^29.7.0\",\n        \"@jest/types\": \"^29.6.3\",\n        \"@types/node\": \"*\",\n        \"ansi-escapes\": \"^4.2.1\",\n        \"chalk\": \"^4.0.0\",\n        \"emittery\": \"^0.13.1\",\n        \"jest-util\": \"^29.7.0\",\n        \"string-length\": \"^4.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-worker\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/jest-worker/-/jest-worker-29.7.0.tgz\",\n      \"integrity\": \"sha512-eIz2msL/EzL9UFTFFx7jBTkeZfku0yUAyZZZmJ93H2TYEiroIx2PQjEXcwYtYl8zXCxb+PAmA2hLIt/6ZEkPHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/node\": \"*\",\n        \"jest-util\": \"^29.7.0\",\n        \"merge-stream\": \"^2.0.0\",\n        \"supports-color\": \"^8.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/jest-worker/node_modules/supports-color\": {\n      \"version\": \"8.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz\",\n      \"integrity\": \"sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-flag\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/supports-color?sponsor=1\"\n      }\n    },\n    \"node_modules/js-tokens\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz\",\n      \"integrity\": \"sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\",\n      \"dev\": true\n    },\n    \"node_modules/js-yaml\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz\",\n      \"integrity\": \"sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"argparse\": \"^2.0.1\"\n      },\n      \"bin\": {\n        \"js-yaml\": \"bin/js-yaml.js\"\n      }\n    },\n    \"node_modules/jsesc\": {\n      \"version\": \"3.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/jsesc/-/jsesc-3.0.2.tgz\",\n      \"integrity\": \"sha512-xKqzzWXDttJuOcawBt4KnKHHIf5oQ/Cxax+0PWFG+DFDgHNAdi+TXECADI+RYiFUMmx8792xsMbbgXj4CwnP4g==\",\n      \"dev\": true,\n      \"bin\": {\n        \"jsesc\": \"bin/jsesc\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/json-buffer\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz\",\n      \"integrity\": \"sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==\",\n      \"dev\": true\n    },\n    \"node_modules/json-parse-even-better-errors\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz\",\n      \"integrity\": \"sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==\",\n      \"dev\": true\n    },\n    \"node_modules/json-schema-traverse\": {\n      \"version\": \"0.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz\",\n      \"integrity\": \"sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/json-stable-stringify-without-jsonify\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz\",\n      \"integrity\": \"sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==\",\n      \"dev\": true\n    },\n    \"node_modules/json5\": {\n      \"version\": \"2.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/json5/-/json5-2.2.3.tgz\",\n      \"integrity\": \"sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==\",\n      \"dev\": true,\n      \"bin\": {\n        \"json5\": \"lib/cli.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/keyv\": {\n      \"version\": \"4.5.4\",\n      \"resolved\": \"https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz\",\n      \"integrity\": \"sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"json-buffer\": \"3.0.1\"\n      }\n    },\n    \"node_modules/kleur\": {\n      \"version\": \"3.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/kleur/-/kleur-3.0.3.tgz\",\n      \"integrity\": \"sha512-eTIzlVOSUR+JxdDFepEYcBMtZ9Qqdef+rnzWdRZuMbOywu5tO2w2N7rqjoANZ5k9vywhL6Br1VRjUIgTQx4E8w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/leven\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/leven/-/leven-3.1.0.tgz\",\n      \"integrity\": \"sha512-qsda+H8jTaUaN/x5vzW2rzc+8Rw4TAQ/4KjB46IwK5VH+IlVeeeje/EoZRpiXvIqjFgK84QffqPztGI3VBLG1A==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/levn\": {\n      \"version\": \"0.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/levn/-/levn-0.4.1.tgz\",\n      \"integrity\": \"sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"prelude-ls\": \"^1.2.1\",\n        \"type-check\": \"~0.4.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.8.0\"\n      }\n    },\n    \"node_modules/lines-and-columns\": {\n      \"version\": \"1.2.4\",\n      \"resolved\": \"https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz\",\n      \"integrity\": \"sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==\",\n      \"dev\": true\n    },\n    \"node_modules/locate-path\": {\n      \"version\": \"6.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz\",\n      \"integrity\": \"sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"p-locate\": \"^5.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/lodash.memoize\": {\n      \"version\": \"4.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/lodash.memoize/-/lodash.memoize-4.1.2.tgz\",\n      \"integrity\": \"sha512-t7j+NzmgnQzTAYXcsHYLgimltOV1MXHtlOWf6GjL9Kj8GK5FInw5JotxvbOs+IvV1/Dzo04/fCGfLVs7aXb4Ag==\",\n      \"dev\": true\n    },\n    \"node_modules/lodash.merge\": {\n      \"version\": \"4.6.2\",\n      \"resolved\": \"https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz\",\n      \"integrity\": \"sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==\",\n      \"dev\": true\n    },\n    \"node_modules/lru-cache\": {\n      \"version\": \"5.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz\",\n      \"integrity\": \"sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"yallist\": \"^3.0.2\"\n      }\n    },\n    \"node_modules/make-dir\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz\",\n      \"integrity\": \"sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"semver\": \"^7.5.3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/make-dir/node_modules/semver\": {\n      \"version\": \"7.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.6.3.tgz\",\n      \"integrity\": \"sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/make-error\": {\n      \"version\": \"1.3.6\",\n      \"resolved\": \"https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz\",\n      \"integrity\": \"sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==\",\n      \"dev\": true\n    },\n    \"node_modules/makeerror\": {\n      \"version\": \"1.0.12\",\n      \"resolved\": \"https://registry.npmjs.org/makeerror/-/makeerror-1.0.12.tgz\",\n      \"integrity\": \"sha512-JmqCvUhmt43madlpFzG4BQzG2Z3m6tvQDNKdClZnO3VbIudJYmxsT0FNJMeiB2+JTSlTQTSbU8QdesVmwJcmLg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"tmpl\": \"1.0.5\"\n      }\n    },\n    \"node_modules/math-intrinsics\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz\",\n      \"integrity\": \"sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      }\n    },\n    \"node_modules/media-typer\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz\",\n      \"integrity\": \"sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/merge-descriptors\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz\",\n      \"integrity\": \"sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E=18\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/merge-stream\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz\",\n      \"integrity\": \"sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==\",\n      \"dev\": true\n    },\n    \"node_modules/merge2\": {\n      \"version\": \"1.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz\",\n      \"integrity\": \"sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E= 8\"\n      }\n    },\n    \"node_modules/methods\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/methods/-/methods-1.1.2.tgz\",\n      \"integrity\": \"sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/micromatch\": {\n      \"version\": \"4.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz\",\n      \"integrity\": \"sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"braces\": \"^3.0.3\",\n        \"picomatch\": \"^2.3.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8.6\"\n      }\n    },\n    \"node_modules/mime\": {\n      \"version\": \"2.6.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime/-/mime-2.6.0.tgz\",\n      \"integrity\": \"sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"bin\": {\n        \"mime\": \"cli.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=4.0.0\"\n      }\n    },\n    \"node_modules/mime-db\": {\n      \"version\": \"1.53.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.53.0.tgz\",\n      \"integrity\": \"sha512-oHlN/w+3MQ3rba9rqFr6V/ypF10LSkdwUysQL7GkXoTgIWeV+tcXGA852TBxH+gsh8UWoyhR1hKcoMJTuWflpg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/mime-types\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-3.0.0.tgz\",\n      \"integrity\": \"sha512-XqoSHeCGjVClAmoGFG3lVFqQFRIrTVw2OH3axRqAcfaw+gHWIfnASS92AV+Rl/mk0MupgZTRHQOjxY6YVnzK5w==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"^1.53.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/mimic-fn\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz\",\n      \"integrity\": \"sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/minimatch\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^1.1.7\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/ms\": {\n      \"version\": \"2.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.3.tgz\",\n      \"integrity\": \"sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==\"\n    },\n    \"node_modules/natural-compare\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz\",\n      \"integrity\": \"sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==\",\n      \"dev\": true\n    },\n    \"node_modules/negotiator\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz\",\n      \"integrity\": \"sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/node-int64\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/node-int64/-/node-int64-0.4.0.tgz\",\n      \"integrity\": \"sha512-O5lz91xSOeoXP6DulyHfllpq+Eg00MWitZIbtPfoSEvqIHdl5gfcY6hYzDWnj0qD5tz52PI08u9qUvSVeUBeHw==\",\n      \"dev\": true\n    },\n    \"node_modules/node-releases\": {\n      \"version\": \"2.0.18\",\n      \"resolved\": \"https://registry.npmjs.org/node-releases/-/node-releases-2.0.18.tgz\",\n      \"integrity\": \"sha512-d9VeXT4SJ7ZeOqGX6R5EM022wpL+eWPooLI+5UpWn2jCT1aosUQEhQP214x33Wkwx3JQMvIm+tIoVOdodFS40g==\",\n      \"dev\": true\n    },\n    \"node_modules/normalize-path\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz\",\n      \"integrity\": \"sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/npm-run-path\": {\n      \"version\": \"4.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz\",\n      \"integrity\": \"sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"path-key\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/object-assign\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz\",\n      \"integrity\": \"sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/object-inspect\": {\n      \"version\": \"1.13.4\",\n      \"resolved\": \"https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz\",\n      \"integrity\": \"sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/on-finished\": {\n      \"version\": \"2.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz\",\n      \"integrity\": \"sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ee-first\": \"1.1.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/once\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n      \"integrity\": \"sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==\",\n      \"dependencies\": {\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/onetime\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz\",\n      \"integrity\": \"sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"mimic-fn\": \"^2.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/optionator\": {\n      \"version\": \"0.9.4\",\n      \"resolved\": \"https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz\",\n      \"integrity\": \"sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"deep-is\": \"^0.1.3\",\n        \"fast-levenshtein\": \"^2.0.6\",\n        \"levn\": \"^0.4.1\",\n        \"prelude-ls\": \"^1.2.1\",\n        \"type-check\": \"^0.4.0\",\n        \"word-wrap\": \"^1.2.5\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.8.0\"\n      }\n    },\n    \"node_modules/p-limit\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz\",\n      \"integrity\": \"sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"yocto-queue\": \"^0.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/p-locate\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz\",\n      \"integrity\": \"sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"p-limit\": \"^3.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/p-try\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-try/-/p-try-2.2.0.tgz\",\n      \"integrity\": \"sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/parent-module\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz\",\n      \"integrity\": \"sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"callsites\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/parse-json\": {\n      \"version\": \"5.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/parse-json/-/parse-json-5.2.0.tgz\",\n      \"integrity\": \"sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/code-frame\": \"^7.0.0\",\n        \"error-ex\": \"^1.3.1\",\n        \"json-parse-even-better-errors\": \"^2.3.0\",\n        \"lines-and-columns\": \"^1.1.6\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/parseurl\": {\n      \"version\": \"1.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz\",\n      \"integrity\": \"sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/path-exists\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz\",\n      \"integrity\": \"sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/path-is-absolute\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n      \"integrity\": \"sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/path-key\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz\",\n      \"integrity\": \"sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==\",\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/path-parse\": {\n      \"version\": \"1.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz\",\n      \"integrity\": \"sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==\",\n      \"dev\": true\n    },\n    \"node_modules/path-to-regexp\": {\n      \"version\": \"8.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz\",\n      \"integrity\": \"sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E=16\"\n      }\n    },\n    \"node_modules/picocolors\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz\",\n      \"integrity\": \"sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==\",\n      \"dev\": true\n    },\n    \"node_modules/picomatch\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz\",\n      \"integrity\": \"sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8.6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/jonschlinkert\"\n      }\n    },\n    \"node_modules/pirates\": {\n      \"version\": \"4.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/pirates/-/pirates-4.0.6.tgz\",\n      \"integrity\": \"sha512-saLsH7WeYYPiD25LDuLRRY/i+6HaPYr6G1OUlN39otzkSTxKnubR9RTxS3/Kk50s1g2JTgFwWQDQyplC5/SHZg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E= 6\"\n      }\n    },\n    \"node_modules/pkce-challenge\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/pkce-challenge/-/pkce-challenge-5.0.0.tgz\",\n      \"integrity\": \"sha512-ueGLflrrnvwB3xuo/uGob5pd5FN7l0MsLf0Z87o/UQmRtwjvfylfc9MurIxRAWywCYTgrvpXBcqjV4OfCYGCIQ==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E=16.20.0\"\n      }\n    },\n    \"node_modules/pkg-dir\": {\n      \"version\": \"4.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/pkg-dir/-/pkg-dir-4.2.0.tgz\",\n      \"integrity\": \"sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"find-up\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/pkg-dir/node_modules/find-up\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz\",\n      \"integrity\": \"sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"locate-path\": \"^5.0.0\",\n        \"path-exists\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/pkg-dir/node_modules/locate-path\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz\",\n      \"integrity\": \"sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"p-locate\": \"^4.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/pkg-dir/node_modules/p-limit\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz\",\n      \"integrity\": \"sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"p-try\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/pkg-dir/node_modules/p-locate\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz\",\n      \"integrity\": \"sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"p-limit\": \"^2.2.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/prelude-ls\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz\",\n      \"integrity\": \"sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E= 0.8.0\"\n      }\n    },\n    \"node_modules/pretty-format\": {\n      \"version\": \"29.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/pretty-format/-/pretty-format-29.7.0.tgz\",\n      \"integrity\": \"sha512-Pdlw/oPxN+aXdmM9R00JVC9WVFoCLTKJvDVLgmJ+qAffBMxsV85l/Lu7sNx4zSzPyoL2euImuEwHhOXdEgNFZQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jest/schemas\": \"^29.6.3\",\n        \"ansi-styles\": \"^5.0.0\",\n        \"react-is\": \"^18.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || \u003E=18.0.0\"\n      }\n    },\n    \"node_modules/pretty-format/node_modules/ansi-styles\": {\n      \"version\": \"5.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz\",\n      \"integrity\": \"sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-styles?sponsor=1\"\n      }\n    },\n    \"node_modules/prompts\": {\n      \"version\": \"2.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/prompts/-/prompts-2.4.2.tgz\",\n      \"integrity\": \"sha512-NxNv/kLguCA7p3jE8oL2aEBsrJWgAakBpgmgK6lpPWV+WuOmY6r2/zbAVnP+T8bQlA0nzHXSJSJW0Hq7ylaD2Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"kleur\": \"^3.0.3\",\n        \"sisteransi\": \"^1.0.5\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 6\"\n      }\n    },\n    \"node_modules/proxy-addr\": {\n      \"version\": \"2.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz\",\n      \"integrity\": \"sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==\",\n      \"dependencies\": {\n        \"forwarded\": \"0.2.0\",\n        \"ipaddr.js\": \"1.9.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.10\"\n      }\n    },\n    \"node_modules/punycode\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz\",\n      \"integrity\": \"sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/pure-rand\": {\n      \"version\": \"6.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/pure-rand/-/pure-rand-6.1.0.tgz\",\n      \"integrity\": \"sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"individual\",\n          \"url\": \"https://github.com/sponsors/dubzzz\"\n        },\n        {\n          \"type\": \"opencollective\",\n          \"url\": \"https://opencollective.com/fast-check\"\n        }\n      ]\n    },\n    \"node_modules/qs\": {\n      \"version\": \"6.13.0\",\n      \"resolved\": \"https://registry.npmjs.org/qs/-/qs-6.13.0.tgz\",\n      \"integrity\": \"sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==\",\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"side-channel\": \"^1.0.6\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=0.6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/queue-microtask\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz\",\n      \"integrity\": \"sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ]\n    },\n    \"node_modules/range-parser\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz\",\n      \"integrity\": \"sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/raw-body\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/raw-body/-/raw-body-3.0.0.tgz\",\n      \"integrity\": \"sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==\",\n      \"dependencies\": {\n        \"bytes\": \"3.1.2\",\n        \"http-errors\": \"2.0.0\",\n        \"iconv-lite\": \"0.6.3\",\n        \"unpipe\": \"1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/raw-body/node_modules/iconv-lite\": {\n      \"version\": \"0.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz\",\n      \"integrity\": \"sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==\",\n      \"dependencies\": {\n        \"safer-buffer\": \"\u003E= 2.1.2 \u003C 3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/react-is\": {\n      \"version\": \"18.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/react-is/-/react-is-18.3.1.tgz\",\n      \"integrity\": \"sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==\",\n      \"dev\": true\n    },\n    \"node_modules/require-directory\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz\",\n      \"integrity\": \"sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/resolve\": {\n      \"version\": \"1.22.8\",\n      \"resolved\": \"https://registry.npmjs.org/resolve/-/resolve-1.22.8.tgz\",\n      \"integrity\": \"sha512-oKWePCxqpd6FlLvGV1VU0x7bkPmmCNolxzjMf4NczoDnQcIWrAF+cPtZn5i6n+RfD2d9i0tzpKnG6Yk168yIyw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-core-module\": \"^2.13.0\",\n        \"path-parse\": \"^1.0.7\",\n        \"supports-preserve-symlinks-flag\": \"^1.0.0\"\n      },\n      \"bin\": {\n        \"resolve\": \"bin/resolve\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/resolve-cwd\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/resolve-cwd/-/resolve-cwd-3.0.0.tgz\",\n      \"integrity\": \"sha512-OrZaX2Mb+rJCpH/6CpSqt9xFVpN++x01XnN2ie9g6P5/3xelLAkXWVADpdz1IHD/KFfEXyE6V0U01OQ3UO2rEg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"resolve-from\": \"^5.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/resolve-cwd/node_modules/resolve-from\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz\",\n      \"integrity\": \"sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/resolve-from\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz\",\n      \"integrity\": \"sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=4\"\n      }\n    },\n    \"node_modules/resolve-pkg-maps\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/resolve-pkg-maps/-/resolve-pkg-maps-1.0.0.tgz\",\n      \"integrity\": \"sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==\",\n      \"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/privatenumber/resolve-pkg-maps?sponsor=1\"\n      }\n    },\n    \"node_modules/resolve.exports\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/resolve.exports/-/resolve.exports-2.0.2.tgz\",\n      \"integrity\": \"sha512-X2UW6Nw3n/aMgDVy+0rSqgHlv39WZAlZrXCdnbyEiKm17DSqHX4MmQMaST3FbeWR5FTuRcUwYAziZajji0Y7mg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/reusify\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz\",\n      \"integrity\": \"sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"iojs\": \"\u003E=1.0.0\",\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/router\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/router/-/router-2.1.0.tgz\",\n      \"integrity\": \"sha512-/m/NSLxeYEgWNtyC+WtNHCF7jbGxOibVWKnn+1Psff4dJGOfoXP+MuC/f2CwSmyiHdOIzYnYFp4W6GxWfekaLA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"is-promise\": \"^4.0.0\",\n        \"parseurl\": \"^1.3.3\",\n        \"path-to-regexp\": \"^8.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 18\"\n      }\n    },\n    \"node_modules/run-parallel\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz\",\n      \"integrity\": \"sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ],\n      \"dependencies\": {\n        \"queue-microtask\": \"^1.2.2\"\n      }\n    },\n    \"node_modules/safe-buffer\": {\n      \"version\": \"5.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz\",\n      \"integrity\": \"sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ],\n      \"license\": \"MIT\"\n    },\n    \"node_modules/safer-buffer\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz\",\n      \"integrity\": \"sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==\"\n    },\n    \"node_modules/semver\": {\n      \"version\": \"6.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.1.tgz\",\n      \"integrity\": \"sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      }\n    },\n    \"node_modules/send\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/send/-/send-1.1.0.tgz\",\n      \"integrity\": \"sha512-v67WcEouB5GxbTWL/4NeToqcZiAWEq90N888fczVArY8A79J0L4FD7vj5hm3eUMua5EpoQ59wa/oovY6TLvRUA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"debug\": \"^4.3.5\",\n        \"destroy\": \"^1.2.0\",\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"etag\": \"^1.8.1\",\n        \"fresh\": \"^0.5.2\",\n        \"http-errors\": \"^2.0.0\",\n        \"mime-types\": \"^2.1.35\",\n        \"ms\": \"^2.1.3\",\n        \"on-finished\": \"^2.4.1\",\n        \"range-parser\": \"^1.2.1\",\n        \"statuses\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 18\"\n      }\n    },\n    \"node_modules/send/node_modules/fresh\": {\n      \"version\": \"0.5.2\",\n      \"resolved\": \"https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz\",\n      \"integrity\": \"sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/send/node_modules/mime-db\": {\n      \"version\": \"1.52.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz\",\n      \"integrity\": \"sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/send/node_modules/mime-types\": {\n      \"version\": \"2.1.35\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz\",\n      \"integrity\": \"sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"mime-db\": \"1.52.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/serve-static\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/serve-static/-/serve-static-2.1.0.tgz\",\n      \"integrity\": \"sha512-A3We5UfEjG8Z7VkDv6uItWw6HY2bBSBJT1KtVESn6EOoOr2jAxNhxWCLY3jDE2WcuHXByWju74ck3ZgLwL8xmA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"encodeurl\": \"^2.0.0\",\n        \"escape-html\": \"^1.0.3\",\n        \"parseurl\": \"^1.3.3\",\n        \"send\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 18\"\n      }\n    },\n    \"node_modules/setprototypeof\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz\",\n      \"integrity\": \"sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==\"\n    },\n    \"node_modules/shebang-command\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz\",\n      \"integrity\": \"sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==\",\n      \"dependencies\": {\n        \"shebang-regex\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/shebang-regex\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz\",\n      \"integrity\": \"sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==\",\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/side-channel\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz\",\n      \"integrity\": \"sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"object-inspect\": \"^1.13.3\",\n        \"side-channel-list\": \"^1.0.0\",\n        \"side-channel-map\": \"^1.0.1\",\n        \"side-channel-weakmap\": \"^1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-list\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz\",\n      \"integrity\": \"sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"es-errors\": \"^1.3.0\",\n        \"object-inspect\": \"^1.13.3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-map\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz\",\n      \"integrity\": \"sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bound\": \"^1.0.2\",\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.5\",\n        \"object-inspect\": \"^1.13.3\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/side-channel-weakmap\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz\",\n      \"integrity\": \"sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"call-bound\": \"^1.0.2\",\n        \"es-errors\": \"^1.3.0\",\n        \"get-intrinsic\": \"^1.2.5\",\n        \"object-inspect\": \"^1.13.3\",\n        \"side-channel-map\": \"^1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/signal-exit\": {\n      \"version\": \"3.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz\",\n      \"integrity\": \"sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==\",\n      \"dev\": true\n    },\n    \"node_modules/sisteransi\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/sisteransi/-/sisteransi-1.0.5.tgz\",\n      \"integrity\": \"sha512-bLGGlR1QxBcynn2d5YmDX4MGjlZvy2MRBDRNHLJ8VI6l6+9FUiyTFNJ0IveOSP0bcXgVDPRcfGqA0pjaqUpfVg==\",\n      \"dev\": true\n    },\n    \"node_modules/slash\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/slash/-/slash-3.0.0.tgz\",\n      \"integrity\": \"sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/source-map\": {\n      \"version\": \"0.6.1\",\n      \"resolved\": \"https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz\",\n      \"integrity\": \"sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/source-map-support\": {\n      \"version\": \"0.5.13\",\n      \"resolved\": \"https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.13.tgz\",\n      \"integrity\": \"sha512-SHSKFHadjVA5oR4PPqhtAVdcBWwRYVd6g6cAXnIbRiIwc2EhPrTuKUBdSLvlEKyIP3GCf89fltvcZiP9MMFA1w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"buffer-from\": \"^1.0.0\",\n        \"source-map\": \"^0.6.0\"\n      }\n    },\n    \"node_modules/sprintf-js\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz\",\n      \"integrity\": \"sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==\",\n      \"dev\": true\n    },\n    \"node_modules/stack-utils\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/stack-utils/-/stack-utils-2.0.6.tgz\",\n      \"integrity\": \"sha512-XlkWvfIm6RmsWtNJx+uqtKLS8eqFbxUg0ZzLXqY0caEy9l7hruX8IpiDnjsLavoBgqCCR71TqWO8MaXYheJ3RQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"escape-string-regexp\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/stack-utils/node_modules/escape-string-regexp\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-2.0.0.tgz\",\n      \"integrity\": \"sha512-UpzcLCXolUWcNu5HtVMHYdXJjArjsF9C0aNnquZYY4uW/Vu0miy5YoWvbV345HauVvcAUnpRuhMMcqTcGOY2+w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/statuses\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz\",\n      \"integrity\": \"sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/string-length\": {\n      \"version\": \"4.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/string-length/-/string-length-4.0.2.tgz\",\n      \"integrity\": \"sha512-+l6rNN5fYHNhZZy41RXsYptCjA2Igmq4EG7kZAYFQI1E1VTXarr6ZPXBg6eq7Y6eK4FEhY6AJlyuFIb/v/S0VQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"char-regex\": \"^1.0.2\",\n        \"strip-ansi\": \"^6.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/string-width\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz\",\n      \"integrity\": \"sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"emoji-regex\": \"^8.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/strip-ansi\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz\",\n      \"integrity\": \"sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ansi-regex\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/strip-bom\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/strip-bom/-/strip-bom-4.0.0.tgz\",\n      \"integrity\": \"sha512-3xurFv5tEgii33Zi8Jtp55wEIILR9eh34FAW00PZf+JnSsTmV/ioewSgQl97JHvgjoRGwPShsWm+IdrxB35d0w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/strip-final-newline\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-2.0.0.tgz\",\n      \"integrity\": \"sha512-BrpvfNAE3dcvq7ll3xVumzjKjZQ5tI1sEUIKr3Uoks0XUl45St3FlatVqef9prk4jRDzhW6WZg+3bk93y6pLjA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=6\"\n      }\n    },\n    \"node_modules/strip-json-comments\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz\",\n      \"integrity\": \"sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/superagent\": {\n      \"version\": \"9.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/superagent/-/superagent-9.0.2.tgz\",\n      \"integrity\": \"sha512-xuW7dzkUpcJq7QnhOsnNUgtYp3xRwpt2F7abdRYIpCsAt0hhUqia0EdxyXZQQpNmGtsCzYHryaKSV3q3GJnq7w==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"component-emitter\": \"^1.3.0\",\n        \"cookiejar\": \"^2.1.4\",\n        \"debug\": \"^4.3.4\",\n        \"fast-safe-stringify\": \"^2.1.1\",\n        \"form-data\": \"^4.0.0\",\n        \"formidable\": \"^3.5.1\",\n        \"methods\": \"^1.1.2\",\n        \"mime\": \"2.6.0\",\n        \"qs\": \"^6.11.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=14.18.0\"\n      }\n    },\n    \"node_modules/supertest\": {\n      \"version\": \"7.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/supertest/-/supertest-7.0.0.tgz\",\n      \"integrity\": \"sha512-qlsr7fIC0lSddmA3tzojvzubYxvlGtzumcdHgPwbFWMISQwL22MhM2Y3LNt+6w9Yyx7559VW5ab70dgphm8qQA==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"methods\": \"^1.1.2\",\n        \"superagent\": \"^9.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=14.18.0\"\n      }\n    },\n    \"node_modules/supports-color\": {\n      \"version\": \"7.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",\n      \"integrity\": \"sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-flag\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/supports-preserve-symlinks-flag\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz\",\n      \"integrity\": \"sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/test-exclude\": {\n      \"version\": \"6.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/test-exclude/-/test-exclude-6.0.0.tgz\",\n      \"integrity\": \"sha512-cAGWPIyOHU6zlmg88jwm7VRyXnMN7iV68OGAbYDk/Mh/xC/pzVPlQtY6ngoIH/5/tciuhGfvESU8GrHrcxD56w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@istanbuljs/schema\": \"^0.1.2\",\n        \"glob\": \"^7.1.4\",\n        \"minimatch\": \"^3.0.4\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8\"\n      }\n    },\n    \"node_modules/text-table\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz\",\n      \"integrity\": \"sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==\",\n      \"dev\": true\n    },\n    \"node_modules/tmpl\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/tmpl/-/tmpl-1.0.5.tgz\",\n      \"integrity\": \"sha512-3f0uOEAQwIqGuWW2MVzYg8fV/QNnc/IpuJNG837rLuczAaLVHslWHZQj4IGiEl5Hs3kkbhwL9Ab7Hrsmuj+Smw==\",\n      \"dev\": true\n    },\n    \"node_modules/to-regex-range\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz\",\n      \"integrity\": \"sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-number\": \"^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=8.0\"\n      }\n    },\n    \"node_modules/toidentifier\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz\",\n      \"integrity\": \"sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==\",\n      \"engines\": {\n        \"node\": \"\u003E=0.6\"\n      }\n    },\n    \"node_modules/ts-api-utils\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-1.3.0.tgz\",\n      \"integrity\": \"sha512-UQMIo7pb8WRomKR1/+MFVLTroIvDVtMX3K6OUir8ynLyzB8Jeriont2bTAtmNPa1ekAgN7YPDyf6V+ygrdU+eQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=16\"\n      },\n      \"peerDependencies\": {\n        \"typescript\": \"\u003E=4.2.0\"\n      }\n    },\n    \"node_modules/ts-jest\": {\n      \"version\": \"29.2.5\",\n      \"resolved\": \"https://registry.npmjs.org/ts-jest/-/ts-jest-29.2.5.tgz\",\n      \"integrity\": \"sha512-KD8zB2aAZrcKIdGk4OwpJggeLcH1FgrICqDSROWqlnJXGCXK4Mn6FcdK2B6670Xr73lHMG1kHw8R87A0ecZ+vA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"bs-logger\": \"^0.2.6\",\n        \"ejs\": \"^3.1.10\",\n        \"fast-json-stable-stringify\": \"^2.1.0\",\n        \"jest-util\": \"^29.0.0\",\n        \"json5\": \"^2.2.3\",\n        \"lodash.memoize\": \"^4.1.2\",\n        \"make-error\": \"^1.3.6\",\n        \"semver\": \"^7.6.3\",\n        \"yargs-parser\": \"^21.1.1\"\n      },\n      \"bin\": {\n        \"ts-jest\": \"cli.js\"\n      },\n      \"engines\": {\n        \"node\": \"^14.15.0 || ^16.10.0 || ^18.0.0 || \u003E=20.0.0\"\n      },\n      \"peerDependencies\": {\n        \"@babel/core\": \"\u003E=7.0.0-beta.0 \u003C8\",\n        \"@jest/transform\": \"^29.0.0\",\n        \"@jest/types\": \"^29.0.0\",\n        \"babel-jest\": \"^29.0.0\",\n        \"jest\": \"^29.0.0\",\n        \"typescript\": \"\u003E=4.3 \u003C6\"\n      },\n      \"peerDependenciesMeta\": {\n        \"@babel/core\": {\n          \"optional\": true\n        },\n        \"@jest/transform\": {\n          \"optional\": true\n        },\n        \"@jest/types\": {\n          \"optional\": true\n        },\n        \"babel-jest\": {\n          \"optional\": true\n        },\n        \"esbuild\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/ts-jest/node_modules/semver\": {\n      \"version\": \"7.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.6.3.tgz\",\n      \"integrity\": \"sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/tsx\": {\n      \"version\": \"4.19.3\",\n      \"resolved\": \"https://registry.npmjs.org/tsx/-/tsx-4.19.3.tgz\",\n      \"integrity\": \"sha512-4H8vUNGNjQ4V2EOoGw005+c+dGuPSnhpPBPHBtsZdGZBk/iJb4kguGlPWaZTZ3q5nMtFOEsY0nRDlh9PJyd6SQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"esbuild\": \"~0.25.0\",\n        \"get-tsconfig\": \"^4.7.5\"\n      },\n      \"bin\": {\n        \"tsx\": \"dist/cli.mjs\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=18.0.0\"\n      },\n      \"optionalDependencies\": {\n        \"fsevents\": \"~2.3.3\"\n      }\n    },\n    \"node_modules/type-check\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz\",\n      \"integrity\": \"sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"prelude-ls\": \"^1.2.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.8.0\"\n      }\n    },\n    \"node_modules/type-detect\": {\n      \"version\": \"4.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz\",\n      \"integrity\": \"sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=4\"\n      }\n    },\n    \"node_modules/type-fest\": {\n      \"version\": \"0.21.3\",\n      \"resolved\": \"https://registry.npmjs.org/type-fest/-/type-fest-0.21.3.tgz\",\n      \"integrity\": \"sha512-t0rzBq87m3fVcduHDUFhKmyyX+9eo6WQjZvf51Ea/M0Q7+T374Jp1aUiyUl0GKxp8M/OETVHSDvmkyPgvX+X2w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/type-is\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/type-is/-/type-is-2.0.0.tgz\",\n      \"integrity\": \"sha512-gd0sGezQYCbWSbkZr75mln4YBidWUN60+devscpLF5mtRDUpiaTvKpBNrdaCvel1NdR2k6vclXybU5fBd2i+nw==\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"content-type\": \"^1.0.5\",\n        \"media-typer\": \"^1.1.0\",\n        \"mime-types\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 0.6\"\n      }\n    },\n    \"node_modules/typescript\": {\n      \"version\": \"5.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-5.6.3.tgz\",\n      \"integrity\": \"sha512-hjcS1mhfuyi4WW8IWtjP7brDrG2cuDZukyrYrSauoXGNgx0S7zceP07adYkJycEr56BOUTNPzbInooiN3fn1qw==\",\n      \"dev\": true,\n      \"bin\": {\n        \"tsc\": \"bin/tsc\",\n        \"tsserver\": \"bin/tsserver\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=14.17\"\n      }\n    },\n    \"node_modules/typescript-eslint\": {\n      \"version\": \"8.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/typescript-eslint/-/typescript-eslint-8.11.0.tgz\",\n      \"integrity\": \"sha512-cBRGnW3FSlxaYwU8KfAewxFK5uzeOAp0l2KebIlPDOT5olVi65KDG/yjBooPBG0kGW/HLkoz1c/iuBFehcS3IA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/eslint-plugin\": \"8.11.0\",\n        \"@typescript-eslint/parser\": \"8.11.0\",\n        \"@typescript-eslint/utils\": \"8.11.0\"\n      },\n      \"engines\": {\n        \"node\": \"^18.18.0 || ^20.9.0 || \u003E=21.1.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/undici-types\": {\n      \"version\": \"6.19.8\",\n      \"resolved\": \"https://registry.npmjs.org/undici-types/-/undici-types-6.19.8.tgz\",\n      \"integrity\": \"sha512-ve2KP6f/JnbPBFyobGHuerC9g1FYGn/F8n1LWTwNxCEzd6IfqTwUQcNXgEtmmQ6DlRrC1hrSrBnCZPokRrDHjw==\",\n      \"dev\": true\n    },\n    \"node_modules/unpipe\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz\",\n      \"integrity\": \"sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/update-browserslist-db\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.1.tgz\",\n      \"integrity\": \"sha512-R8UzCaa9Az+38REPiJ1tXlImTJXlVfgHZsglwBD/k6nj76ctsH1E3q4doGrukiLQd3sGQYu56r5+lo5r94l29A==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"opencollective\",\n          \"url\": \"https://opencollective.com/browserslist\"\n        },\n        {\n          \"type\": \"tidelift\",\n          \"url\": \"https://tidelift.com/funding/github/npm/browserslist\"\n        },\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/ai\"\n        }\n      ],\n      \"dependencies\": {\n        \"escalade\": \"^3.2.0\",\n        \"picocolors\": \"^1.1.0\"\n      },\n      \"bin\": {\n        \"update-browserslist-db\": \"cli.js\"\n      },\n      \"peerDependencies\": {\n        \"browserslist\": \"\u003E= 4.21.0\"\n      }\n    },\n    \"node_modules/uri-js\": {\n      \"version\": \"4.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz\",\n      \"integrity\": \"sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==\",\n      \"license\": \"BSD-2-Clause\",\n      \"dependencies\": {\n        \"punycode\": \"^2.1.0\"\n      }\n    },\n    \"node_modules/utils-merge\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz\",\n      \"integrity\": \"sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.4.0\"\n      }\n    },\n    \"node_modules/v8-to-istanbul\": {\n      \"version\": \"9.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/v8-to-istanbul/-/v8-to-istanbul-9.3.0.tgz\",\n      \"integrity\": \"sha512-kiGUalWN+rgBJ/1OHZsBtU4rXZOfj/7rKQxULKlIzwzQSvMJUUNgPwJEEh7gU6xEVxC0ahoOBvN2YI8GH6FNgA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@jridgewell/trace-mapping\": \"^0.3.12\",\n        \"@types/istanbul-lib-coverage\": \"^2.0.1\",\n        \"convert-source-map\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10.12.0\"\n      }\n    },\n    \"node_modules/vary\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/vary/-/vary-1.1.2.tgz\",\n      \"integrity\": \"sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==\",\n      \"engines\": {\n        \"node\": \"\u003E= 0.8\"\n      }\n    },\n    \"node_modules/walker\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/walker/-/walker-1.0.8.tgz\",\n      \"integrity\": \"sha512-ts/8E8l5b7kY0vlWLewOkDXMmPdLcVV4GmOQLyxuSswIJsweeFZtAsMF7k1Nszz+TYBQrlYRmzOnr398y1JemQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"makeerror\": \"1.0.12\"\n      }\n    },\n    \"node_modules/which\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",\n      \"integrity\": \"sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\",\n      \"dependencies\": {\n        \"isexe\": \"^2.0.0\"\n      },\n      \"bin\": {\n        \"node-which\": \"bin/node-which\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E= 8\"\n      }\n    },\n    \"node_modules/word-wrap\": {\n      \"version\": \"1.2.5\",\n      \"resolved\": \"https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz\",\n      \"integrity\": \"sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=0.10.0\"\n      }\n    },\n    \"node_modules/wrap-ansi\": {\n      \"version\": \"7.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz\",\n      \"integrity\": \"sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ansi-styles\": \"^4.0.0\",\n        \"string-width\": \"^4.1.0\",\n        \"strip-ansi\": \"^6.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/wrap-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/wrappy\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n      \"integrity\": \"sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==\"\n    },\n    \"node_modules/write-file-atomic\": {\n      \"version\": \"4.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/write-file-atomic/-/write-file-atomic-4.0.2.tgz\",\n      \"integrity\": \"sha512-7KxauUdBmSdWnmpaGFg+ppNjKF8uNLry8LyzjauQDOVONfFLNKrKvQOxZ/VuTIcS/gge/YNahf5RIIQWTSarlg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"imurmurhash\": \"^0.1.4\",\n        \"signal-exit\": \"^3.0.7\"\n      },\n      \"engines\": {\n        \"node\": \"^12.13.0 || ^14.15.0 || \u003E=16.0.0\"\n      }\n    },\n    \"node_modules/ws\": {\n      \"version\": \"8.18.0\",\n      \"resolved\": \"https://registry.npmjs.org/ws/-/ws-8.18.0.tgz\",\n      \"integrity\": \"sha512-8VbfWfHLbbwu3+N6OKsOMpBdT4kXPDDB9cJk2bJ6mh9ucxdlnNvH1e+roYkKmN9Nxw2yjz7VzeO9oOz2zJ04Pw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10.0.0\"\n      },\n      \"peerDependencies\": {\n        \"bufferutil\": \"^4.0.1\",\n        \"utf-8-validate\": \"\u003E=5.0.2\"\n      },\n      \"peerDependenciesMeta\": {\n        \"bufferutil\": {\n          \"optional\": true\n        },\n        \"utf-8-validate\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/y18n\": {\n      \"version\": \"5.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz\",\n      \"integrity\": \"sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      }\n    },\n    \"node_modules/yallist\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz\",\n      \"integrity\": \"sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==\",\n      \"dev\": true\n    },\n    \"node_modules/yargs\": {\n      \"version\": \"17.7.2\",\n      \"resolved\": \"https://registry.npmjs.org/yargs/-/yargs-17.7.2.tgz\",\n      \"integrity\": \"sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"cliui\": \"^8.0.1\",\n        \"escalade\": \"^3.1.1\",\n        \"get-caller-file\": \"^2.0.5\",\n        \"require-directory\": \"^2.1.1\",\n        \"string-width\": \"^4.2.3\",\n        \"y18n\": \"^5.0.5\",\n        \"yargs-parser\": \"^21.1.1\"\n      },\n      \"engines\": {\n        \"node\": \"\u003E=12\"\n      }\n    },\n    \"node_modules/yargs-parser\": {\n      \"version\": \"21.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/yargs-parser/-/yargs-parser-21.1.1.tgz\",\n      \"integrity\": \"sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=12\"\n      }\n    },\n    \"node_modules/yocto-queue\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz\",\n      \"integrity\": \"sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"\u003E=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/zod\": {\n      \"version\": \"3.24.1\",\n      \"resolved\": \"https://registry.npmjs.org/zod/-/zod-3.24.1.tgz\",\n      \"integrity\": \"sha512-muH7gBL9sI1nciMZV67X5fTKKBLtwpZ5VBp1vsOQzj1MhrBZ4wlVCm3gedKZWLp0Oyel8sIGfeiz54Su+OVT+A==\",\n      \"license\": \"MIT\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/colinhacks\"\n      }\n    },\n    \"node_modules/zod-to-json-schema\": {\n      \"version\": \"3.24.1\",\n      \"resolved\": \"https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.24.1.tgz\",\n      \"integrity\": \"sha512-3h08nf3Vw3Wl3PK+q3ow/lIil81IT2Oa7YpQyUUDsEWbXveMesdfK1xBd2RhCkynwZndAxixji/7SYJJowr62w==\",\n      \"license\": \"ISC\",\n      \"peerDependencies\": {\n        \"zod\": \"^3.24.1\"\n      }\n    }\n  }\n}\n",
      "hash": "b73039340f75f7ec1d179a480f0a979e5207a2699ba16406fcd4896f20093364",
      "size": 240189,
      "json": {
        "name": "@modelcontextprotocol/sdk",
        "version": "1.17.4",
        "lockfileVersion": 3,
        "requires": true,
        "packages": {
          "": {
            "name": "@modelcontextprotocol/sdk",
            "version": "1.17.4",
            "license": "MIT",
            "dependencies": {
              "ajv": "^6.12.6",
              "content-type": "^1.0.5",
              "cors": "^2.8.5",
              "cross-spawn": "^7.0.5",
              "eventsource": "^3.0.2",
              "eventsource-parser": "^3.0.0",
              "express": "^5.0.1",
              "express-rate-limit": "^7.5.0",
              "pkce-challenge": "^5.0.0",
              "raw-body": "^3.0.0",
              "zod": "^3.23.8",
              "zod-to-json-schema": "^3.24.1"
            },
            "devDependencies": {
              "@eslint/js": "^9.8.0",
              "@jest-mock/express": "^3.0.0",
              "@types/content-type": "^1.1.8",
              "@types/cors": "^2.8.17",
              "@types/cross-spawn": "^6.0.6",
              "@types/eslint__js": "^8.42.3",
              "@types/eventsource": "^1.1.15",
              "@types/express": "^5.0.0",
              "@types/jest": "^29.5.12",
              "@types/node": "^22.0.2",
              "@types/supertest": "^6.0.2",
              "@types/ws": "^8.5.12",
              "eslint": "^9.8.0",
              "jest": "^29.7.0",
              "supertest": "^7.0.0",
              "ts-jest": "^29.2.4",
              "tsx": "^4.16.5",
              "typescript": "^5.5.4",
              "typescript-eslint": "^8.0.0",
              "ws": "^8.18.0"
            },
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@ampproject/remapping": {
            "version": "2.3.0",
            "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
            "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
            "dev": true,
            "dependencies": {
              "@jridgewell/gen-mapping": "^0.3.5",
              "@jridgewell/trace-mapping": "^0.3.24"
            },
            "engines": {
              "node": "\u003E=6.0.0"
            }
          },
          "node_modules/@babel/code-frame": {
            "version": "7.26.2",
            "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.26.2.tgz",
            "integrity": "sha512-RJlIHRueQgwWitWgF8OdFYGZX328Ax5BCemNGlqHfplnRT9ESi8JkFlvaVYbS+UubVY6dpv87Fs2u5M29iNFVQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@babel/helper-validator-identifier": "^7.25.9",
              "js-tokens": "^4.0.0",
              "picocolors": "^1.0.0"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/compat-data": {
            "version": "7.26.0",
            "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.26.0.tgz",
            "integrity": "sha512-qETICbZSLe7uXv9VE8T/RWOdIE5qqyTucOt4zLYMafj2MRO271VGgLd4RACJMeBO37UPWhXiKMBk7YlJ0fOzQA==",
            "dev": true,
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/core": {
            "version": "7.26.0",
            "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.26.0.tgz",
            "integrity": "sha512-i1SLeK+DzNnQ3LL/CswPCa/E5u4lh1k6IAEphON8F+cXt0t9euTshDru0q7/IqMa1PMPz5RnHuHscF8/ZJsStg==",
            "dev": true,
            "dependencies": {
              "@ampproject/remapping": "^2.2.0",
              "@babel/code-frame": "^7.26.0",
              "@babel/generator": "^7.26.0",
              "@babel/helper-compilation-targets": "^7.25.9",
              "@babel/helper-module-transforms": "^7.26.0",
              "@babel/helpers": "^7.26.0",
              "@babel/parser": "^7.26.0",
              "@babel/template": "^7.25.9",
              "@babel/traverse": "^7.25.9",
              "@babel/types": "^7.26.0",
              "convert-source-map": "^2.0.0",
              "debug": "^4.1.0",
              "gensync": "^1.0.0-beta.2",
              "json5": "^2.2.3",
              "semver": "^6.3.1"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/babel"
            }
          },
          "node_modules/@babel/generator": {
            "version": "7.26.0",
            "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.26.0.tgz",
            "integrity": "sha512-/AIkAmInnWwgEAJGQr9vY0c66Mj6kjkE2ZPB1PurTRaRAh3U+J45sAQMjQDJdh4WbR3l0x5xkimXBKyBXXAu2w==",
            "dev": true,
            "dependencies": {
              "@babel/parser": "^7.26.0",
              "@babel/types": "^7.26.0",
              "@jridgewell/gen-mapping": "^0.3.5",
              "@jridgewell/trace-mapping": "^0.3.25",
              "jsesc": "^3.0.2"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/helper-compilation-targets": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.25.9.tgz",
            "integrity": "sha512-j9Db8Suy6yV/VHa4qzrj9yZfZxhLWQdVnRlXxmKLYlhWUVB1sB2G5sxuWYXk/whHD9iW76PmNzxZ4UCnTQTVEQ==",
            "dev": true,
            "dependencies": {
              "@babel/compat-data": "^7.25.9",
              "@babel/helper-validator-option": "^7.25.9",
              "browserslist": "^4.24.0",
              "lru-cache": "^5.1.1",
              "semver": "^6.3.1"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/helper-module-imports": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.25.9.tgz",
            "integrity": "sha512-tnUA4RsrmflIM6W6RFTLFSXITtl0wKjgpnLgXyowocVPrbYrLUXSBXDgTs8BlbmIzIdlBySRQjINYs2BAkiLtw==",
            "dev": true,
            "dependencies": {
              "@babel/traverse": "^7.25.9",
              "@babel/types": "^7.25.9"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/helper-module-transforms": {
            "version": "7.26.0",
            "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.26.0.tgz",
            "integrity": "sha512-xO+xu6B5K2czEnQye6BHA7DolFFmS3LB7stHZFaOLb1pAwO1HWLS8fXA+eh0A2yIvltPVmx3eNNDBJA2SLHXFw==",
            "dev": true,
            "dependencies": {
              "@babel/helper-module-imports": "^7.25.9",
              "@babel/helper-validator-identifier": "^7.25.9",
              "@babel/traverse": "^7.25.9"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0"
            }
          },
          "node_modules/@babel/helper-plugin-utils": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.25.9.tgz",
            "integrity": "sha512-kSMlyUVdWe25rEsRGviIgOWnoT/nfABVWlqt9N19/dIPWViAOW2s9wznP5tURbs/IDuNk4gPy3YdYRgH3uxhBw==",
            "dev": true,
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/helper-string-parser": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.25.9.tgz",
            "integrity": "sha512-4A/SCr/2KLd5jrtOMFzaKjVtAei3+2r/NChoBNoZ3EyP/+GlhoaEGoWOZUmFmoITP7zOJyHIMm+DYRd8o3PvHA==",
            "dev": true,
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/helper-validator-identifier": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.25.9.tgz",
            "integrity": "sha512-Ed61U6XJc3CVRfkERJWDz4dJwKe7iLmmJsbOGu9wSloNSFttHV0I8g6UAgb7qnK5ly5bGLPd4oXZlxCdANBOWQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/helper-validator-option": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.25.9.tgz",
            "integrity": "sha512-e/zv1co8pp55dNdEcCynfj9X7nyUKUXoUEwfXqaZt0omVOmDe9oOTdKStH4GmAw6zxMFs50ZayuMfHDKlO7Tfw==",
            "dev": true,
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/helpers": {
            "version": "7.27.0",
            "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.27.0.tgz",
            "integrity": "sha512-U5eyP/CTFPuNE3qk+WZMxFkp/4zUzdceQlfzf7DdGdhp+Fezd7HD+i8Y24ZuTMKX3wQBld449jijbGq6OdGNQg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@babel/template": "^7.27.0",
              "@babel/types": "^7.27.0"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/parser": {
            "version": "7.27.0",
            "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.27.0.tgz",
            "integrity": "sha512-iaepho73/2Pz7w2eMS0Q5f83+0RKI7i4xmiYeBmDzfRVbQtTOG7Ts0S4HzJVsTMGI9keU8rNfuZr8DKfSt7Yyg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@babel/types": "^7.27.0"
            },
            "bin": {
              "parser": "bin/babel-parser.js"
            },
            "engines": {
              "node": "\u003E=6.0.0"
            }
          },
          "node_modules/@babel/plugin-syntax-async-generators": {
            "version": "7.8.4",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-async-generators/-/plugin-syntax-async-generators-7.8.4.tgz",
            "integrity": "sha512-tycmZxkGfZaxhMRbXlPXuVFpdWlXpir2W4AMhSJgRKzk/eDlIXOhb2LHWoLpDF7TEHylV5zNhykX6KAgHJmTNw==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-bigint": {
            "version": "7.8.3",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-bigint/-/plugin-syntax-bigint-7.8.3.tgz",
            "integrity": "sha512-wnTnFlG+YxQm3vDxpGE57Pj0srRU4sHE/mDkt1qv2YJJSeUAec2ma4WLUnUPeKjyrfntVwe/N6dCXpU+zL3Npg==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-class-properties": {
            "version": "7.12.13",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-properties/-/plugin-syntax-class-properties-7.12.13.tgz",
            "integrity": "sha512-fm4idjKla0YahUNgFNLCB0qySdsoPiZP3iQE3rky0mBUtMZ23yDJ9SJdg6dXTSDnulOVqiF3Hgr9nbXvXTQZYA==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.12.13"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-class-static-block": {
            "version": "7.14.5",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-static-block/-/plugin-syntax-class-static-block-7.14.5.tgz",
            "integrity": "sha512-b+YyPmr6ldyNnM6sqYeMWE+bgJcJpO6yS4QD7ymxgH34GBPNDM/THBh8iunyvKIZztiwLH4CJZ0RxTk9emgpjw==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.14.5"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-import-attributes": {
            "version": "7.26.0",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-attributes/-/plugin-syntax-import-attributes-7.26.0.tgz",
            "integrity": "sha512-e2dttdsJ1ZTpi3B9UYGLw41hifAubg19AtCu/2I/F1QNVclOBr1dYpTdmdyZ84Xiz43BS/tCUkMAZNLv12Pi+A==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.25.9"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-import-meta": {
            "version": "7.10.4",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-meta/-/plugin-syntax-import-meta-7.10.4.tgz",
            "integrity": "sha512-Yqfm+XDx0+Prh3VSeEQCPU81yC+JWZ2pDPFSS4ZdpfZhp4MkFMaDC1UqseovEKwSUpnIL7+vK+Clp7bfh0iD7g==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.10.4"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-json-strings": {
            "version": "7.8.3",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-json-strings/-/plugin-syntax-json-strings-7.8.3.tgz",
            "integrity": "sha512-lY6kdGpWHvjoe2vk4WrAapEuBR69EMxZl+RoGRhrFGNYVK8mOPAW8VfbT/ZgrFbXlDNiiaxQnAtgVCZ6jv30EA==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-jsx": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-jsx/-/plugin-syntax-jsx-7.25.9.tgz",
            "integrity": "sha512-ld6oezHQMZsZfp6pWtbjaNDF2tiiCYYDqQszHt5VV437lewP9aSi2Of99CK0D0XB21k7FLgnLcmQKyKzynfeAA==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.25.9"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-logical-assignment-operators": {
            "version": "7.10.4",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.10.4.tgz",
            "integrity": "sha512-d8waShlpFDinQ5MtvGU9xDAOzKH47+FFoney2baFIoMr952hKOLp1HR7VszoZvOsV/4+RRszNY7D17ba0te0ig==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.10.4"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-nullish-coalescing-operator": {
            "version": "7.8.3",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-nullish-coalescing-operator/-/plugin-syntax-nullish-coalescing-operator-7.8.3.tgz",
            "integrity": "sha512-aSff4zPII1u2QD7y+F8oDsz19ew4IGEJg9SVW+bqwpwtfFleiQDMdzA/R+UlWDzfnHFCxxleFT0PMIrR36XLNQ==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-numeric-separator": {
            "version": "7.10.4",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-numeric-separator/-/plugin-syntax-numeric-separator-7.10.4.tgz",
            "integrity": "sha512-9H6YdfkcK/uOnY/K7/aA2xpzaAgkQn37yzWUMRK7OaPOqOpGS1+n0H5hxT9AUw9EsSjPW8SVyMJwYRtWs3X3ug==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.10.4"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-object-rest-spread": {
            "version": "7.8.3",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-object-rest-spread/-/plugin-syntax-object-rest-spread-7.8.3.tgz",
            "integrity": "sha512-XoqMijGZb9y3y2XskN+P1wUGiVwWZ5JmoDRwx5+3GmEplNyVM2s2Dg8ILFQm8rWM48orGy5YpI5Bl8U1y7ydlA==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-optional-catch-binding": {
            "version": "7.8.3",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-catch-binding/-/plugin-syntax-optional-catch-binding-7.8.3.tgz",
            "integrity": "sha512-6VPD0Pc1lpTqw0aKoeRTMiB+kWhAoT24PA+ksWSBrFtl5SIRVpZlwN3NNPQjehA2E/91FV3RjLWoVTglWcSV3Q==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-optional-chaining": {
            "version": "7.8.3",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-chaining/-/plugin-syntax-optional-chaining-7.8.3.tgz",
            "integrity": "sha512-KoK9ErH1MBlCPxV0VANkXW2/dw4vlbGDrFgz8bmUsBGYkFRcbRwMh6cIJubdPrkxRwuGdtCk0v/wPTKbQgBjkg==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.8.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-private-property-in-object": {
            "version": "7.14.5",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-private-property-in-object/-/plugin-syntax-private-property-in-object-7.14.5.tgz",
            "integrity": "sha512-0wVnp9dxJ72ZUJDV27ZfbSj6iHLoytYZmh3rFcxNnvsJF3ktkzLDZPy/mA17HGsaQT3/DQsWYX1f1QGWkCoVUg==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.14.5"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-top-level-await": {
            "version": "7.14.5",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-top-level-await/-/plugin-syntax-top-level-await-7.14.5.tgz",
            "integrity": "sha512-hx++upLv5U1rgYfwe1xBQUhRmU41NEvpUvrp8jkrSCdvGSnM5/qdRMtylJ6PG5OFkBaHkbTAKTnd3/YyESRHFw==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.14.5"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/plugin-syntax-typescript": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-typescript/-/plugin-syntax-typescript-7.25.9.tgz",
            "integrity": "sha512-hjMgRy5hb8uJJjUcdWunWVcoi9bGpJp8p5Ol1229PoN6aytsLwNMgmdftO23wnCLMfVmTwZDWMPNq/D1SY60JQ==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.25.9"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0-0"
            }
          },
          "node_modules/@babel/template": {
            "version": "7.27.0",
            "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.0.tgz",
            "integrity": "sha512-2ncevenBqXI6qRMukPlXwHKHchC7RyMuu4xv5JBXRfOGVcTy1mXCD12qrp7Jsoxll1EV3+9sE4GugBVRjT2jFA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@babel/code-frame": "^7.26.2",
              "@babel/parser": "^7.27.0",
              "@babel/types": "^7.27.0"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/traverse": {
            "version": "7.25.9",
            "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.25.9.tgz",
            "integrity": "sha512-ZCuvfwOwlz/bawvAuvcj8rrithP2/N55Tzz342AkTvq4qaWbGfmCk/tKhNaV2cthijKrPAA8SRJV5WWe7IBMJw==",
            "dev": true,
            "dependencies": {
              "@babel/code-frame": "^7.25.9",
              "@babel/generator": "^7.25.9",
              "@babel/parser": "^7.25.9",
              "@babel/template": "^7.25.9",
              "@babel/types": "^7.25.9",
              "debug": "^4.3.1",
              "globals": "^11.1.0"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@babel/traverse/node_modules/globals": {
            "version": "11.12.0",
            "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
            "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==",
            "dev": true,
            "engines": {
              "node": "\u003E=4"
            }
          },
          "node_modules/@babel/types": {
            "version": "7.27.0",
            "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.27.0.tgz",
            "integrity": "sha512-H45s8fVLYjbhFH62dIJ3WtmJ6RSPt/3DRO0ZcT2SUiYiQyz3BLVb9ADEnLl91m74aQPS3AzzeajZHYOalWe3bg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@babel/helper-string-parser": "^7.25.9",
              "@babel/helper-validator-identifier": "^7.25.9"
            },
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/@bcoe/v8-coverage": {
            "version": "0.2.3",
            "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
            "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
            "dev": true
          },
          "node_modules/@esbuild/aix-ppc64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.0.tgz",
            "integrity": "sha512-O7vun9Sf8DFjH2UtqK8Ku3LkquL9SZL8OLY1T5NZkA34+wG3OQF7cl4Ql8vdNzM6fzBbYfLaiRLIOZ+2FOCgBQ==",
            "cpu": [
              "ppc64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "aix"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/android-arm": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.0.tgz",
            "integrity": "sha512-PTyWCYYiU0+1eJKmw21lWtC+d08JDZPQ5g+kFyxP0V+es6VPPSUhM6zk8iImp2jbV6GwjX4pap0JFbUQN65X1g==",
            "cpu": [
              "arm"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "android"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/android-arm64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.0.tgz",
            "integrity": "sha512-grvv8WncGjDSyUBjN9yHXNt+cq0snxXbDxy5pJtzMKGmmpPxeAmAhWxXI+01lU5rwZomDgD3kJwulEnhTRUd6g==",
            "cpu": [
              "arm64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "android"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/android-x64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.0.tgz",
            "integrity": "sha512-m/ix7SfKG5buCnxasr52+LI78SQ+wgdENi9CqyCXwjVR2X4Jkz+BpC3le3AoBPYTC9NHklwngVXvbJ9/Akhrfg==",
            "cpu": [
              "x64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "android"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/darwin-arm64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.0.tgz",
            "integrity": "sha512-mVwdUb5SRkPayVadIOI78K7aAnPamoeFR2bT5nszFUZ9P8UpK4ratOdYbZZXYSqPKMHfS1wdHCJk1P1EZpRdvw==",
            "cpu": [
              "arm64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "darwin"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/darwin-x64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.0.tgz",
            "integrity": "sha512-DgDaYsPWFTS4S3nWpFcMn/33ZZwAAeAFKNHNa1QN0rI4pUjgqf0f7ONmXf6d22tqTY+H9FNdgeaAa+YIFUn2Rg==",
            "cpu": [
              "x64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "darwin"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/freebsd-arm64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.0.tgz",
            "integrity": "sha512-VN4ocxy6dxefN1MepBx/iD1dH5K8qNtNe227I0mnTRjry8tj5MRk4zprLEdG8WPyAPb93/e4pSgi1SoHdgOa4w==",
            "cpu": [
              "arm64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "freebsd"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/freebsd-x64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.0.tgz",
            "integrity": "sha512-mrSgt7lCh07FY+hDD1TxiTyIHyttn6vnjesnPoVDNmDfOmggTLXRv8Id5fNZey1gl/V2dyVK1VXXqVsQIiAk+A==",
            "cpu": [
              "x64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "freebsd"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-arm": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.0.tgz",
            "integrity": "sha512-vkB3IYj2IDo3g9xX7HqhPYxVkNQe8qTK55fraQyTzTX/fxaDtXiEnavv9geOsonh2Fd2RMB+i5cbhu2zMNWJwg==",
            "cpu": [
              "arm"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-arm64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.0.tgz",
            "integrity": "sha512-9QAQjTWNDM/Vk2bgBl17yWuZxZNQIF0OUUuPZRKoDtqF2k4EtYbpyiG5/Dk7nqeK6kIJWPYldkOcBqjXjrUlmg==",
            "cpu": [
              "arm64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-ia32": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.0.tgz",
            "integrity": "sha512-43ET5bHbphBegyeqLb7I1eYn2P/JYGNmzzdidq/w0T8E2SsYL1U6un2NFROFRg1JZLTzdCoRomg8Rvf9M6W6Gg==",
            "cpu": [
              "ia32"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-loong64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.0.tgz",
            "integrity": "sha512-fC95c/xyNFueMhClxJmeRIj2yrSMdDfmqJnyOY4ZqsALkDrrKJfIg5NTMSzVBr5YW1jf+l7/cndBfP3MSDpoHw==",
            "cpu": [
              "loong64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-mips64el": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.0.tgz",
            "integrity": "sha512-nkAMFju7KDW73T1DdH7glcyIptm95a7Le8irTQNO/qtkoyypZAnjchQgooFUDQhNAy4iu08N79W4T4pMBwhPwQ==",
            "cpu": [
              "mips64el"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-ppc64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.0.tgz",
            "integrity": "sha512-NhyOejdhRGS8Iwv+KKR2zTq2PpysF9XqY+Zk77vQHqNbo/PwZCzB5/h7VGuREZm1fixhs4Q/qWRSi5zmAiO4Fw==",
            "cpu": [
              "ppc64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-riscv64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.0.tgz",
            "integrity": "sha512-5S/rbP5OY+GHLC5qXp1y/Mx//e92L1YDqkiBbO9TQOvuFXM+iDqUNG5XopAnXoRH3FjIUDkeGcY1cgNvnXp/kA==",
            "cpu": [
              "riscv64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-s390x": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.0.tgz",
            "integrity": "sha512-XM2BFsEBz0Fw37V0zU4CXfcfuACMrppsMFKdYY2WuTS3yi8O1nFOhil/xhKTmE1nPmVyvQJjJivgDT+xh8pXJA==",
            "cpu": [
              "s390x"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/linux-x64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.0.tgz",
            "integrity": "sha512-9yl91rHw/cpwMCNytUDxwj2XjFpxML0y9HAOH9pNVQDpQrBxHy01Dx+vaMu0N1CKa/RzBD2hB4u//nfc+Sd3Cw==",
            "cpu": [
              "x64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "linux"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/netbsd-arm64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.0.tgz",
            "integrity": "sha512-RuG4PSMPFfrkH6UwCAqBzauBWTygTvb1nxWasEJooGSJ/NwRw7b2HOwyRTQIU97Hq37l3npXoZGYMy3b3xYvPw==",
            "cpu": [
              "arm64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "netbsd"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/netbsd-x64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.0.tgz",
            "integrity": "sha512-jl+qisSB5jk01N5f7sPCsBENCOlPiS/xptD5yxOx2oqQfyourJwIKLRA2yqWdifj3owQZCL2sn6o08dBzZGQzA==",
            "cpu": [
              "x64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "netbsd"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/openbsd-arm64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.0.tgz",
            "integrity": "sha512-21sUNbq2r84YE+SJDfaQRvdgznTD8Xc0oc3p3iW/a1EVWeNj/SdUCbm5U0itZPQYRuRTW20fPMWMpcrciH2EJw==",
            "cpu": [
              "arm64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "openbsd"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/openbsd-x64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.0.tgz",
            "integrity": "sha512-2gwwriSMPcCFRlPlKx3zLQhfN/2WjJ2NSlg5TKLQOJdV0mSxIcYNTMhk3H3ulL/cak+Xj0lY1Ym9ysDV1igceg==",
            "cpu": [
              "x64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "openbsd"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/sunos-x64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.0.tgz",
            "integrity": "sha512-bxI7ThgLzPrPz484/S9jLlvUAHYMzy6I0XiU1ZMeAEOBcS0VePBFxh1JjTQt3Xiat5b6Oh4x7UC7IwKQKIJRIg==",
            "cpu": [
              "x64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "sunos"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/win32-arm64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.0.tgz",
            "integrity": "sha512-ZUAc2YK6JW89xTbXvftxdnYy3m4iHIkDtK3CLce8wg8M2L+YZhIvO1DKpxrd0Yr59AeNNkTiic9YLf6FTtXWMw==",
            "cpu": [
              "arm64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "win32"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/win32-ia32": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.0.tgz",
            "integrity": "sha512-eSNxISBu8XweVEWG31/JzjkIGbGIJN/TrRoiSVZwZ6pkC6VX4Im/WV2cz559/TXLcYbcrDN8JtKgd9DJVIo8GA==",
            "cpu": [
              "ia32"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "win32"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@esbuild/win32-x64": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.0.tgz",
            "integrity": "sha512-ZENoHJBxA20C2zFzh6AI4fT6RraMzjYw4xKWemRTRmRVtN9c5DcH9r/f2ihEkMjOW5eGgrwCslG/+Y/3bL+DHQ==",
            "cpu": [
              "x64"
            ],
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
              "win32"
            ],
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/@eslint-community/eslint-utils": {
            "version": "4.4.1",
            "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.4.1.tgz",
            "integrity": "sha512-s3O3waFUrMV8P/XaF/+ZTp1X9XBZW1a4B97ZnjQF2KYWaFD2A8KyFBsrsfSjEmjn3RGWAIuvlneuZm3CUK3jbA==",
            "dev": true,
            "dependencies": {
              "eslint-visitor-keys": "^3.4.3"
            },
            "engines": {
              "node": "^12.22.0 || ^14.17.0 || \u003E=16.0.0"
            },
            "funding": {
              "url": "https://opencollective.com/eslint"
            },
            "peerDependencies": {
              "eslint": "^6.0.0 || ^7.0.0 || \u003E=8.0.0"
            }
          },
          "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
            "version": "3.4.3",
            "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
            "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
            "dev": true,
            "engines": {
              "node": "^12.22.0 || ^14.17.0 || \u003E=16.0.0"
            },
            "funding": {
              "url": "https://opencollective.com/eslint"
            }
          },
          "node_modules/@eslint-community/regexpp": {
            "version": "4.12.1",
            "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.1.tgz",
            "integrity": "sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==",
            "dev": true,
            "engines": {
              "node": "^12.0.0 || ^14.0.0 || \u003E=16.0.0"
            }
          },
          "node_modules/@eslint/config-array": {
            "version": "0.18.0",
            "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.18.0.tgz",
            "integrity": "sha512-fTxvnS1sRMu3+JjXwJG0j/i4RT9u4qJ+lqS/yCGap4lH4zZGzQ7tu+xZqQmcMZq5OBZDL4QRxQzRjkWcGt8IVw==",
            "dev": true,
            "dependencies": {
              "@eslint/object-schema": "^2.1.4",
              "debug": "^4.3.1",
              "minimatch": "^3.1.2"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            }
          },
          "node_modules/@eslint/core": {
            "version": "0.7.0",
            "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.7.0.tgz",
            "integrity": "sha512-xp5Jirz5DyPYlPiKat8jaq0EmYvDXKKpzTbxXMpT9eqlRJkRKIz9AGMdlvYjih+im+QlhWrpvVjl8IPC/lHlUw==",
            "dev": true,
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            }
          },
          "node_modules/@eslint/eslintrc": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.1.0.tgz",
            "integrity": "sha512-4Bfj15dVJdoy3RfZmmo86RK1Fwzn6SstsvK9JS+BaVKqC6QQQQyXekNaC+g+LKNgkQ+2VhGAzm6hO40AhMR3zQ==",
            "dev": true,
            "dependencies": {
              "ajv": "^6.12.4",
              "debug": "^4.3.2",
              "espree": "^10.0.1",
              "globals": "^14.0.0",
              "ignore": "^5.2.0",
              "import-fresh": "^3.2.1",
              "js-yaml": "^4.1.0",
              "minimatch": "^3.1.2",
              "strip-json-comments": "^3.1.1"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "url": "https://opencollective.com/eslint"
            }
          },
          "node_modules/@eslint/js": {
            "version": "9.13.0",
            "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.13.0.tgz",
            "integrity": "sha512-IFLyoY4d72Z5y/6o/BazFBezupzI/taV8sGumxTAVw3lXG9A6md1Dc34T9s1FoD/an9pJH8RHbAxsaEbBed9lA==",
            "dev": true,
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            }
          },
          "node_modules/@eslint/object-schema": {
            "version": "2.1.4",
            "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.4.tgz",
            "integrity": "sha512-BsWiH1yFGjXXS2yvrf5LyuoSIIbPrGUWob917o+BTKuZ7qJdxX8aJLRxs1fS9n6r7vESrq1OUqb68dANcFXuQQ==",
            "dev": true,
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            }
          },
          "node_modules/@eslint/plugin-kit": {
            "version": "0.2.3",
            "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.2.3.tgz",
            "integrity": "sha512-2b/g5hRmpbb1o4GnTZax9N9m0FXzz9OV42ZzI4rDDMDuHUqigAiQCEWChBWCY4ztAGVRjoWT19v0yMmc5/L5kA==",
            "dev": true,
            "dependencies": {
              "levn": "^0.4.1"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            }
          },
          "node_modules/@humanfs/core": {
            "version": "0.19.0",
            "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.0.tgz",
            "integrity": "sha512-2cbWIHbZVEweE853g8jymffCA+NCMiuqeECeBBLm8dg2oFdjuGJhgN4UAbI+6v0CKbbhvtXA4qV8YR5Ji86nmw==",
            "dev": true,
            "engines": {
              "node": "\u003E=18.18.0"
            }
          },
          "node_modules/@humanfs/node": {
            "version": "0.16.5",
            "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.5.tgz",
            "integrity": "sha512-KSPA4umqSG4LHYRodq31VDwKAvaTF4xmVlzM8Aeh4PlU1JQ3IG0wiA8C25d3RQ9nJyM3mBHyI53K06VVL/oFFg==",
            "dev": true,
            "dependencies": {
              "@humanfs/core": "^0.19.0",
              "@humanwhocodes/retry": "^0.3.0"
            },
            "engines": {
              "node": "\u003E=18.18.0"
            }
          },
          "node_modules/@humanwhocodes/module-importer": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
            "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
            "dev": true,
            "engines": {
              "node": "\u003E=12.22"
            },
            "funding": {
              "type": "github",
              "url": "https://github.com/sponsors/nzakas"
            }
          },
          "node_modules/@humanwhocodes/retry": {
            "version": "0.3.1",
            "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.3.1.tgz",
            "integrity": "sha512-JBxkERygn7Bv/GbN5Rv8Ul6LVknS+5Bp6RgDC/O8gEBU/yeH5Ui5C/OlWrTb6qct7LjjfT6Re2NxB0ln0yYybA==",
            "dev": true,
            "engines": {
              "node": "\u003E=18.18"
            },
            "funding": {
              "type": "github",
              "url": "https://github.com/sponsors/nzakas"
            }
          },
          "node_modules/@istanbuljs/load-nyc-config": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@istanbuljs/load-nyc-config/-/load-nyc-config-1.1.0.tgz",
            "integrity": "sha512-VjeHSlIzpv/NyD3N0YuHfXOPDIixcA1q2ZV98wsMqcYlPmv2n3Yb2lYP9XMElnaFVXg5A7YLTeLu6V84uQDjmQ==",
            "dev": true,
            "dependencies": {
              "camelcase": "^5.3.1",
              "find-up": "^4.1.0",
              "get-package-type": "^0.1.0",
              "js-yaml": "^3.13.1",
              "resolve-from": "^5.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/@istanbuljs/load-nyc-config/node_modules/argparse": {
            "version": "1.0.10",
            "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
            "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
            "dev": true,
            "dependencies": {
              "sprintf-js": "~1.0.2"
            }
          },
          "node_modules/@istanbuljs/load-nyc-config/node_modules/find-up": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz",
            "integrity": "sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==",
            "dev": true,
            "dependencies": {
              "locate-path": "^5.0.0",
              "path-exists": "^4.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/@istanbuljs/load-nyc-config/node_modules/js-yaml": {
            "version": "3.14.1",
            "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz",
            "integrity": "sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==",
            "dev": true,
            "dependencies": {
              "argparse": "^1.0.7",
              "esprima": "^4.0.0"
            },
            "bin": {
              "js-yaml": "bin/js-yaml.js"
            }
          },
          "node_modules/@istanbuljs/load-nyc-config/node_modules/locate-path": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz",
            "integrity": "sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==",
            "dev": true,
            "dependencies": {
              "p-locate": "^4.1.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/@istanbuljs/load-nyc-config/node_modules/p-limit": {
            "version": "2.3.0",
            "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz",
            "integrity": "sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==",
            "dev": true,
            "dependencies": {
              "p-try": "^2.0.0"
            },
            "engines": {
              "node": "\u003E=6"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/@istanbuljs/load-nyc-config/node_modules/p-locate": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz",
            "integrity": "sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==",
            "dev": true,
            "dependencies": {
              "p-limit": "^2.2.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/@istanbuljs/load-nyc-config/node_modules/resolve-from": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
            "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/@istanbuljs/schema": {
            "version": "0.1.3",
            "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
            "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/@jest-mock/express": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/@jest-mock/express/-/express-3.0.0.tgz",
            "integrity": "sha512-omOl6bh4EOUbp9bvcPSBZKaG8nAtBlhVSUhLx0brHrNpEDn+fMtQp58NkhdY3OoUfXjb7go/EcSYwk+H1BVLdg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@types/express": "^5.0.0"
            }
          },
          "node_modules/@jest/console": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/console/-/console-29.7.0.tgz",
            "integrity": "sha512-5Ni4CU7XHQi32IJ398EEP4RrB8eV09sXP2ROqD4bksHrnTree52PsxvX8tpL8LvTZ3pFzXyPbNQReSN41CAhOg==",
            "dev": true,
            "dependencies": {
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "chalk": "^4.0.0",
              "jest-message-util": "^29.7.0",
              "jest-util": "^29.7.0",
              "slash": "^3.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/core": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/core/-/core-29.7.0.tgz",
            "integrity": "sha512-n7aeXWKMnGtDA48y8TLWJPJmLmmZ642Ceo78cYWEpiD7FzDgmNDV/GCVRorPABdXLJZ/9wzzgZAlHjXjxDHGsg==",
            "dev": true,
            "dependencies": {
              "@jest/console": "^29.7.0",
              "@jest/reporters": "^29.7.0",
              "@jest/test-result": "^29.7.0",
              "@jest/transform": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "ansi-escapes": "^4.2.1",
              "chalk": "^4.0.0",
              "ci-info": "^3.2.0",
              "exit": "^0.1.2",
              "graceful-fs": "^4.2.9",
              "jest-changed-files": "^29.7.0",
              "jest-config": "^29.7.0",
              "jest-haste-map": "^29.7.0",
              "jest-message-util": "^29.7.0",
              "jest-regex-util": "^29.6.3",
              "jest-resolve": "^29.7.0",
              "jest-resolve-dependencies": "^29.7.0",
              "jest-runner": "^29.7.0",
              "jest-runtime": "^29.7.0",
              "jest-snapshot": "^29.7.0",
              "jest-util": "^29.7.0",
              "jest-validate": "^29.7.0",
              "jest-watcher": "^29.7.0",
              "micromatch": "^4.0.4",
              "pretty-format": "^29.7.0",
              "slash": "^3.0.0",
              "strip-ansi": "^6.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            },
            "peerDependencies": {
              "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
            },
            "peerDependenciesMeta": {
              "node-notifier": {
                "optional": true
              }
            }
          },
          "node_modules/@jest/environment": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/environment/-/environment-29.7.0.tgz",
            "integrity": "sha512-aQIfHDq33ExsN4jP1NWGXhxgQ/wixs60gDiKO+XVMd8Mn0NWPWgc34ZQDTb2jKaUWQ7MuwoitXAsN2XVXNMpAw==",
            "dev": true,
            "dependencies": {
              "@jest/fake-timers": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "jest-mock": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/expect": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/expect/-/expect-29.7.0.tgz",
            "integrity": "sha512-8uMeAMycttpva3P1lBHB8VciS9V0XAr3GymPpipdyQXbBcuhkLQOSe8E/p92RyAdToS6ZD1tFkX+CkhoECE0dQ==",
            "dev": true,
            "dependencies": {
              "expect": "^29.7.0",
              "jest-snapshot": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/expect-utils": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/expect-utils/-/expect-utils-29.7.0.tgz",
            "integrity": "sha512-GlsNBWiFQFCVi9QVSx7f5AgMeLxe9YCCs5PuP2O2LdjDAA8Jh9eX7lA1Jq/xdXw3Wb3hyvlFNfZIfcRetSzYcA==",
            "dev": true,
            "dependencies": {
              "jest-get-type": "^29.6.3"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/fake-timers": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/fake-timers/-/fake-timers-29.7.0.tgz",
            "integrity": "sha512-q4DH1Ha4TTFPdxLsqDXK1d3+ioSL7yL5oCMJZgDYm6i+6CygW5E5xVr/D1HdsGxjt1ZWSfUAs9OxSB/BNelWrQ==",
            "dev": true,
            "dependencies": {
              "@jest/types": "^29.6.3",
              "@sinonjs/fake-timers": "^10.0.2",
              "@types/node": "*",
              "jest-message-util": "^29.7.0",
              "jest-mock": "^29.7.0",
              "jest-util": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/globals": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/globals/-/globals-29.7.0.tgz",
            "integrity": "sha512-mpiz3dutLbkW2MNFubUGUEVLkTGiqW6yLVTA+JbP6fI6J5iL9Y0Nlg8k95pcF8ctKwCS7WVxteBs29hhfAotzQ==",
            "dev": true,
            "dependencies": {
              "@jest/environment": "^29.7.0",
              "@jest/expect": "^29.7.0",
              "@jest/types": "^29.6.3",
              "jest-mock": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/reporters": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/reporters/-/reporters-29.7.0.tgz",
            "integrity": "sha512-DApq0KJbJOEzAFYjHADNNxAE3KbhxQB1y5Kplb5Waqw6zVbuWatSnMjE5gs8FUgEPmNsnZA3NCWl9NG0ia04Pg==",
            "dev": true,
            "dependencies": {
              "@bcoe/v8-coverage": "^0.2.3",
              "@jest/console": "^29.7.0",
              "@jest/test-result": "^29.7.0",
              "@jest/transform": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@jridgewell/trace-mapping": "^0.3.18",
              "@types/node": "*",
              "chalk": "^4.0.0",
              "collect-v8-coverage": "^1.0.0",
              "exit": "^0.1.2",
              "glob": "^7.1.3",
              "graceful-fs": "^4.2.9",
              "istanbul-lib-coverage": "^3.0.0",
              "istanbul-lib-instrument": "^6.0.0",
              "istanbul-lib-report": "^3.0.0",
              "istanbul-lib-source-maps": "^4.0.0",
              "istanbul-reports": "^3.1.3",
              "jest-message-util": "^29.7.0",
              "jest-util": "^29.7.0",
              "jest-worker": "^29.7.0",
              "slash": "^3.0.0",
              "string-length": "^4.0.1",
              "strip-ansi": "^6.0.0",
              "v8-to-istanbul": "^9.0.1"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            },
            "peerDependencies": {
              "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
            },
            "peerDependenciesMeta": {
              "node-notifier": {
                "optional": true
              }
            }
          },
          "node_modules/@jest/schemas": {
            "version": "29.6.3",
            "resolved": "https://registry.npmjs.org/@jest/schemas/-/schemas-29.6.3.tgz",
            "integrity": "sha512-mo5j5X+jIZmJQveBKeS/clAueipV7KgiX1vMgCxam1RNYiqE1w62n0/tJJnHtjW8ZHcQco5gY85jA3mi0L+nSA==",
            "dev": true,
            "dependencies": {
              "@sinclair/typebox": "^0.27.8"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/source-map": {
            "version": "29.6.3",
            "resolved": "https://registry.npmjs.org/@jest/source-map/-/source-map-29.6.3.tgz",
            "integrity": "sha512-MHjT95QuipcPrpLM+8JMSzFx6eHp5Bm+4XeFDJlwsvVBjmKNiIAvasGK2fxz2WbGRlnvqehFbh07MMa7n3YJnw==",
            "dev": true,
            "dependencies": {
              "@jridgewell/trace-mapping": "^0.3.18",
              "callsites": "^3.0.0",
              "graceful-fs": "^4.2.9"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/test-result": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/test-result/-/test-result-29.7.0.tgz",
            "integrity": "sha512-Fdx+tv6x1zlkJPcWXmMDAG2HBnaR9XPSd5aDWQVsfrZmLVT3lU1cwyxLgRmXR9yrq4NBoEm9BMsfgFzTQAbJYA==",
            "dev": true,
            "dependencies": {
              "@jest/console": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@types/istanbul-lib-coverage": "^2.0.0",
              "collect-v8-coverage": "^1.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/test-sequencer": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/test-sequencer/-/test-sequencer-29.7.0.tgz",
            "integrity": "sha512-GQwJ5WZVrKnOJuiYiAF52UNUJXgTZx1NHjFSEB0qEMmSZKAkdMoIzw/Cj6x6NF4AvV23AUqDpFzQkN/eYCYTxw==",
            "dev": true,
            "dependencies": {
              "@jest/test-result": "^29.7.0",
              "graceful-fs": "^4.2.9",
              "jest-haste-map": "^29.7.0",
              "slash": "^3.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/transform": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/@jest/transform/-/transform-29.7.0.tgz",
            "integrity": "sha512-ok/BTPFzFKVMwO5eOHRrvnBVHdRy9IrsrW1GpMaQ9MCnilNLXQKmAX8s1YXDFaai9xJpac2ySzV0YeRRECr2Vw==",
            "dev": true,
            "dependencies": {
              "@babel/core": "^7.11.6",
              "@jest/types": "^29.6.3",
              "@jridgewell/trace-mapping": "^0.3.18",
              "babel-plugin-istanbul": "^6.1.1",
              "chalk": "^4.0.0",
              "convert-source-map": "^2.0.0",
              "fast-json-stable-stringify": "^2.1.0",
              "graceful-fs": "^4.2.9",
              "jest-haste-map": "^29.7.0",
              "jest-regex-util": "^29.6.3",
              "jest-util": "^29.7.0",
              "micromatch": "^4.0.4",
              "pirates": "^4.0.4",
              "slash": "^3.0.0",
              "write-file-atomic": "^4.0.2"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jest/types": {
            "version": "29.6.3",
            "resolved": "https://registry.npmjs.org/@jest/types/-/types-29.6.3.tgz",
            "integrity": "sha512-u3UPsIilWKOM3F9CXtrG8LEJmNxwoCQC/XVj4IKYXvvpx7QIi/Kg1LI5uDmDpKlac62NUtX7eLjRh+jVZcLOzw==",
            "dev": true,
            "dependencies": {
              "@jest/schemas": "^29.6.3",
              "@types/istanbul-lib-coverage": "^2.0.0",
              "@types/istanbul-reports": "^3.0.0",
              "@types/node": "*",
              "@types/yargs": "^17.0.8",
              "chalk": "^4.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/@jridgewell/gen-mapping": {
            "version": "0.3.5",
            "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.5.tgz",
            "integrity": "sha512-IzL8ZoEDIBRWEzlCcRhOaCupYyN5gdIK+Q6fbFdPDg6HqX6jpkItn7DFIpW9LQzXG6Df9sA7+OKnq0qlz/GaQg==",
            "dev": true,
            "dependencies": {
              "@jridgewell/set-array": "^1.2.1",
              "@jridgewell/sourcemap-codec": "^1.4.10",
              "@jridgewell/trace-mapping": "^0.3.24"
            },
            "engines": {
              "node": "\u003E=6.0.0"
            }
          },
          "node_modules/@jridgewell/resolve-uri": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
            "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
            "dev": true,
            "engines": {
              "node": "\u003E=6.0.0"
            }
          },
          "node_modules/@jridgewell/set-array": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.2.1.tgz",
            "integrity": "sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==",
            "dev": true,
            "engines": {
              "node": "\u003E=6.0.0"
            }
          },
          "node_modules/@jridgewell/sourcemap-codec": {
            "version": "1.5.0",
            "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz",
            "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==",
            "dev": true
          },
          "node_modules/@jridgewell/trace-mapping": {
            "version": "0.3.25",
            "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.25.tgz",
            "integrity": "sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==",
            "dev": true,
            "dependencies": {
              "@jridgewell/resolve-uri": "^3.1.0",
              "@jridgewell/sourcemap-codec": "^1.4.14"
            }
          },
          "node_modules/@noble/hashes": {
            "version": "1.8.0",
            "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
            "integrity": "sha512-jCs9ldd7NwzpgXDIf6P3+NrHh9/sD6CQdxHyjQI+h/6rDNo88ypBxxz45UDuZHz9r3tNz7N/VInSVoVdtXEI4A==",
            "dev": true,
            "license": "MIT",
            "engines": {
              "node": "^14.21.3 || \u003E=16"
            },
            "funding": {
              "url": "https://paulmillr.com/funding/"
            }
          },
          "node_modules/@nodelib/fs.scandir": {
            "version": "2.1.5",
            "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
            "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
            "dev": true,
            "dependencies": {
              "@nodelib/fs.stat": "2.0.5",
              "run-parallel": "^1.1.9"
            },
            "engines": {
              "node": "\u003E= 8"
            }
          },
          "node_modules/@nodelib/fs.stat": {
            "version": "2.0.5",
            "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
            "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
            "dev": true,
            "engines": {
              "node": "\u003E= 8"
            }
          },
          "node_modules/@nodelib/fs.walk": {
            "version": "1.2.8",
            "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
            "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
            "dev": true,
            "dependencies": {
              "@nodelib/fs.scandir": "2.1.5",
              "fastq": "^1.6.0"
            },
            "engines": {
              "node": "\u003E= 8"
            }
          },
          "node_modules/@paralleldrive/cuid2": {
            "version": "2.2.2",
            "resolved": "https://registry.npmjs.org/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz",
            "integrity": "sha512-ZOBkgDwEdoYVlSeRbYYXs0S9MejQofiVYoTbKzy/6GQa39/q5tQU2IX46+shYnUkpEl3wc+J6wRlar7r2EK2xA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@noble/hashes": "^1.1.5"
            }
          },
          "node_modules/@sinclair/typebox": {
            "version": "0.27.8",
            "resolved": "https://registry.npmjs.org/@sinclair/typebox/-/typebox-0.27.8.tgz",
            "integrity": "sha512-+Fj43pSMwJs4KRrH/938Uf+uAELIgVBmQzg/q1YG10djyfA3TnrU8N8XzqCh/okZdszqBQTZf96idMfE5lnwTA==",
            "dev": true
          },
          "node_modules/@sinonjs/commons": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/@sinonjs/commons/-/commons-3.0.1.tgz",
            "integrity": "sha512-K3mCHKQ9sVh8o1C9cxkwxaOmXoAMlDxC1mYyHrjqOWEcBjYr76t96zL2zlj5dUGZ3HSw240X1qgH3Mjf1yJWpQ==",
            "dev": true,
            "dependencies": {
              "type-detect": "4.0.8"
            }
          },
          "node_modules/@sinonjs/fake-timers": {
            "version": "10.3.0",
            "resolved": "https://registry.npmjs.org/@sinonjs/fake-timers/-/fake-timers-10.3.0.tgz",
            "integrity": "sha512-V4BG07kuYSUkTCSBHG8G8TNhM+F19jXFWnQtzj+we8DrkpSBCee9Z3Ms8yiGer/dlmhe35/Xdgyo3/0rQKg7YA==",
            "dev": true,
            "dependencies": {
              "@sinonjs/commons": "^3.0.0"
            }
          },
          "node_modules/@types/babel__core": {
            "version": "7.20.5",
            "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
            "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
            "dev": true,
            "dependencies": {
              "@babel/parser": "^7.20.7",
              "@babel/types": "^7.20.7",
              "@types/babel__generator": "*",
              "@types/babel__template": "*",
              "@types/babel__traverse": "*"
            }
          },
          "node_modules/@types/babel__generator": {
            "version": "7.6.8",
            "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.6.8.tgz",
            "integrity": "sha512-ASsj+tpEDsEiFr1arWrlN6V3mdfjRMZt6LtK/Vp/kreFLnr5QH5+DhvD5nINYZXzwJvXeGq+05iUXcAzVrqWtw==",
            "dev": true,
            "dependencies": {
              "@babel/types": "^7.0.0"
            }
          },
          "node_modules/@types/babel__template": {
            "version": "7.4.4",
            "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
            "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
            "dev": true,
            "dependencies": {
              "@babel/parser": "^7.1.0",
              "@babel/types": "^7.0.0"
            }
          },
          "node_modules/@types/babel__traverse": {
            "version": "7.20.6",
            "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.20.6.tgz",
            "integrity": "sha512-r1bzfrm0tomOI8g1SzvCaQHo6Lcv6zu0EA+W2kHrt8dyrHQxGzBBL4kdkzIS+jBMV+EYcMAEAqXqYaLJq5rOZg==",
            "dev": true,
            "dependencies": {
              "@babel/types": "^7.20.7"
            }
          },
          "node_modules/@types/body-parser": {
            "version": "1.19.5",
            "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz",
            "integrity": "sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@types/connect": "*",
              "@types/node": "*"
            }
          },
          "node_modules/@types/connect": {
            "version": "3.4.38",
            "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
            "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
            "dev": true,
            "dependencies": {
              "@types/node": "*"
            }
          },
          "node_modules/@types/content-type": {
            "version": "1.1.8",
            "resolved": "https://registry.npmjs.org/@types/content-type/-/content-type-1.1.8.tgz",
            "integrity": "sha512-1tBhmVUeso3+ahfyaKluXe38p+94lovUZdoVfQ3OnJo9uJC42JT7CBoN3k9HYhAae+GwiBYmHu+N9FZhOG+2Pg==",
            "dev": true
          },
          "node_modules/@types/cookiejar": {
            "version": "2.1.5",
            "resolved": "https://registry.npmjs.org/@types/cookiejar/-/cookiejar-2.1.5.tgz",
            "integrity": "sha512-he+DHOWReW0nghN24E1WUqM0efK4kI9oTqDm6XmK8ZPe2djZ90BSNdGnIyCLzCPw7/pogPlGbzI2wHGGmi4O/Q==",
            "dev": true,
            "license": "MIT"
          },
          "node_modules/@types/cors": {
            "version": "2.8.17",
            "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.17.tgz",
            "integrity": "sha512-8CGDvrBj1zgo2qE+oS3pOCyYNqCPryMWY2bGfwA0dcfopWGgxs+78df0Rs3rc9THP4JkOhLsAa+15VdpAqkcUA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@types/node": "*"
            }
          },
          "node_modules/@types/cross-spawn": {
            "version": "6.0.6",
            "resolved": "https://registry.npmjs.org/@types/cross-spawn/-/cross-spawn-6.0.6.tgz",
            "integrity": "sha512-fXRhhUkG4H3TQk5dBhQ7m/JDdSNHKwR2BBia62lhwEIq9xGiQKLxd6LymNhn47SjXhsUEPmxi+PKw2OkW4LLjA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@types/node": "*"
            }
          },
          "node_modules/@types/eslint": {
            "version": "9.6.1",
            "resolved": "https://registry.npmjs.org/@types/eslint/-/eslint-9.6.1.tgz",
            "integrity": "sha512-FXx2pKgId/WyYo2jXw63kk7/+TY7u7AziEJxJAnSFzHlqTAS3Ync6SvgYAN/k4/PQpnnVuzoMuVnByKK2qp0ag==",
            "dev": true,
            "dependencies": {
              "@types/estree": "*",
              "@types/json-schema": "*"
            }
          },
          "node_modules/@types/eslint__js": {
            "version": "8.42.3",
            "resolved": "https://registry.npmjs.org/@types/eslint__js/-/eslint__js-8.42.3.tgz",
            "integrity": "sha512-alfG737uhmPdnvkrLdZLcEKJ/B8s9Y4hrZ+YAdzUeoArBlSUERA2E87ROfOaS4jd/C45fzOoZzidLc1IPwLqOw==",
            "dev": true,
            "dependencies": {
              "@types/eslint": "*"
            }
          },
          "node_modules/@types/estree": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.6.tgz",
            "integrity": "sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==",
            "dev": true
          },
          "node_modules/@types/eventsource": {
            "version": "1.1.15",
            "resolved": "https://registry.npmjs.org/@types/eventsource/-/eventsource-1.1.15.tgz",
            "integrity": "sha512-XQmGcbnxUNa06HR3VBVkc9+A2Vpi9ZyLJcdS5dwaQQ/4ZMWFO+5c90FnMUpbtMZwB/FChoYHwuVg8TvkECacTA==",
            "dev": true
          },
          "node_modules/@types/express": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/@types/express/-/express-5.0.0.tgz",
            "integrity": "sha512-DvZriSMehGHL1ZNLzi6MidnsDhUZM/x2pRdDIKdwbUNqqwHxMlRdkxtn6/EPKyqKpHqTl/4nRZsRNLpZxZRpPQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@types/body-parser": "*",
              "@types/express-serve-static-core": "^5.0.0",
              "@types/qs": "*",
              "@types/serve-static": "*"
            }
          },
          "node_modules/@types/express-serve-static-core": {
            "version": "5.0.6",
            "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-5.0.6.tgz",
            "integrity": "sha512-3xhRnjJPkULekpSzgtoNYYcTWgEZkp4myc+Saevii5JPnHNvHMRlBSHDbs7Bh1iPPoVTERHEZXyhyLbMEsExsA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@types/node": "*",
              "@types/qs": "*",
              "@types/range-parser": "*",
              "@types/send": "*"
            }
          },
          "node_modules/@types/graceful-fs": {
            "version": "4.1.9",
            "resolved": "https://registry.npmjs.org/@types/graceful-fs/-/graceful-fs-4.1.9.tgz",
            "integrity": "sha512-olP3sd1qOEe5dXTSaFvQG+02VdRXcdytWLAZsAq1PecU8uqQAhkrnbli7DagjtXKW/Bl7YJbUsa8MPcuc8LHEQ==",
            "dev": true,
            "dependencies": {
              "@types/node": "*"
            }
          },
          "node_modules/@types/http-errors": {
            "version": "2.0.4",
            "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz",
            "integrity": "sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==",
            "dev": true
          },
          "node_modules/@types/istanbul-lib-coverage": {
            "version": "2.0.6",
            "resolved": "https://registry.npmjs.org/@types/istanbul-lib-coverage/-/istanbul-lib-coverage-2.0.6.tgz",
            "integrity": "sha512-2QF/t/auWm0lsy8XtKVPG19v3sSOQlJe/YHZgfjb/KBBHOGSV+J2q/S671rcq9uTBrLAXmZpqJiaQbMT+zNU1w==",
            "dev": true
          },
          "node_modules/@types/istanbul-lib-report": {
            "version": "3.0.3",
            "resolved": "https://registry.npmjs.org/@types/istanbul-lib-report/-/istanbul-lib-report-3.0.3.tgz",
            "integrity": "sha512-NQn7AHQnk/RSLOxrBbGyJM/aVQ+pjj5HCgasFxc0K/KhoATfQ/47AyUl15I2yBUpihjmas+a+VJBOqecrFH+uA==",
            "dev": true,
            "dependencies": {
              "@types/istanbul-lib-coverage": "*"
            }
          },
          "node_modules/@types/istanbul-reports": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/@types/istanbul-reports/-/istanbul-reports-3.0.4.tgz",
            "integrity": "sha512-pk2B1NWalF9toCRu6gjBzR69syFjP4Od8WRAX+0mmf9lAjCRicLOWc+ZrxZHx/0XRjotgkF9t6iaMJ+aXcOdZQ==",
            "dev": true,
            "dependencies": {
              "@types/istanbul-lib-report": "*"
            }
          },
          "node_modules/@types/jest": {
            "version": "29.5.14",
            "resolved": "https://registry.npmjs.org/@types/jest/-/jest-29.5.14.tgz",
            "integrity": "sha512-ZN+4sdnLUbo8EVvVc2ao0GFW6oVrQRPn4K2lglySj7APvSrgzxHiNNK99us4WDMi57xxA2yggblIAMNhXOotLQ==",
            "dev": true,
            "dependencies": {
              "expect": "^29.0.0",
              "pretty-format": "^29.0.0"
            }
          },
          "node_modules/@types/json-schema": {
            "version": "7.0.15",
            "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
            "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
            "dev": true
          },
          "node_modules/@types/methods": {
            "version": "1.1.4",
            "resolved": "https://registry.npmjs.org/@types/methods/-/methods-1.1.4.tgz",
            "integrity": "sha512-ymXWVrDiCxTBE3+RIrrP533E70eA+9qu7zdWoHuOmGujkYtzf4HQF96b8nwHLqhuf4ykX61IGRIB38CC6/sImQ==",
            "dev": true,
            "license": "MIT"
          },
          "node_modules/@types/mime": {
            "version": "1.3.5",
            "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
            "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
            "dev": true
          },
          "node_modules/@types/node": {
            "version": "22.8.1",
            "resolved": "https://registry.npmjs.org/@types/node/-/node-22.8.1.tgz",
            "integrity": "sha512-k6Gi8Yyo8EtrNtkHXutUu2corfDf9su95VYVP10aGYMMROM6SAItZi0w1XszA6RtWTHSVp5OeFof37w0IEqCQg==",
            "dev": true,
            "dependencies": {
              "undici-types": "~6.19.8"
            }
          },
          "node_modules/@types/qs": {
            "version": "6.9.18",
            "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.18.tgz",
            "integrity": "sha512-kK7dgTYDyGqS+e2Q4aK9X3D7q234CIZ1Bv0q/7Z5IwRDoADNU81xXJK/YVyLbLTZCoIwUoDoffFeF+p/eIklAA==",
            "dev": true,
            "license": "MIT"
          },
          "node_modules/@types/range-parser": {
            "version": "1.2.7",
            "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
            "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
            "dev": true,
            "license": "MIT"
          },
          "node_modules/@types/send": {
            "version": "0.17.4",
            "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz",
            "integrity": "sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==",
            "dev": true,
            "dependencies": {
              "@types/mime": "^1",
              "@types/node": "*"
            }
          },
          "node_modules/@types/serve-static": {
            "version": "1.15.7",
            "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz",
            "integrity": "sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==",
            "dev": true,
            "dependencies": {
              "@types/http-errors": "*",
              "@types/node": "*",
              "@types/send": "*"
            }
          },
          "node_modules/@types/stack-utils": {
            "version": "2.0.3",
            "resolved": "https://registry.npmjs.org/@types/stack-utils/-/stack-utils-2.0.3.tgz",
            "integrity": "sha512-9aEbYZ3TbYMznPdcdr3SmIrLXwC/AKZXQeCf9Pgao5CKb8CyHuEX5jzWPTkvregvhRJHcpRO6BFoGW9ycaOkYw==",
            "dev": true
          },
          "node_modules/@types/superagent": {
            "version": "8.1.9",
            "resolved": "https://registry.npmjs.org/@types/superagent/-/superagent-8.1.9.tgz",
            "integrity": "sha512-pTVjI73witn+9ILmoJdajHGW2jkSaOzhiFYF1Rd3EQ94kymLqB9PjD9ISg7WaALC7+dCHT0FGe9T2LktLq/3GQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@types/cookiejar": "^2.1.5",
              "@types/methods": "^1.1.4",
              "@types/node": "*",
              "form-data": "^4.0.0"
            }
          },
          "node_modules/@types/supertest": {
            "version": "6.0.2",
            "resolved": "https://registry.npmjs.org/@types/supertest/-/supertest-6.0.2.tgz",
            "integrity": "sha512-137ypx2lk/wTQbW6An6safu9hXmajAifU/s7szAHLN/FeIm5w7yR0Wkl9fdJMRSHwOn4HLAI0DaB2TOORuhPDg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@types/methods": "^1.1.4",
              "@types/superagent": "^8.1.0"
            }
          },
          "node_modules/@types/ws": {
            "version": "8.5.12",
            "resolved": "https://registry.npmjs.org/@types/ws/-/ws-8.5.12.tgz",
            "integrity": "sha512-3tPRkv1EtkDpzlgyKyI8pGsGZAGPEaXeu0DOj5DI25Ja91bdAYddYHbADRYVrZMRbfW+1l5YwXVDKohDJNQxkQ==",
            "dev": true,
            "dependencies": {
              "@types/node": "*"
            }
          },
          "node_modules/@types/yargs": {
            "version": "17.0.33",
            "resolved": "https://registry.npmjs.org/@types/yargs/-/yargs-17.0.33.tgz",
            "integrity": "sha512-WpxBCKWPLr4xSsHgz511rFJAM+wS28w2zEO1QDNY5zM/S8ok70NNfztH0xwhqKyaK0OHCbN98LDAZuy1ctxDkA==",
            "dev": true,
            "dependencies": {
              "@types/yargs-parser": "*"
            }
          },
          "node_modules/@types/yargs-parser": {
            "version": "21.0.3",
            "resolved": "https://registry.npmjs.org/@types/yargs-parser/-/yargs-parser-21.0.3.tgz",
            "integrity": "sha512-I4q9QU9MQv4oEOz4tAHJtNz1cwuLxn2F3xcc2iV5WdqLPpUnj30aUuxt1mAxYTG+oe8CZMV/+6rU4S4gRDzqtQ==",
            "dev": true
          },
          "node_modules/@typescript-eslint/eslint-plugin": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-8.11.0.tgz",
            "integrity": "sha512-KhGn2LjW1PJT2A/GfDpiyOfS4a8xHQv2myUagTM5+zsormOmBlYsnQ6pobJ8XxJmh6hnHwa2Mbe3fPrDJoDhbA==",
            "dev": true,
            "dependencies": {
              "@eslint-community/regexpp": "^4.10.0",
              "@typescript-eslint/scope-manager": "8.11.0",
              "@typescript-eslint/type-utils": "8.11.0",
              "@typescript-eslint/utils": "8.11.0",
              "@typescript-eslint/visitor-keys": "8.11.0",
              "graphemer": "^1.4.0",
              "ignore": "^5.3.1",
              "natural-compare": "^1.4.0",
              "ts-api-utils": "^1.3.0"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependencies": {
              "@typescript-eslint/parser": "^8.0.0 || ^8.0.0-alpha.0",
              "eslint": "^8.57.0 || ^9.0.0"
            },
            "peerDependenciesMeta": {
              "typescript": {
                "optional": true
              }
            }
          },
          "node_modules/@typescript-eslint/parser": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.11.0.tgz",
            "integrity": "sha512-lmt73NeHdy1Q/2ul295Qy3uninSqi6wQI18XwSpm8w0ZbQXUpjCAWP1Vlv/obudoBiIjJVjlztjQ+d/Md98Yxg==",
            "dev": true,
            "dependencies": {
              "@typescript-eslint/scope-manager": "8.11.0",
              "@typescript-eslint/types": "8.11.0",
              "@typescript-eslint/typescript-estree": "8.11.0",
              "@typescript-eslint/visitor-keys": "8.11.0",
              "debug": "^4.3.4"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependencies": {
              "eslint": "^8.57.0 || ^9.0.0"
            },
            "peerDependenciesMeta": {
              "typescript": {
                "optional": true
              }
            }
          },
          "node_modules/@typescript-eslint/scope-manager": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.11.0.tgz",
            "integrity": "sha512-Uholz7tWhXmA4r6epo+vaeV7yjdKy5QFCERMjs1kMVsLRKIrSdM6o21W2He9ftp5PP6aWOVpD5zvrvuHZC0bMQ==",
            "dev": true,
            "dependencies": {
              "@typescript-eslint/types": "8.11.0",
              "@typescript-eslint/visitor-keys": "8.11.0"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            }
          },
          "node_modules/@typescript-eslint/type-utils": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-8.11.0.tgz",
            "integrity": "sha512-ItiMfJS6pQU0NIKAaybBKkuVzo6IdnAhPFZA/2Mba/uBjuPQPet/8+zh5GtLHwmuFRShZx+8lhIs7/QeDHflOg==",
            "dev": true,
            "dependencies": {
              "@typescript-eslint/typescript-estree": "8.11.0",
              "@typescript-eslint/utils": "8.11.0",
              "debug": "^4.3.4",
              "ts-api-utils": "^1.3.0"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependenciesMeta": {
              "typescript": {
                "optional": true
              }
            }
          },
          "node_modules/@typescript-eslint/types": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-8.11.0.tgz",
            "integrity": "sha512-tn6sNMHf6EBAYMvmPUaKaVeYvhUsrE6x+bXQTxjQRp360h1giATU0WvgeEys1spbvb5R+VpNOZ+XJmjD8wOUHw==",
            "dev": true,
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            }
          },
          "node_modules/@typescript-eslint/typescript-estree": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.11.0.tgz",
            "integrity": "sha512-yHC3s1z1RCHoCz5t06gf7jH24rr3vns08XXhfEqzYpd6Hll3z/3g23JRi0jM8A47UFKNc3u/y5KIMx8Ynbjohg==",
            "dev": true,
            "dependencies": {
              "@typescript-eslint/types": "8.11.0",
              "@typescript-eslint/visitor-keys": "8.11.0",
              "debug": "^4.3.4",
              "fast-glob": "^3.3.2",
              "is-glob": "^4.0.3",
              "minimatch": "^9.0.4",
              "semver": "^7.6.0",
              "ts-api-utils": "^1.3.0"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependenciesMeta": {
              "typescript": {
                "optional": true
              }
            }
          },
          "node_modules/@typescript-eslint/typescript-estree/node_modules/brace-expansion": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
            "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
            "dev": true,
            "dependencies": {
              "balanced-match": "^1.0.0"
            }
          },
          "node_modules/@typescript-eslint/typescript-estree/node_modules/minimatch": {
            "version": "9.0.5",
            "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
            "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
            "dev": true,
            "dependencies": {
              "brace-expansion": "^2.0.1"
            },
            "engines": {
              "node": "\u003E=16 || 14 \u003E=14.17"
            },
            "funding": {
              "url": "https://github.com/sponsors/isaacs"
            }
          },
          "node_modules/@typescript-eslint/typescript-estree/node_modules/semver": {
            "version": "7.6.3",
            "resolved": "https://registry.npmjs.org/semver/-/semver-7.6.3.tgz",
            "integrity": "sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==",
            "dev": true,
            "bin": {
              "semver": "bin/semver.js"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/@typescript-eslint/utils": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-8.11.0.tgz",
            "integrity": "sha512-CYiX6WZcbXNJV7UNB4PLDIBtSdRmRI/nb0FMyqHPTQD1rMjA0foPLaPUV39C/MxkTd/QKSeX+Gb34PPsDVC35g==",
            "dev": true,
            "dependencies": {
              "@eslint-community/eslint-utils": "^4.4.0",
              "@typescript-eslint/scope-manager": "8.11.0",
              "@typescript-eslint/types": "8.11.0",
              "@typescript-eslint/typescript-estree": "8.11.0"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependencies": {
              "eslint": "^8.57.0 || ^9.0.0"
            }
          },
          "node_modules/@typescript-eslint/visitor-keys": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.11.0.tgz",
            "integrity": "sha512-EaewX6lxSjRJnc+99+dqzTeoDZUfyrA52d2/HRrkI830kgovWsmIiTfmr0NZorzqic7ga+1bS60lRBUgR3n/Bw==",
            "dev": true,
            "dependencies": {
              "@typescript-eslint/types": "8.11.0",
              "eslint-visitor-keys": "^3.4.3"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            }
          },
          "node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys": {
            "version": "3.4.3",
            "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
            "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
            "dev": true,
            "engines": {
              "node": "^12.22.0 || ^14.17.0 || \u003E=16.0.0"
            },
            "funding": {
              "url": "https://opencollective.com/eslint"
            }
          },
          "node_modules/accepts": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz",
            "integrity": "sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==",
            "license": "MIT",
            "dependencies": {
              "mime-types": "^3.0.0",
              "negotiator": "^1.0.0"
            },
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/acorn": {
            "version": "8.14.0",
            "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.0.tgz",
            "integrity": "sha512-cl669nCJTZBsL97OF4kUQm5g5hC2uihk0NxY3WENAC0TYdILVkAyHymAntgxGkl7K+t0cXIrH5siy5S4XkFycA==",
            "dev": true,
            "bin": {
              "acorn": "bin/acorn"
            },
            "engines": {
              "node": "\u003E=0.4.0"
            }
          },
          "node_modules/acorn-jsx": {
            "version": "5.3.2",
            "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
            "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
            "dev": true,
            "peerDependencies": {
              "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
            }
          },
          "node_modules/ajv": {
            "version": "6.12.6",
            "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
            "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
            "license": "MIT",
            "dependencies": {
              "fast-deep-equal": "^3.1.1",
              "fast-json-stable-stringify": "^2.0.0",
              "json-schema-traverse": "^0.4.1",
              "uri-js": "^4.2.2"
            },
            "funding": {
              "type": "github",
              "url": "https://github.com/sponsors/epoberezkin"
            }
          },
          "node_modules/ansi-escapes": {
            "version": "4.3.2",
            "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz",
            "integrity": "sha512-gKXj5ALrKWQLsYG9jlTRmR/xKluxHV+Z9QEwNIgCfM1/uwPMCuzVVnh5mwTd+OuBZcwSIMbqssNWRm1lE51QaQ==",
            "dev": true,
            "dependencies": {
              "type-fest": "^0.21.3"
            },
            "engines": {
              "node": "\u003E=8"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/ansi-regex": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
            "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/ansi-styles": {
            "version": "4.3.0",
            "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
            "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
            "dev": true,
            "dependencies": {
              "color-convert": "^2.0.1"
            },
            "engines": {
              "node": "\u003E=8"
            },
            "funding": {
              "url": "https://github.com/chalk/ansi-styles?sponsor=1"
            }
          },
          "node_modules/anymatch": {
            "version": "3.1.3",
            "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
            "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
            "dev": true,
            "dependencies": {
              "normalize-path": "^3.0.0",
              "picomatch": "^2.0.4"
            },
            "engines": {
              "node": "\u003E= 8"
            }
          },
          "node_modules/argparse": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
            "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
            "dev": true
          },
          "node_modules/asap": {
            "version": "2.0.6",
            "resolved": "https://registry.npmjs.org/asap/-/asap-2.0.6.tgz",
            "integrity": "sha512-BSHWgDSAiKs50o2Re8ppvp3seVHXSRM44cdSsT9FfNEUUZLOGWVCsiWaRPWM1Znn+mqZ1OfVZ3z3DWEzSp7hRA==",
            "dev": true,
            "license": "MIT"
          },
          "node_modules/async": {
            "version": "3.2.6",
            "resolved": "https://registry.npmjs.org/async/-/async-3.2.6.tgz",
            "integrity": "sha512-htCUDlxyyCLMgaM3xXg0C0LW2xqfuQ6p05pCEIsXuyQ+a1koYKTuBMzRNwmybfLgvJDMd0r1LTn4+E0Ti6C2AA==",
            "dev": true
          },
          "node_modules/asynckit": {
            "version": "0.4.0",
            "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
            "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
            "dev": true,
            "license": "MIT"
          },
          "node_modules/babel-jest": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/babel-jest/-/babel-jest-29.7.0.tgz",
            "integrity": "sha512-BrvGY3xZSwEcCzKvKsCi2GgHqDqsYkOP4/by5xCgIwGXQxIEh+8ew3gmrE1y7XRR6LHZIj6yLYnUi/mm2KXKBg==",
            "dev": true,
            "dependencies": {
              "@jest/transform": "^29.7.0",
              "@types/babel__core": "^7.1.14",
              "babel-plugin-istanbul": "^6.1.1",
              "babel-preset-jest": "^29.6.3",
              "chalk": "^4.0.0",
              "graceful-fs": "^4.2.9",
              "slash": "^3.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.8.0"
            }
          },
          "node_modules/babel-plugin-istanbul": {
            "version": "6.1.1",
            "resolved": "https://registry.npmjs.org/babel-plugin-istanbul/-/babel-plugin-istanbul-6.1.1.tgz",
            "integrity": "sha512-Y1IQok9821cC9onCx5otgFfRm7Lm+I+wwxOx738M/WLPZ9Q42m4IG5W0FNX8WLL2gYMZo3JkuXIH2DOpWM+qwA==",
            "dev": true,
            "dependencies": {
              "@babel/helper-plugin-utils": "^7.0.0",
              "@istanbuljs/load-nyc-config": "^1.0.0",
              "@istanbuljs/schema": "^0.1.2",
              "istanbul-lib-instrument": "^5.0.4",
              "test-exclude": "^6.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/babel-plugin-istanbul/node_modules/istanbul-lib-instrument": {
            "version": "5.2.1",
            "resolved": "https://registry.npmjs.org/istanbul-lib-instrument/-/istanbul-lib-instrument-5.2.1.tgz",
            "integrity": "sha512-pzqtp31nLv/XFOzXGuvhCb8qhjmTVo5vjVk19XE4CRlSWz0KoeJ3bw9XsA7nOp9YBf4qHjwBxkDzKcME/J29Yg==",
            "dev": true,
            "dependencies": {
              "@babel/core": "^7.12.3",
              "@babel/parser": "^7.14.7",
              "@istanbuljs/schema": "^0.1.2",
              "istanbul-lib-coverage": "^3.2.0",
              "semver": "^6.3.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/babel-plugin-jest-hoist": {
            "version": "29.6.3",
            "resolved": "https://registry.npmjs.org/babel-plugin-jest-hoist/-/babel-plugin-jest-hoist-29.6.3.tgz",
            "integrity": "sha512-ESAc/RJvGTFEzRwOTT4+lNDk/GNHMkKbNzsvT0qKRfDyyYTskxB5rnU2njIDYVxXCBHHEI1c0YwHob3WaYujOg==",
            "dev": true,
            "dependencies": {
              "@babel/template": "^7.3.3",
              "@babel/types": "^7.3.3",
              "@types/babel__core": "^7.1.14",
              "@types/babel__traverse": "^7.0.6"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/babel-preset-current-node-syntax": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/babel-preset-current-node-syntax/-/babel-preset-current-node-syntax-1.1.0.tgz",
            "integrity": "sha512-ldYss8SbBlWva1bs28q78Ju5Zq1F+8BrqBZZ0VFhLBvhh6lCpC2o3gDJi/5DRLs9FgYZCnmPYIVFU4lRXCkyUw==",
            "dev": true,
            "dependencies": {
              "@babel/plugin-syntax-async-generators": "^7.8.4",
              "@babel/plugin-syntax-bigint": "^7.8.3",
              "@babel/plugin-syntax-class-properties": "^7.12.13",
              "@babel/plugin-syntax-class-static-block": "^7.14.5",
              "@babel/plugin-syntax-import-attributes": "^7.24.7",
              "@babel/plugin-syntax-import-meta": "^7.10.4",
              "@babel/plugin-syntax-json-strings": "^7.8.3",
              "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4",
              "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
              "@babel/plugin-syntax-numeric-separator": "^7.10.4",
              "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
              "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
              "@babel/plugin-syntax-optional-chaining": "^7.8.3",
              "@babel/plugin-syntax-private-property-in-object": "^7.14.5",
              "@babel/plugin-syntax-top-level-await": "^7.14.5"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0"
            }
          },
          "node_modules/babel-preset-jest": {
            "version": "29.6.3",
            "resolved": "https://registry.npmjs.org/babel-preset-jest/-/babel-preset-jest-29.6.3.tgz",
            "integrity": "sha512-0B3bhxR6snWXJZtR/RliHTDPRgn1sNHOR0yVtq/IiQFyuOVjFS+wuio/R4gSNkyYmKmJB4wGZv2NZanmKmTnNA==",
            "dev": true,
            "dependencies": {
              "babel-plugin-jest-hoist": "^29.6.3",
              "babel-preset-current-node-syntax": "^1.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            },
            "peerDependencies": {
              "@babel/core": "^7.0.0"
            }
          },
          "node_modules/balanced-match": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
            "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
            "dev": true
          },
          "node_modules/body-parser": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-2.1.0.tgz",
            "integrity": "sha512-/hPxh61E+ll0Ujp24Ilm64cykicul1ypfwjVttduAiEdtnJFvLePSrIPk+HMImtNv5270wOGCb1Tns2rybMkoQ==",
            "license": "MIT",
            "dependencies": {
              "bytes": "^3.1.2",
              "content-type": "^1.0.5",
              "debug": "^4.4.0",
              "http-errors": "^2.0.0",
              "iconv-lite": "^0.5.2",
              "on-finished": "^2.4.1",
              "qs": "^6.14.0",
              "raw-body": "^3.0.0",
              "type-is": "^2.0.0"
            },
            "engines": {
              "node": "\u003E=18"
            }
          },
          "node_modules/body-parser/node_modules/debug": {
            "version": "4.4.0",
            "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz",
            "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==",
            "license": "MIT",
            "dependencies": {
              "ms": "^2.1.3"
            },
            "engines": {
              "node": "\u003E=6.0"
            },
            "peerDependenciesMeta": {
              "supports-color": {
                "optional": true
              }
            }
          },
          "node_modules/body-parser/node_modules/qs": {
            "version": "6.14.0",
            "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
            "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
            "license": "BSD-3-Clause",
            "dependencies": {
              "side-channel": "^1.1.0"
            },
            "engines": {
              "node": "\u003E=0.6"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/brace-expansion": {
            "version": "1.1.11",
            "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
            "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
            "dev": true,
            "dependencies": {
              "balanced-match": "^1.0.0",
              "concat-map": "0.0.1"
            }
          },
          "node_modules/braces": {
            "version": "3.0.3",
            "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
            "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
            "dev": true,
            "dependencies": {
              "fill-range": "^7.1.1"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/browserslist": {
            "version": "4.24.2",
            "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.24.2.tgz",
            "integrity": "sha512-ZIc+Q62revdMcqC6aChtW4jz3My3klmCO1fEmINZY/8J3EpBg5/A/D0AKmBveUh6pgoeycoMkVMko84tuYS+Gg==",
            "dev": true,
            "funding": [
              {
                "type": "opencollective",
                "url": "https://opencollective.com/browserslist"
              },
              {
                "type": "tidelift",
                "url": "https://tidelift.com/funding/github/npm/browserslist"
              },
              {
                "type": "github",
                "url": "https://github.com/sponsors/ai"
              }
            ],
            "dependencies": {
              "caniuse-lite": "^1.0.30001669",
              "electron-to-chromium": "^1.5.41",
              "node-releases": "^2.0.18",
              "update-browserslist-db": "^1.1.1"
            },
            "bin": {
              "browserslist": "cli.js"
            },
            "engines": {
              "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || \u003E=13.7"
            }
          },
          "node_modules/bs-logger": {
            "version": "0.2.6",
            "resolved": "https://registry.npmjs.org/bs-logger/-/bs-logger-0.2.6.tgz",
            "integrity": "sha512-pd8DCoxmbgc7hyPKOvxtqNcjYoOsABPQdcCUjGp3d42VR2CX1ORhk2A87oqqu5R1kk+76nsxZupkmyd+MVtCog==",
            "dev": true,
            "dependencies": {
              "fast-json-stable-stringify": "2.x"
            },
            "engines": {
              "node": "\u003E= 6"
            }
          },
          "node_modules/bser": {
            "version": "2.1.1",
            "resolved": "https://registry.npmjs.org/bser/-/bser-2.1.1.tgz",
            "integrity": "sha512-gQxTNE/GAfIIrmHLUE3oJyp5FO6HRBfhjnw4/wMmA63ZGDJnWBmgY/lyQBpnDUkGmAhbSe39tx2d/iTOAfglwQ==",
            "dev": true,
            "dependencies": {
              "node-int64": "^0.4.0"
            }
          },
          "node_modules/buffer-from": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
            "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
            "dev": true
          },
          "node_modules/bytes": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
            "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/call-bind-apply-helpers": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
            "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
            "license": "MIT",
            "dependencies": {
              "es-errors": "^1.3.0",
              "function-bind": "^1.1.2"
            },
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/call-bound": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.3.tgz",
            "integrity": "sha512-YTd+6wGlNlPxSuri7Y6X8tY2dmm12UMH66RpKMhiX6rsk5wXXnYgbUcOt8kiS31/AjfoTOvCsE+w8nZQLQnzHA==",
            "license": "MIT",
            "dependencies": {
              "call-bind-apply-helpers": "^1.0.1",
              "get-intrinsic": "^1.2.6"
            },
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/callsites": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
            "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/camelcase": {
            "version": "5.3.1",
            "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz",
            "integrity": "sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/caniuse-lite": {
            "version": "1.0.30001673",
            "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001673.tgz",
            "integrity": "sha512-WTrjUCSMp3LYX0nE12ECkV0a+e6LC85E0Auz75555/qr78Oc8YWhEPNfDd6SHdtlCMSzqtuXY0uyEMNRcsKpKw==",
            "dev": true,
            "funding": [
              {
                "type": "opencollective",
                "url": "https://opencollective.com/browserslist"
              },
              {
                "type": "tidelift",
                "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
              },
              {
                "type": "github",
                "url": "https://github.com/sponsors/ai"
              }
            ]
          },
          "node_modules/chalk": {
            "version": "4.1.2",
            "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
            "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
            "dev": true,
            "dependencies": {
              "ansi-styles": "^4.1.0",
              "supports-color": "^7.1.0"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/chalk/chalk?sponsor=1"
            }
          },
          "node_modules/char-regex": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/char-regex/-/char-regex-1.0.2.tgz",
            "integrity": "sha512-kWWXztvZ5SBQV+eRgKFeh8q5sLuZY2+8WUIzlxWVTg+oGwY14qylx1KbKzHd8P6ZYkAg0xyIDU9JMHhyJMZ1jw==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/ci-info": {
            "version": "3.9.0",
            "resolved": "https://registry.npmjs.org/ci-info/-/ci-info-3.9.0.tgz",
            "integrity": "sha512-NIxF55hv4nSqQswkAeiOi1r83xy8JldOFDTWiug55KBu9Jnblncd2U6ViHmYgHf01TPZS77NJBhBMKdWj9HQMQ==",
            "dev": true,
            "funding": [
              {
                "type": "github",
                "url": "https://github.com/sponsors/sibiraj-s"
              }
            ],
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/cjs-module-lexer": {
            "version": "1.4.1",
            "resolved": "https://registry.npmjs.org/cjs-module-lexer/-/cjs-module-lexer-1.4.1.tgz",
            "integrity": "sha512-cuSVIHi9/9E/+821Qjdvngor+xpnlwnuwIyZOaLmHBVdXL+gP+I6QQB9VkO7RI77YIcTV+S1W9AreJ5eN63JBA==",
            "dev": true
          },
          "node_modules/cliui": {
            "version": "8.0.1",
            "resolved": "https://registry.npmjs.org/cliui/-/cliui-8.0.1.tgz",
            "integrity": "sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==",
            "dev": true,
            "dependencies": {
              "string-width": "^4.2.0",
              "strip-ansi": "^6.0.1",
              "wrap-ansi": "^7.0.0"
            },
            "engines": {
              "node": "\u003E=12"
            }
          },
          "node_modules/co": {
            "version": "4.6.0",
            "resolved": "https://registry.npmjs.org/co/-/co-4.6.0.tgz",
            "integrity": "sha512-QVb0dM5HvG+uaxitm8wONl7jltx8dqhfU33DcqtOZcLSVIKSDDLDi7+0LbAKiyI8hD9u42m2YxXSkMGWThaecQ==",
            "dev": true,
            "engines": {
              "iojs": "\u003E= 1.0.0",
              "node": "\u003E= 0.12.0"
            }
          },
          "node_modules/collect-v8-coverage": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/collect-v8-coverage/-/collect-v8-coverage-1.0.2.tgz",
            "integrity": "sha512-lHl4d5/ONEbLlJvaJNtsF/Lz+WvB07u2ycqTYbdrq7UypDXailES4valYb2eWiJFxZlVmpGekfqoxQhzyFdT4Q==",
            "dev": true
          },
          "node_modules/color-convert": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
            "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
            "dev": true,
            "dependencies": {
              "color-name": "~1.1.4"
            },
            "engines": {
              "node": "\u003E=7.0.0"
            }
          },
          "node_modules/color-name": {
            "version": "1.1.4",
            "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
            "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
            "dev": true
          },
          "node_modules/combined-stream": {
            "version": "1.0.8",
            "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
            "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "delayed-stream": "~1.0.0"
            },
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/component-emitter": {
            "version": "1.3.1",
            "resolved": "https://registry.npmjs.org/component-emitter/-/component-emitter-1.3.1.tgz",
            "integrity": "sha512-T0+barUSQRTUQASh8bx02dl+DhF54GtIDY13Y3m9oWTklKbb3Wv974meRpeZ3lp1JpLVECWWNHC4vaG2XHXouQ==",
            "dev": true,
            "license": "MIT",
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/concat-map": {
            "version": "0.0.1",
            "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
            "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
            "dev": true
          },
          "node_modules/content-disposition": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.0.tgz",
            "integrity": "sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==",
            "license": "MIT",
            "dependencies": {
              "safe-buffer": "5.2.1"
            },
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/content-type": {
            "version": "1.0.5",
            "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
            "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/convert-source-map": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
            "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
            "dev": true
          },
          "node_modules/cookie": {
            "version": "0.7.1",
            "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
            "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/cookie-signature": {
            "version": "1.2.2",
            "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
            "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E=6.6.0"
            }
          },
          "node_modules/cookiejar": {
            "version": "2.1.4",
            "resolved": "https://registry.npmjs.org/cookiejar/-/cookiejar-2.1.4.tgz",
            "integrity": "sha512-LDx6oHrK+PhzLKJU9j5S7/Y3jM/mUHvD/DeI1WQmJn652iPC5Y4TBzC9l+5OMOXlyTTA+SmVUPm0HQUwpD5Jqw==",
            "dev": true,
            "license": "MIT"
          },
          "node_modules/cors": {
            "version": "2.8.5",
            "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
            "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
            "license": "MIT",
            "dependencies": {
              "object-assign": "^4",
              "vary": "^1"
            },
            "engines": {
              "node": "\u003E= 0.10"
            }
          },
          "node_modules/create-jest": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/create-jest/-/create-jest-29.7.0.tgz",
            "integrity": "sha512-Adz2bdH0Vq3F53KEMJOoftQFutWCukm6J24wbPWRO4k1kMY7gS7ds/uoJkNuV8wDCtWWnuwGcJwpWcih+zEW1Q==",
            "dev": true,
            "dependencies": {
              "@jest/types": "^29.6.3",
              "chalk": "^4.0.0",
              "exit": "^0.1.2",
              "graceful-fs": "^4.2.9",
              "jest-config": "^29.7.0",
              "jest-util": "^29.7.0",
              "prompts": "^2.0.1"
            },
            "bin": {
              "create-jest": "bin/create-jest.js"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/cross-spawn": {
            "version": "7.0.5",
            "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.5.tgz",
            "integrity": "sha512-ZVJrKKYunU38/76t0RMOulHOnUcbU9GbpWKAOZ0mhjr7CX6FVrH+4FrAapSOekrgFQ3f/8gwMEuIft0aKq6Hug==",
            "dependencies": {
              "path-key": "^3.1.0",
              "shebang-command": "^2.0.0",
              "which": "^2.0.1"
            },
            "engines": {
              "node": "\u003E= 8"
            }
          },
          "node_modules/debug": {
            "version": "4.3.7",
            "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.7.tgz",
            "integrity": "sha512-Er2nc/H7RrMXZBFCEim6TCmMk02Z8vLC2Rbi1KEBggpo0fS6l0S1nnapwmIi3yW/+GOJap1Krg4w0Hg80oCqgQ==",
            "dependencies": {
              "ms": "^2.1.3"
            },
            "engines": {
              "node": "\u003E=6.0"
            },
            "peerDependenciesMeta": {
              "supports-color": {
                "optional": true
              }
            }
          },
          "node_modules/dedent": {
            "version": "1.5.3",
            "resolved": "https://registry.npmjs.org/dedent/-/dedent-1.5.3.tgz",
            "integrity": "sha512-NHQtfOOW68WD8lgypbLA5oT+Bt0xXJhiYvoR6SmmNXZfpzOGXwdKWmcwG8N7PwVVWV3eF/68nmD9BaJSsTBhyQ==",
            "dev": true,
            "peerDependencies": {
              "babel-plugin-macros": "^3.1.0"
            },
            "peerDependenciesMeta": {
              "babel-plugin-macros": {
                "optional": true
              }
            }
          },
          "node_modules/deep-is": {
            "version": "0.1.4",
            "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
            "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
            "dev": true
          },
          "node_modules/deepmerge": {
            "version": "4.3.1",
            "resolved": "https://registry.npmjs.org/deepmerge/-/deepmerge-4.3.1.tgz",
            "integrity": "sha512-3sUqbMEc77XqpdNO7FRyRog+eW3ph+GYCbj+rK+uYyRMuwsVy0rMiVtPn+QJlKFvWP/1PYpapqYn0Me2knFn+A==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/delayed-stream": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
            "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
              "node": "\u003E=0.4.0"
            }
          },
          "node_modules/depd": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
            "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/destroy": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
            "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.8",
              "npm": "1.2.8000 || \u003E= 1.4.16"
            }
          },
          "node_modules/detect-newline": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/detect-newline/-/detect-newline-3.1.0.tgz",
            "integrity": "sha512-TLz+x/vEXm/Y7P7wn1EJFNLxYpUD4TgMosxY6fAVJUnJMbupHBOncxyWUG9OpTaH9EBD7uFI5LfEgmMOc54DsA==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/dezalgo": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/dezalgo/-/dezalgo-1.0.4.tgz",
            "integrity": "sha512-rXSP0bf+5n0Qonsb+SVVfNfIsimO4HEtmnIpPHY8Q1UCzKlQrDMfdobr8nJOOsRgWCyMRqeSBQzmWUMq7zvVig==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
              "asap": "^2.0.0",
              "wrappy": "1"
            }
          },
          "node_modules/diff-sequences": {
            "version": "29.6.3",
            "resolved": "https://registry.npmjs.org/diff-sequences/-/diff-sequences-29.6.3.tgz",
            "integrity": "sha512-EjePK1srD3P08o2j4f0ExnylqRs5B9tJjcp9t1krH2qRi8CCdsYfwe9JgSLurFBWwq4uOlipzfk5fHNvwFKr8Q==",
            "dev": true,
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/dunder-proto": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
            "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
            "license": "MIT",
            "dependencies": {
              "call-bind-apply-helpers": "^1.0.1",
              "es-errors": "^1.3.0",
              "gopd": "^1.2.0"
            },
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/ee-first": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
            "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
            "license": "MIT"
          },
          "node_modules/ejs": {
            "version": "3.1.10",
            "resolved": "https://registry.npmjs.org/ejs/-/ejs-3.1.10.tgz",
            "integrity": "sha512-UeJmFfOrAQS8OJWPZ4qtgHyWExa088/MtK5UEyoJGFH67cDEXkZSviOiKRCZ4Xij0zxI3JECgYs3oKx+AizQBA==",
            "dev": true,
            "dependencies": {
              "jake": "^10.8.5"
            },
            "bin": {
              "ejs": "bin/cli.js"
            },
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/electron-to-chromium": {
            "version": "1.5.47",
            "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.47.tgz",
            "integrity": "sha512-zS5Yer0MOYw4rtK2iq43cJagHZ8sXN0jDHDKzB+86gSBSAI4v07S97mcq+Gs2vclAxSh1j7vOAHxSVgduiiuVQ==",
            "dev": true
          },
          "node_modules/emittery": {
            "version": "0.13.1",
            "resolved": "https://registry.npmjs.org/emittery/-/emittery-0.13.1.tgz",
            "integrity": "sha512-DeWwawk6r5yR9jFgnDKYt4sLS0LmHJJi3ZOnb5/JdbYwj3nW+FxQnHIjhBKz8YLC7oRNPVM9NQ47I3CVx34eqQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=12"
            },
            "funding": {
              "url": "https://github.com/sindresorhus/emittery?sponsor=1"
            }
          },
          "node_modules/emoji-regex": {
            "version": "8.0.0",
            "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
            "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
            "dev": true
          },
          "node_modules/encodeurl": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
            "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/error-ex": {
            "version": "1.3.2",
            "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz",
            "integrity": "sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==",
            "dev": true,
            "dependencies": {
              "is-arrayish": "^0.2.1"
            }
          },
          "node_modules/es-define-property": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
            "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/es-errors": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
            "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/es-object-atoms": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
            "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
            "license": "MIT",
            "dependencies": {
              "es-errors": "^1.3.0"
            },
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/es-set-tostringtag": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
            "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "es-errors": "^1.3.0",
              "get-intrinsic": "^1.2.6",
              "has-tostringtag": "^1.0.2",
              "hasown": "^2.0.2"
            },
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/esbuild": {
            "version": "0.25.0",
            "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.0.tgz",
            "integrity": "sha512-BXq5mqc8ltbaN34cDqWuYKyNhX8D/Z0J1xdtdQ8UcIIIyJyz+ZMKUt58tF3SrZ85jcfN/PZYhjR5uDQAYNVbuw==",
            "dev": true,
            "hasInstallScript": true,
            "license": "MIT",
            "bin": {
              "esbuild": "bin/esbuild"
            },
            "engines": {
              "node": "\u003E=18"
            },
            "optionalDependencies": {
              "@esbuild/aix-ppc64": "0.25.0",
              "@esbuild/android-arm": "0.25.0",
              "@esbuild/android-arm64": "0.25.0",
              "@esbuild/android-x64": "0.25.0",
              "@esbuild/darwin-arm64": "0.25.0",
              "@esbuild/darwin-x64": "0.25.0",
              "@esbuild/freebsd-arm64": "0.25.0",
              "@esbuild/freebsd-x64": "0.25.0",
              "@esbuild/linux-arm": "0.25.0",
              "@esbuild/linux-arm64": "0.25.0",
              "@esbuild/linux-ia32": "0.25.0",
              "@esbuild/linux-loong64": "0.25.0",
              "@esbuild/linux-mips64el": "0.25.0",
              "@esbuild/linux-ppc64": "0.25.0",
              "@esbuild/linux-riscv64": "0.25.0",
              "@esbuild/linux-s390x": "0.25.0",
              "@esbuild/linux-x64": "0.25.0",
              "@esbuild/netbsd-arm64": "0.25.0",
              "@esbuild/netbsd-x64": "0.25.0",
              "@esbuild/openbsd-arm64": "0.25.0",
              "@esbuild/openbsd-x64": "0.25.0",
              "@esbuild/sunos-x64": "0.25.0",
              "@esbuild/win32-arm64": "0.25.0",
              "@esbuild/win32-ia32": "0.25.0",
              "@esbuild/win32-x64": "0.25.0"
            }
          },
          "node_modules/escalade": {
            "version": "3.2.0",
            "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
            "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/escape-html": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
            "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
            "license": "MIT"
          },
          "node_modules/escape-string-regexp": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
            "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/eslint": {
            "version": "9.13.0",
            "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.13.0.tgz",
            "integrity": "sha512-EYZK6SX6zjFHST/HRytOdA/zE72Cq/bfw45LSyuwrdvcclb/gqV8RRQxywOBEWO2+WDpva6UZa4CcDeJKzUCFA==",
            "dev": true,
            "dependencies": {
              "@eslint-community/eslint-utils": "^4.2.0",
              "@eslint-community/regexpp": "^4.11.0",
              "@eslint/config-array": "^0.18.0",
              "@eslint/core": "^0.7.0",
              "@eslint/eslintrc": "^3.1.0",
              "@eslint/js": "9.13.0",
              "@eslint/plugin-kit": "^0.2.0",
              "@humanfs/node": "^0.16.5",
              "@humanwhocodes/module-importer": "^1.0.1",
              "@humanwhocodes/retry": "^0.3.1",
              "@types/estree": "^1.0.6",
              "@types/json-schema": "^7.0.15",
              "ajv": "^6.12.4",
              "chalk": "^4.0.0",
              "cross-spawn": "^7.0.2",
              "debug": "^4.3.2",
              "escape-string-regexp": "^4.0.0",
              "eslint-scope": "^8.1.0",
              "eslint-visitor-keys": "^4.1.0",
              "espree": "^10.2.0",
              "esquery": "^1.5.0",
              "esutils": "^2.0.2",
              "fast-deep-equal": "^3.1.3",
              "file-entry-cache": "^8.0.0",
              "find-up": "^5.0.0",
              "glob-parent": "^6.0.2",
              "ignore": "^5.2.0",
              "imurmurhash": "^0.1.4",
              "is-glob": "^4.0.0",
              "json-stable-stringify-without-jsonify": "^1.0.1",
              "lodash.merge": "^4.6.2",
              "minimatch": "^3.1.2",
              "natural-compare": "^1.4.0",
              "optionator": "^0.9.3",
              "text-table": "^0.2.0"
            },
            "bin": {
              "eslint": "bin/eslint.js"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "url": "https://eslint.org/donate"
            },
            "peerDependencies": {
              "jiti": "*"
            },
            "peerDependenciesMeta": {
              "jiti": {
                "optional": true
              }
            }
          },
          "node_modules/eslint-scope": {
            "version": "8.1.0",
            "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.1.0.tgz",
            "integrity": "sha512-14dSvlhaVhKKsa9Fx1l8A17s7ah7Ef7wCakJ10LYk6+GYmP9yDti2oq2SEwcyndt6knfcZyhyxwY3i9yL78EQw==",
            "dev": true,
            "dependencies": {
              "esrecurse": "^4.3.0",
              "estraverse": "^5.2.0"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "url": "https://opencollective.com/eslint"
            }
          },
          "node_modules/eslint-visitor-keys": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.1.0.tgz",
            "integrity": "sha512-Q7lok0mqMUSf5a/AdAZkA5a/gHcO6snwQClVNNvFKCAVlxXucdU8pKydU5ZVZjBx5xr37vGbFFWtLQYreLzrZg==",
            "dev": true,
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "url": "https://opencollective.com/eslint"
            }
          },
          "node_modules/espree": {
            "version": "10.2.0",
            "resolved": "https://registry.npmjs.org/espree/-/espree-10.2.0.tgz",
            "integrity": "sha512-upbkBJbckcCNBDBDXEbuhjbP68n+scUd3k/U2EkyM9nw+I/jPiL4cLF/Al06CF96wRltFda16sxDFrxsI1v0/g==",
            "dev": true,
            "dependencies": {
              "acorn": "^8.12.0",
              "acorn-jsx": "^5.3.2",
              "eslint-visitor-keys": "^4.1.0"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "url": "https://opencollective.com/eslint"
            }
          },
          "node_modules/esprima": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
            "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
            "dev": true,
            "bin": {
              "esparse": "bin/esparse.js",
              "esvalidate": "bin/esvalidate.js"
            },
            "engines": {
              "node": "\u003E=4"
            }
          },
          "node_modules/esquery": {
            "version": "1.6.0",
            "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz",
            "integrity": "sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==",
            "dev": true,
            "dependencies": {
              "estraverse": "^5.1.0"
            },
            "engines": {
              "node": "\u003E=0.10"
            }
          },
          "node_modules/esrecurse": {
            "version": "4.3.0",
            "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
            "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
            "dev": true,
            "dependencies": {
              "estraverse": "^5.2.0"
            },
            "engines": {
              "node": "\u003E=4.0"
            }
          },
          "node_modules/estraverse": {
            "version": "5.3.0",
            "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
            "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
            "dev": true,
            "engines": {
              "node": "\u003E=4.0"
            }
          },
          "node_modules/esutils": {
            "version": "2.0.3",
            "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
            "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/etag": {
            "version": "1.8.1",
            "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
            "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/eventsource": {
            "version": "3.0.2",
            "resolved": "https://registry.npmjs.org/eventsource/-/eventsource-3.0.2.tgz",
            "integrity": "sha512-YolzkJNxsTL3tCJMWFxpxtG2sCjbZ4LQUBUrkdaJK0ub0p6lmJt+2+1SwhKjLc652lpH9L/79Ptez972H9tphw==",
            "license": "MIT",
            "dependencies": {
              "eventsource-parser": "^3.0.0"
            },
            "engines": {
              "node": "\u003E=18.0.0"
            }
          },
          "node_modules/eventsource-parser": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-3.0.0.tgz",
            "integrity": "sha512-T1C0XCUimhxVQzW4zFipdx0SficT651NnkR0ZSH3yQwh+mFMdLfgjABVi4YtMTtaL4s168593DaoaRLMqryavA==",
            "license": "MIT",
            "engines": {
              "node": "\u003E=18.0.0"
            }
          },
          "node_modules/execa": {
            "version": "5.1.1",
            "resolved": "https://registry.npmjs.org/execa/-/execa-5.1.1.tgz",
            "integrity": "sha512-8uSpZZocAZRBAPIEINJj3Lo9HyGitllczc27Eh5YYojjMFMn8yHMDMaUHE2Jqfq05D/wucwI4JGURyXt1vchyg==",
            "dev": true,
            "dependencies": {
              "cross-spawn": "^7.0.3",
              "get-stream": "^6.0.0",
              "human-signals": "^2.1.0",
              "is-stream": "^2.0.0",
              "merge-stream": "^2.0.0",
              "npm-run-path": "^4.0.1",
              "onetime": "^5.1.2",
              "signal-exit": "^3.0.3",
              "strip-final-newline": "^2.0.0"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sindresorhus/execa?sponsor=1"
            }
          },
          "node_modules/exit": {
            "version": "0.1.2",
            "resolved": "https://registry.npmjs.org/exit/-/exit-0.1.2.tgz",
            "integrity": "sha512-Zk/eNKV2zbjpKzrsQ+n1G6poVbErQxJ0LBOJXaKZ1EViLzH+hrLu9cdXI4zw9dBQJslwBEpbQ2P1oS7nDxs6jQ==",
            "dev": true,
            "engines": {
              "node": "\u003E= 0.8.0"
            }
          },
          "node_modules/expect": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/expect/-/expect-29.7.0.tgz",
            "integrity": "sha512-2Zks0hf1VLFYI1kbh0I5jP3KHHyCHpkfyHBzsSXRFgl/Bg9mWYfMW8oD+PdMPlEwy5HNsR9JutYy6pMeOh61nw==",
            "dev": true,
            "dependencies": {
              "@jest/expect-utils": "^29.7.0",
              "jest-get-type": "^29.6.3",
              "jest-matcher-utils": "^29.7.0",
              "jest-message-util": "^29.7.0",
              "jest-util": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/express": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/express/-/express-5.0.1.tgz",
            "integrity": "sha512-ORF7g6qGnD+YtUG9yx4DFoqCShNMmUKiXuT5oWMHiOvt/4WFbHC6yCwQMTSBMno7AqntNCAzzcnnjowRkTL9eQ==",
            "license": "MIT",
            "dependencies": {
              "accepts": "^2.0.0",
              "body-parser": "^2.0.1",
              "content-disposition": "^1.0.0",
              "content-type": "~1.0.4",
              "cookie": "0.7.1",
              "cookie-signature": "^1.2.1",
              "debug": "4.3.6",
              "depd": "2.0.0",
              "encodeurl": "~2.0.0",
              "escape-html": "~1.0.3",
              "etag": "~1.8.1",
              "finalhandler": "^2.0.0",
              "fresh": "2.0.0",
              "http-errors": "2.0.0",
              "merge-descriptors": "^2.0.0",
              "methods": "~1.1.2",
              "mime-types": "^3.0.0",
              "on-finished": "2.4.1",
              "once": "1.4.0",
              "parseurl": "~1.3.3",
              "proxy-addr": "~2.0.7",
              "qs": "6.13.0",
              "range-parser": "~1.2.1",
              "router": "^2.0.0",
              "safe-buffer": "5.2.1",
              "send": "^1.1.0",
              "serve-static": "^2.1.0",
              "setprototypeof": "1.2.0",
              "statuses": "2.0.1",
              "type-is": "^2.0.0",
              "utils-merge": "1.0.1",
              "vary": "~1.1.2"
            },
            "engines": {
              "node": "\u003E= 18"
            }
          },
          "node_modules/express-rate-limit": {
            "version": "7.5.0",
            "resolved": "https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-7.5.0.tgz",
            "integrity": "sha512-eB5zbQh5h+VenMPM3fh+nw1YExi5nMr6HUCR62ELSP11huvxm/Uir1H1QEyTkk5QX6A58pX6NmaTMceKZ0Eodg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 16"
            },
            "funding": {
              "url": "https://github.com/sponsors/express-rate-limit"
            },
            "peerDependencies": {
              "express": "^4.11 || 5 || ^5.0.0-beta.1"
            }
          },
          "node_modules/express/node_modules/debug": {
            "version": "4.3.6",
            "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.6.tgz",
            "integrity": "sha512-O/09Bd4Z1fBrU4VzkhFqVgpPzaGbw6Sm9FEkBT1A/YBXQFGuuSxa1dN2nxgxS34JmKXqYx8CZAwEVoJFImUXIg==",
            "license": "MIT",
            "dependencies": {
              "ms": "2.1.2"
            },
            "engines": {
              "node": "\u003E=6.0"
            },
            "peerDependenciesMeta": {
              "supports-color": {
                "optional": true
              }
            }
          },
          "node_modules/express/node_modules/ms": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
            "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
            "license": "MIT"
          },
          "node_modules/fast-deep-equal": {
            "version": "3.1.3",
            "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
            "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q=="
          },
          "node_modules/fast-glob": {
            "version": "3.3.2",
            "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.2.tgz",
            "integrity": "sha512-oX2ruAFQwf/Orj8m737Y5adxDQO0LAB7/S5MnxCdTNDd4p6BsyIVsv9JQsATbTSq8KHRpLwIHbVlUNatxd+1Ow==",
            "dev": true,
            "dependencies": {
              "@nodelib/fs.stat": "^2.0.2",
              "@nodelib/fs.walk": "^1.2.3",
              "glob-parent": "^5.1.2",
              "merge2": "^1.3.0",
              "micromatch": "^4.0.4"
            },
            "engines": {
              "node": "\u003E=8.6.0"
            }
          },
          "node_modules/fast-glob/node_modules/glob-parent": {
            "version": "5.1.2",
            "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
            "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
            "dev": true,
            "dependencies": {
              "is-glob": "^4.0.1"
            },
            "engines": {
              "node": "\u003E= 6"
            }
          },
          "node_modules/fast-json-stable-stringify": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
            "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw=="
          },
          "node_modules/fast-levenshtein": {
            "version": "2.0.6",
            "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
            "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
            "dev": true
          },
          "node_modules/fast-safe-stringify": {
            "version": "2.1.1",
            "resolved": "https://registry.npmjs.org/fast-safe-stringify/-/fast-safe-stringify-2.1.1.tgz",
            "integrity": "sha512-W+KJc2dmILlPplD/H4K9l9LcAHAfPtP6BY84uVLXQ6Evcz9Lcg33Y2z1IVblT6xdY54PXYVHEv+0Wpq8Io6zkA==",
            "dev": true,
            "license": "MIT"
          },
          "node_modules/fastq": {
            "version": "1.17.1",
            "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.17.1.tgz",
            "integrity": "sha512-sRVD3lWVIXWg6By68ZN7vho9a1pQcN/WBFaAAsDDFzlJjvoGx0P8z7V1t72grFJfJhu3YPZBuu25f7Kaw2jN1w==",
            "dev": true,
            "dependencies": {
              "reusify": "^1.0.4"
            }
          },
          "node_modules/fb-watchman": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/fb-watchman/-/fb-watchman-2.0.2.tgz",
            "integrity": "sha512-p5161BqbuCaSnB8jIbzQHOlpgsPmK5rJVDfDKO91Axs5NC1uu3HRQm6wt9cd9/+GtQQIO53JdGXXoyDpTAsgYA==",
            "dev": true,
            "dependencies": {
              "bser": "2.1.1"
            }
          },
          "node_modules/file-entry-cache": {
            "version": "8.0.0",
            "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
            "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
            "dev": true,
            "dependencies": {
              "flat-cache": "^4.0.0"
            },
            "engines": {
              "node": "\u003E=16.0.0"
            }
          },
          "node_modules/filelist": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/filelist/-/filelist-1.0.4.tgz",
            "integrity": "sha512-w1cEuf3S+DrLCQL7ET6kz+gmlJdbq9J7yXCSjK/OZCPA+qEN1WyF4ZAf0YYJa4/shHJra2t/d/r8SV4Ji+x+8Q==",
            "dev": true,
            "dependencies": {
              "minimatch": "^5.0.1"
            }
          },
          "node_modules/filelist/node_modules/brace-expansion": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
            "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
            "dev": true,
            "dependencies": {
              "balanced-match": "^1.0.0"
            }
          },
          "node_modules/filelist/node_modules/minimatch": {
            "version": "5.1.6",
            "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-5.1.6.tgz",
            "integrity": "sha512-lKwV/1brpG6mBUFHtb7NUmtABCb2WZZmm2wNiOA5hAb8VdCS4B3dtMWyvcoViccwAW/COERjXLt0zP1zXUN26g==",
            "dev": true,
            "dependencies": {
              "brace-expansion": "^2.0.1"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/fill-range": {
            "version": "7.1.1",
            "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
            "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
            "dev": true,
            "dependencies": {
              "to-regex-range": "^5.0.1"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/finalhandler": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-2.0.0.tgz",
            "integrity": "sha512-MX6Zo2adDViYh+GcxxB1dpO43eypOGUOL12rLCOTMQv/DfIbpSJUy4oQIIZhVZkH9e+bZWKMon0XHFEju16tkQ==",
            "license": "MIT",
            "dependencies": {
              "debug": "2.6.9",
              "encodeurl": "~1.0.2",
              "escape-html": "~1.0.3",
              "on-finished": "2.4.1",
              "parseurl": "~1.3.3",
              "statuses": "2.0.1",
              "unpipe": "~1.0.0"
            },
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/finalhandler/node_modules/debug": {
            "version": "2.6.9",
            "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
            "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
            "license": "MIT",
            "dependencies": {
              "ms": "2.0.0"
            }
          },
          "node_modules/finalhandler/node_modules/encodeurl": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
            "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/finalhandler/node_modules/ms": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
            "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
            "license": "MIT"
          },
          "node_modules/find-up": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
            "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
            "dev": true,
            "dependencies": {
              "locate-path": "^6.0.0",
              "path-exists": "^4.0.0"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/flat-cache": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
            "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
            "dev": true,
            "dependencies": {
              "flatted": "^3.2.9",
              "keyv": "^4.5.4"
            },
            "engines": {
              "node": "\u003E=16"
            }
          },
          "node_modules/flatted": {
            "version": "3.3.1",
            "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.1.tgz",
            "integrity": "sha512-X8cqMLLie7KsNUDSdzeN8FYK9rEt4Dt67OsG/DNGnYTSDBG4uFAJFBnUeiV+zCVAvwFy56IjM9sH51jVaEhNxw==",
            "dev": true
          },
          "node_modules/form-data": {
            "version": "4.0.4",
            "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.4.tgz",
            "integrity": "sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "asynckit": "^0.4.0",
              "combined-stream": "^1.0.8",
              "es-set-tostringtag": "^2.1.0",
              "hasown": "^2.0.2",
              "mime-types": "^2.1.12"
            },
            "engines": {
              "node": "\u003E= 6"
            }
          },
          "node_modules/form-data/node_modules/mime-db": {
            "version": "1.52.0",
            "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
            "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
            "dev": true,
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/form-data/node_modules/mime-types": {
            "version": "2.1.35",
            "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
            "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "mime-db": "1.52.0"
            },
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/formidable": {
            "version": "3.5.4",
            "resolved": "https://registry.npmjs.org/formidable/-/formidable-3.5.4.tgz",
            "integrity": "sha512-YikH+7CUTOtP44ZTnUhR7Ic2UASBPOqmaRkRKxRbywPTe5VxF7RRCck4af9wutiZ/QKM5nME9Bie2fFaPz5Gug==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "@paralleldrive/cuid2": "^2.2.2",
              "dezalgo": "^1.0.4",
              "once": "^1.4.0"
            },
            "engines": {
              "node": "\u003E=14.0.0"
            },
            "funding": {
              "url": "https://ko-fi.com/tunnckoCore/commissions"
            }
          },
          "node_modules/forwarded": {
            "version": "0.2.0",
            "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
            "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/fresh": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz",
            "integrity": "sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/fs.realpath": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
            "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==",
            "dev": true
          },
          "node_modules/fsevents": {
            "version": "2.3.3",
            "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
            "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
            "dev": true,
            "hasInstallScript": true,
            "optional": true,
            "os": [
              "darwin"
            ],
            "engines": {
              "node": "^8.16.0 || ^10.6.0 || \u003E=11.0.0"
            }
          },
          "node_modules/function-bind": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
            "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/gensync": {
            "version": "1.0.0-beta.2",
            "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
            "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
            "dev": true,
            "engines": {
              "node": "\u003E=6.9.0"
            }
          },
          "node_modules/get-caller-file": {
            "version": "2.0.5",
            "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
            "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
            "dev": true,
            "engines": {
              "node": "6.* || 8.* || \u003E= 10.*"
            }
          },
          "node_modules/get-intrinsic": {
            "version": "1.2.7",
            "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.2.7.tgz",
            "integrity": "sha512-VW6Pxhsrk0KAOqs3WEd0klDiF/+V7gQOpAvY1jVU/LHmaD/kQO4523aiJuikX/QAKYiW6x8Jh+RJej1almdtCA==",
            "license": "MIT",
            "dependencies": {
              "call-bind-apply-helpers": "^1.0.1",
              "es-define-property": "^1.0.1",
              "es-errors": "^1.3.0",
              "es-object-atoms": "^1.0.0",
              "function-bind": "^1.1.2",
              "get-proto": "^1.0.0",
              "gopd": "^1.2.0",
              "has-symbols": "^1.1.0",
              "hasown": "^2.0.2",
              "math-intrinsics": "^1.1.0"
            },
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/get-package-type": {
            "version": "0.1.0",
            "resolved": "https://registry.npmjs.org/get-package-type/-/get-package-type-0.1.0.tgz",
            "integrity": "sha512-pjzuKtY64GYfWizNAJ0fr9VqttZkNiK2iS430LtIHzjBEr6bX8Am2zm4sW4Ro5wjWW5cAlRL1qAMTcXbjNAO2Q==",
            "dev": true,
            "engines": {
              "node": "\u003E=8.0.0"
            }
          },
          "node_modules/get-proto": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
            "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
            "license": "MIT",
            "dependencies": {
              "dunder-proto": "^1.0.1",
              "es-object-atoms": "^1.0.0"
            },
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/get-stream": {
            "version": "6.0.1",
            "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
            "integrity": "sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/get-tsconfig": {
            "version": "4.8.1",
            "resolved": "https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.8.1.tgz",
            "integrity": "sha512-k9PN+cFBmaLWtVz29SkUoqU5O0slLuHJXt/2P+tMVFT+phsSGXGkp9t3rQIqdz0e+06EHNGs3oM6ZX1s2zHxRg==",
            "dev": true,
            "dependencies": {
              "resolve-pkg-maps": "^1.0.0"
            },
            "funding": {
              "url": "https://github.com/privatenumber/get-tsconfig?sponsor=1"
            }
          },
          "node_modules/glob": {
            "version": "7.2.3",
            "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
            "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
            "deprecated": "Glob versions prior to v9 are no longer supported",
            "dev": true,
            "dependencies": {
              "fs.realpath": "^1.0.0",
              "inflight": "^1.0.4",
              "inherits": "2",
              "minimatch": "^3.1.1",
              "once": "^1.3.0",
              "path-is-absolute": "^1.0.0"
            },
            "engines": {
              "node": "*"
            },
            "funding": {
              "url": "https://github.com/sponsors/isaacs"
            }
          },
          "node_modules/glob-parent": {
            "version": "6.0.2",
            "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
            "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
            "dev": true,
            "dependencies": {
              "is-glob": "^4.0.3"
            },
            "engines": {
              "node": "\u003E=10.13.0"
            }
          },
          "node_modules/globals": {
            "version": "14.0.0",
            "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
            "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=18"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/gopd": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
            "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/graceful-fs": {
            "version": "4.2.11",
            "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
            "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
            "dev": true
          },
          "node_modules/graphemer": {
            "version": "1.4.0",
            "resolved": "https://registry.npmjs.org/graphemer/-/graphemer-1.4.0.tgz",
            "integrity": "sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==",
            "dev": true
          },
          "node_modules/has-flag": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
            "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/has-symbols": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
            "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/has-tostringtag": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
            "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "has-symbols": "^1.0.3"
            },
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/hasown": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
            "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
            "dependencies": {
              "function-bind": "^1.1.2"
            },
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/html-escaper": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
            "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
            "dev": true
          },
          "node_modules/http-errors": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
            "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
            "dependencies": {
              "depd": "2.0.0",
              "inherits": "2.0.4",
              "setprototypeof": "1.2.0",
              "statuses": "2.0.1",
              "toidentifier": "1.0.1"
            },
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/human-signals": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-2.1.0.tgz",
            "integrity": "sha512-B4FFZ6q/T2jhhksgkbEW3HBvWIfDW85snkQgawt07S7J5QXTk6BkNV+0yAeZrM5QpMAdYlocGoljn0sJ/WQkFw==",
            "dev": true,
            "engines": {
              "node": "\u003E=10.17.0"
            }
          },
          "node_modules/iconv-lite": {
            "version": "0.5.2",
            "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.5.2.tgz",
            "integrity": "sha512-kERHXvpSaB4aU3eANwidg79K8FlrN77m8G9V+0vOR3HYaRifrlwMEpT7ZBJqLSEIHnEgJTHcWK82wwLwwKwtag==",
            "license": "MIT",
            "dependencies": {
              "safer-buffer": "\u003E= 2.1.2 \u003C 3"
            },
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/ignore": {
            "version": "5.3.2",
            "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
            "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
            "dev": true,
            "engines": {
              "node": "\u003E= 4"
            }
          },
          "node_modules/import-fresh": {
            "version": "3.3.0",
            "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz",
            "integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==",
            "dev": true,
            "dependencies": {
              "parent-module": "^1.0.0",
              "resolve-from": "^4.0.0"
            },
            "engines": {
              "node": "\u003E=6"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/import-local": {
            "version": "3.2.0",
            "resolved": "https://registry.npmjs.org/import-local/-/import-local-3.2.0.tgz",
            "integrity": "sha512-2SPlun1JUPWoM6t3F0dw0FkCF/jWY8kttcY4f599GLTSjh2OCuuhdTkJQsEcZzBqbXZGKMK2OqW1oZsjtf/gQA==",
            "dev": true,
            "dependencies": {
              "pkg-dir": "^4.2.0",
              "resolve-cwd": "^3.0.0"
            },
            "bin": {
              "import-local-fixture": "fixtures/cli.js"
            },
            "engines": {
              "node": "\u003E=8"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/imurmurhash": {
            "version": "0.1.4",
            "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
            "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.8.19"
            }
          },
          "node_modules/inflight": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
            "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
            "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.",
            "dev": true,
            "dependencies": {
              "once": "^1.3.0",
              "wrappy": "1"
            }
          },
          "node_modules/inherits": {
            "version": "2.0.4",
            "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
            "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
          },
          "node_modules/ipaddr.js": {
            "version": "1.9.1",
            "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
            "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
            "engines": {
              "node": "\u003E= 0.10"
            }
          },
          "node_modules/is-arrayish": {
            "version": "0.2.1",
            "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
            "integrity": "sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==",
            "dev": true
          },
          "node_modules/is-core-module": {
            "version": "2.15.1",
            "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.15.1.tgz",
            "integrity": "sha512-z0vtXSwucUJtANQWldhbtbt7BnL0vxiFjIdDLAatwhDYty2bad6s+rijD6Ri4YuYJubLzIJLUidCh09e1djEVQ==",
            "dev": true,
            "dependencies": {
              "hasown": "^2.0.2"
            },
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/is-extglob": {
            "version": "2.1.1",
            "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
            "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/is-fullwidth-code-point": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
            "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/is-generator-fn": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/is-generator-fn/-/is-generator-fn-2.1.0.tgz",
            "integrity": "sha512-cTIB4yPYL/Grw0EaSzASzg6bBy9gqCofvWN8okThAYIxKJZC+udlRAmGbM0XLeniEJSs8uEgHPGuHSe1XsOLSQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/is-glob": {
            "version": "4.0.3",
            "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
            "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
            "dev": true,
            "dependencies": {
              "is-extglob": "^2.1.1"
            },
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/is-number": {
            "version": "7.0.0",
            "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
            "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.12.0"
            }
          },
          "node_modules/is-promise": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz",
            "integrity": "sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==",
            "license": "MIT"
          },
          "node_modules/is-stream": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
            "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/isexe": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
            "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw=="
          },
          "node_modules/istanbul-lib-coverage": {
            "version": "3.2.2",
            "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
            "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/istanbul-lib-instrument": {
            "version": "6.0.3",
            "resolved": "https://registry.npmjs.org/istanbul-lib-instrument/-/istanbul-lib-instrument-6.0.3.tgz",
            "integrity": "sha512-Vtgk7L/R2JHyyGW07spoFlB8/lpjiOLTjMdms6AFMraYt3BaJauod/NGrfnVG/y4Ix1JEuMRPDPEj2ua+zz1/Q==",
            "dev": true,
            "dependencies": {
              "@babel/core": "^7.23.9",
              "@babel/parser": "^7.23.9",
              "@istanbuljs/schema": "^0.1.3",
              "istanbul-lib-coverage": "^3.2.0",
              "semver": "^7.5.4"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/istanbul-lib-instrument/node_modules/semver": {
            "version": "7.6.3",
            "resolved": "https://registry.npmjs.org/semver/-/semver-7.6.3.tgz",
            "integrity": "sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==",
            "dev": true,
            "bin": {
              "semver": "bin/semver.js"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/istanbul-lib-report": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
            "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
            "dev": true,
            "dependencies": {
              "istanbul-lib-coverage": "^3.0.0",
              "make-dir": "^4.0.0",
              "supports-color": "^7.1.0"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/istanbul-lib-source-maps": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-4.0.1.tgz",
            "integrity": "sha512-n3s8EwkdFIJCG3BPKBYvskgXGoy88ARzvegkitk60NxRdwltLOTaH7CUiMRXvwYorl0Q712iEjcWB+fK/MrWVw==",
            "dev": true,
            "dependencies": {
              "debug": "^4.1.1",
              "istanbul-lib-coverage": "^3.0.0",
              "source-map": "^0.6.1"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/istanbul-reports": {
            "version": "3.1.7",
            "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.1.7.tgz",
            "integrity": "sha512-BewmUXImeuRk2YY0PVbxgKAysvhRPUQE0h5QRM++nVWyubKGV0l8qQ5op8+B2DOmwSe63Jivj0BjkPQVf8fP5g==",
            "dev": true,
            "dependencies": {
              "html-escaper": "^2.0.0",
              "istanbul-lib-report": "^3.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/jake": {
            "version": "10.9.2",
            "resolved": "https://registry.npmjs.org/jake/-/jake-10.9.2.tgz",
            "integrity": "sha512-2P4SQ0HrLQ+fw6llpLnOaGAvN2Zu6778SJMrCUwns4fOoG9ayrTiZk3VV8sCPkVZF8ab0zksVpS8FDY5pRCNBA==",
            "dev": true,
            "dependencies": {
              "async": "^3.2.3",
              "chalk": "^4.0.2",
              "filelist": "^1.0.4",
              "minimatch": "^3.1.2"
            },
            "bin": {
              "jake": "bin/cli.js"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/jest": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest/-/jest-29.7.0.tgz",
            "integrity": "sha512-NIy3oAFp9shda19hy4HK0HRTWKtPJmGdnvywu01nOqNC2vZg+Z+fvJDxpMQA88eb2I9EcafcdjYgsDthnYTvGw==",
            "dev": true,
            "dependencies": {
              "@jest/core": "^29.7.0",
              "@jest/types": "^29.6.3",
              "import-local": "^3.0.2",
              "jest-cli": "^29.7.0"
            },
            "bin": {
              "jest": "bin/jest.js"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            },
            "peerDependencies": {
              "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
            },
            "peerDependenciesMeta": {
              "node-notifier": {
                "optional": true
              }
            }
          },
          "node_modules/jest-changed-files": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-changed-files/-/jest-changed-files-29.7.0.tgz",
            "integrity": "sha512-fEArFiwf1BpQ+4bXSprcDc3/x4HSzL4al2tozwVpDFpsxALjLYdyiIK4e5Vz66GQJIbXJ82+35PtysofptNX2w==",
            "dev": true,
            "dependencies": {
              "execa": "^5.0.0",
              "jest-util": "^29.7.0",
              "p-limit": "^3.1.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-circus": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-circus/-/jest-circus-29.7.0.tgz",
            "integrity": "sha512-3E1nCMgipcTkCocFwM90XXQab9bS+GMsjdpmPrlelaxwD93Ad8iVEjX/vvHPdLPnFf+L40u+5+iutRdA1N9myw==",
            "dev": true,
            "dependencies": {
              "@jest/environment": "^29.7.0",
              "@jest/expect": "^29.7.0",
              "@jest/test-result": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "chalk": "^4.0.0",
              "co": "^4.6.0",
              "dedent": "^1.0.0",
              "is-generator-fn": "^2.0.0",
              "jest-each": "^29.7.0",
              "jest-matcher-utils": "^29.7.0",
              "jest-message-util": "^29.7.0",
              "jest-runtime": "^29.7.0",
              "jest-snapshot": "^29.7.0",
              "jest-util": "^29.7.0",
              "p-limit": "^3.1.0",
              "pretty-format": "^29.7.0",
              "pure-rand": "^6.0.0",
              "slash": "^3.0.0",
              "stack-utils": "^2.0.3"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-cli": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-cli/-/jest-cli-29.7.0.tgz",
            "integrity": "sha512-OVVobw2IubN/GSYsxETi+gOe7Ka59EFMR/twOU3Jb2GnKKeMGJB5SGUUrEz3SFVmJASUdZUzy83sLNNQ2gZslg==",
            "dev": true,
            "dependencies": {
              "@jest/core": "^29.7.0",
              "@jest/test-result": "^29.7.0",
              "@jest/types": "^29.6.3",
              "chalk": "^4.0.0",
              "create-jest": "^29.7.0",
              "exit": "^0.1.2",
              "import-local": "^3.0.2",
              "jest-config": "^29.7.0",
              "jest-util": "^29.7.0",
              "jest-validate": "^29.7.0",
              "yargs": "^17.3.1"
            },
            "bin": {
              "jest": "bin/jest.js"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            },
            "peerDependencies": {
              "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
            },
            "peerDependenciesMeta": {
              "node-notifier": {
                "optional": true
              }
            }
          },
          "node_modules/jest-config": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-config/-/jest-config-29.7.0.tgz",
            "integrity": "sha512-uXbpfeQ7R6TZBqI3/TxCU4q4ttk3u0PJeC+E0zbfSoSjq6bJ7buBPxzQPL0ifrkY4DNu4JUdk0ImlBUYi840eQ==",
            "dev": true,
            "dependencies": {
              "@babel/core": "^7.11.6",
              "@jest/test-sequencer": "^29.7.0",
              "@jest/types": "^29.6.3",
              "babel-jest": "^29.7.0",
              "chalk": "^4.0.0",
              "ci-info": "^3.2.0",
              "deepmerge": "^4.2.2",
              "glob": "^7.1.3",
              "graceful-fs": "^4.2.9",
              "jest-circus": "^29.7.0",
              "jest-environment-node": "^29.7.0",
              "jest-get-type": "^29.6.3",
              "jest-regex-util": "^29.6.3",
              "jest-resolve": "^29.7.0",
              "jest-runner": "^29.7.0",
              "jest-util": "^29.7.0",
              "jest-validate": "^29.7.0",
              "micromatch": "^4.0.4",
              "parse-json": "^5.2.0",
              "pretty-format": "^29.7.0",
              "slash": "^3.0.0",
              "strip-json-comments": "^3.1.1"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            },
            "peerDependencies": {
              "@types/node": "*",
              "ts-node": "\u003E=9.0.0"
            },
            "peerDependenciesMeta": {
              "@types/node": {
                "optional": true
              },
              "ts-node": {
                "optional": true
              }
            }
          },
          "node_modules/jest-diff": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-diff/-/jest-diff-29.7.0.tgz",
            "integrity": "sha512-LMIgiIrhigmPrs03JHpxUh2yISK3vLFPkAodPeo0+BuF7wA2FoQbkEg1u8gBYBThncu7e1oEDUfIXVuTqLRUjw==",
            "dev": true,
            "dependencies": {
              "chalk": "^4.0.0",
              "diff-sequences": "^29.6.3",
              "jest-get-type": "^29.6.3",
              "pretty-format": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-docblock": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-docblock/-/jest-docblock-29.7.0.tgz",
            "integrity": "sha512-q617Auw3A612guyaFgsbFeYpNP5t2aoUNLwBUbc/0kD1R4t9ixDbyFTHd1nok4epoVFpr7PmeWHrhvuV3XaJ4g==",
            "dev": true,
            "dependencies": {
              "detect-newline": "^3.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-each": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-each/-/jest-each-29.7.0.tgz",
            "integrity": "sha512-gns+Er14+ZrEoC5fhOfYCY1LOHHr0TI+rQUHZS8Ttw2l7gl+80eHc/gFf2Ktkw0+SIACDTeWvpFcv3B04VembQ==",
            "dev": true,
            "dependencies": {
              "@jest/types": "^29.6.3",
              "chalk": "^4.0.0",
              "jest-get-type": "^29.6.3",
              "jest-util": "^29.7.0",
              "pretty-format": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-environment-node": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-environment-node/-/jest-environment-node-29.7.0.tgz",
            "integrity": "sha512-DOSwCRqXirTOyheM+4d5YZOrWcdu0LNZ87ewUoywbcb2XR4wKgqiG8vNeYwhjFMbEkfju7wx2GYH0P2gevGvFw==",
            "dev": true,
            "dependencies": {
              "@jest/environment": "^29.7.0",
              "@jest/fake-timers": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "jest-mock": "^29.7.0",
              "jest-util": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-get-type": {
            "version": "29.6.3",
            "resolved": "https://registry.npmjs.org/jest-get-type/-/jest-get-type-29.6.3.tgz",
            "integrity": "sha512-zrteXnqYxfQh7l5FHyL38jL39di8H8rHoecLH3JNxH3BwOrBsNeabdap5e0I23lD4HHI8W5VFBZqG4Eaq5LNcw==",
            "dev": true,
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-haste-map": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-haste-map/-/jest-haste-map-29.7.0.tgz",
            "integrity": "sha512-fP8u2pyfqx0K1rGn1R9pyE0/KTn+G7PxktWidOBTqFPLYX0b9ksaMFkhK5vrS3DVun09pckLdlx90QthlW7AmA==",
            "dev": true,
            "dependencies": {
              "@jest/types": "^29.6.3",
              "@types/graceful-fs": "^4.1.3",
              "@types/node": "*",
              "anymatch": "^3.0.3",
              "fb-watchman": "^2.0.0",
              "graceful-fs": "^4.2.9",
              "jest-regex-util": "^29.6.3",
              "jest-util": "^29.7.0",
              "jest-worker": "^29.7.0",
              "micromatch": "^4.0.4",
              "walker": "^1.0.8"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            },
            "optionalDependencies": {
              "fsevents": "^2.3.2"
            }
          },
          "node_modules/jest-leak-detector": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-leak-detector/-/jest-leak-detector-29.7.0.tgz",
            "integrity": "sha512-kYA8IJcSYtST2BY9I+SMC32nDpBT3J2NvWJx8+JCuCdl/CR1I4EKUJROiP8XtCcxqgTTBGJNdbB1A8XRKbTetw==",
            "dev": true,
            "dependencies": {
              "jest-get-type": "^29.6.3",
              "pretty-format": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-matcher-utils": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-matcher-utils/-/jest-matcher-utils-29.7.0.tgz",
            "integrity": "sha512-sBkD+Xi9DtcChsI3L3u0+N0opgPYnCRPtGcQYrgXmR+hmt/fYfWAL0xRXYU8eWOdfuLgBe0YCW3AFtnRLagq/g==",
            "dev": true,
            "dependencies": {
              "chalk": "^4.0.0",
              "jest-diff": "^29.7.0",
              "jest-get-type": "^29.6.3",
              "pretty-format": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-message-util": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-message-util/-/jest-message-util-29.7.0.tgz",
            "integrity": "sha512-GBEV4GRADeP+qtB2+6u61stea8mGcOT4mCtrYISZwfu9/ISHFJ/5zOMXYbpBE9RsS5+Gb63DW4FgmnKJ79Kf6w==",
            "dev": true,
            "dependencies": {
              "@babel/code-frame": "^7.12.13",
              "@jest/types": "^29.6.3",
              "@types/stack-utils": "^2.0.0",
              "chalk": "^4.0.0",
              "graceful-fs": "^4.2.9",
              "micromatch": "^4.0.4",
              "pretty-format": "^29.7.0",
              "slash": "^3.0.0",
              "stack-utils": "^2.0.3"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-mock": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-mock/-/jest-mock-29.7.0.tgz",
            "integrity": "sha512-ITOMZn+UkYS4ZFh83xYAOzWStloNzJFO2s8DWrE4lhtGD+AorgnbkiKERe4wQVBydIGPx059g6riW5Btp6Llnw==",
            "dev": true,
            "dependencies": {
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "jest-util": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-pnp-resolver": {
            "version": "1.2.3",
            "resolved": "https://registry.npmjs.org/jest-pnp-resolver/-/jest-pnp-resolver-1.2.3.tgz",
            "integrity": "sha512-+3NpwQEnRoIBtx4fyhblQDPgJI0H1IEIkX7ShLUjPGA7TtUTvI1oiKi3SR4oBR0hQhQR80l4WAe5RrXBwWMA8w==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            },
            "peerDependencies": {
              "jest-resolve": "*"
            },
            "peerDependenciesMeta": {
              "jest-resolve": {
                "optional": true
              }
            }
          },
          "node_modules/jest-regex-util": {
            "version": "29.6.3",
            "resolved": "https://registry.npmjs.org/jest-regex-util/-/jest-regex-util-29.6.3.tgz",
            "integrity": "sha512-KJJBsRCyyLNWCNBOvZyRDnAIfUiRJ8v+hOBQYGn8gDyF3UegwiP4gwRR3/SDa42g1YbVycTidUF3rKjyLFDWbg==",
            "dev": true,
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-resolve": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-resolve/-/jest-resolve-29.7.0.tgz",
            "integrity": "sha512-IOVhZSrg+UvVAshDSDtHyFCCBUl/Q3AAJv8iZ6ZjnZ74xzvwuzLXid9IIIPgTnY62SJjfuupMKZsZQRsCvxEgA==",
            "dev": true,
            "dependencies": {
              "chalk": "^4.0.0",
              "graceful-fs": "^4.2.9",
              "jest-haste-map": "^29.7.0",
              "jest-pnp-resolver": "^1.2.2",
              "jest-util": "^29.7.0",
              "jest-validate": "^29.7.0",
              "resolve": "^1.20.0",
              "resolve.exports": "^2.0.0",
              "slash": "^3.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-resolve-dependencies": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-resolve-dependencies/-/jest-resolve-dependencies-29.7.0.tgz",
            "integrity": "sha512-un0zD/6qxJ+S0et7WxeI3H5XSe9lTBBR7bOHCHXkKR6luG5mwDDlIzVQ0V5cZCuoTgEdcdwzTghYkTWfubi+nA==",
            "dev": true,
            "dependencies": {
              "jest-regex-util": "^29.6.3",
              "jest-snapshot": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-runner": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-runner/-/jest-runner-29.7.0.tgz",
            "integrity": "sha512-fsc4N6cPCAahybGBfTRcq5wFR6fpLznMg47sY5aDpsoejOcVYFb07AHuSnR0liMcPTgBsA3ZJL6kFOjPdoNipQ==",
            "dev": true,
            "dependencies": {
              "@jest/console": "^29.7.0",
              "@jest/environment": "^29.7.0",
              "@jest/test-result": "^29.7.0",
              "@jest/transform": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "chalk": "^4.0.0",
              "emittery": "^0.13.1",
              "graceful-fs": "^4.2.9",
              "jest-docblock": "^29.7.0",
              "jest-environment-node": "^29.7.0",
              "jest-haste-map": "^29.7.0",
              "jest-leak-detector": "^29.7.0",
              "jest-message-util": "^29.7.0",
              "jest-resolve": "^29.7.0",
              "jest-runtime": "^29.7.0",
              "jest-util": "^29.7.0",
              "jest-watcher": "^29.7.0",
              "jest-worker": "^29.7.0",
              "p-limit": "^3.1.0",
              "source-map-support": "0.5.13"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-runtime": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-runtime/-/jest-runtime-29.7.0.tgz",
            "integrity": "sha512-gUnLjgwdGqW7B4LvOIkbKs9WGbn+QLqRQQ9juC6HndeDiezIwhDP+mhMwHWCEcfQ5RUXa6OPnFF8BJh5xegwwQ==",
            "dev": true,
            "dependencies": {
              "@jest/environment": "^29.7.0",
              "@jest/fake-timers": "^29.7.0",
              "@jest/globals": "^29.7.0",
              "@jest/source-map": "^29.6.3",
              "@jest/test-result": "^29.7.0",
              "@jest/transform": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "chalk": "^4.0.0",
              "cjs-module-lexer": "^1.0.0",
              "collect-v8-coverage": "^1.0.0",
              "glob": "^7.1.3",
              "graceful-fs": "^4.2.9",
              "jest-haste-map": "^29.7.0",
              "jest-message-util": "^29.7.0",
              "jest-mock": "^29.7.0",
              "jest-regex-util": "^29.6.3",
              "jest-resolve": "^29.7.0",
              "jest-snapshot": "^29.7.0",
              "jest-util": "^29.7.0",
              "slash": "^3.0.0",
              "strip-bom": "^4.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-snapshot": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-snapshot/-/jest-snapshot-29.7.0.tgz",
            "integrity": "sha512-Rm0BMWtxBcioHr1/OX5YCP8Uov4riHvKPknOGs804Zg9JGZgmIBkbtlxJC/7Z4msKYVbIJtfU+tKb8xlYNfdkw==",
            "dev": true,
            "dependencies": {
              "@babel/core": "^7.11.6",
              "@babel/generator": "^7.7.2",
              "@babel/plugin-syntax-jsx": "^7.7.2",
              "@babel/plugin-syntax-typescript": "^7.7.2",
              "@babel/types": "^7.3.3",
              "@jest/expect-utils": "^29.7.0",
              "@jest/transform": "^29.7.0",
              "@jest/types": "^29.6.3",
              "babel-preset-current-node-syntax": "^1.0.0",
              "chalk": "^4.0.0",
              "expect": "^29.7.0",
              "graceful-fs": "^4.2.9",
              "jest-diff": "^29.7.0",
              "jest-get-type": "^29.6.3",
              "jest-matcher-utils": "^29.7.0",
              "jest-message-util": "^29.7.0",
              "jest-util": "^29.7.0",
              "natural-compare": "^1.4.0",
              "pretty-format": "^29.7.0",
              "semver": "^7.5.3"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-snapshot/node_modules/semver": {
            "version": "7.6.3",
            "resolved": "https://registry.npmjs.org/semver/-/semver-7.6.3.tgz",
            "integrity": "sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==",
            "dev": true,
            "bin": {
              "semver": "bin/semver.js"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/jest-util": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-util/-/jest-util-29.7.0.tgz",
            "integrity": "sha512-z6EbKajIpqGKU56y5KBUgy1dt1ihhQJgWzUlZHArA/+X2ad7Cb5iF+AK1EWVL/Bo7Rz9uurpqw6SiBCefUbCGA==",
            "dev": true,
            "dependencies": {
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "chalk": "^4.0.0",
              "ci-info": "^3.2.0",
              "graceful-fs": "^4.2.9",
              "picomatch": "^2.2.3"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-validate": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-validate/-/jest-validate-29.7.0.tgz",
            "integrity": "sha512-ZB7wHqaRGVw/9hST/OuFUReG7M8vKeq0/J2egIGLdvjHCmYqGARhzXmtgi+gVeZ5uXFF219aOc3Ls2yLg27tkw==",
            "dev": true,
            "dependencies": {
              "@jest/types": "^29.6.3",
              "camelcase": "^6.2.0",
              "chalk": "^4.0.0",
              "jest-get-type": "^29.6.3",
              "leven": "^3.1.0",
              "pretty-format": "^29.7.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-validate/node_modules/camelcase": {
            "version": "6.3.0",
            "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.3.0.tgz",
            "integrity": "sha512-Gmy6FhYlCY7uOElZUSbxo2UCDH8owEk996gkbrpsgGtrJLM3J7jGxl9Ic7Qwwj4ivOE5AWZWRMecDdF7hqGjFA==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/jest-watcher": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-watcher/-/jest-watcher-29.7.0.tgz",
            "integrity": "sha512-49Fg7WXkU3Vl2h6LbLtMQ/HyB6rXSIX7SqvBLQmssRBGN9I0PNvPmAmCWSOY6SOvrjhI/F7/bGAv9RtnsPA03g==",
            "dev": true,
            "dependencies": {
              "@jest/test-result": "^29.7.0",
              "@jest/types": "^29.6.3",
              "@types/node": "*",
              "ansi-escapes": "^4.2.1",
              "chalk": "^4.0.0",
              "emittery": "^0.13.1",
              "jest-util": "^29.7.0",
              "string-length": "^4.0.1"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-worker": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-29.7.0.tgz",
            "integrity": "sha512-eIz2msL/EzL9UFTFFx7jBTkeZfku0yUAyZZZmJ93H2TYEiroIx2PQjEXcwYtYl8zXCxb+PAmA2hLIt/6ZEkPHw==",
            "dev": true,
            "dependencies": {
              "@types/node": "*",
              "jest-util": "^29.7.0",
              "merge-stream": "^2.0.0",
              "supports-color": "^8.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/jest-worker/node_modules/supports-color": {
            "version": "8.1.1",
            "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
            "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
            "dev": true,
            "dependencies": {
              "has-flag": "^4.0.0"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/chalk/supports-color?sponsor=1"
            }
          },
          "node_modules/js-tokens": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
            "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
            "dev": true
          },
          "node_modules/js-yaml": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
            "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
            "dev": true,
            "dependencies": {
              "argparse": "^2.0.1"
            },
            "bin": {
              "js-yaml": "bin/js-yaml.js"
            }
          },
          "node_modules/jsesc": {
            "version": "3.0.2",
            "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.0.2.tgz",
            "integrity": "sha512-xKqzzWXDttJuOcawBt4KnKHHIf5oQ/Cxax+0PWFG+DFDgHNAdi+TXECADI+RYiFUMmx8792xsMbbgXj4CwnP4g==",
            "dev": true,
            "bin": {
              "jsesc": "bin/jsesc"
            },
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/json-buffer": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
            "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
            "dev": true
          },
          "node_modules/json-parse-even-better-errors": {
            "version": "2.3.1",
            "resolved": "https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz",
            "integrity": "sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==",
            "dev": true
          },
          "node_modules/json-schema-traverse": {
            "version": "0.4.1",
            "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
            "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
            "license": "MIT"
          },
          "node_modules/json-stable-stringify-without-jsonify": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
            "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
            "dev": true
          },
          "node_modules/json5": {
            "version": "2.2.3",
            "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
            "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
            "dev": true,
            "bin": {
              "json5": "lib/cli.js"
            },
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/keyv": {
            "version": "4.5.4",
            "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
            "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
            "dev": true,
            "dependencies": {
              "json-buffer": "3.0.1"
            }
          },
          "node_modules/kleur": {
            "version": "3.0.3",
            "resolved": "https://registry.npmjs.org/kleur/-/kleur-3.0.3.tgz",
            "integrity": "sha512-eTIzlVOSUR+JxdDFepEYcBMtZ9Qqdef+rnzWdRZuMbOywu5tO2w2N7rqjoANZ5k9vywhL6Br1VRjUIgTQx4E8w==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/leven": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/leven/-/leven-3.1.0.tgz",
            "integrity": "sha512-qsda+H8jTaUaN/x5vzW2rzc+8Rw4TAQ/4KjB46IwK5VH+IlVeeeje/EoZRpiXvIqjFgK84QffqPztGI3VBLG1A==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/levn": {
            "version": "0.4.1",
            "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
            "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
            "dev": true,
            "dependencies": {
              "prelude-ls": "^1.2.1",
              "type-check": "~0.4.0"
            },
            "engines": {
              "node": "\u003E= 0.8.0"
            }
          },
          "node_modules/lines-and-columns": {
            "version": "1.2.4",
            "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
            "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
            "dev": true
          },
          "node_modules/locate-path": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
            "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
            "dev": true,
            "dependencies": {
              "p-locate": "^5.0.0"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/lodash.memoize": {
            "version": "4.1.2",
            "resolved": "https://registry.npmjs.org/lodash.memoize/-/lodash.memoize-4.1.2.tgz",
            "integrity": "sha512-t7j+NzmgnQzTAYXcsHYLgimltOV1MXHtlOWf6GjL9Kj8GK5FInw5JotxvbOs+IvV1/Dzo04/fCGfLVs7aXb4Ag==",
            "dev": true
          },
          "node_modules/lodash.merge": {
            "version": "4.6.2",
            "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
            "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
            "dev": true
          },
          "node_modules/lru-cache": {
            "version": "5.1.1",
            "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
            "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
            "dev": true,
            "dependencies": {
              "yallist": "^3.0.2"
            }
          },
          "node_modules/make-dir": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
            "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
            "dev": true,
            "dependencies": {
              "semver": "^7.5.3"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/make-dir/node_modules/semver": {
            "version": "7.6.3",
            "resolved": "https://registry.npmjs.org/semver/-/semver-7.6.3.tgz",
            "integrity": "sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==",
            "dev": true,
            "bin": {
              "semver": "bin/semver.js"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/make-error": {
            "version": "1.3.6",
            "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
            "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
            "dev": true
          },
          "node_modules/makeerror": {
            "version": "1.0.12",
            "resolved": "https://registry.npmjs.org/makeerror/-/makeerror-1.0.12.tgz",
            "integrity": "sha512-JmqCvUhmt43madlpFzG4BQzG2Z3m6tvQDNKdClZnO3VbIudJYmxsT0FNJMeiB2+JTSlTQTSbU8QdesVmwJcmLg==",
            "dev": true,
            "dependencies": {
              "tmpl": "1.0.5"
            }
          },
          "node_modules/math-intrinsics": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
            "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.4"
            }
          },
          "node_modules/media-typer": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz",
            "integrity": "sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/merge-descriptors": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz",
            "integrity": "sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==",
            "license": "MIT",
            "engines": {
              "node": "\u003E=18"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/merge-stream": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
            "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
            "dev": true
          },
          "node_modules/merge2": {
            "version": "1.4.1",
            "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
            "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
            "dev": true,
            "engines": {
              "node": "\u003E= 8"
            }
          },
          "node_modules/methods": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
            "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/micromatch": {
            "version": "4.0.8",
            "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
            "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
            "dev": true,
            "dependencies": {
              "braces": "^3.0.3",
              "picomatch": "^2.3.1"
            },
            "engines": {
              "node": "\u003E=8.6"
            }
          },
          "node_modules/mime": {
            "version": "2.6.0",
            "resolved": "https://registry.npmjs.org/mime/-/mime-2.6.0.tgz",
            "integrity": "sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==",
            "dev": true,
            "license": "MIT",
            "bin": {
              "mime": "cli.js"
            },
            "engines": {
              "node": "\u003E=4.0.0"
            }
          },
          "node_modules/mime-db": {
            "version": "1.53.0",
            "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.53.0.tgz",
            "integrity": "sha512-oHlN/w+3MQ3rba9rqFr6V/ypF10LSkdwUysQL7GkXoTgIWeV+tcXGA852TBxH+gsh8UWoyhR1hKcoMJTuWflpg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/mime-types": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-3.0.0.tgz",
            "integrity": "sha512-XqoSHeCGjVClAmoGFG3lVFqQFRIrTVw2OH3axRqAcfaw+gHWIfnASS92AV+Rl/mk0MupgZTRHQOjxY6YVnzK5w==",
            "license": "MIT",
            "dependencies": {
              "mime-db": "^1.53.0"
            },
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/mimic-fn": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
            "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/minimatch": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
            "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
            "dev": true,
            "dependencies": {
              "brace-expansion": "^1.1.7"
            },
            "engines": {
              "node": "*"
            }
          },
          "node_modules/ms": {
            "version": "2.1.3",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
            "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
          },
          "node_modules/natural-compare": {
            "version": "1.4.0",
            "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
            "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
            "dev": true
          },
          "node_modules/negotiator": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz",
            "integrity": "sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/node-int64": {
            "version": "0.4.0",
            "resolved": "https://registry.npmjs.org/node-int64/-/node-int64-0.4.0.tgz",
            "integrity": "sha512-O5lz91xSOeoXP6DulyHfllpq+Eg00MWitZIbtPfoSEvqIHdl5gfcY6hYzDWnj0qD5tz52PI08u9qUvSVeUBeHw==",
            "dev": true
          },
          "node_modules/node-releases": {
            "version": "2.0.18",
            "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.18.tgz",
            "integrity": "sha512-d9VeXT4SJ7ZeOqGX6R5EM022wpL+eWPooLI+5UpWn2jCT1aosUQEhQP214x33Wkwx3JQMvIm+tIoVOdodFS40g==",
            "dev": true
          },
          "node_modules/normalize-path": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
            "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/npm-run-path": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz",
            "integrity": "sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==",
            "dev": true,
            "dependencies": {
              "path-key": "^3.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/object-assign": {
            "version": "4.1.1",
            "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
            "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/object-inspect": {
            "version": "1.13.4",
            "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
            "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/on-finished": {
            "version": "2.4.1",
            "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
            "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
            "license": "MIT",
            "dependencies": {
              "ee-first": "1.1.1"
            },
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/once": {
            "version": "1.4.0",
            "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
            "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
            "dependencies": {
              "wrappy": "1"
            }
          },
          "node_modules/onetime": {
            "version": "5.1.2",
            "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
            "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
            "dev": true,
            "dependencies": {
              "mimic-fn": "^2.1.0"
            },
            "engines": {
              "node": "\u003E=6"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/optionator": {
            "version": "0.9.4",
            "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
            "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
            "dev": true,
            "dependencies": {
              "deep-is": "^0.1.3",
              "fast-levenshtein": "^2.0.6",
              "levn": "^0.4.1",
              "prelude-ls": "^1.2.1",
              "type-check": "^0.4.0",
              "word-wrap": "^1.2.5"
            },
            "engines": {
              "node": "\u003E= 0.8.0"
            }
          },
          "node_modules/p-limit": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
            "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
            "dev": true,
            "dependencies": {
              "yocto-queue": "^0.1.0"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/p-locate": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
            "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
            "dev": true,
            "dependencies": {
              "p-limit": "^3.0.2"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/p-try": {
            "version": "2.2.0",
            "resolved": "https://registry.npmjs.org/p-try/-/p-try-2.2.0.tgz",
            "integrity": "sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/parent-module": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
            "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
            "dev": true,
            "dependencies": {
              "callsites": "^3.0.0"
            },
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/parse-json": {
            "version": "5.2.0",
            "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-5.2.0.tgz",
            "integrity": "sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==",
            "dev": true,
            "dependencies": {
              "@babel/code-frame": "^7.0.0",
              "error-ex": "^1.3.1",
              "json-parse-even-better-errors": "^2.3.0",
              "lines-and-columns": "^1.1.6"
            },
            "engines": {
              "node": "\u003E=8"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/parseurl": {
            "version": "1.3.3",
            "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
            "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/path-exists": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
            "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/path-is-absolute": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
            "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/path-key": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
            "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/path-parse": {
            "version": "1.0.7",
            "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
            "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
            "dev": true
          },
          "node_modules/path-to-regexp": {
            "version": "8.2.0",
            "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz",
            "integrity": "sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==",
            "license": "MIT",
            "engines": {
              "node": "\u003E=16"
            }
          },
          "node_modules/picocolors": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
            "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
            "dev": true
          },
          "node_modules/picomatch": {
            "version": "2.3.1",
            "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
            "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
            "dev": true,
            "engines": {
              "node": "\u003E=8.6"
            },
            "funding": {
              "url": "https://github.com/sponsors/jonschlinkert"
            }
          },
          "node_modules/pirates": {
            "version": "4.0.6",
            "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.6.tgz",
            "integrity": "sha512-saLsH7WeYYPiD25LDuLRRY/i+6HaPYr6G1OUlN39otzkSTxKnubR9RTxS3/Kk50s1g2JTgFwWQDQyplC5/SHZg==",
            "dev": true,
            "engines": {
              "node": "\u003E= 6"
            }
          },
          "node_modules/pkce-challenge": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/pkce-challenge/-/pkce-challenge-5.0.0.tgz",
            "integrity": "sha512-ueGLflrrnvwB3xuo/uGob5pd5FN7l0MsLf0Z87o/UQmRtwjvfylfc9MurIxRAWywCYTgrvpXBcqjV4OfCYGCIQ==",
            "license": "MIT",
            "engines": {
              "node": "\u003E=16.20.0"
            }
          },
          "node_modules/pkg-dir": {
            "version": "4.2.0",
            "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-4.2.0.tgz",
            "integrity": "sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==",
            "dev": true,
            "dependencies": {
              "find-up": "^4.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/pkg-dir/node_modules/find-up": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz",
            "integrity": "sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==",
            "dev": true,
            "dependencies": {
              "locate-path": "^5.0.0",
              "path-exists": "^4.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/pkg-dir/node_modules/locate-path": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz",
            "integrity": "sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==",
            "dev": true,
            "dependencies": {
              "p-locate": "^4.1.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/pkg-dir/node_modules/p-limit": {
            "version": "2.3.0",
            "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz",
            "integrity": "sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==",
            "dev": true,
            "dependencies": {
              "p-try": "^2.0.0"
            },
            "engines": {
              "node": "\u003E=6"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/pkg-dir/node_modules/p-locate": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz",
            "integrity": "sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==",
            "dev": true,
            "dependencies": {
              "p-limit": "^2.2.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/prelude-ls": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
            "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
            "dev": true,
            "engines": {
              "node": "\u003E= 0.8.0"
            }
          },
          "node_modules/pretty-format": {
            "version": "29.7.0",
            "resolved": "https://registry.npmjs.org/pretty-format/-/pretty-format-29.7.0.tgz",
            "integrity": "sha512-Pdlw/oPxN+aXdmM9R00JVC9WVFoCLTKJvDVLgmJ+qAffBMxsV85l/Lu7sNx4zSzPyoL2euImuEwHhOXdEgNFZQ==",
            "dev": true,
            "dependencies": {
              "@jest/schemas": "^29.6.3",
              "ansi-styles": "^5.0.0",
              "react-is": "^18.0.0"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || \u003E=18.0.0"
            }
          },
          "node_modules/pretty-format/node_modules/ansi-styles": {
            "version": "5.2.0",
            "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz",
            "integrity": "sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/chalk/ansi-styles?sponsor=1"
            }
          },
          "node_modules/prompts": {
            "version": "2.4.2",
            "resolved": "https://registry.npmjs.org/prompts/-/prompts-2.4.2.tgz",
            "integrity": "sha512-NxNv/kLguCA7p3jE8oL2aEBsrJWgAakBpgmgK6lpPWV+WuOmY6r2/zbAVnP+T8bQlA0nzHXSJSJW0Hq7ylaD2Q==",
            "dev": true,
            "dependencies": {
              "kleur": "^3.0.3",
              "sisteransi": "^1.0.5"
            },
            "engines": {
              "node": "\u003E= 6"
            }
          },
          "node_modules/proxy-addr": {
            "version": "2.0.7",
            "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
            "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
            "dependencies": {
              "forwarded": "0.2.0",
              "ipaddr.js": "1.9.1"
            },
            "engines": {
              "node": "\u003E= 0.10"
            }
          },
          "node_modules/punycode": {
            "version": "2.3.1",
            "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
            "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/pure-rand": {
            "version": "6.1.0",
            "resolved": "https://registry.npmjs.org/pure-rand/-/pure-rand-6.1.0.tgz",
            "integrity": "sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA==",
            "dev": true,
            "funding": [
              {
                "type": "individual",
                "url": "https://github.com/sponsors/dubzzz"
              },
              {
                "type": "opencollective",
                "url": "https://opencollective.com/fast-check"
              }
            ]
          },
          "node_modules/qs": {
            "version": "6.13.0",
            "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
            "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
            "license": "BSD-3-Clause",
            "dependencies": {
              "side-channel": "^1.0.6"
            },
            "engines": {
              "node": "\u003E=0.6"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/queue-microtask": {
            "version": "1.2.3",
            "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
            "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
            "dev": true,
            "funding": [
              {
                "type": "github",
                "url": "https://github.com/sponsors/feross"
              },
              {
                "type": "patreon",
                "url": "https://www.patreon.com/feross"
              },
              {
                "type": "consulting",
                "url": "https://feross.org/support"
              }
            ]
          },
          "node_modules/range-parser": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
            "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/raw-body": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.0.tgz",
            "integrity": "sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==",
            "dependencies": {
              "bytes": "3.1.2",
              "http-errors": "2.0.0",
              "iconv-lite": "0.6.3",
              "unpipe": "1.0.0"
            },
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/raw-body/node_modules/iconv-lite": {
            "version": "0.6.3",
            "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
            "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
            "dependencies": {
              "safer-buffer": "\u003E= 2.1.2 \u003C 3.0.0"
            },
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/react-is": {
            "version": "18.3.1",
            "resolved": "https://registry.npmjs.org/react-is/-/react-is-18.3.1.tgz",
            "integrity": "sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==",
            "dev": true
          },
          "node_modules/require-directory": {
            "version": "2.1.1",
            "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
            "integrity": "sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/resolve": {
            "version": "1.22.8",
            "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.8.tgz",
            "integrity": "sha512-oKWePCxqpd6FlLvGV1VU0x7bkPmmCNolxzjMf4NczoDnQcIWrAF+cPtZn5i6n+RfD2d9i0tzpKnG6Yk168yIyw==",
            "dev": true,
            "dependencies": {
              "is-core-module": "^2.13.0",
              "path-parse": "^1.0.7",
              "supports-preserve-symlinks-flag": "^1.0.0"
            },
            "bin": {
              "resolve": "bin/resolve"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/resolve-cwd": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/resolve-cwd/-/resolve-cwd-3.0.0.tgz",
            "integrity": "sha512-OrZaX2Mb+rJCpH/6CpSqt9xFVpN++x01XnN2ie9g6P5/3xelLAkXWVADpdz1IHD/KFfEXyE6V0U01OQ3UO2rEg==",
            "dev": true,
            "dependencies": {
              "resolve-from": "^5.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/resolve-cwd/node_modules/resolve-from": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
            "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/resolve-from": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
            "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
            "dev": true,
            "engines": {
              "node": "\u003E=4"
            }
          },
          "node_modules/resolve-pkg-maps": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/resolve-pkg-maps/-/resolve-pkg-maps-1.0.0.tgz",
            "integrity": "sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==",
            "dev": true,
            "funding": {
              "url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1"
            }
          },
          "node_modules/resolve.exports": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/resolve.exports/-/resolve.exports-2.0.2.tgz",
            "integrity": "sha512-X2UW6Nw3n/aMgDVy+0rSqgHlv39WZAlZrXCdnbyEiKm17DSqHX4MmQMaST3FbeWR5FTuRcUwYAziZajji0Y7mg==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/reusify": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz",
            "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==",
            "dev": true,
            "engines": {
              "iojs": "\u003E=1.0.0",
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/router": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/router/-/router-2.1.0.tgz",
            "integrity": "sha512-/m/NSLxeYEgWNtyC+WtNHCF7jbGxOibVWKnn+1Psff4dJGOfoXP+MuC/f2CwSmyiHdOIzYnYFp4W6GxWfekaLA==",
            "license": "MIT",
            "dependencies": {
              "is-promise": "^4.0.0",
              "parseurl": "^1.3.3",
              "path-to-regexp": "^8.0.0"
            },
            "engines": {
              "node": "\u003E= 18"
            }
          },
          "node_modules/run-parallel": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
            "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
            "dev": true,
            "funding": [
              {
                "type": "github",
                "url": "https://github.com/sponsors/feross"
              },
              {
                "type": "patreon",
                "url": "https://www.patreon.com/feross"
              },
              {
                "type": "consulting",
                "url": "https://feross.org/support"
              }
            ],
            "dependencies": {
              "queue-microtask": "^1.2.2"
            }
          },
          "node_modules/safe-buffer": {
            "version": "5.2.1",
            "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
            "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
            "funding": [
              {
                "type": "github",
                "url": "https://github.com/sponsors/feross"
              },
              {
                "type": "patreon",
                "url": "https://www.patreon.com/feross"
              },
              {
                "type": "consulting",
                "url": "https://feross.org/support"
              }
            ],
            "license": "MIT"
          },
          "node_modules/safer-buffer": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
            "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
          },
          "node_modules/semver": {
            "version": "6.3.1",
            "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
            "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
            "dev": true,
            "bin": {
              "semver": "bin/semver.js"
            }
          },
          "node_modules/send": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/send/-/send-1.1.0.tgz",
            "integrity": "sha512-v67WcEouB5GxbTWL/4NeToqcZiAWEq90N888fczVArY8A79J0L4FD7vj5hm3eUMua5EpoQ59wa/oovY6TLvRUA==",
            "license": "MIT",
            "dependencies": {
              "debug": "^4.3.5",
              "destroy": "^1.2.0",
              "encodeurl": "^2.0.0",
              "escape-html": "^1.0.3",
              "etag": "^1.8.1",
              "fresh": "^0.5.2",
              "http-errors": "^2.0.0",
              "mime-types": "^2.1.35",
              "ms": "^2.1.3",
              "on-finished": "^2.4.1",
              "range-parser": "^1.2.1",
              "statuses": "^2.0.1"
            },
            "engines": {
              "node": "\u003E= 18"
            }
          },
          "node_modules/send/node_modules/fresh": {
            "version": "0.5.2",
            "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
            "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/send/node_modules/mime-db": {
            "version": "1.52.0",
            "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
            "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
            "license": "MIT",
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/send/node_modules/mime-types": {
            "version": "2.1.35",
            "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
            "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
            "license": "MIT",
            "dependencies": {
              "mime-db": "1.52.0"
            },
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/serve-static": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-2.1.0.tgz",
            "integrity": "sha512-A3We5UfEjG8Z7VkDv6uItWw6HY2bBSBJT1KtVESn6EOoOr2jAxNhxWCLY3jDE2WcuHXByWju74ck3ZgLwL8xmA==",
            "license": "MIT",
            "dependencies": {
              "encodeurl": "^2.0.0",
              "escape-html": "^1.0.3",
              "parseurl": "^1.3.3",
              "send": "^1.0.0"
            },
            "engines": {
              "node": "\u003E= 18"
            }
          },
          "node_modules/setprototypeof": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
            "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
          },
          "node_modules/shebang-command": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
            "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
            "dependencies": {
              "shebang-regex": "^3.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/shebang-regex": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
            "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/side-channel": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
            "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
            "license": "MIT",
            "dependencies": {
              "es-errors": "^1.3.0",
              "object-inspect": "^1.13.3",
              "side-channel-list": "^1.0.0",
              "side-channel-map": "^1.0.1",
              "side-channel-weakmap": "^1.0.2"
            },
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/side-channel-list": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
            "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
            "license": "MIT",
            "dependencies": {
              "es-errors": "^1.3.0",
              "object-inspect": "^1.13.3"
            },
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/side-channel-map": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
            "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
            "license": "MIT",
            "dependencies": {
              "call-bound": "^1.0.2",
              "es-errors": "^1.3.0",
              "get-intrinsic": "^1.2.5",
              "object-inspect": "^1.13.3"
            },
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/side-channel-weakmap": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
            "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
            "license": "MIT",
            "dependencies": {
              "call-bound": "^1.0.2",
              "es-errors": "^1.3.0",
              "get-intrinsic": "^1.2.5",
              "object-inspect": "^1.13.3",
              "side-channel-map": "^1.0.1"
            },
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/signal-exit": {
            "version": "3.0.7",
            "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
            "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
            "dev": true
          },
          "node_modules/sisteransi": {
            "version": "1.0.5",
            "resolved": "https://registry.npmjs.org/sisteransi/-/sisteransi-1.0.5.tgz",
            "integrity": "sha512-bLGGlR1QxBcynn2d5YmDX4MGjlZvy2MRBDRNHLJ8VI6l6+9FUiyTFNJ0IveOSP0bcXgVDPRcfGqA0pjaqUpfVg==",
            "dev": true
          },
          "node_modules/slash": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
            "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/source-map": {
            "version": "0.6.1",
            "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
            "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/source-map-support": {
            "version": "0.5.13",
            "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.13.tgz",
            "integrity": "sha512-SHSKFHadjVA5oR4PPqhtAVdcBWwRYVd6g6cAXnIbRiIwc2EhPrTuKUBdSLvlEKyIP3GCf89fltvcZiP9MMFA1w==",
            "dev": true,
            "dependencies": {
              "buffer-from": "^1.0.0",
              "source-map": "^0.6.0"
            }
          },
          "node_modules/sprintf-js": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
            "integrity": "sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==",
            "dev": true
          },
          "node_modules/stack-utils": {
            "version": "2.0.6",
            "resolved": "https://registry.npmjs.org/stack-utils/-/stack-utils-2.0.6.tgz",
            "integrity": "sha512-XlkWvfIm6RmsWtNJx+uqtKLS8eqFbxUg0ZzLXqY0caEy9l7hruX8IpiDnjsLavoBgqCCR71TqWO8MaXYheJ3RQ==",
            "dev": true,
            "dependencies": {
              "escape-string-regexp": "^2.0.0"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/stack-utils/node_modules/escape-string-regexp": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-2.0.0.tgz",
            "integrity": "sha512-UpzcLCXolUWcNu5HtVMHYdXJjArjsF9C0aNnquZYY4uW/Vu0miy5YoWvbV345HauVvcAUnpRuhMMcqTcGOY2+w==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/statuses": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
            "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/string-length": {
            "version": "4.0.2",
            "resolved": "https://registry.npmjs.org/string-length/-/string-length-4.0.2.tgz",
            "integrity": "sha512-+l6rNN5fYHNhZZy41RXsYptCjA2Igmq4EG7kZAYFQI1E1VTXarr6ZPXBg6eq7Y6eK4FEhY6AJlyuFIb/v/S0VQ==",
            "dev": true,
            "dependencies": {
              "char-regex": "^1.0.2",
              "strip-ansi": "^6.0.0"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/string-width": {
            "version": "4.2.3",
            "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
            "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
            "dev": true,
            "dependencies": {
              "emoji-regex": "^8.0.0",
              "is-fullwidth-code-point": "^3.0.0",
              "strip-ansi": "^6.0.1"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/strip-ansi": {
            "version": "6.0.1",
            "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
            "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
            "dev": true,
            "dependencies": {
              "ansi-regex": "^5.0.1"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/strip-bom": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-4.0.0.tgz",
            "integrity": "sha512-3xurFv5tEgii33Zi8Jtp55wEIILR9eh34FAW00PZf+JnSsTmV/ioewSgQl97JHvgjoRGwPShsWm+IdrxB35d0w==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/strip-final-newline": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-2.0.0.tgz",
            "integrity": "sha512-BrpvfNAE3dcvq7ll3xVumzjKjZQ5tI1sEUIKr3Uoks0XUl45St3FlatVqef9prk4jRDzhW6WZg+3bk93y6pLjA==",
            "dev": true,
            "engines": {
              "node": "\u003E=6"
            }
          },
          "node_modules/strip-json-comments": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
            "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
            "dev": true,
            "engines": {
              "node": "\u003E=8"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/superagent": {
            "version": "9.0.2",
            "resolved": "https://registry.npmjs.org/superagent/-/superagent-9.0.2.tgz",
            "integrity": "sha512-xuW7dzkUpcJq7QnhOsnNUgtYp3xRwpt2F7abdRYIpCsAt0hhUqia0EdxyXZQQpNmGtsCzYHryaKSV3q3GJnq7w==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "component-emitter": "^1.3.0",
              "cookiejar": "^2.1.4",
              "debug": "^4.3.4",
              "fast-safe-stringify": "^2.1.1",
              "form-data": "^4.0.0",
              "formidable": "^3.5.1",
              "methods": "^1.1.2",
              "mime": "2.6.0",
              "qs": "^6.11.0"
            },
            "engines": {
              "node": "\u003E=14.18.0"
            }
          },
          "node_modules/supertest": {
            "version": "7.0.0",
            "resolved": "https://registry.npmjs.org/supertest/-/supertest-7.0.0.tgz",
            "integrity": "sha512-qlsr7fIC0lSddmA3tzojvzubYxvlGtzumcdHgPwbFWMISQwL22MhM2Y3LNt+6w9Yyx7559VW5ab70dgphm8qQA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "methods": "^1.1.2",
              "superagent": "^9.0.1"
            },
            "engines": {
              "node": "\u003E=14.18.0"
            }
          },
          "node_modules/supports-color": {
            "version": "7.2.0",
            "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
            "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
            "dev": true,
            "dependencies": {
              "has-flag": "^4.0.0"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/supports-preserve-symlinks-flag": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
            "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
            "dev": true,
            "engines": {
              "node": "\u003E= 0.4"
            },
            "funding": {
              "url": "https://github.com/sponsors/ljharb"
            }
          },
          "node_modules/test-exclude": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-6.0.0.tgz",
            "integrity": "sha512-cAGWPIyOHU6zlmg88jwm7VRyXnMN7iV68OGAbYDk/Mh/xC/pzVPlQtY6ngoIH/5/tciuhGfvESU8GrHrcxD56w==",
            "dev": true,
            "dependencies": {
              "@istanbuljs/schema": "^0.1.2",
              "glob": "^7.1.4",
              "minimatch": "^3.0.4"
            },
            "engines": {
              "node": "\u003E=8"
            }
          },
          "node_modules/text-table": {
            "version": "0.2.0",
            "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
            "integrity": "sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==",
            "dev": true
          },
          "node_modules/tmpl": {
            "version": "1.0.5",
            "resolved": "https://registry.npmjs.org/tmpl/-/tmpl-1.0.5.tgz",
            "integrity": "sha512-3f0uOEAQwIqGuWW2MVzYg8fV/QNnc/IpuJNG837rLuczAaLVHslWHZQj4IGiEl5Hs3kkbhwL9Ab7Hrsmuj+Smw==",
            "dev": true
          },
          "node_modules/to-regex-range": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
            "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
            "dev": true,
            "dependencies": {
              "is-number": "^7.0.0"
            },
            "engines": {
              "node": "\u003E=8.0"
            }
          },
          "node_modules/toidentifier": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
            "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
            "engines": {
              "node": "\u003E=0.6"
            }
          },
          "node_modules/ts-api-utils": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-1.3.0.tgz",
            "integrity": "sha512-UQMIo7pb8WRomKR1/+MFVLTroIvDVtMX3K6OUir8ynLyzB8Jeriont2bTAtmNPa1ekAgN7YPDyf6V+ygrdU+eQ==",
            "dev": true,
            "engines": {
              "node": "\u003E=16"
            },
            "peerDependencies": {
              "typescript": "\u003E=4.2.0"
            }
          },
          "node_modules/ts-jest": {
            "version": "29.2.5",
            "resolved": "https://registry.npmjs.org/ts-jest/-/ts-jest-29.2.5.tgz",
            "integrity": "sha512-KD8zB2aAZrcKIdGk4OwpJggeLcH1FgrICqDSROWqlnJXGCXK4Mn6FcdK2B6670Xr73lHMG1kHw8R87A0ecZ+vA==",
            "dev": true,
            "dependencies": {
              "bs-logger": "^0.2.6",
              "ejs": "^3.1.10",
              "fast-json-stable-stringify": "^2.1.0",
              "jest-util": "^29.0.0",
              "json5": "^2.2.3",
              "lodash.memoize": "^4.1.2",
              "make-error": "^1.3.6",
              "semver": "^7.6.3",
              "yargs-parser": "^21.1.1"
            },
            "bin": {
              "ts-jest": "cli.js"
            },
            "engines": {
              "node": "^14.15.0 || ^16.10.0 || ^18.0.0 || \u003E=20.0.0"
            },
            "peerDependencies": {
              "@babel/core": "\u003E=7.0.0-beta.0 \u003C8",
              "@jest/transform": "^29.0.0",
              "@jest/types": "^29.0.0",
              "babel-jest": "^29.0.0",
              "jest": "^29.0.0",
              "typescript": "\u003E=4.3 \u003C6"
            },
            "peerDependenciesMeta": {
              "@babel/core": {
                "optional": true
              },
              "@jest/transform": {
                "optional": true
              },
              "@jest/types": {
                "optional": true
              },
              "babel-jest": {
                "optional": true
              },
              "esbuild": {
                "optional": true
              }
            }
          },
          "node_modules/ts-jest/node_modules/semver": {
            "version": "7.6.3",
            "resolved": "https://registry.npmjs.org/semver/-/semver-7.6.3.tgz",
            "integrity": "sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==",
            "dev": true,
            "bin": {
              "semver": "bin/semver.js"
            },
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/tsx": {
            "version": "4.19.3",
            "resolved": "https://registry.npmjs.org/tsx/-/tsx-4.19.3.tgz",
            "integrity": "sha512-4H8vUNGNjQ4V2EOoGw005+c+dGuPSnhpPBPHBtsZdGZBk/iJb4kguGlPWaZTZ3q5nMtFOEsY0nRDlh9PJyd6SQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
              "esbuild": "~0.25.0",
              "get-tsconfig": "^4.7.5"
            },
            "bin": {
              "tsx": "dist/cli.mjs"
            },
            "engines": {
              "node": "\u003E=18.0.0"
            },
            "optionalDependencies": {
              "fsevents": "~2.3.3"
            }
          },
          "node_modules/type-check": {
            "version": "0.4.0",
            "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
            "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
            "dev": true,
            "dependencies": {
              "prelude-ls": "^1.2.1"
            },
            "engines": {
              "node": "\u003E= 0.8.0"
            }
          },
          "node_modules/type-detect": {
            "version": "4.0.8",
            "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz",
            "integrity": "sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==",
            "dev": true,
            "engines": {
              "node": "\u003E=4"
            }
          },
          "node_modules/type-fest": {
            "version": "0.21.3",
            "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.21.3.tgz",
            "integrity": "sha512-t0rzBq87m3fVcduHDUFhKmyyX+9eo6WQjZvf51Ea/M0Q7+T374Jp1aUiyUl0GKxp8M/OETVHSDvmkyPgvX+X2w==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/type-is": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/type-is/-/type-is-2.0.0.tgz",
            "integrity": "sha512-gd0sGezQYCbWSbkZr75mln4YBidWUN60+devscpLF5mtRDUpiaTvKpBNrdaCvel1NdR2k6vclXybU5fBd2i+nw==",
            "license": "MIT",
            "dependencies": {
              "content-type": "^1.0.5",
              "media-typer": "^1.1.0",
              "mime-types": "^3.0.0"
            },
            "engines": {
              "node": "\u003E= 0.6"
            }
          },
          "node_modules/typescript": {
            "version": "5.6.3",
            "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.6.3.tgz",
            "integrity": "sha512-hjcS1mhfuyi4WW8IWtjP7brDrG2cuDZukyrYrSauoXGNgx0S7zceP07adYkJycEr56BOUTNPzbInooiN3fn1qw==",
            "dev": true,
            "bin": {
              "tsc": "bin/tsc",
              "tsserver": "bin/tsserver"
            },
            "engines": {
              "node": "\u003E=14.17"
            }
          },
          "node_modules/typescript-eslint": {
            "version": "8.11.0",
            "resolved": "https://registry.npmjs.org/typescript-eslint/-/typescript-eslint-8.11.0.tgz",
            "integrity": "sha512-cBRGnW3FSlxaYwU8KfAewxFK5uzeOAp0l2KebIlPDOT5olVi65KDG/yjBooPBG0kGW/HLkoz1c/iuBFehcS3IA==",
            "dev": true,
            "dependencies": {
              "@typescript-eslint/eslint-plugin": "8.11.0",
              "@typescript-eslint/parser": "8.11.0",
              "@typescript-eslint/utils": "8.11.0"
            },
            "engines": {
              "node": "^18.18.0 || ^20.9.0 || \u003E=21.1.0"
            },
            "funding": {
              "type": "opencollective",
              "url": "https://opencollective.com/typescript-eslint"
            },
            "peerDependenciesMeta": {
              "typescript": {
                "optional": true
              }
            }
          },
          "node_modules/undici-types": {
            "version": "6.19.8",
            "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.19.8.tgz",
            "integrity": "sha512-ve2KP6f/JnbPBFyobGHuerC9g1FYGn/F8n1LWTwNxCEzd6IfqTwUQcNXgEtmmQ6DlRrC1hrSrBnCZPokRrDHjw==",
            "dev": true
          },
          "node_modules/unpipe": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
            "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/update-browserslist-db": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.1.tgz",
            "integrity": "sha512-R8UzCaa9Az+38REPiJ1tXlImTJXlVfgHZsglwBD/k6nj76ctsH1E3q4doGrukiLQd3sGQYu56r5+lo5r94l29A==",
            "dev": true,
            "funding": [
              {
                "type": "opencollective",
                "url": "https://opencollective.com/browserslist"
              },
              {
                "type": "tidelift",
                "url": "https://tidelift.com/funding/github/npm/browserslist"
              },
              {
                "type": "github",
                "url": "https://github.com/sponsors/ai"
              }
            ],
            "dependencies": {
              "escalade": "^3.2.0",
              "picocolors": "^1.1.0"
            },
            "bin": {
              "update-browserslist-db": "cli.js"
            },
            "peerDependencies": {
              "browserslist": "\u003E= 4.21.0"
            }
          },
          "node_modules/uri-js": {
            "version": "4.4.1",
            "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
            "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
            "license": "BSD-2-Clause",
            "dependencies": {
              "punycode": "^2.1.0"
            }
          },
          "node_modules/utils-merge": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
            "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
            "engines": {
              "node": "\u003E= 0.4.0"
            }
          },
          "node_modules/v8-to-istanbul": {
            "version": "9.3.0",
            "resolved": "https://registry.npmjs.org/v8-to-istanbul/-/v8-to-istanbul-9.3.0.tgz",
            "integrity": "sha512-kiGUalWN+rgBJ/1OHZsBtU4rXZOfj/7rKQxULKlIzwzQSvMJUUNgPwJEEh7gU6xEVxC0ahoOBvN2YI8GH6FNgA==",
            "dev": true,
            "dependencies": {
              "@jridgewell/trace-mapping": "^0.3.12",
              "@types/istanbul-lib-coverage": "^2.0.1",
              "convert-source-map": "^2.0.0"
            },
            "engines": {
              "node": "\u003E=10.12.0"
            }
          },
          "node_modules/vary": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
            "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
            "engines": {
              "node": "\u003E= 0.8"
            }
          },
          "node_modules/walker": {
            "version": "1.0.8",
            "resolved": "https://registry.npmjs.org/walker/-/walker-1.0.8.tgz",
            "integrity": "sha512-ts/8E8l5b7kY0vlWLewOkDXMmPdLcVV4GmOQLyxuSswIJsweeFZtAsMF7k1Nszz+TYBQrlYRmzOnr398y1JemQ==",
            "dev": true,
            "dependencies": {
              "makeerror": "1.0.12"
            }
          },
          "node_modules/which": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
            "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
            "dependencies": {
              "isexe": "^2.0.0"
            },
            "bin": {
              "node-which": "bin/node-which"
            },
            "engines": {
              "node": "\u003E= 8"
            }
          },
          "node_modules/word-wrap": {
            "version": "1.2.5",
            "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
            "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
            "dev": true,
            "engines": {
              "node": "\u003E=0.10.0"
            }
          },
          "node_modules/wrap-ansi": {
            "version": "7.0.0",
            "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
            "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
            "dev": true,
            "dependencies": {
              "ansi-styles": "^4.0.0",
              "string-width": "^4.1.0",
              "strip-ansi": "^6.0.0"
            },
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
            }
          },
          "node_modules/wrappy": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
            "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ=="
          },
          "node_modules/write-file-atomic": {
            "version": "4.0.2",
            "resolved": "https://registry.npmjs.org/write-file-atomic/-/write-file-atomic-4.0.2.tgz",
            "integrity": "sha512-7KxauUdBmSdWnmpaGFg+ppNjKF8uNLry8LyzjauQDOVONfFLNKrKvQOxZ/VuTIcS/gge/YNahf5RIIQWTSarlg==",
            "dev": true,
            "dependencies": {
              "imurmurhash": "^0.1.4",
              "signal-exit": "^3.0.7"
            },
            "engines": {
              "node": "^12.13.0 || ^14.15.0 || \u003E=16.0.0"
            }
          },
          "node_modules/ws": {
            "version": "8.18.0",
            "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.0.tgz",
            "integrity": "sha512-8VbfWfHLbbwu3+N6OKsOMpBdT4kXPDDB9cJk2bJ6mh9ucxdlnNvH1e+roYkKmN9Nxw2yjz7VzeO9oOz2zJ04Pw==",
            "dev": true,
            "engines": {
              "node": "\u003E=10.0.0"
            },
            "peerDependencies": {
              "bufferutil": "^4.0.1",
              "utf-8-validate": "\u003E=5.0.2"
            },
            "peerDependenciesMeta": {
              "bufferutil": {
                "optional": true
              },
              "utf-8-validate": {
                "optional": true
              }
            }
          },
          "node_modules/y18n": {
            "version": "5.0.8",
            "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
            "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            }
          },
          "node_modules/yallist": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
            "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
            "dev": true
          },
          "node_modules/yargs": {
            "version": "17.7.2",
            "resolved": "https://registry.npmjs.org/yargs/-/yargs-17.7.2.tgz",
            "integrity": "sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==",
            "dev": true,
            "dependencies": {
              "cliui": "^8.0.1",
              "escalade": "^3.1.1",
              "get-caller-file": "^2.0.5",
              "require-directory": "^2.1.1",
              "string-width": "^4.2.3",
              "y18n": "^5.0.5",
              "yargs-parser": "^21.1.1"
            },
            "engines": {
              "node": "\u003E=12"
            }
          },
          "node_modules/yargs-parser": {
            "version": "21.1.1",
            "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-21.1.1.tgz",
            "integrity": "sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==",
            "dev": true,
            "engines": {
              "node": "\u003E=12"
            }
          },
          "node_modules/yocto-queue": {
            "version": "0.1.0",
            "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
            "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
            "dev": true,
            "engines": {
              "node": "\u003E=10"
            },
            "funding": {
              "url": "https://github.com/sponsors/sindresorhus"
            }
          },
          "node_modules/zod": {
            "version": "3.24.1",
            "resolved": "https://registry.npmjs.org/zod/-/zod-3.24.1.tgz",
            "integrity": "sha512-muH7gBL9sI1nciMZV67X5fTKKBLtwpZ5VBp1vsOQzj1MhrBZ4wlVCm3gedKZWLp0Oyel8sIGfeiz54Su+OVT+A==",
            "license": "MIT",
            "funding": {
              "url": "https://github.com/sponsors/colinhacks"
            }
          },
          "node_modules/zod-to-json-schema": {
            "version": "3.24.1",
            "resolved": "https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.24.1.tgz",
            "integrity": "sha512-3h08nf3Vw3Wl3PK+q3ow/lIil81IT2Oa7YpQyUUDsEWbXveMesdfK1xBd2RhCkynwZndAxixji/7SYJJowr62w==",
            "license": "ISC",
            "peerDependencies": {
              "zod": "^3.24.1"
            }
          }
        }
      }
    },
    "/package.json": {
      "type": "content",
      "content": "{\n  \"name\": \"@modelcontextprotocol/sdk\",\n  \"version\": \"1.17.4\",\n  \"description\": \"Model Context Protocol implementation for TypeScript\",\n  \"license\": \"MIT\",\n  \"author\": \"Anthropic, PBC (https://anthropic.com)\",\n  \"homepage\": \"https://modelcontextprotocol.io\",\n  \"bugs\": \"https://github.com/modelcontextprotocol/typescript-sdk/issues\",\n  \"type\": \"module\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/modelcontextprotocol/typescript-sdk.git\"\n  },\n  \"engines\": {\n    \"node\": \"\u003E=18\"\n  },\n  \"keywords\": [\n    \"modelcontextprotocol\",\n    \"mcp\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/esm/index.js\",\n      \"require\": \"./dist/cjs/index.js\"\n    },\n    \"./client\": {\n      \"import\": \"./dist/esm/client/index.js\",\n      \"require\": \"./dist/cjs/client/index.js\"\n    },\n    \"./server\": {\n      \"import\": \"./dist/esm/server/index.js\",\n      \"require\": \"./dist/cjs/server/index.js\"\n    },\n    \"./*\": {\n      \"import\": \"./dist/esm/*\",\n      \"require\": \"./dist/cjs/*\"\n    }\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"*\": [\n        \"./dist/esm/*\"\n      ]\n    }\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"fetch:spec-types\": \"curl -o spec.types.ts https://raw.githubusercontent.com/modelcontextprotocol/modelcontextprotocol/refs/heads/main/schema/draft/schema.ts\",\n    \"build\": \"npm run build:esm && npm run build:cjs\",\n    \"build:esm\": \"mkdir -p dist/esm && echo '{\\\"type\\\": \\\"module\\\"}' \u003E dist/esm/package.json && tsc -p tsconfig.prod.json\",\n    \"build:esm:w\": \"npm run build:esm -- -w\",\n    \"build:cjs\": \"mkdir -p dist/cjs && echo '{\\\"type\\\": \\\"commonjs\\\"}' \u003E dist/cjs/package.json && tsc -p tsconfig.cjs.json\",\n    \"build:cjs:w\": \"npm run build:cjs -- -w\",\n    \"examples:simple-server:w\": \"tsx --watch src/examples/server/simpleStreamableHttp.ts --oauth\",\n    \"prepack\": \"npm run build:esm && npm run build:cjs\",\n    \"lint\": \"eslint src/\",\n    \"test\": \"npm run fetch:spec-types && jest\",\n    \"start\": \"npm run server\",\n    \"server\": \"tsx watch --clear-screen=false src/cli.ts server\",\n    \"client\": \"tsx src/cli.ts client\"\n  },\n  \"dependencies\": {\n    \"ajv\": \"^6.12.6\",\n    \"content-type\": \"^1.0.5\",\n    \"cors\": \"^2.8.5\",\n    \"cross-spawn\": \"^7.0.5\",\n    \"eventsource\": \"^3.0.2\",\n    \"eventsource-parser\": \"^3.0.0\",\n    \"express\": \"^5.0.1\",\n    \"express-rate-limit\": \"^7.5.0\",\n    \"pkce-challenge\": \"^5.0.0\",\n    \"raw-body\": \"^3.0.0\",\n    \"zod\": \"^3.23.8\",\n    \"zod-to-json-schema\": \"^3.24.1\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.8.0\",\n    \"@jest-mock/express\": \"^3.0.0\",\n    \"@types/content-type\": \"^1.1.8\",\n    \"@types/cors\": \"^2.8.17\",\n    \"@types/cross-spawn\": \"^6.0.6\",\n    \"@types/eslint__js\": \"^8.42.3\",\n    \"@types/eventsource\": \"^1.1.15\",\n    \"@types/express\": \"^5.0.0\",\n    \"@types/jest\": \"^29.5.12\",\n    \"@types/node\": \"^22.0.2\",\n    \"@types/supertest\": \"^6.0.2\",\n    \"@types/ws\": \"^8.5.12\",\n    \"eslint\": \"^9.8.0\",\n    \"jest\": \"^29.7.0\",\n    \"supertest\": \"^7.0.0\",\n    \"ts-jest\": \"^29.2.4\",\n    \"tsx\": \"^4.16.5\",\n    \"typescript\": \"^5.5.4\",\n    \"typescript-eslint\": \"^8.0.0\",\n    \"ws\": \"^8.18.0\"\n  },\n  \"resolutions\": {\n    \"strip-ansi\": \"6.0.1\"\n  }\n}",
      "hash": "59c13d0a3b09ea57e792b9efac5a7067b105f62ed0bb55fbe4a4b515334d89ea",
      "size": 3114,
      "json": {
        "name": "@modelcontextprotocol/sdk",
        "version": "1.17.4",
        "description": "Model Context Protocol implementation for TypeScript",
        "license": "MIT",
        "author": "Anthropic, PBC (https://anthropic.com)",
        "homepage": "https://modelcontextprotocol.io",
        "bugs": "https://github.com/modelcontextprotocol/typescript-sdk/issues",
        "type": "module",
        "repository": {
          "type": "git",
          "url": "git+https://github.com/modelcontextprotocol/typescript-sdk.git"
        },
        "engines": {
          "node": "\u003E=18"
        },
        "keywords": [
          "modelcontextprotocol",
          "mcp"
        ],
        "exports": {
          ".": {
            "import": "./dist/esm/index.js",
            "require": "./dist/cjs/index.js"
          },
          "./client": {
            "import": "./dist/esm/client/index.js",
            "require": "./dist/cjs/client/index.js"
          },
          "./server": {
            "import": "./dist/esm/server/index.js",
            "require": "./dist/cjs/server/index.js"
          },
          "./*": {
            "import": "./dist/esm/*",
            "require": "./dist/cjs/*"
          }
        },
        "typesVersions": {
          "*": {
            "*": [
              "./dist/esm/*"
            ]
          }
        },
        "files": [
          "dist"
        ],
        "scripts": {
          "fetch:spec-types": "curl -o spec.types.ts https://raw.githubusercontent.com/modelcontextprotocol/modelcontextprotocol/refs/heads/main/schema/draft/schema.ts",
          "build": "npm run build:esm && npm run build:cjs",
          "build:esm": "mkdir -p dist/esm && echo '{\"type\": \"module\"}' \u003E dist/esm/package.json && tsc -p tsconfig.prod.json",
          "build:esm:w": "npm run build:esm -- -w",
          "build:cjs": "mkdir -p dist/cjs && echo '{\"type\": \"commonjs\"}' \u003E dist/cjs/package.json && tsc -p tsconfig.cjs.json",
          "build:cjs:w": "npm run build:cjs -- -w",
          "examples:simple-server:w": "tsx --watch src/examples/server/simpleStreamableHttp.ts --oauth",
          "prepack": "npm run build:esm && npm run build:cjs",
          "lint": "eslint src/",
          "test": "npm run fetch:spec-types && jest",
          "start": "npm run server",
          "server": "tsx watch --clear-screen=false src/cli.ts server",
          "client": "tsx src/cli.ts client"
        },
        "dependencies": {
          "ajv": "^6.12.6",
          "content-type": "^1.0.5",
          "cors": "^2.8.5",
          "cross-spawn": "^7.0.5",
          "eventsource": "^3.0.2",
          "eventsource-parser": "^3.0.0",
          "express": "^5.0.1",
          "express-rate-limit": "^7.5.0",
          "pkce-challenge": "^5.0.0",
          "raw-body": "^3.0.0",
          "zod": "^3.23.8",
          "zod-to-json-schema": "^3.24.1"
        },
        "devDependencies": {
          "@eslint/js": "^9.8.0",
          "@jest-mock/express": "^3.0.0",
          "@types/content-type": "^1.1.8",
          "@types/cors": "^2.8.17",
          "@types/cross-spawn": "^6.0.6",
          "@types/eslint__js": "^8.42.3",
          "@types/eventsource": "^1.1.15",
          "@types/express": "^5.0.0",
          "@types/jest": "^29.5.12",
          "@types/node": "^22.0.2",
          "@types/supertest": "^6.0.2",
          "@types/ws": "^8.5.12",
          "eslint": "^9.8.0",
          "jest": "^29.7.0",
          "supertest": "^7.0.0",
          "ts-jest": "^29.2.4",
          "tsx": "^4.16.5",
          "typescript": "^5.5.4",
          "typescript-eslint": "^8.0.0",
          "ws": "^8.18.0"
        },
        "resolutions": {
          "strip-ansi": "6.0.1"
        }
      }
    },
    "/src/__mocks__/pkce-challenge.ts": {
      "type": "content",
      "content": "export default function pkceChallenge() {\n  return {\n    code_verifier: \"test_verifier\",\n    code_challenge: \"test_challenge\",\n  };\n}",
      "hash": "0e6f0088713818aad75f8b8bf93c878550159018316671a513fa8bcca45fbfad",
      "size": 133
    },
    "/src/cli.ts": {
      "type": "content",
      "content": "import WebSocket from \"ws\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(global as any).WebSocket = WebSocket;\n\nimport express from \"express\";\nimport { Client } from \"./client/index.js\";\nimport { SSEClientTransport } from \"./client/sse.js\";\nimport { StdioClientTransport } from \"./client/stdio.js\";\nimport { WebSocketClientTransport } from \"./client/websocket.js\";\nimport { Server } from \"./server/index.js\";\nimport { SSEServerTransport } from \"./server/sse.js\";\nimport { StdioServerTransport } from \"./server/stdio.js\";\nimport { ListResourcesResultSchema } from \"./types.js\";\n\nasync function runClient(url_or_command: string, args: string[]) {\n  const client = new Client(\n    {\n      name: \"mcp-typescript test client\",\n      version: \"0.1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  let clientTransport;\n\n  let url: URL | undefined = undefined;\n  try {\n    url = new URL(url_or_command);\n  } catch {\n    // Ignore\n  }\n\n  if (url?.protocol === \"http:\" || url?.protocol === \"https:\") {\n    clientTransport = new SSEClientTransport(new URL(url_or_command));\n  } else if (url?.protocol === \"ws:\" || url?.protocol === \"wss:\") {\n    clientTransport = new WebSocketClientTransport(new URL(url_or_command));\n  } else {\n    clientTransport = new StdioClientTransport({\n      command: url_or_command,\n      args,\n    });\n  }\n\n  console.log(\"Connected to server.\");\n\n  await client.connect(clientTransport);\n  console.log(\"Initialized.\");\n\n  await client.request({ method: \"resources/list\" }, ListResourcesResultSchema);\n\n  await client.close();\n  console.log(\"Closed.\");\n}\n\nasync function runServer(port: number | null) {\n  if (port !== null) {\n    const app = express();\n\n    let servers: Server[] = [];\n\n    app.get(\"/sse\", async (req, res) =\u003E {\n      console.log(\"Got new SSE connection\");\n\n      const transport = new SSEServerTransport(\"/message\", res);\n      const server = new Server(\n        {\n          name: \"mcp-typescript test server\",\n          version: \"0.1.0\",\n        },\n        {\n          capabilities: {},\n        },\n      );\n\n      servers.push(server);\n\n      server.onclose = () =\u003E {\n        console.log(\"SSE connection closed\");\n        servers = servers.filter((s) =\u003E s !== server);\n      };\n\n      await server.connect(transport);\n    });\n\n    app.post(\"/message\", async (req, res) =\u003E {\n      console.log(\"Received message\");\n\n      const sessionId = req.query.sessionId as string;\n      const transport = servers\n        .map((s) =\u003E s.transport as SSEServerTransport)\n        .find((t) =\u003E t.sessionId === sessionId);\n      if (!transport) {\n        res.status(404).send(\"Session not found\");\n        return;\n      }\n\n      await transport.handlePostMessage(req, res);\n    });\n\n    app.listen(port, (error) =\u003E {\n      if (error) {\n        console.error('Failed to start server:', error);\n        process.exit(1);\n      }\n      console.log(`Server running on http://localhost:${port}/sse`);\n    });\n  } else {\n    const server = new Server(\n      {\n        name: \"mcp-typescript test server\",\n        version: \"0.1.0\",\n      },\n      {\n        capabilities: {\n          prompts: {},\n          resources: {},\n          tools: {},\n          logging: {},\n        },\n      },\n    );\n\n    const transport = new StdioServerTransport();\n    await server.connect(transport);\n\n    console.log(\"Server running on stdio\");\n  }\n}\n\nconst args = process.argv.slice(2);\nconst command = args[0];\nswitch (command) {\n  case \"client\":\n    if (args.length \u003C 2) {\n      console.error(\"Usage: client \u003Cserver_url_or_command\u003E [args...]\");\n      process.exit(1);\n    }\n\n    runClient(args[1], args.slice(2)).catch((error) =\u003E {\n      console.error(error);\n      process.exit(1);\n    });\n\n    break;\n\n  case \"server\": {\n    const port = args[1] ? parseInt(args[1]) : null;\n    runServer(port).catch((error) =\u003E {\n      console.error(error);\n      process.exit(1);\n    });\n\n    break;\n  }\n\n  default:\n    console.error(\"Unrecognized command:\", command);\n}\n",
      "hash": "bcedd5dd0110b057487eca82eff181e9de1f9b8088bc4be6fb99e78dbddfdf3a",
      "size": 4005
    },
    "/src/client/auth.test.ts": {
      "type": "content",
      "content": "import { LATEST_PROTOCOL_VERSION } from '../types.js';\nimport {\n  discoverOAuthMetadata,\n  discoverAuthorizationServerMetadata,\n  buildDiscoveryUrls,\n  startAuthorization,\n  exchangeAuthorization,\n  refreshAuthorization,\n  registerClient,\n  discoverOAuthProtectedResourceMetadata,\n  extractResourceMetadataUrl,\n  auth,\n  type OAuthClientProvider,\n} from \"./auth.js\";\nimport {ServerError} from \"../server/auth/errors.js\";\nimport { AuthorizationServerMetadata } from '../shared/auth.js';\n\n// Mock fetch globally\nconst mockFetch = jest.fn();\nglobal.fetch = mockFetch;\n\ndescribe(\"OAuth Authorization\", () =\u003E {\n  beforeEach(() =\u003E {\n    mockFetch.mockReset();\n  });\n\n  describe(\"extractResourceMetadataUrl\", () =\u003E {\n    it(\"returns resource metadata url when present\", async () =\u003E {\n      const resourceUrl = \"https://resource.example.com/.well-known/oauth-protected-resource\"\n      const mockResponse = {\n        headers: {\n          get: jest.fn((name) =\u003E name === \"WWW-Authenticate\" ? `Bearer realm=\"mcp\", resource_metadata=\"${resourceUrl}\"` : null),\n        }\n      } as unknown as Response\n\n      expect(extractResourceMetadataUrl(mockResponse)).toEqual(new URL(resourceUrl));\n    });\n\n    it(\"returns undefined if not bearer\", async () =\u003E {\n      const resourceUrl = \"https://resource.example.com/.well-known/oauth-protected-resource\"\n      const mockResponse = {\n        headers: {\n          get: jest.fn((name) =\u003E name === \"WWW-Authenticate\" ? `Basic realm=\"mcp\", resource_metadata=\"${resourceUrl}\"` : null),\n        }\n      } as unknown as Response\n\n      expect(extractResourceMetadataUrl(mockResponse)).toBeUndefined();\n    });\n\n    it(\"returns undefined if resource_metadata not present\", async () =\u003E {\n      const mockResponse = {\n        headers: {\n          get: jest.fn((name) =\u003E name === \"WWW-Authenticate\" ? `Basic realm=\"mcp\"` : null),\n        }\n      } as unknown as Response\n\n      expect(extractResourceMetadataUrl(mockResponse)).toBeUndefined();\n    });\n\n    it(\"returns undefined on invalid url\", async () =\u003E {\n      const resourceUrl = \"invalid-url\"\n      const mockResponse = {\n        headers: {\n          get: jest.fn((name) =\u003E name === \"WWW-Authenticate\" ? `Basic realm=\"mcp\", resource_metadata=\"${resourceUrl}\"` : null),\n        }\n      } as unknown as Response\n\n      expect(extractResourceMetadataUrl(mockResponse)).toBeUndefined();\n    });\n  });\n\n  describe(\"discoverOAuthProtectedResourceMetadata\", () =\u003E {\n    const validMetadata = {\n      resource: \"https://resource.example.com\",\n      authorization_servers: [\"https://auth.example.com\"],\n    };\n\n    it(\"returns metadata when discovery succeeds\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthProtectedResourceMetadata(\"https://resource.example.com\");\n      expect(metadata).toEqual(validMetadata);\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1);\n      const [url] = calls[0];\n      expect(url.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource\");\n    });\n\n    it(\"returns metadata when first fetch fails but second without MCP header succeeds\", async () =\u003E {\n      // Set up a counter to control behavior\n      let callCount = 0;\n\n      // Mock implementation that changes behavior based on call count\n      mockFetch.mockImplementation((_url, _options) =\u003E {\n        callCount++;\n\n        if (callCount === 1) {\n          // First call with MCP header - fail with TypeError (simulating CORS error)\n          // We need to use TypeError specifically because that's what the implementation checks for\n          return Promise.reject(new TypeError(\"Network error\"));\n        } else {\n          // Second call without header - succeed\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E validMetadata\n          });\n        }\n      });\n\n      // Should succeed with the second call\n      const metadata = await discoverOAuthProtectedResourceMetadata(\"https://resource.example.com\");\n      expect(metadata).toEqual(validMetadata);\n\n      // Verify both calls were made\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n\n      // Verify first call had MCP header\n      expect(mockFetch.mock.calls[0][1]?.headers).toHaveProperty(\"MCP-Protocol-Version\");\n    });\n\n    it(\"throws an error when all fetch attempts fail\", async () =\u003E {\n      // Set up a counter to control behavior\n      let callCount = 0;\n\n      // Mock implementation that changes behavior based on call count\n      mockFetch.mockImplementation((_url, _options) =\u003E {\n        callCount++;\n\n        if (callCount === 1) {\n          // First call - fail with TypeError\n          return Promise.reject(new TypeError(\"First failure\"));\n        } else {\n          // Second call - fail with different error\n          return Promise.reject(new Error(\"Second failure\"));\n        }\n      });\n\n      // Should fail with the second error\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com\"))\n        .rejects.toThrow(\"Second failure\");\n\n      // Verify both calls were made\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n    });\n\n    it(\"throws on 404 errors\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com\"))\n        .rejects.toThrow(\"Resource server does not implement OAuth 2.0 Protected Resource Metadata.\");\n    });\n\n    it(\"throws on non-404 errors\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 500,\n      });\n\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com\"))\n        .rejects.toThrow(\"HTTP 500\");\n    });\n\n    it(\"validates metadata schema\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          // Missing required fields\n          scopes_supported: [\"email\", \"mcp\"],\n        }),\n      });\n\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com\"))\n        .rejects.toThrow();\n    });\n\n    it(\"returns metadata when discovery succeeds with path\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthProtectedResourceMetadata(\"https://resource.example.com/path/name\");\n      expect(metadata).toEqual(validMetadata);\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1);\n      const [url] = calls[0];\n      expect(url.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource/path/name\");\n    });\n\n    it(\"preserves query parameters in path-aware discovery\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthProtectedResourceMetadata(\"https://resource.example.com/path?param=value\");\n      expect(metadata).toEqual(validMetadata);\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1);\n      const [url] = calls[0];\n      expect(url.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource/path?param=value\");\n    });\n\n    it.each([400, 401, 403, 404, 410, 422, 429])(\"falls back to root discovery when path-aware discovery returns %d\", async (statusCode) =\u003E {\n      // First call (path-aware) returns 4xx\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: statusCode,\n      });\n\n      // Second call (root fallback) succeeds\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthProtectedResourceMetadata(\"https://resource.example.com/path/name\");\n      expect(metadata).toEqual(validMetadata);\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(2);\n\n      // First call should be path-aware\n      const [firstUrl, firstOptions] = calls[0];\n      expect(firstUrl.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource/path/name\");\n      expect(firstOptions.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n\n      // Second call should be root fallback\n      const [secondUrl, secondOptions] = calls[1];\n      expect(secondUrl.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource\");\n      expect(secondOptions.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n    });\n\n    it(\"throws error when both path-aware and root discovery return 404\", async () =\u003E {\n      // First call (path-aware) returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      // Second call (root fallback) also returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com/path/name\"))\n        .rejects.toThrow(\"Resource server does not implement OAuth 2.0 Protected Resource Metadata.\");\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(2);\n    });\n\n    it(\"throws error on 500 status and does not fallback\", async () =\u003E {\n      // First call (path-aware) returns 500\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 500,\n      });\n\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com/path/name\"))\n        .rejects.toThrow();\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1); // Should not attempt fallback\n    });\n\n    it(\"does not fallback when the original URL is already at root path\", async () =\u003E {\n      // First call (path-aware for root) returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com/\"))\n        .rejects.toThrow(\"Resource server does not implement OAuth 2.0 Protected Resource Metadata.\");\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1); // Should not attempt fallback\n\n      const [url] = calls[0];\n      expect(url.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource\");\n    });\n\n    it(\"does not fallback when the original URL has no path\", async () =\u003E {\n      // First call (path-aware for no path) returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com\"))\n        .rejects.toThrow(\"Resource server does not implement OAuth 2.0 Protected Resource Metadata.\");\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1); // Should not attempt fallback\n\n      const [url] = calls[0];\n      expect(url.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource\");\n    });\n\n    it(\"falls back when path-aware discovery encounters CORS error\", async () =\u003E {\n      // First call (path-aware) fails with TypeError (CORS)\n      mockFetch.mockImplementationOnce(() =\u003E Promise.reject(new TypeError(\"CORS error\")));\n\n      // Retry path-aware without headers (simulating CORS retry)\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      // Second call (root fallback) succeeds\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthProtectedResourceMetadata(\"https://resource.example.com/deep/path\");\n      expect(metadata).toEqual(validMetadata);\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(3);\n\n      // Final call should be root fallback\n      const [lastUrl, lastOptions] = calls[2];\n      expect(lastUrl.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource\");\n      expect(lastOptions.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n    });\n\n    it(\"does not fallback when resourceMetadataUrl is provided\", async () =\u003E {\n      // Call with explicit URL returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      await expect(discoverOAuthProtectedResourceMetadata(\"https://resource.example.com/path\", {\n        resourceMetadataUrl: \"https://custom.example.com/metadata\"\n      })).rejects.toThrow(\"Resource server does not implement OAuth 2.0 Protected Resource Metadata.\");\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1); // Should not attempt fallback when explicit URL is provided\n\n      const [url] = calls[0];\n      expect(url.toString()).toBe(\"https://custom.example.com/metadata\");\n    });\n\n    it(\"supports overriding the fetch function used for requests\", async () =\u003E {\n      const validMetadata = {\n        resource: \"https://resource.example.com\",\n        authorization_servers: [\"https://auth.example.com\"],\n      };\n\n      const customFetch = jest.fn().mockResolvedValue({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthProtectedResourceMetadata(\n        \"https://resource.example.com\",\n        undefined,\n        customFetch\n      );\n\n      expect(metadata).toEqual(validMetadata);\n      expect(customFetch).toHaveBeenCalledTimes(1);\n      expect(mockFetch).not.toHaveBeenCalled();\n\n      const [url, options] = customFetch.mock.calls[0];\n      expect(url.toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource\");\n      expect(options.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n    });\n  });\n\n  describe(\"discoverOAuthMetadata\", () =\u003E {\n    const validMetadata = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/authorize\",\n      token_endpoint: \"https://auth.example.com/token\",\n      registration_endpoint: \"https://auth.example.com/register\",\n      response_types_supported: [\"code\"],\n      code_challenge_methods_supported: [\"S256\"],\n    };\n\n    it(\"returns metadata when discovery succeeds\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com\");\n      expect(metadata).toEqual(validMetadata);\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1);\n      const [url, options] = calls[0];\n      expect(url.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n      expect(options.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n    });\n\n    it(\"returns metadata when discovery succeeds with path\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com/path/name\");\n      expect(metadata).toEqual(validMetadata);\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1);\n      const [url, options] = calls[0];\n      expect(url.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server/path/name\");\n      expect(options.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n    });\n\n    it(\"falls back to root discovery when path-aware discovery returns 404\", async () =\u003E {\n      // First call (path-aware) returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      // Second call (root fallback) succeeds\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com/path/name\");\n      expect(metadata).toEqual(validMetadata);\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(2);\n\n      // First call should be path-aware\n      const [firstUrl, firstOptions] = calls[0];\n      expect(firstUrl.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server/path/name\");\n      expect(firstOptions.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n\n      // Second call should be root fallback\n      const [secondUrl, secondOptions] = calls[1];\n      expect(secondUrl.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n      expect(secondOptions.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n    });\n\n    it(\"returns undefined when both path-aware and root discovery return 404\", async () =\u003E {\n      // First call (path-aware) returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      // Second call (root fallback) also returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com/path/name\");\n      expect(metadata).toBeUndefined();\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(2);\n    });\n\n    it(\"does not fallback when the original URL is already at root path\", async () =\u003E {\n      // First call (path-aware for root) returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com/\");\n      expect(metadata).toBeUndefined();\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1); // Should not attempt fallback\n\n      const [url] = calls[0];\n      expect(url.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n    });\n\n    it(\"does not fallback when the original URL has no path\", async () =\u003E {\n      // First call (path-aware for no path) returns 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com\");\n      expect(metadata).toBeUndefined();\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1); // Should not attempt fallback\n\n      const [url] = calls[0];\n      expect(url.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n    });\n\n    it(\"falls back when path-aware discovery encounters CORS error\", async () =\u003E {\n      // First call (path-aware) fails with TypeError (CORS)\n      mockFetch.mockImplementationOnce(() =\u003E Promise.reject(new TypeError(\"CORS error\")));\n\n      // Retry path-aware without headers (simulating CORS retry)\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      // Second call (root fallback) succeeds\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com/deep/path\");\n      expect(metadata).toEqual(validMetadata);\n\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(3);\n\n      // Final call should be root fallback\n      const [lastUrl, lastOptions] = calls[2];\n      expect(lastUrl.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n      expect(lastOptions.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n    });\n\n    it(\"returns metadata when first fetch fails but second without MCP header succeeds\", async () =\u003E {\n      // Set up a counter to control behavior\n      let callCount = 0;\n\n      // Mock implementation that changes behavior based on call count\n      mockFetch.mockImplementation((_url, _options) =\u003E {\n        callCount++;\n\n        if (callCount === 1) {\n          // First call with MCP header - fail with TypeError (simulating CORS error)\n          // We need to use TypeError specifically because that's what the implementation checks for\n          return Promise.reject(new TypeError(\"Network error\"));\n        } else {\n          // Second call without header - succeed\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E validMetadata\n          });\n        }\n      });\n\n      // Should succeed with the second call\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com\");\n      expect(metadata).toEqual(validMetadata);\n\n      // Verify both calls were made\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n\n      // Verify first call had MCP header\n      expect(mockFetch.mock.calls[0][1]?.headers).toHaveProperty(\"MCP-Protocol-Version\");\n    });\n\n    it(\"throws an error when all fetch attempts fail\", async () =\u003E {\n      // Set up a counter to control behavior\n      let callCount = 0;\n\n      // Mock implementation that changes behavior based on call count\n      mockFetch.mockImplementation((_url, _options) =\u003E {\n        callCount++;\n\n        if (callCount === 1) {\n          // First call - fail with TypeError\n          return Promise.reject(new TypeError(\"First failure\"));\n        } else {\n          // Second call - fail with different error\n          return Promise.reject(new Error(\"Second failure\"));\n        }\n      });\n\n      // Should fail with the second error\n      await expect(discoverOAuthMetadata(\"https://auth.example.com\"))\n        .rejects.toThrow(\"Second failure\");\n\n      // Verify both calls were made\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n    });\n\n    it(\"returns undefined when both CORS requests fail in fetchWithCorsRetry\", async () =\u003E {\n      // fetchWithCorsRetry tries with headers (fails with CORS), then retries without headers (also fails with CORS)\n      // simulating a 404 w/o headers set. We want this to return undefined, not throw TypeError\n      mockFetch.mockImplementation(() =\u003E {\n        // Both the initial request with headers and retry without headers fail with CORS TypeError\n        return Promise.reject(new TypeError(\"Failed to fetch\"));\n      });\n\n      // This should return undefined (the desired behavior after the fix)\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com/path\");\n      expect(metadata).toBeUndefined();\n    });\n\n    it(\"returns undefined when discovery endpoint returns 404\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com\");\n      expect(metadata).toBeUndefined();\n    });\n\n    it(\"throws on non-404 errors\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce(new Response(null, { status: 500 }));\n\n      await expect(\n        discoverOAuthMetadata(\"https://auth.example.com\")\n      ).rejects.toThrow(\"HTTP 500\");\n    });\n\n    it(\"validates metadata schema\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce(\n        Response.json(\n          {\n            // Missing required fields\n            issuer: \"https://auth.example.com\",\n          },\n          { status: 200 }\n        )\n      );\n\n      await expect(\n        discoverOAuthMetadata(\"https://auth.example.com\")\n      ).rejects.toThrow();\n    });\n\n    it(\"supports overriding the fetch function used for requests\", async () =\u003E {\n      const validMetadata = {\n        issuer: \"https://auth.example.com\",\n        authorization_endpoint: \"https://auth.example.com/authorize\",\n        token_endpoint: \"https://auth.example.com/token\",\n        registration_endpoint: \"https://auth.example.com/register\",\n        response_types_supported: [\"code\"],\n        code_challenge_methods_supported: [\"S256\"],\n      };\n\n      const customFetch = jest.fn().mockResolvedValue({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validMetadata,\n      });\n\n      const metadata = await discoverOAuthMetadata(\n        \"https://auth.example.com\",\n        {},\n        customFetch\n      );\n\n      expect(metadata).toEqual(validMetadata);\n      expect(customFetch).toHaveBeenCalledTimes(1);\n      expect(mockFetch).not.toHaveBeenCalled();\n\n      const [url, options] = customFetch.mock.calls[0];\n      expect(url.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n      expect(options.headers).toEqual({\n        \"MCP-Protocol-Version\": LATEST_PROTOCOL_VERSION\n      });\n    });\n  });\n\n  describe(\"buildDiscoveryUrls\", () =\u003E {\n    it(\"generates correct URLs for server without path\", () =\u003E {\n      const urls = buildDiscoveryUrls(\"https://auth.example.com\");\n\n      expect(urls).toHaveLength(2);\n      expect(urls.map(u =\u003E ({ url: u.url.toString(), type: u.type }))).toEqual([\n        {\n          url: \"https://auth.example.com/.well-known/oauth-authorization-server\",\n          type: \"oauth\"\n        },\n        {\n          url: \"https://auth.example.com/.well-known/openid-configuration\",\n          type: \"oidc\"\n        }\n      ]);\n    });\n\n    it(\"generates correct URLs for server with path\", () =\u003E {\n      const urls = buildDiscoveryUrls(\"https://auth.example.com/tenant1\");\n\n      expect(urls).toHaveLength(4);\n      expect(urls.map(u =\u003E ({ url: u.url.toString(), type: u.type }))).toEqual([\n        {\n          url: \"https://auth.example.com/.well-known/oauth-authorization-server/tenant1\",\n          type: \"oauth\"\n        },\n        {\n          url: \"https://auth.example.com/.well-known/oauth-authorization-server\",\n          type: \"oauth\"\n        },\n        {\n          url: \"https://auth.example.com/.well-known/openid-configuration/tenant1\",\n          type: \"oidc\"\n        },\n        {\n          url: \"https://auth.example.com/tenant1/.well-known/openid-configuration\",\n          type: \"oidc\"\n        }\n      ]);\n    });\n\n    it(\"handles URL object input\", () =\u003E {\n      const urls = buildDiscoveryUrls(new URL(\"https://auth.example.com/tenant1\"));\n\n      expect(urls).toHaveLength(4);\n      expect(urls[0].url.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server/tenant1\");\n    });\n  });\n\n  describe(\"discoverAuthorizationServerMetadata\", () =\u003E {\n    const validOAuthMetadata = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/authorize\",\n      token_endpoint: \"https://auth.example.com/token\",\n      registration_endpoint: \"https://auth.example.com/register\",\n      response_types_supported: [\"code\"],\n      code_challenge_methods_supported: [\"S256\"],\n    };\n\n    const validOpenIdMetadata = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/authorize\",\n      token_endpoint: \"https://auth.example.com/token\",\n      jwks_uri: \"https://auth.example.com/jwks\",\n      subject_types_supported: [\"public\"],\n      id_token_signing_alg_values_supported: [\"RS256\"],\n      response_types_supported: [\"code\"],\n      code_challenge_methods_supported: [\"S256\"],\n    };\n\n    it(\"tries URLs in order and returns first successful metadata\", async () =\u003E {\n      // First OAuth URL fails with 404\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      // Second OAuth URL (root) succeeds\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validOAuthMetadata,\n      });\n\n      const metadata = await discoverAuthorizationServerMetadata(\n        \"https://auth.example.com/tenant1\"\n      );\n\n      expect(metadata).toEqual(validOAuthMetadata);\n\n      // Verify it tried the URLs in the correct order\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(2);\n      expect(calls[0][0].toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server/tenant1\");\n      expect(calls[1][0].toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n    });\n\n    it(\"throws error when OIDC provider does not support S256 PKCE\", async () =\u003E {\n      // OAuth discovery fails\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      // OpenID Connect discovery succeeds but without S256 support\n      const invalidOpenIdMetadata = {\n        ...validOpenIdMetadata,\n        code_challenge_methods_supported: [\"plain\"], // Missing S256\n      };\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E invalidOpenIdMetadata,\n      });\n\n      await expect(\n        discoverAuthorizationServerMetadata(\n          \"https://auth.example.com\"\n        )\n      ).rejects.toThrow(\"does not support S256 code challenge method required by MCP specification\");\n    });\n\n    it(\"continues on 4xx errors\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 400,\n      });\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validOpenIdMetadata,\n      });\n\n      const metadata = await discoverAuthorizationServerMetadata(\"https://mcp.example.com\");\n\n      expect(metadata).toEqual(validOpenIdMetadata);\n\n    });\n\n    it(\"throws on non-4xx errors\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 500,\n      });\n\n      await expect(\n        discoverAuthorizationServerMetadata(\"https://mcp.example.com\")\n      ).rejects.toThrow(\"HTTP 500\");\n    });\n\n    it(\"handles CORS errors with retry\", async () =\u003E {\n      // First call fails with CORS\n      mockFetch.mockImplementationOnce(() =\u003E Promise.reject(new TypeError(\"CORS error\")));\n\n      // Retry without headers succeeds\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validOAuthMetadata,\n      });\n\n      const metadata = await discoverAuthorizationServerMetadata(\n        \"https://auth.example.com\"\n      );\n\n      expect(metadata).toEqual(validOAuthMetadata);\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(2);\n\n      // First call should have headers\n      expect(calls[0][1]?.headers).toHaveProperty(\"MCP-Protocol-Version\");\n\n      // Second call should not have headers (CORS retry)\n      expect(calls[1][1]?.headers).toBeUndefined();\n    });\n\n    it(\"supports custom fetch function\", async () =\u003E {\n      const customFetch = jest.fn().mockResolvedValue({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validOAuthMetadata,\n      });\n\n      const metadata = await discoverAuthorizationServerMetadata(\n        \"https://auth.example.com\",\n        { fetchFn: customFetch }\n      );\n\n      expect(metadata).toEqual(validOAuthMetadata);\n      expect(customFetch).toHaveBeenCalledTimes(1);\n      expect(mockFetch).not.toHaveBeenCalled();\n    });\n\n    it(\"supports custom protocol version\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validOAuthMetadata,\n      });\n\n      const metadata = await discoverAuthorizationServerMetadata(\n        \"https://auth.example.com\",\n        { protocolVersion: \"2025-01-01\" }\n      );\n\n      expect(metadata).toEqual(validOAuthMetadata);\n      const calls = mockFetch.mock.calls;\n      const [, options] = calls[0];\n      expect(options.headers).toEqual({\n        \"MCP-Protocol-Version\": \"2025-01-01\"\n      });\n    });\n\n    it(\"returns undefined when all URLs fail with CORS errors\", async () =\u003E {\n      // All fetch attempts fail with CORS errors (TypeError)\n      mockFetch.mockImplementation(() =\u003E Promise.reject(new TypeError(\"CORS error\")));\n\n      const metadata = await discoverAuthorizationServerMetadata(\"https://auth.example.com/tenant1\");\n\n      expect(metadata).toBeUndefined();\n\n      // Verify that all discovery URLs were attempted\n      expect(mockFetch).toHaveBeenCalledTimes(8); // 4 URLs × 2 attempts each (with and without headers)\n    });\n  });\n\n  describe(\"startAuthorization\", () =\u003E {\n    const validMetadata = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/auth\",\n      token_endpoint: \"https://auth.example.com/tkn\",\n      response_types_supported: [\"code\"],\n      code_challenge_methods_supported: [\"S256\"],\n    };\n\n    const validClientInfo = {\n      client_id: \"client123\",\n      client_secret: \"secret123\",\n      redirect_uris: [\"http://localhost:3000/callback\"],\n      client_name: \"Test Client\",\n    };\n\n    it(\"generates authorization URL with PKCE challenge\", async () =\u003E {\n      const { authorizationUrl, codeVerifier } = await startAuthorization(\n        \"https://auth.example.com\",\n        {\n          metadata: undefined,\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n          resource: new URL(\"https://api.example.com/mcp-server\"),\n        }\n      );\n\n      expect(authorizationUrl.toString()).toMatch(\n        /^https:\\/\\/auth\\.example\\.com\\/authorize\\?/\n      );\n      expect(authorizationUrl.searchParams.get(\"response_type\")).toBe(\"code\");\n      expect(authorizationUrl.searchParams.get(\"code_challenge\")).toBe(\"test_challenge\");\n      expect(authorizationUrl.searchParams.get(\"code_challenge_method\")).toBe(\n        \"S256\"\n      );\n      expect(authorizationUrl.searchParams.get(\"redirect_uri\")).toBe(\n        \"http://localhost:3000/callback\"\n      );\n      expect(authorizationUrl.searchParams.get(\"resource\")).toBe(\"https://api.example.com/mcp-server\");\n      expect(codeVerifier).toBe(\"test_verifier\");\n    });\n\n    it(\"includes scope parameter when provided\", async () =\u003E {\n      const { authorizationUrl } = await startAuthorization(\n        \"https://auth.example.com\",\n        {\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n          scope: \"read write profile\",\n        }\n      );\n\n      expect(authorizationUrl.searchParams.get(\"scope\")).toBe(\"read write profile\");\n    });\n\n    it(\"excludes scope parameter when not provided\", async () =\u003E {\n      const { authorizationUrl } = await startAuthorization(\n        \"https://auth.example.com\",\n        {\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        }\n      );\n\n      expect(authorizationUrl.searchParams.has(\"scope\")).toBe(false);\n    });\n\n    it(\"includes state parameter when provided\", async () =\u003E {\n      const { authorizationUrl } = await startAuthorization(\n        \"https://auth.example.com\",\n        {\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n          state: \"foobar\",\n        }\n      );\n\n      expect(authorizationUrl.searchParams.get(\"state\")).toBe(\"foobar\");\n    });\n\n    it(\"excludes state parameter when not provided\", async () =\u003E {\n      const { authorizationUrl } = await startAuthorization(\n        \"https://auth.example.com\",\n        {\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        }\n      );\n\n      expect(authorizationUrl.searchParams.has(\"state\")).toBe(false);\n    });\n\n    // OpenID Connect requires that the user is prompted for consent if the scope includes 'offline_access'\n    it(\"includes consent prompt parameter if scope includes 'offline_access'\", async () =\u003E {\n      const { authorizationUrl } = await startAuthorization(\n          \"https://auth.example.com\",\n          {\n            clientInformation: validClientInfo,\n            redirectUrl: \"http://localhost:3000/callback\",\n            scope: \"read write profile offline_access\",\n          }\n      );\n\n      expect(authorizationUrl.searchParams.get(\"prompt\")).toBe(\"consent\");\n    });\n\n    it(\"uses metadata authorization_endpoint when provided\", async () =\u003E {\n      const { authorizationUrl } = await startAuthorization(\n        \"https://auth.example.com\",\n        {\n          metadata: validMetadata,\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        }\n      );\n\n      expect(authorizationUrl.toString()).toMatch(\n        /^https:\\/\\/auth\\.example\\.com\\/auth\\?/\n      );\n    });\n\n    it(\"validates response type support\", async () =\u003E {\n      const metadata = {\n        ...validMetadata,\n        response_types_supported: [\"token\"], // Does not support 'code'\n      };\n\n      await expect(\n        startAuthorization(\"https://auth.example.com\", {\n          metadata,\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        })\n      ).rejects.toThrow(/does not support response type/);\n    });\n\n    it(\"validates PKCE support\", async () =\u003E {\n      const metadata = {\n        ...validMetadata,\n        response_types_supported: [\"code\"],\n        code_challenge_methods_supported: [\"plain\"], // Does not support 'S256'\n      };\n\n      await expect(\n        startAuthorization(\"https://auth.example.com\", {\n          metadata,\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        })\n      ).rejects.toThrow(/does not support code challenge method/);\n    });\n  });\n\n  describe(\"exchangeAuthorization\", () =\u003E {\n    const validTokens = {\n      access_token: \"access123\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n      refresh_token: \"refresh123\",\n    };\n\n    const validMetadata = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/authorize\",\n      token_endpoint: \"https://auth.example.com/token\",\n      response_types_supported: [\"code\"]\n    };\n\n    const validClientInfo = {\n      client_id: \"client123\",\n      client_secret: \"secret123\",\n      redirect_uris: [\"http://localhost:3000/callback\"],\n      client_name: \"Test Client\",\n    };\n\n    it(\"exchanges code for tokens\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await exchangeAuthorization(\"https://auth.example.com\", {\n        clientInformation: validClientInfo,\n        authorizationCode: \"code123\",\n        codeVerifier: \"verifier123\",\n        redirectUri: \"http://localhost:3000/callback\",\n        resource: new URL(\"https://api.example.com/mcp-server\"),\n      });\n\n      expect(tokens).toEqual(validTokens);\n      expect(mockFetch).toHaveBeenCalledWith(\n        expect.objectContaining({\n          href: \"https://auth.example.com/token\",\n        }),\n        expect.objectContaining({\n          method: \"POST\",\n          headers: new Headers({\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          }),\n        })\n      );\n\n      const body = mockFetch.mock.calls[0][1].body as URLSearchParams;\n      expect(body.get(\"grant_type\")).toBe(\"authorization_code\");\n      expect(body.get(\"code\")).toBe(\"code123\");\n      expect(body.get(\"code_verifier\")).toBe(\"verifier123\");\n      expect(body.get(\"client_id\")).toBe(\"client123\");\n      expect(body.get(\"client_secret\")).toBe(\"secret123\");\n      expect(body.get(\"redirect_uri\")).toBe(\"http://localhost:3000/callback\");\n      expect(body.get(\"resource\")).toBe(\"https://api.example.com/mcp-server\");\n    });\n\n    it(\"exchanges code for tokens with auth\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await exchangeAuthorization(\"https://auth.example.com\", {\n        metadata: validMetadata,\n        clientInformation: validClientInfo,\n        authorizationCode: \"code123\",\n        codeVerifier: \"verifier123\",\n        redirectUri: \"http://localhost:3000/callback\",\n        addClientAuthentication: (headers: Headers, params: URLSearchParams, url: string | URL, metadata: AuthorizationServerMetadata) =\u003E {\n          headers.set(\"Authorization\", \"Basic \" + btoa(validClientInfo.client_id + \":\" + validClientInfo.client_secret));\n          params.set(\"example_url\", typeof url === 'string' ? url : url.toString());\n          params.set(\"example_metadata\", metadata.authorization_endpoint);\n          params.set(\"example_param\", \"example_value\");\n        },\n      });\n\n      expect(tokens).toEqual(validTokens);\n      expect(mockFetch).toHaveBeenCalledWith(\n        expect.objectContaining({\n          href: \"https://auth.example.com/token\",\n        }),\n        expect.objectContaining({\n          method: \"POST\",\n        })\n      );\n\n      const headers = mockFetch.mock.calls[0][1].headers as Headers;\n      expect(headers.get(\"Content-Type\")).toBe(\"application/x-www-form-urlencoded\");\n      expect(headers.get(\"Authorization\")).toBe(\"Basic Y2xpZW50MTIzOnNlY3JldDEyMw==\");\n      const body = mockFetch.mock.calls[0][1].body as URLSearchParams;\n      expect(body.get(\"grant_type\")).toBe(\"authorization_code\");\n      expect(body.get(\"code\")).toBe(\"code123\");\n      expect(body.get(\"code_verifier\")).toBe(\"verifier123\");\n      expect(body.get(\"client_id\")).toBeNull();\n      expect(body.get(\"redirect_uri\")).toBe(\"http://localhost:3000/callback\");\n      expect(body.get(\"example_url\")).toBe(\"https://auth.example.com\");\n      expect(body.get(\"example_metadata\")).toBe(\"https://auth.example.com/authorize\");\n      expect(body.get(\"example_param\")).toBe(\"example_value\");\n      expect(body.get(\"client_secret\")).toBeNull();\n    });\n\n    it(\"validates token response schema\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          // Missing required fields\n          access_token: \"access123\",\n        }),\n      });\n\n      await expect(\n        exchangeAuthorization(\"https://auth.example.com\", {\n          clientInformation: validClientInfo,\n          authorizationCode: \"code123\",\n          codeVerifier: \"verifier123\",\n          redirectUri: \"http://localhost:3000/callback\",\n        })\n      ).rejects.toThrow();\n    });\n\n    it(\"throws on error response\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce(\n        Response.json(\n          new ServerError(\"Token exchange failed\").toResponseObject(),\n          { status: 400 }\n        )\n      );\n\n      await expect(\n        exchangeAuthorization(\"https://auth.example.com\", {\n          clientInformation: validClientInfo,\n          authorizationCode: \"code123\",\n          codeVerifier: \"verifier123\",\n          redirectUri: \"http://localhost:3000/callback\",\n        })\n      ).rejects.toThrow(\"Token exchange failed\");\n    });\n\n    it(\"supports overriding the fetch function used for requests\", async () =\u003E {\n      const customFetch = jest.fn().mockResolvedValue({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await exchangeAuthorization(\"https://auth.example.com\", {\n        clientInformation: validClientInfo,\n        authorizationCode: \"code123\",\n        codeVerifier: \"verifier123\",\n        redirectUri: \"http://localhost:3000/callback\",\n        resource: new URL(\"https://api.example.com/mcp-server\"),\n        fetchFn: customFetch,\n      });\n\n      expect(tokens).toEqual(validTokens);\n      expect(customFetch).toHaveBeenCalledTimes(1);\n      expect(mockFetch).not.toHaveBeenCalled();\n\n      const [url, options] = customFetch.mock.calls[0];\n      expect(url.toString()).toBe(\"https://auth.example.com/token\");\n      expect(options).toEqual(\n        expect.objectContaining({\n          method: \"POST\",\n          headers: expect.any(Headers),\n          body: expect.any(URLSearchParams),\n        })\n      );\n\n      const body = options.body as URLSearchParams;\n      expect(body.get(\"grant_type\")).toBe(\"authorization_code\");\n      expect(body.get(\"code\")).toBe(\"code123\");\n      expect(body.get(\"code_verifier\")).toBe(\"verifier123\");\n      expect(body.get(\"client_id\")).toBe(\"client123\");\n      expect(body.get(\"client_secret\")).toBe(\"secret123\");\n      expect(body.get(\"redirect_uri\")).toBe(\"http://localhost:3000/callback\");\n      expect(body.get(\"resource\")).toBe(\"https://api.example.com/mcp-server\");\n    });\n  });\n\n  describe(\"refreshAuthorization\", () =\u003E {\n    const validTokens = {\n      access_token: \"newaccess123\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    }\n    const validTokensWithNewRefreshToken = {\n      ...validTokens,\n      refresh_token: \"newrefresh123\",\n    };\n\n    const validMetadata = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/authorize\",\n      token_endpoint: \"https://auth.example.com/token\",\n      response_types_supported: [\"code\"]\n    };\n\n    const validClientInfo = {\n      client_id: \"client123\",\n      client_secret: \"secret123\",\n      redirect_uris: [\"http://localhost:3000/callback\"],\n      client_name: \"Test Client\",\n    };\n\n    it(\"exchanges refresh token for new tokens\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokensWithNewRefreshToken,\n      });\n\n      const tokens = await refreshAuthorization(\"https://auth.example.com\", {\n        clientInformation: validClientInfo,\n        refreshToken: \"refresh123\",\n        resource: new URL(\"https://api.example.com/mcp-server\"),\n      });\n\n      expect(tokens).toEqual(validTokensWithNewRefreshToken);\n      expect(mockFetch).toHaveBeenCalledWith(\n        expect.objectContaining({\n          href: \"https://auth.example.com/token\",\n        }),\n        expect.objectContaining({\n          method: \"POST\",\n          headers: new Headers({\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          }),\n        })\n      );\n\n      const body = mockFetch.mock.calls[0][1].body as URLSearchParams;\n      expect(body.get(\"grant_type\")).toBe(\"refresh_token\");\n      expect(body.get(\"refresh_token\")).toBe(\"refresh123\");\n      expect(body.get(\"client_id\")).toBe(\"client123\");\n      expect(body.get(\"client_secret\")).toBe(\"secret123\");\n      expect(body.get(\"resource\")).toBe(\"https://api.example.com/mcp-server\");\n    });\n\n    it(\"exchanges refresh token for new tokens with auth\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokensWithNewRefreshToken,\n      });\n\n      const tokens = await refreshAuthorization(\"https://auth.example.com\", {\n        metadata: validMetadata,\n        clientInformation: validClientInfo,\n        refreshToken: \"refresh123\",\n        addClientAuthentication: (headers: Headers, params: URLSearchParams, url: string | URL, metadata?: AuthorizationServerMetadata) =\u003E {\n          headers.set(\"Authorization\", \"Basic \" + btoa(validClientInfo.client_id + \":\" + validClientInfo.client_secret));\n          params.set(\"example_url\", typeof url === 'string' ? url : url.toString());\n          params.set(\"example_metadata\", metadata?.authorization_endpoint ?? '?');\n          params.set(\"example_param\", \"example_value\");\n        },\n      });\n\n      expect(tokens).toEqual(validTokensWithNewRefreshToken);\n      expect(mockFetch).toHaveBeenCalledWith(\n        expect.objectContaining({\n          href: \"https://auth.example.com/token\",\n        }),\n        expect.objectContaining({\n          method: \"POST\",\n        })\n      );\n\n      const headers = mockFetch.mock.calls[0][1].headers as Headers;\n      expect(headers.get(\"Content-Type\")).toBe(\"application/x-www-form-urlencoded\");\n      expect(headers.get(\"Authorization\")).toBe(\"Basic Y2xpZW50MTIzOnNlY3JldDEyMw==\");\n      const body = mockFetch.mock.calls[0][1].body as URLSearchParams;\n      expect(body.get(\"grant_type\")).toBe(\"refresh_token\");\n      expect(body.get(\"refresh_token\")).toBe(\"refresh123\");\n      expect(body.get(\"client_id\")).toBeNull();\n      expect(body.get(\"example_url\")).toBe(\"https://auth.example.com\");\n      expect(body.get(\"example_metadata\")).toBe(\"https://auth.example.com/authorize\");\n      expect(body.get(\"example_param\")).toBe(\"example_value\");\n      expect(body.get(\"client_secret\")).toBeNull();\n    });\n\n    it(\"exchanges refresh token for new tokens and keep existing refresh token if none is returned\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const refreshToken = \"refresh123\";\n      const tokens = await refreshAuthorization(\"https://auth.example.com\", {\n        clientInformation: validClientInfo,\n        refreshToken,\n      });\n\n      expect(tokens).toEqual({ refresh_token: refreshToken, ...validTokens });\n    });\n\n    it(\"validates token response schema\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          // Missing required fields\n          access_token: \"newaccess123\",\n        }),\n      });\n\n      await expect(\n        refreshAuthorization(\"https://auth.example.com\", {\n          clientInformation: validClientInfo,\n          refreshToken: \"refresh123\",\n        })\n      ).rejects.toThrow();\n    });\n\n    it(\"throws on error response\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce(\n        Response.json(\n          new ServerError(\"Token refresh failed\").toResponseObject(),\n          { status: 400 }\n        )\n      );\n\n      await expect(\n        refreshAuthorization(\"https://auth.example.com\", {\n          clientInformation: validClientInfo,\n          refreshToken: \"refresh123\",\n        })\n      ).rejects.toThrow(\"Token refresh failed\");\n    });\n  });\n\n  describe(\"registerClient\", () =\u003E {\n    const validClientMetadata = {\n      redirect_uris: [\"http://localhost:3000/callback\"],\n      client_name: \"Test Client\",\n    };\n\n    const validClientInfo = {\n      client_id: \"client123\",\n      client_secret: \"secret123\",\n      client_id_issued_at: 1612137600,\n      client_secret_expires_at: 1612224000,\n      ...validClientMetadata,\n    };\n\n    it(\"registers client and returns client information\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validClientInfo,\n      });\n\n      const clientInfo = await registerClient(\"https://auth.example.com\", {\n        clientMetadata: validClientMetadata,\n      });\n\n      expect(clientInfo).toEqual(validClientInfo);\n      expect(mockFetch).toHaveBeenCalledWith(\n        expect.objectContaining({\n          href: \"https://auth.example.com/register\",\n        }),\n        expect.objectContaining({\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(validClientMetadata),\n        })\n      );\n    });\n\n    it(\"validates client information response schema\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          // Missing required fields\n          client_secret: \"secret123\",\n        }),\n      });\n\n      await expect(\n        registerClient(\"https://auth.example.com\", {\n          clientMetadata: validClientMetadata,\n        })\n      ).rejects.toThrow();\n    });\n\n    it(\"throws when registration endpoint not available in metadata\", async () =\u003E {\n      const metadata = {\n        issuer: \"https://auth.example.com\",\n        authorization_endpoint: \"https://auth.example.com/authorize\",\n        token_endpoint: \"https://auth.example.com/token\",\n        response_types_supported: [\"code\"],\n      };\n\n      await expect(\n        registerClient(\"https://auth.example.com\", {\n          metadata,\n          clientMetadata: validClientMetadata,\n        })\n      ).rejects.toThrow(/does not support dynamic client registration/);\n    });\n\n    it(\"throws on error response\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce(\n        Response.json(\n          new ServerError(\"Dynamic client registration failed\").toResponseObject(),\n          { status: 400 }\n        )\n      );\n\n      await expect(\n        registerClient(\"https://auth.example.com\", {\n          clientMetadata: validClientMetadata,\n        })\n      ).rejects.toThrow(\"Dynamic client registration failed\");\n    });\n  });\n\n  describe(\"auth function\", () =\u003E {\n    const mockProvider: OAuthClientProvider = {\n      get redirectUrl() { return \"http://localhost:3000/callback\"; },\n      get clientMetadata() {\n        return {\n          redirect_uris: [\"http://localhost:3000/callback\"],\n          client_name: \"Test Client\",\n        };\n      },\n      clientInformation: jest.fn(),\n      tokens: jest.fn(),\n      saveTokens: jest.fn(),\n      redirectToAuthorization: jest.fn(),\n      saveCodeVerifier: jest.fn(),\n      codeVerifier: jest.fn(),\n    };\n\n    beforeEach(() =\u003E {\n      jest.clearAllMocks();\n    });\n\n    it(\"falls back to /.well-known/oauth-authorization-server when no protected-resource-metadata\", async () =\u003E {\n      // Setup: First call to protected resource metadata fails (404)\n      // Second call to auth server metadata succeeds\n      let callCount = 0;\n      mockFetch.mockImplementation((url) =\u003E {\n        callCount++;\n\n        const urlString = url.toString();\n\n        if (callCount === 1 && urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          // First call - protected resource metadata fails with 404\n          return Promise.resolve({\n            ok: false,\n            status: 404,\n          });\n        } else if (callCount === 2 && urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          // Second call - auth server metadata succeeds\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              registration_endpoint: \"https://auth.example.com/register\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        } else if (callCount === 3 && urlString.includes(\"/register\")) {\n          // Third call - client registration succeeds\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              client_id: \"test-client-id\",\n              client_secret: \"test-client-secret\",\n              client_id_issued_at: 1612137600,\n              client_secret_expires_at: 1612224000,\n              redirect_uris: [\"http://localhost:3000/callback\"],\n              client_name: \"Test Client\",\n            }),\n          });\n        }\n\n        return Promise.reject(new Error(`Unexpected fetch call: ${urlString}`));\n      });\n\n      // Mock provider methods\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.tokens as jest.Mock).mockResolvedValue(undefined);\n      mockProvider.saveClientInformation = jest.fn();\n\n      // Call the auth function\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://resource.example.com\",\n      });\n\n      // Verify the result\n      expect(result).toBe(\"REDIRECT\");\n\n      // Verify the sequence of calls\n      expect(mockFetch).toHaveBeenCalledTimes(3);\n\n      // First call should be to protected resource metadata\n      expect(mockFetch.mock.calls[0][0].toString()).toBe(\n        \"https://resource.example.com/.well-known/oauth-protected-resource\"\n      );\n\n      // Second call should be to oauth metadata\n      expect(mockFetch.mock.calls[1][0].toString()).toBe(\n        \"https://resource.example.com/.well-known/oauth-authorization-server\"\n      );\n    });\n\n    it(\"passes resource parameter through authorization flow\", async () =\u003E {\n      // Mock successful metadata discovery - need to include protected resource metadata\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n        if (urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              resource: \"https://api.example.com/mcp-server\",\n              authorization_servers: [\"https://auth.example.com\"],\n            }),\n          });\n        } else if (urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        }\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods for authorization flow\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (mockProvider.tokens as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.saveCodeVerifier as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.redirectToAuthorization as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth without authorization code (should trigger redirect)\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://api.example.com/mcp-server\",\n      });\n\n      expect(result).toBe(\"REDIRECT\");\n\n      // Verify the authorization URL includes the resource parameter\n      expect(mockProvider.redirectToAuthorization).toHaveBeenCalledWith(\n        expect.objectContaining({\n          searchParams: expect.any(URLSearchParams),\n        })\n      );\n\n      const redirectCall = (mockProvider.redirectToAuthorization as jest.Mock).mock.calls[0];\n      const authUrl: URL = redirectCall[0];\n      expect(authUrl.searchParams.get(\"resource\")).toBe(\"https://api.example.com/mcp-server\");\n    });\n\n    it(\"includes resource in token exchange when authorization code is provided\", async () =\u003E {\n      // Mock successful metadata discovery and token exchange - need protected resource metadata\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n\n        if (urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              resource: \"https://api.example.com/mcp-server\",\n              authorization_servers: [\"https://auth.example.com\"],\n            }),\n          });\n        } else if (urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        } else if (urlString.includes(\"/token\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              access_token: \"access123\",\n              token_type: \"Bearer\",\n              expires_in: 3600,\n              refresh_token: \"refresh123\",\n            }),\n          });\n        }\n\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods for token exchange\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (mockProvider.codeVerifier as jest.Mock).mockResolvedValue(\"test-verifier\");\n      (mockProvider.saveTokens as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth with authorization code\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://api.example.com/mcp-server\",\n        authorizationCode: \"auth-code-123\",\n      });\n\n      expect(result).toBe(\"AUTHORIZED\");\n\n      // Find the token exchange call\n      const tokenCall = mockFetch.mock.calls.find(call =\u003E\n        call[0].toString().includes(\"/token\")\n      );\n      expect(tokenCall).toBeDefined();\n\n      const body = tokenCall![1].body as URLSearchParams;\n      expect(body.get(\"resource\")).toBe(\"https://api.example.com/mcp-server\");\n      expect(body.get(\"code\")).toBe(\"auth-code-123\");\n    });\n\n    it(\"includes resource in token refresh\", async () =\u003E {\n      // Mock successful metadata discovery and token refresh - need protected resource metadata\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n\n        if (urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              resource: \"https://api.example.com/mcp-server\",\n              authorization_servers: [\"https://auth.example.com\"],\n            }),\n          });\n        } else if (urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        } else if (urlString.includes(\"/token\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              access_token: \"new-access123\",\n              token_type: \"Bearer\",\n              expires_in: 3600,\n            }),\n          });\n        }\n\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods for token refresh\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (mockProvider.tokens as jest.Mock).mockResolvedValue({\n        access_token: \"old-access\",\n        refresh_token: \"refresh123\",\n      });\n      (mockProvider.saveTokens as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth with existing tokens (should trigger refresh)\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://api.example.com/mcp-server\",\n      });\n\n      expect(result).toBe(\"AUTHORIZED\");\n\n      // Find the token refresh call\n      const tokenCall = mockFetch.mock.calls.find(call =\u003E\n        call[0].toString().includes(\"/token\")\n      );\n      expect(tokenCall).toBeDefined();\n\n      const body = tokenCall![1].body as URLSearchParams;\n      expect(body.get(\"resource\")).toBe(\"https://api.example.com/mcp-server\");\n      expect(body.get(\"grant_type\")).toBe(\"refresh_token\");\n      expect(body.get(\"refresh_token\")).toBe(\"refresh123\");\n    });\n\n    it(\"skips default PRM resource validation when custom validateResourceURL is provided\", async () =\u003E {\n      const mockValidateResourceURL = jest.fn().mockResolvedValue(undefined);\n      const providerWithCustomValidation = {\n        ...mockProvider,\n        validateResourceURL: mockValidateResourceURL,\n      };\n\n      // Mock protected resource metadata with mismatched resource URL\n      // This would normally throw an error in default validation, but should be skipped\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n\n        if (urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              resource: \"https://different-resource.example.com/mcp-server\", // Mismatched resource\n              authorization_servers: [\"https://auth.example.com\"],\n            }),\n          });\n        } else if (urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        }\n\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods\n      (providerWithCustomValidation.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (providerWithCustomValidation.tokens as jest.Mock).mockResolvedValue(undefined);\n      (providerWithCustomValidation.saveCodeVerifier as jest.Mock).mockResolvedValue(undefined);\n      (providerWithCustomValidation.redirectToAuthorization as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth - should succeed despite resource mismatch because custom validation overrides default\n      const result = await auth(providerWithCustomValidation, {\n        serverUrl: \"https://api.example.com/mcp-server\",\n      });\n\n      expect(result).toBe(\"REDIRECT\");\n\n      // Verify custom validation method was called\n      expect(mockValidateResourceURL).toHaveBeenCalledWith(\n        new URL(\"https://api.example.com/mcp-server\"),\n        \"https://different-resource.example.com/mcp-server\"\n      );\n    });\n\n    it(\"uses prefix of server URL from PRM resource as resource parameter\", async () =\u003E {\n      // Mock successful metadata discovery with resource URL that is a prefix of requested URL\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n\n        if (urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              // Resource is a prefix of the requested server URL\n              resource: \"https://api.example.com/\",\n              authorization_servers: [\"https://auth.example.com\"],\n            }),\n          });\n        } else if (urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        }\n\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (mockProvider.tokens as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.saveCodeVerifier as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.redirectToAuthorization as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth with a URL that has the resource as prefix\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://api.example.com/mcp-server/endpoint\",\n      });\n\n      expect(result).toBe(\"REDIRECT\");\n\n      // Verify the authorization URL includes the resource parameter from PRM\n      expect(mockProvider.redirectToAuthorization).toHaveBeenCalledWith(\n        expect.objectContaining({\n          searchParams: expect.any(URLSearchParams),\n        })\n      );\n\n      const redirectCall = (mockProvider.redirectToAuthorization as jest.Mock).mock.calls[0];\n      const authUrl: URL = redirectCall[0];\n      // Should use the PRM's resource value, not the full requested URL\n      expect(authUrl.searchParams.get(\"resource\")).toBe(\"https://api.example.com/\");\n    });\n\n    it(\"excludes resource parameter when Protected Resource Metadata is not present\", async () =\u003E {\n      // Mock metadata discovery where protected resource metadata is not available (404)\n      // but authorization server metadata is available\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n\n        if (urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          // Protected resource metadata not available\n          return Promise.resolve({\n            ok: false,\n            status: 404,\n          });\n        } else if (urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        }\n\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (mockProvider.tokens as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.saveCodeVerifier as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.redirectToAuthorization as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth - should not include resource parameter\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://api.example.com/mcp-server\",\n      });\n\n      expect(result).toBe(\"REDIRECT\");\n\n      // Verify the authorization URL does NOT include the resource parameter\n      expect(mockProvider.redirectToAuthorization).toHaveBeenCalledWith(\n        expect.objectContaining({\n          searchParams: expect.any(URLSearchParams),\n        })\n      );\n\n      const redirectCall = (mockProvider.redirectToAuthorization as jest.Mock).mock.calls[0];\n      const authUrl: URL = redirectCall[0];\n      // Resource parameter should not be present when PRM is not available\n      expect(authUrl.searchParams.has(\"resource\")).toBe(false);\n    });\n\n    it(\"excludes resource parameter in token exchange when Protected Resource Metadata is not present\", async () =\u003E {\n      // Mock metadata discovery - no protected resource metadata, but auth server metadata available\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n\n        if (urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          return Promise.resolve({\n            ok: false,\n            status: 404,\n          });\n        } else if (urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        } else if (urlString.includes(\"/token\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              access_token: \"access123\",\n              token_type: \"Bearer\",\n              expires_in: 3600,\n              refresh_token: \"refresh123\",\n            }),\n          });\n        }\n\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods for token exchange\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (mockProvider.codeVerifier as jest.Mock).mockResolvedValue(\"test-verifier\");\n      (mockProvider.saveTokens as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth with authorization code\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://api.example.com/mcp-server\",\n        authorizationCode: \"auth-code-123\",\n      });\n\n      expect(result).toBe(\"AUTHORIZED\");\n\n      // Find the token exchange call\n      const tokenCall = mockFetch.mock.calls.find(call =\u003E\n        call[0].toString().includes(\"/token\")\n      );\n      expect(tokenCall).toBeDefined();\n\n      const body = tokenCall![1].body as URLSearchParams;\n      // Resource parameter should not be present when PRM is not available\n      expect(body.has(\"resource\")).toBe(false);\n      expect(body.get(\"code\")).toBe(\"auth-code-123\");\n    });\n\n    it(\"excludes resource parameter in token refresh when Protected Resource Metadata is not present\", async () =\u003E {\n      // Mock metadata discovery - no protected resource metadata, but auth server metadata available\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n\n        if (urlString.includes(\"/.well-known/oauth-protected-resource\")) {\n          return Promise.resolve({\n            ok: false,\n            status: 404,\n          });\n        } else if (urlString.includes(\"/.well-known/oauth-authorization-server\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        } else if (urlString.includes(\"/token\")) {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              access_token: \"new-access123\",\n              token_type: \"Bearer\",\n              expires_in: 3600,\n            }),\n          });\n        }\n\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods for token refresh\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (mockProvider.tokens as jest.Mock).mockResolvedValue({\n        access_token: \"old-access\",\n        refresh_token: \"refresh123\",\n      });\n      (mockProvider.saveTokens as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth with existing tokens (should trigger refresh)\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://api.example.com/mcp-server\",\n      });\n\n      expect(result).toBe(\"AUTHORIZED\");\n\n      // Find the token refresh call\n      const tokenCall = mockFetch.mock.calls.find(call =\u003E\n        call[0].toString().includes(\"/token\")\n      );\n      expect(tokenCall).toBeDefined();\n\n      const body = tokenCall![1].body as URLSearchParams;\n      // Resource parameter should not be present when PRM is not available\n      expect(body.has(\"resource\")).toBe(false);\n      expect(body.get(\"grant_type\")).toBe(\"refresh_token\");\n      expect(body.get(\"refresh_token\")).toBe(\"refresh123\");\n    });\n\n    it(\"fetches AS metadata with path from serverUrl when PRM returns external AS\", async () =\u003E {\n      // Mock PRM discovery that returns an external AS\n      mockFetch.mockImplementation((url) =\u003E {\n        const urlString = url.toString();\n\n        if (urlString === \"https://my.resource.com/.well-known/oauth-protected-resource/path/name\") {\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              resource: \"https://my.resource.com/\",\n              authorization_servers: [\"https://auth.example.com/oauth\"],\n            }),\n          });\n        } else if (urlString === \"https://auth.example.com/.well-known/oauth-authorization-server/path/name\") {\n          // Path-aware discovery on AS with path from serverUrl\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () =\u003E ({\n              issuer: \"https://auth.example.com\",\n              authorization_endpoint: \"https://auth.example.com/authorize\",\n              token_endpoint: \"https://auth.example.com/token\",\n              response_types_supported: [\"code\"],\n              code_challenge_methods_supported: [\"S256\"],\n            }),\n          });\n        }\n\n        return Promise.resolve({ ok: false, status: 404 });\n      });\n\n      // Mock provider methods\n      (mockProvider.clientInformation as jest.Mock).mockResolvedValue({\n        client_id: \"test-client\",\n        client_secret: \"test-secret\",\n      });\n      (mockProvider.tokens as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.saveCodeVerifier as jest.Mock).mockResolvedValue(undefined);\n      (mockProvider.redirectToAuthorization as jest.Mock).mockResolvedValue(undefined);\n\n      // Call auth with serverUrl that has a path\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://my.resource.com/path/name\",\n      });\n\n      expect(result).toBe(\"REDIRECT\");\n\n      // Verify the correct URLs were fetched\n      const calls = mockFetch.mock.calls;\n\n      // First call should be to PRM\n      expect(calls[0][0].toString()).toBe(\"https://my.resource.com/.well-known/oauth-protected-resource/path/name\");\n\n      // Second call should be to AS metadata with the path from authorization server\n      expect(calls[1][0].toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server/oauth\");\n    });\n\n    it(\"supports overriding the fetch function used for requests\", async () =\u003E {\n      const customFetch = jest.fn();\n\n      // Mock PRM discovery\n      customFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          resource: \"https://resource.example.com\",\n          authorization_servers: [\"https://auth.example.com\"],\n        }),\n      });\n\n      // Mock AS metadata discovery\n      customFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          issuer: \"https://auth.example.com\",\n          authorization_endpoint: \"https://auth.example.com/authorize\",\n          token_endpoint: \"https://auth.example.com/token\",\n          registration_endpoint: \"https://auth.example.com/register\",\n          response_types_supported: [\"code\"],\n          code_challenge_methods_supported: [\"S256\"],\n        }),\n      });\n\n      const mockProvider: OAuthClientProvider = {\n        get redirectUrl() { return \"http://localhost:3000/callback\"; },\n        get clientMetadata() {\n          return {\n            client_name: \"Test Client\",\n            redirect_uris: [\"http://localhost:3000/callback\"],\n          };\n        },\n        clientInformation: jest.fn().mockResolvedValue({\n          client_id: \"client123\",\n          client_secret: \"secret123\",\n        }),\n        tokens: jest.fn().mockResolvedValue(undefined),\n        saveTokens: jest.fn(),\n        redirectToAuthorization: jest.fn(),\n        saveCodeVerifier: jest.fn(),\n        codeVerifier: jest.fn().mockResolvedValue(\"verifier123\"),\n      };\n\n      const result = await auth(mockProvider, {\n        serverUrl: \"https://resource.example.com\",\n        fetchFn: customFetch,\n      });\n\n      expect(result).toBe(\"REDIRECT\");\n      expect(customFetch).toHaveBeenCalledTimes(2);\n      expect(mockFetch).not.toHaveBeenCalled();\n\n      // Verify custom fetch was called for PRM discovery\n      expect(customFetch.mock.calls[0][0].toString()).toBe(\"https://resource.example.com/.well-known/oauth-protected-resource\");\n\n      // Verify custom fetch was called for AS metadata discovery\n      expect(customFetch.mock.calls[1][0].toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n    });\n  });\n\n  describe(\"exchangeAuthorization with multiple client authentication methods\", () =\u003E {\n    const validTokens = {\n      access_token: \"access123\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n      refresh_token: \"refresh123\",\n    };\n\n    const validClientInfo = {\n      client_id: \"client123\",\n      client_secret: \"secret123\",\n      redirect_uris: [\"http://localhost:3000/callback\"],\n      client_name: \"Test Client\",\n    };\n\n    const metadataWithBasicOnly = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/auth\",\n      token_endpoint: \"https://auth.example.com/token\",\n      response_types_supported: [\"code\"],\n      code_challenge_methods_supported: [\"S256\"],\n      token_endpoint_auth_methods_supported: [\"client_secret_basic\"],\n    };\n\n    const metadataWithPostOnly = {\n      ...metadataWithBasicOnly,\n      token_endpoint_auth_methods_supported: [\"client_secret_post\"],\n    };\n\n    const metadataWithNoneOnly = {\n      ...metadataWithBasicOnly,\n      token_endpoint_auth_methods_supported: [\"none\"],\n    };\n\n    const metadataWithAllBuiltinMethods = {\n      ...metadataWithBasicOnly,\n      token_endpoint_auth_methods_supported: [\"client_secret_basic\", \"client_secret_post\", \"none\"],\n    };\n\n    it(\"uses HTTP Basic authentication when client_secret_basic is supported\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await exchangeAuthorization(\"https://auth.example.com\", {\n        metadata: metadataWithBasicOnly,\n        clientInformation: validClientInfo,\n        authorizationCode: \"code123\",\n        redirectUri: \"http://localhost:3000/callback\",\n        codeVerifier: \"verifier123\",\n      });\n\n      expect(tokens).toEqual(validTokens);\n      const request = mockFetch.mock.calls[0][1];\n\n      // Check Authorization header\n      const authHeader = request.headers.get(\"Authorization\");\n      const expected = \"Basic \" + btoa(\"client123:secret123\");\n      expect(authHeader).toBe(expected);\n\n      const body = request.body as URLSearchParams;\n      expect(body.get(\"client_id\")).toBeNull();\n      expect(body.get(\"client_secret\")).toBeNull();\n    });\n\n    it(\"includes credentials in request body when client_secret_post is supported\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await exchangeAuthorization(\"https://auth.example.com\", {\n        metadata: metadataWithPostOnly,\n        clientInformation: validClientInfo,\n        authorizationCode: \"code123\",\n        redirectUri: \"http://localhost:3000/callback\",\n        codeVerifier: \"verifier123\",\n      });\n\n      expect(tokens).toEqual(validTokens);\n      const request = mockFetch.mock.calls[0][1];\n\n      // Check no Authorization header\n      expect(request.headers.get(\"Authorization\")).toBeNull();\n\n      const body = request.body as URLSearchParams;\n      expect(body.get(\"client_id\")).toBe(\"client123\");\n      expect(body.get(\"client_secret\")).toBe(\"secret123\");\n    });\n\n    it(\"it picks client_secret_basic when all builtin methods are supported\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await exchangeAuthorization(\"https://auth.example.com\", {\n        metadata: metadataWithAllBuiltinMethods,\n        clientInformation: validClientInfo,\n        authorizationCode: \"code123\",\n        redirectUri: \"http://localhost:3000/callback\",\n        codeVerifier: \"verifier123\",\n      });\n\n      expect(tokens).toEqual(validTokens);\n      const request = mockFetch.mock.calls[0][1];\n\n      // Check Authorization header - should use Basic auth as it's the most secure\n      const authHeader = request.headers.get(\"Authorization\");\n      const expected = \"Basic \" + btoa(\"client123:secret123\");\n      expect(authHeader).toBe(expected);\n\n      // Credentials should not be in body when using Basic auth\n      const body = request.body as URLSearchParams;\n      expect(body.get(\"client_id\")).toBeNull();\n      expect(body.get(\"client_secret\")).toBeNull();\n    });\n\n    it(\"uses public client authentication when none method is specified\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const clientInfoWithoutSecret = {\n        client_id: \"client123\",\n        redirect_uris: [\"http://localhost:3000/callback\"],\n        client_name: \"Test Client\",\n      };\n\n      const tokens = await exchangeAuthorization(\"https://auth.example.com\", {\n        metadata: metadataWithNoneOnly,\n        clientInformation: clientInfoWithoutSecret,\n        authorizationCode: \"code123\",\n        redirectUri: \"http://localhost:3000/callback\",\n        codeVerifier: \"verifier123\",\n      });\n\n      expect(tokens).toEqual(validTokens);\n      const request = mockFetch.mock.calls[0][1];\n\n      // Check no Authorization header\n      expect(request.headers.get(\"Authorization\")).toBeNull();\n\n      const body = request.body as URLSearchParams;\n      expect(body.get(\"client_id\")).toBe(\"client123\");\n      expect(body.get(\"client_secret\")).toBeNull();\n    });\n\n    it(\"defaults to client_secret_post when no auth methods specified\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await exchangeAuthorization(\"https://auth.example.com\", {\n        clientInformation: validClientInfo,\n        authorizationCode: \"code123\",\n        redirectUri: \"http://localhost:3000/callback\",\n        codeVerifier: \"verifier123\",\n      });\n\n      expect(tokens).toEqual(validTokens);\n      const request = mockFetch.mock.calls[0][1];\n\n      // Check headers\n      expect(request.headers.get(\"Content-Type\")).toBe(\"application/x-www-form-urlencoded\");\n      expect(request.headers.get(\"Authorization\")).toBeNull();\n\n      const body = request.body as URLSearchParams;\n      expect(body.get(\"client_id\")).toBe(\"client123\");\n      expect(body.get(\"client_secret\")).toBe(\"secret123\");\n    });\n  });\n\n  describe(\"refreshAuthorization with multiple client authentication methods\", () =\u003E {\n    const validTokens = {\n      access_token: \"newaccess123\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n      refresh_token: \"newrefresh123\",\n    };\n\n    const validClientInfo = {\n      client_id: \"client123\",\n      client_secret: \"secret123\",\n      redirect_uris: [\"http://localhost:3000/callback\"],\n      client_name: \"Test Client\",\n    };\n\n    const metadataWithBasicOnly = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/auth\",\n      token_endpoint: \"https://auth.example.com/token\",\n      response_types_supported: [\"code\"],\n      token_endpoint_auth_methods_supported: [\"client_secret_basic\"],\n    };\n\n    const metadataWithPostOnly = {\n      ...metadataWithBasicOnly,\n      token_endpoint_auth_methods_supported: [\"client_secret_post\"],\n    };\n\n    it(\"uses client_secret_basic for refresh token\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await refreshAuthorization(\"https://auth.example.com\", {\n        metadata: metadataWithBasicOnly,\n        clientInformation: validClientInfo,\n        refreshToken: \"refresh123\",\n      });\n\n      expect(tokens).toEqual(validTokens);\n      const request = mockFetch.mock.calls[0][1];\n\n      // Check Authorization header\n      const authHeader = request.headers.get(\"Authorization\");\n      const expected = \"Basic \" + btoa(\"client123:secret123\");\n      expect(authHeader).toBe(expected);\n\n      const body = request.body as URLSearchParams;\n      expect(body.get(\"client_id\")).toBeNull();     // should not be in body\n      expect(body.get(\"client_secret\")).toBeNull(); // should not be in body\n      expect(body.get(\"refresh_token\")).toBe(\"refresh123\");\n    });\n\n    it(\"uses client_secret_post for refresh token\", async () =\u003E {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E validTokens,\n      });\n\n      const tokens = await refreshAuthorization(\"https://auth.example.com\", {\n        metadata: metadataWithPostOnly,\n        clientInformation: validClientInfo,\n        refreshToken: \"refresh123\",\n      });\n\n      expect(tokens).toEqual(validTokens);\n      const request = mockFetch.mock.calls[0][1];\n\n      // Check no Authorization header\n      expect(request.headers.get(\"Authorization\")).toBeNull();\n\n      const body = request.body as URLSearchParams;\n      expect(body.get(\"client_id\")).toBe(\"client123\");\n      expect(body.get(\"client_secret\")).toBe(\"secret123\");\n      expect(body.get(\"refresh_token\")).toBe(\"refresh123\");\n    });\n  });\n\n});\n",
      "hash": "1b498c504e49a77889bde169fc43a4dc9443f41073ce9f5ce5540d5ed5f10912",
      "size": 89667
    },
    "/src/client/auth.ts": {
      "type": "content",
      "content": "import pkceChallenge from \"pkce-challenge\";\nimport { LATEST_PROTOCOL_VERSION } from \"../types.js\";\nimport {\n  OAuthClientMetadata,\n  OAuthClientInformation,\n  OAuthTokens,\n  OAuthMetadata,\n  OAuthClientInformationFull,\n  OAuthProtectedResourceMetadata,\n  OAuthErrorResponseSchema,\n  AuthorizationServerMetadata,\n  OpenIdProviderDiscoveryMetadataSchema\n} from \"../shared/auth.js\";\nimport { OAuthClientInformationFullSchema, OAuthMetadataSchema, OAuthProtectedResourceMetadataSchema, OAuthTokensSchema } from \"../shared/auth.js\";\nimport { checkResourceAllowed, resourceUrlFromServerUrl } from \"../shared/auth-utils.js\";\nimport {\n  InvalidClientError,\n  InvalidGrantError,\n  OAUTH_ERRORS,\n  OAuthError,\n  ServerError,\n  UnauthorizedClientError\n} from \"../server/auth/errors.js\";\nimport { FetchLike } from \"../shared/transport.js\";\n\n/**\n * Implements an end-to-end OAuth client to be used with one MCP server.\n *\n * This client relies upon a concept of an authorized \"session,\" the exact\n * meaning of which is application-defined. Tokens, authorization codes, and\n * code verifiers should not cross different sessions.\n */\nexport interface OAuthClientProvider {\n  /**\n   * The URL to redirect the user agent to after authorization.\n   */\n  get redirectUrl(): string | URL;\n\n  /**\n   * Metadata about this OAuth client.\n   */\n  get clientMetadata(): OAuthClientMetadata;\n\n  /**\n   * Returns a OAuth2 state parameter.\n   */\n  state?(): string | Promise\u003Cstring\u003E;\n\n  /**\n   * Loads information about this OAuth client, as registered already with the\n   * server, or returns `undefined` if the client is not registered with the\n   * server.\n   */\n  clientInformation(): OAuthClientInformation | undefined | Promise\u003COAuthClientInformation | undefined\u003E;\n\n  /**\n   * If implemented, this permits the OAuth client to dynamically register with\n   * the server. Client information saved this way should later be read via\n   * `clientInformation()`.\n   *\n   * This method is not required to be implemented if client information is\n   * statically known (e.g., pre-registered).\n   */\n  saveClientInformation?(clientInformation: OAuthClientInformationFull): void | Promise\u003Cvoid\u003E;\n\n  /**\n   * Loads any existing OAuth tokens for the current session, or returns\n   * `undefined` if there are no saved tokens.\n   */\n  tokens(): OAuthTokens | undefined | Promise\u003COAuthTokens | undefined\u003E;\n\n  /**\n   * Stores new OAuth tokens for the current session, after a successful\n   * authorization.\n   */\n  saveTokens(tokens: OAuthTokens): void | Promise\u003Cvoid\u003E;\n\n  /**\n   * Invoked to redirect the user agent to the given URL to begin the authorization flow.\n   */\n  redirectToAuthorization(authorizationUrl: URL): void | Promise\u003Cvoid\u003E;\n\n  /**\n   * Saves a PKCE code verifier for the current session, before redirecting to\n   * the authorization flow.\n   */\n  saveCodeVerifier(codeVerifier: string): void | Promise\u003Cvoid\u003E;\n\n  /**\n   * Loads the PKCE code verifier for the current session, necessary to validate\n   * the authorization result.\n   */\n  codeVerifier(): string | Promise\u003Cstring\u003E;\n\n  /**\n   * Adds custom client authentication to OAuth token requests.\n   *\n   * This optional method allows implementations to customize how client credentials\n   * are included in token exchange and refresh requests. When provided, this method\n   * is called instead of the default authentication logic, giving full control over\n   * the authentication mechanism.\n   *\n   * Common use cases include:\n   * - Supporting authentication methods beyond the standard OAuth 2.0 methods\n   * - Adding custom headers for proprietary authentication schemes\n   * - Implementing client assertion-based authentication (e.g., JWT bearer tokens)\n   *\n   * @param headers - The request headers (can be modified to add authentication)\n   * @param params - The request body parameters (can be modified to add credentials)\n   * @param url - The token endpoint URL being called\n   * @param metadata - Optional OAuth metadata for the server, which may include supported authentication methods\n   */\n  addClientAuthentication?(headers: Headers, params: URLSearchParams, url: string | URL, metadata?: AuthorizationServerMetadata): void | Promise\u003Cvoid\u003E;\n\n  /**\n   * If defined, overrides the selection and validation of the\n   * RFC 8707 Resource Indicator. If left undefined, default\n   * validation behavior will be used.\n   *\n   * Implementations must verify the returned resource matches the MCP server.\n   */\n  validateResourceURL?(serverUrl: string | URL, resource?: string): Promise\u003CURL | undefined\u003E;\n\n  /**\n   * If implemented, provides a way for the client to invalidate (e.g. delete) the specified\n   * credentials, in the case where the server has indicated that they are no longer valid.\n   * This avoids requiring the user to intervene manually.\n   */\n  invalidateCredentials?(scope: 'all' | 'client' | 'tokens' | 'verifier'): void | Promise\u003Cvoid\u003E;\n}\n\nexport type AuthResult = \"AUTHORIZED\" | \"REDIRECT\";\n\nexport class UnauthorizedError extends Error {\n  constructor(message?: string) {\n    super(message ?? \"Unauthorized\");\n  }\n}\n\ntype ClientAuthMethod = 'client_secret_basic' | 'client_secret_post' | 'none';\n\n/**\n * Determines the best client authentication method to use based on server support and client configuration.\n *\n * Priority order (highest to lowest):\n * 1. client_secret_basic (if client secret is available)\n * 2. client_secret_post (if client secret is available)\n * 3. none (for public clients)\n *\n * @param clientInformation - OAuth client information containing credentials\n * @param supportedMethods - Authentication methods supported by the authorization server\n * @returns The selected authentication method\n */\nfunction selectClientAuthMethod(\n  clientInformation: OAuthClientInformation,\n  supportedMethods: string[]\n): ClientAuthMethod {\n  const hasClientSecret = clientInformation.client_secret !== undefined;\n\n  // If server doesn't specify supported methods, use RFC 6749 defaults\n  if (supportedMethods.length === 0) {\n    return hasClientSecret ? \"client_secret_post\" : \"none\";\n  }\n\n  // Try methods in priority order (most secure first)\n  if (hasClientSecret && supportedMethods.includes(\"client_secret_basic\")) {\n    return \"client_secret_basic\";\n  }\n\n  if (hasClientSecret && supportedMethods.includes(\"client_secret_post\")) {\n    return \"client_secret_post\";\n  }\n\n  if (supportedMethods.includes(\"none\")) {\n    return \"none\";\n  }\n\n  // Fallback: use what we have\n  return hasClientSecret ? \"client_secret_post\" : \"none\";\n}\n\n/**\n * Applies client authentication to the request based on the specified method.\n *\n * Implements OAuth 2.1 client authentication methods:\n * - client_secret_basic: HTTP Basic authentication (RFC 6749 Section 2.3.1)\n * - client_secret_post: Credentials in request body (RFC 6749 Section 2.3.1)\n * - none: Public client authentication (RFC 6749 Section 2.1)\n *\n * @param method - The authentication method to use\n * @param clientInformation - OAuth client information containing credentials\n * @param headers - HTTP headers object to modify\n * @param params - URL search parameters to modify\n * @throws {Error} When required credentials are missing\n */\nfunction applyClientAuthentication(\n  method: ClientAuthMethod,\n  clientInformation: OAuthClientInformation,\n  headers: Headers,\n  params: URLSearchParams\n): void {\n  const { client_id, client_secret } = clientInformation;\n\n  switch (method) {\n    case \"client_secret_basic\":\n      applyBasicAuth(client_id, client_secret, headers);\n      return;\n    case \"client_secret_post\":\n      applyPostAuth(client_id, client_secret, params);\n      return;\n    case \"none\":\n      applyPublicAuth(client_id, params);\n      return;\n    default:\n      throw new Error(`Unsupported client authentication method: ${method}`);\n  }\n}\n\n/**\n * Applies HTTP Basic authentication (RFC 6749 Section 2.3.1)\n */\nfunction applyBasicAuth(clientId: string, clientSecret: string | undefined, headers: Headers): void {\n  if (!clientSecret) {\n    throw new Error(\"client_secret_basic authentication requires a client_secret\");\n  }\n\n  const credentials = btoa(`${clientId}:${clientSecret}`);\n  headers.set(\"Authorization\", `Basic ${credentials}`);\n}\n\n/**\n * Applies POST body authentication (RFC 6749 Section 2.3.1)\n */\nfunction applyPostAuth(clientId: string, clientSecret: string | undefined, params: URLSearchParams): void {\n  params.set(\"client_id\", clientId);\n  if (clientSecret) {\n    params.set(\"client_secret\", clientSecret);\n  }\n}\n\n/**\n * Applies public client authentication (RFC 6749 Section 2.1)\n */\nfunction applyPublicAuth(clientId: string, params: URLSearchParams): void {\n  params.set(\"client_id\", clientId);\n}\n\n/**\n * Parses an OAuth error response from a string or Response object.\n *\n * If the input is a standard OAuth2.0 error response, it will be parsed according to the spec\n * and an instance of the appropriate OAuthError subclass will be returned.\n * If parsing fails, it falls back to a generic ServerError that includes\n * the response status (if available) and original content.\n *\n * @param input - A Response object or string containing the error response\n * @returns A Promise that resolves to an OAuthError instance\n */\nexport async function parseErrorResponse(input: Response | string): Promise\u003COAuthError\u003E {\n  const statusCode = input instanceof Response ? input.status : undefined;\n  const body = input instanceof Response ? await input.text() : input;\n\n  try {\n    const result = OAuthErrorResponseSchema.parse(JSON.parse(body));\n    const { error, error_description, error_uri } = result;\n    const errorClass = OAUTH_ERRORS[error] || ServerError;\n    return new errorClass(error_description || '', error_uri);\n  } catch (error) {\n    // Not a valid OAuth error response, but try to inform the user of the raw data anyway\n    const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ''}Invalid OAuth error response: ${error}. Raw body: ${body}`;\n    return new ServerError(errorMessage);\n  }\n}\n\n/**\n * Orchestrates the full auth flow with a server.\n *\n * This can be used as a single entry point for all authorization functionality,\n * instead of linking together the other lower-level functions in this module.\n */\nexport async function auth(\n  provider: OAuthClientProvider,\n  options: {\n    serverUrl: string | URL;\n    authorizationCode?: string;\n    scope?: string;\n    resourceMetadataUrl?: URL;\n    fetchFn?: FetchLike;\n}): Promise\u003CAuthResult\u003E {\n  try {\n    return await authInternal(provider, options);\n  } catch (error) {\n    // Handle recoverable error types by invalidating credentials and retrying\n    if (error instanceof InvalidClientError || error instanceof UnauthorizedClientError) {\n      await provider.invalidateCredentials?.('all');\n      return await authInternal(provider, options);\n    } else if (error instanceof InvalidGrantError) {\n      await provider.invalidateCredentials?.('tokens');\n      return await authInternal(provider, options);\n    }\n\n    // Throw otherwise\n    throw error\n  }\n}\n\nasync function authInternal(\n  provider: OAuthClientProvider,\n  { serverUrl,\n    authorizationCode,\n    scope,\n    resourceMetadataUrl,\n    fetchFn,\n  }: {\n    serverUrl: string | URL;\n    authorizationCode?: string;\n    scope?: string;\n    resourceMetadataUrl?: URL;\n    fetchFn?: FetchLike;\n  },\n): Promise\u003CAuthResult\u003E {\n\n  let resourceMetadata: OAuthProtectedResourceMetadata | undefined;\n  let authorizationServerUrl: string | URL | undefined;\n  try {\n    resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);\n    if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length \u003E 0) {\n      authorizationServerUrl = resourceMetadata.authorization_servers[0];\n    }\n  } catch {\n    // Ignore errors and fall back to /.well-known/oauth-authorization-server\n  }\n\n  /**\n   * If we don't get a valid authorization server metadata from protected resource metadata,\n   * fallback to the legacy MCP spec's implementation (version 2025-03-26): MCP server acts as the Authorization server.\n   */\n  if (!authorizationServerUrl) {\n    authorizationServerUrl = serverUrl;\n  }\n\n  const resource: URL | undefined = await selectResourceURL(serverUrl, provider, resourceMetadata);\n\n  const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {\n    fetchFn,\n  });\n\n  // Handle client registration if needed\n  let clientInformation = await Promise.resolve(provider.clientInformation());\n  if (!clientInformation) {\n    if (authorizationCode !== undefined) {\n      throw new Error(\"Existing OAuth client information is required when exchanging an authorization code\");\n    }\n\n    if (!provider.saveClientInformation) {\n      throw new Error(\"OAuth client information must be saveable for dynamic registration\");\n    }\n\n    const fullInformation = await registerClient(authorizationServerUrl, {\n      metadata,\n      clientMetadata: provider.clientMetadata,\n      fetchFn,\n    });\n\n    await provider.saveClientInformation(fullInformation);\n    clientInformation = fullInformation;\n  }\n\n  // Exchange authorization code for tokens\n  if (authorizationCode !== undefined) {\n    const codeVerifier = await provider.codeVerifier();\n    const tokens = await exchangeAuthorization(authorizationServerUrl, {\n      metadata,\n      clientInformation,\n      authorizationCode,\n      codeVerifier,\n      redirectUri: provider.redirectUrl,\n      resource,\n      addClientAuthentication: provider.addClientAuthentication,\n      fetchFn: fetchFn,\n    });\n\n    await provider.saveTokens(tokens);\n    return \"AUTHORIZED\"\n  }\n\n  const tokens = await provider.tokens();\n\n  // Handle token refresh or new authorization\n  if (tokens?.refresh_token) {\n    try {\n      // Attempt to refresh the token\n      const newTokens = await refreshAuthorization(authorizationServerUrl, {\n        metadata,\n        clientInformation,\n        refreshToken: tokens.refresh_token,\n        resource,\n        addClientAuthentication: provider.addClientAuthentication,\n        fetchFn,\n      });\n\n      await provider.saveTokens(newTokens);\n      return \"AUTHORIZED\"\n    } catch (error) {\n      // If this is a ServerError, or an unknown type, log it out and try to continue. Otherwise, escalate so we can fix things and retry.\n      if (!(error instanceof OAuthError) || error instanceof ServerError) {\n        // Could not refresh OAuth tokens\n      } else {\n        // Refresh failed for another reason, re-throw\n        throw error;\n      }\n    }\n  }\n\n  const state = provider.state ? await provider.state() : undefined;\n\n  // Start new authorization flow\n  const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {\n    metadata,\n    clientInformation,\n    state,\n    redirectUrl: provider.redirectUrl,\n    scope: scope || provider.clientMetadata.scope,\n    resource,\n  });\n\n  await provider.saveCodeVerifier(codeVerifier);\n  await provider.redirectToAuthorization(authorizationUrl);\n  return \"REDIRECT\"\n}\n\nexport async function selectResourceURL(serverUrl: string | URL, provider: OAuthClientProvider, resourceMetadata?: OAuthProtectedResourceMetadata): Promise\u003CURL | undefined\u003E {\n  const defaultResource = resourceUrlFromServerUrl(serverUrl);\n\n  // If provider has custom validation, delegate to it\n  if (provider.validateResourceURL) {\n    return await provider.validateResourceURL(defaultResource, resourceMetadata?.resource);\n  }\n\n  // Only include resource parameter when Protected Resource Metadata is present\n  if (!resourceMetadata) {\n    return undefined;\n  }\n\n  // Validate that the metadata's resource is compatible with our request\n  if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {\n    throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);\n  }\n  // Prefer the resource from metadata since it's what the server is telling us to request\n  return new URL(resourceMetadata.resource);\n}\n\n/**\n * Extract resource_metadata from response header.\n */\nexport function extractResourceMetadataUrl(res: Response): URL | undefined {\n\n  const authenticateHeader = res.headers.get(\"WWW-Authenticate\");\n  if (!authenticateHeader) {\n    return undefined;\n  }\n\n  const [type, scheme] = authenticateHeader.split(' ');\n  if (type.toLowerCase() !== 'bearer' || !scheme) {\n    return undefined;\n  }\n  const regex = /resource_metadata=\"([^\"]*)\"/;\n  const match = regex.exec(authenticateHeader);\n\n  if (!match) {\n    return undefined;\n  }\n\n  try {\n    return new URL(match[1]);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Looks up RFC 9728 OAuth 2.0 Protected Resource Metadata.\n *\n * If the server returns a 404 for the well-known endpoint, this function will\n * return `undefined`. Any other errors will be thrown as exceptions.\n */\nexport async function discoverOAuthProtectedResourceMetadata(\n  serverUrl: string | URL,\n  opts?: { protocolVersion?: string, resourceMetadataUrl?: string | URL },\n  fetchFn: FetchLike = fetch,\n): Promise\u003COAuthProtectedResourceMetadata\u003E {\n  const response = await discoverMetadataWithFallback(\n    serverUrl,\n    'oauth-protected-resource',\n    fetchFn,\n    {\n      protocolVersion: opts?.protocolVersion,\n      metadataUrl: opts?.resourceMetadataUrl,\n    },\n  );\n\n  if (!response || response.status === 404) {\n    throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);\n  }\n\n  if (!response.ok) {\n    throw new Error(\n      `HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`,\n    );\n  }\n  return OAuthProtectedResourceMetadataSchema.parse(await response.json());\n}\n\n/**\n * Helper function to handle fetch with CORS retry logic\n */\nasync function fetchWithCorsRetry(\n  url: URL,\n  headers?: Record\u003Cstring, string\u003E,\n  fetchFn: FetchLike = fetch,\n): Promise\u003CResponse | undefined\u003E {\n  try {\n    return await fetchFn(url, { headers });\n  } catch (error) {\n    if (error instanceof TypeError) {\n      if (headers) {\n        // CORS errors come back as TypeError, retry without headers\n        return fetchWithCorsRetry(url, undefined, fetchFn)\n      } else {\n        // We're getting CORS errors on retry too, return undefined\n        return undefined\n      }\n    }\n    throw error;\n  }\n}\n\n/**\n * Constructs the well-known path for auth-related metadata discovery\n */\nfunction buildWellKnownPath(\n  wellKnownPrefix: 'oauth-authorization-server' | 'oauth-protected-resource' | 'openid-configuration',\n  pathname: string = '',\n  options: { prependPathname?: boolean } = {}\n): string {\n  // Strip trailing slash from pathname to avoid double slashes\n  if (pathname.endsWith('/')) {\n    pathname = pathname.slice(0, -1);\n  }\n\n  return options.prependPathname\n    ? `${pathname}/.well-known/${wellKnownPrefix}`\n    : `/.well-known/${wellKnownPrefix}${pathname}`;\n}\n\n/**\n * Tries to discover OAuth metadata at a specific URL\n */\nasync function tryMetadataDiscovery(\n  url: URL,\n  protocolVersion: string,\n  fetchFn: FetchLike = fetch,\n): Promise\u003CResponse | undefined\u003E {\n  const headers = {\n    \"MCP-Protocol-Version\": protocolVersion\n  };\n  return await fetchWithCorsRetry(url, headers, fetchFn);\n}\n\n/**\n * Determines if fallback to root discovery should be attempted\n */\nfunction shouldAttemptFallback(response: Response | undefined, pathname: string): boolean {\n  return !response || (response.status \u003E= 400 && response.status \u003C 500) && pathname !== '/';\n}\n\n/**\n * Generic function for discovering OAuth metadata with fallback support\n */\nasync function discoverMetadataWithFallback(\n  serverUrl: string | URL,\n  wellKnownType: 'oauth-authorization-server' | 'oauth-protected-resource',\n  fetchFn: FetchLike,\n  opts?: { protocolVersion?: string; metadataUrl?: string | URL, metadataServerUrl?: string | URL },\n): Promise\u003CResponse | undefined\u003E {\n  const issuer = new URL(serverUrl);\n  const protocolVersion = opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION;\n\n  let url: URL;\n  if (opts?.metadataUrl) {\n    url = new URL(opts.metadataUrl);\n  } else {\n    // Try path-aware discovery first\n    const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);\n    url = new URL(wellKnownPath, opts?.metadataServerUrl ?? issuer);\n    url.search = issuer.search;\n  }\n\n  let response = await tryMetadataDiscovery(url, protocolVersion, fetchFn);\n\n  // If path-aware discovery fails with 404 and we're not already at root, try fallback to root discovery\n  if (!opts?.metadataUrl && shouldAttemptFallback(response, issuer.pathname)) {\n    const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);\n    response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);\n  }\n\n  return response;\n}\n\n/**\n * Looks up RFC 8414 OAuth 2.0 Authorization Server Metadata.\n *\n * If the server returns a 404 for the well-known endpoint, this function will\n * return `undefined`. Any other errors will be thrown as exceptions.\n *\n * @deprecated This function is deprecated in favor of `discoverAuthorizationServerMetadata`.\n */\nexport async function discoverOAuthMetadata(\n  issuer: string | URL,\n  {\n    authorizationServerUrl,\n    protocolVersion,\n  }: {\n    authorizationServerUrl?: string | URL,\n    protocolVersion?: string,\n  } = {},\n  fetchFn: FetchLike = fetch,\n): Promise\u003COAuthMetadata | undefined\u003E {\n  if (typeof issuer === 'string') {\n    issuer = new URL(issuer);\n  }\n  if (!authorizationServerUrl) {\n    authorizationServerUrl = issuer;\n  }\n  if (typeof authorizationServerUrl === 'string') {\n    authorizationServerUrl = new URL(authorizationServerUrl);\n  }\n  protocolVersion ??= LATEST_PROTOCOL_VERSION ;\n\n  const response = await discoverMetadataWithFallback(\n    authorizationServerUrl,\n    'oauth-authorization-server',\n    fetchFn,\n    {\n      protocolVersion,\n      metadataServerUrl: authorizationServerUrl,\n    },\n  );\n\n  if (!response || response.status === 404) {\n    return undefined;\n  }\n\n  if (!response.ok) {\n    throw new Error(\n      `HTTP ${response.status} trying to load well-known OAuth metadata`,\n    );\n  }\n\n  return OAuthMetadataSchema.parse(await response.json());\n}\n\n\n/**\n * Builds a list of discovery URLs to try for authorization server metadata.\n * URLs are returned in priority order:\n * 1. OAuth metadata at the given URL\n * 2. OAuth metadata at root (if URL has path)\n * 3. OIDC metadata endpoints\n */\nexport function buildDiscoveryUrls(authorizationServerUrl: string | URL): { url: URL; type: 'oauth' | 'oidc' }[] {\n  const url = typeof authorizationServerUrl === 'string' ? new URL(authorizationServerUrl) : authorizationServerUrl;\n  const hasPath = url.pathname !== '/';\n  const urlsToTry: { url: URL; type: 'oauth' | 'oidc' }[] = [];\n\n\n  if (!hasPath) {\n    // Root path: https://example.com/.well-known/oauth-authorization-server\n    urlsToTry.push({\n      url: new URL('/.well-known/oauth-authorization-server', url.origin),\n      type: 'oauth'\n    });\n\n    // OIDC: https://example.com/.well-known/openid-configuration\n    urlsToTry.push({\n      url: new URL(`/.well-known/openid-configuration`, url.origin),\n      type: 'oidc'\n    });\n\n    return urlsToTry;\n  }\n\n  // Strip trailing slash from pathname to avoid double slashes\n  let pathname = url.pathname;\n  if (pathname.endsWith('/')) {\n    pathname = pathname.slice(0, -1);\n  }\n\n  // 1. OAuth metadata at the given URL\n  // Insert well-known before the path: https://example.com/.well-known/oauth-authorization-server/tenant1\n  urlsToTry.push({\n    url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url.origin),\n    type: 'oauth'\n  });\n\n  // Root path: https://example.com/.well-known/oauth-authorization-server\n  urlsToTry.push({\n    url: new URL('/.well-known/oauth-authorization-server', url.origin),\n    type: 'oauth'\n  });\n\n  // 3. OIDC metadata endpoints\n  // RFC 8414 style: Insert /.well-known/openid-configuration before the path\n  urlsToTry.push({\n    url: new URL(`/.well-known/openid-configuration${pathname}`, url.origin),\n    type: 'oidc'\n  });\n  // OIDC Discovery 1.0 style: Append /.well-known/openid-configuration after the path\n  urlsToTry.push({\n    url: new URL(`${pathname}/.well-known/openid-configuration`, url.origin),\n    type: 'oidc'\n  });\n\n  return urlsToTry;\n}\n\n/**\n * Discovers authorization server metadata with support for RFC 8414 OAuth 2.0 Authorization Server Metadata\n * and OpenID Connect Discovery 1.0 specifications.\n *\n * This function implements a fallback strategy for authorization server discovery:\n * 1. Attempts RFC 8414 OAuth metadata discovery first\n * 2. If OAuth discovery fails, falls back to OpenID Connect Discovery\n *\n * @param authorizationServerUrl - The authorization server URL obtained from the MCP Server's\n *                                 protected resource metadata, or the MCP server's URL if the\n *                                 metadata was not found.\n * @param options - Configuration options\n * @param options.fetchFn - Optional fetch function for making HTTP requests, defaults to global fetch\n * @param options.protocolVersion - MCP protocol version to use, defaults to LATEST_PROTOCOL_VERSION\n * @returns Promise resolving to authorization server metadata, or undefined if discovery fails\n */\nexport async function discoverAuthorizationServerMetadata(\n  authorizationServerUrl: string | URL,\n  {\n    fetchFn = fetch,\n    protocolVersion = LATEST_PROTOCOL_VERSION,\n  }: {\n    fetchFn?: FetchLike;\n    protocolVersion?: string;\n  } = {}\n): Promise\u003CAuthorizationServerMetadata | undefined\u003E {\n  const headers = { 'MCP-Protocol-Version': protocolVersion };\n\n  // Get the list of URLs to try\n  const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);\n\n  // Try each URL in order\n  for (const { url: endpointUrl, type } of urlsToTry) {\n    const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);\n\n    if (!response) {\n      /**\n       * CORS error occurred - don't throw as the endpoint may not allow CORS,\n       * continue trying other possible endpoints\n       */\n      continue;\n    }\n\n    if (!response.ok) {\n      // Continue looking for any 4xx response code.\n      if (response.status \u003E= 400 && response.status \u003C 500) {\n        continue; // Try next URL\n      }\n      throw new Error(`HTTP ${response.status} trying to load ${type === 'oauth' ? 'OAuth' : 'OpenID provider'} metadata from ${endpointUrl}`);\n    }\n\n    // Parse and validate based on type\n    if (type === 'oauth') {\n      return OAuthMetadataSchema.parse(await response.json());\n    } else {\n      const metadata = OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());\n\n      // MCP spec requires OIDC providers to support S256 PKCE\n      if (!metadata.code_challenge_methods_supported?.includes('S256')) {\n        throw new Error(\n          `Incompatible OIDC provider at ${endpointUrl}: does not support S256 code challenge method required by MCP specification`\n        );\n      }\n\n      return metadata;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Begins the authorization flow with the given server, by generating a PKCE challenge and constructing the authorization URL.\n */\nexport async function startAuthorization(\n  authorizationServerUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    redirectUrl,\n    scope,\n    state,\n    resource,\n  }: {\n    metadata?: AuthorizationServerMetadata;\n    clientInformation: OAuthClientInformation;\n    redirectUrl: string | URL;\n    scope?: string;\n    state?: string;\n    resource?: URL;\n  },\n): Promise\u003C{ authorizationUrl: URL; codeVerifier: string }\u003E {\n  const responseType = \"code\";\n  const codeChallengeMethod = \"S256\";\n\n  let authorizationUrl: URL;\n  if (metadata) {\n    authorizationUrl = new URL(metadata.authorization_endpoint);\n\n    if (!metadata.response_types_supported.includes(responseType)) {\n      throw new Error(\n        `Incompatible auth server: does not support response type ${responseType}`,\n      );\n    }\n\n    if (\n      !metadata.code_challenge_methods_supported ||\n      !metadata.code_challenge_methods_supported.includes(codeChallengeMethod)\n    ) {\n      throw new Error(\n        `Incompatible auth server: does not support code challenge method ${codeChallengeMethod}`,\n      );\n    }\n  } else {\n    authorizationUrl = new URL(\"/authorize\", authorizationServerUrl);\n  }\n\n  // Generate PKCE challenge\n  const challenge = await pkceChallenge();\n  const codeVerifier = challenge.code_verifier;\n  const codeChallenge = challenge.code_challenge;\n\n  authorizationUrl.searchParams.set(\"response_type\", responseType);\n  authorizationUrl.searchParams.set(\"client_id\", clientInformation.client_id);\n  authorizationUrl.searchParams.set(\"code_challenge\", codeChallenge);\n  authorizationUrl.searchParams.set(\n    \"code_challenge_method\",\n    codeChallengeMethod,\n  );\n  authorizationUrl.searchParams.set(\"redirect_uri\", String(redirectUrl));\n\n  if (state) {\n    authorizationUrl.searchParams.set(\"state\", state);\n  }\n\n  if (scope) {\n    authorizationUrl.searchParams.set(\"scope\", scope);\n  }\n\n  if (scope?.includes(\"offline_access\")) {\n    // if the request includes the OIDC-only \"offline_access\" scope,\n    // we need to set the prompt to \"consent\" to ensure the user is prompted to grant offline access\n    // https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess\n    authorizationUrl.searchParams.append(\"prompt\", \"consent\");\n  }\n\n  if (resource) {\n    authorizationUrl.searchParams.set(\"resource\", resource.href);\n  }\n\n  return { authorizationUrl, codeVerifier };\n}\n\n/**\n * Exchanges an authorization code for an access token with the given server.\n *\n * Supports multiple client authentication methods as specified in OAuth 2.1:\n * - Automatically selects the best authentication method based on server support\n * - Falls back to appropriate defaults when server metadata is unavailable\n *\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration object containing client info, auth code, etc.\n * @returns Promise resolving to OAuth tokens\n * @throws {Error} When token exchange fails or authentication is invalid\n */\nexport async function exchangeAuthorization(\n  authorizationServerUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    authorizationCode,\n    codeVerifier,\n    redirectUri,\n    resource,\n    addClientAuthentication,\n    fetchFn,\n  }: {\n    metadata?: AuthorizationServerMetadata;\n    clientInformation: OAuthClientInformation;\n    authorizationCode: string;\n    codeVerifier: string;\n    redirectUri: string | URL;\n    resource?: URL;\n    addClientAuthentication?: OAuthClientProvider[\"addClientAuthentication\"];\n    fetchFn?: FetchLike;\n  },\n): Promise\u003COAuthTokens\u003E {\n  const grantType = \"authorization_code\";\n\n  const tokenUrl = metadata?.token_endpoint\n      ? new URL(metadata.token_endpoint)\n      : new URL(\"/token\", authorizationServerUrl);\n\n  if (\n      metadata?.grant_types_supported &&\n      !metadata.grant_types_supported.includes(grantType)\n  ) {\n    throw new Error(\n        `Incompatible auth server: does not support grant type ${grantType}`,\n    );\n  }\n\n  // Exchange code for tokens\n  const headers = new Headers({\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n    \"Accept\": \"application/json\",\n  });\n  const params = new URLSearchParams({\n    grant_type: grantType,\n    code: authorizationCode,\n    code_verifier: codeVerifier,\n    redirect_uri: String(redirectUri),\n  });\n\n  if (addClientAuthentication) {\n    addClientAuthentication(headers, params, authorizationServerUrl, metadata);\n  } else {\n    // Determine and apply client authentication method\n    const supportedMethods = metadata?.token_endpoint_auth_methods_supported ?? [];\n    const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);\n\n    applyClientAuthentication(authMethod, clientInformation, headers, params);\n  }\n\n  if (resource) {\n    params.set(\"resource\", resource.href);\n  }\n\n  const response = await (fetchFn ?? fetch)(tokenUrl, {\n    method: \"POST\",\n    headers,\n    body: params,\n  });\n\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n\n  return OAuthTokensSchema.parse(await response.json());\n}\n\n/**\n * Exchange a refresh token for an updated access token.\n *\n * Supports multiple client authentication methods as specified in OAuth 2.1:\n * - Automatically selects the best authentication method based on server support\n * - Preserves the original refresh token if a new one is not returned\n *\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration object containing client info, refresh token, etc.\n * @returns Promise resolving to OAuth tokens (preserves original refresh_token if not replaced)\n * @throws {Error} When token refresh fails or authentication is invalid\n */\nexport async function refreshAuthorization(\n  authorizationServerUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    refreshToken,\n    resource,\n    addClientAuthentication,\n    fetchFn,\n  }: {\n    metadata?: AuthorizationServerMetadata;\n    clientInformation: OAuthClientInformation;\n    refreshToken: string;\n    resource?: URL;\n    addClientAuthentication?: OAuthClientProvider[\"addClientAuthentication\"];\n    fetchFn?: FetchLike;\n  }\n): Promise\u003COAuthTokens\u003E {\n  const grantType = \"refresh_token\";\n\n  let tokenUrl: URL;\n  if (metadata) {\n    tokenUrl = new URL(metadata.token_endpoint);\n\n    if (\n      metadata.grant_types_supported &&\n      !metadata.grant_types_supported.includes(grantType)\n    ) {\n      throw new Error(\n        `Incompatible auth server: does not support grant type ${grantType}`,\n      );\n    }\n  } else {\n    tokenUrl = new URL(\"/token\", authorizationServerUrl);\n  }\n\n  // Exchange refresh token\n  const headers = new Headers({\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n  });\n  const params = new URLSearchParams({\n    grant_type: grantType,\n    refresh_token: refreshToken,\n  });\n\n  if (addClientAuthentication) {\n    addClientAuthentication(headers, params, authorizationServerUrl, metadata);\n  } else {\n    // Determine and apply client authentication method\n    const supportedMethods = metadata?.token_endpoint_auth_methods_supported ?? [];\n    const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);\n\n    applyClientAuthentication(authMethod, clientInformation, headers, params);\n  }\n\n  if (resource) {\n    params.set(\"resource\", resource.href);\n  }\n\n  const response = await (fetchFn ?? fetch)(tokenUrl, {\n    method: \"POST\",\n    headers,\n    body: params,\n  });\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n\n  return OAuthTokensSchema.parse({ refresh_token: refreshToken, ...(await response.json()) });\n}\n\n/**\n * Performs OAuth 2.0 Dynamic Client Registration according to RFC 7591.\n */\nexport async function registerClient(\n  authorizationServerUrl: string | URL,\n  {\n    metadata,\n    clientMetadata,\n    fetchFn,\n  }: {\n    metadata?: AuthorizationServerMetadata;\n    clientMetadata: OAuthClientMetadata;\n    fetchFn?: FetchLike;\n  },\n): Promise\u003COAuthClientInformationFull\u003E {\n  let registrationUrl: URL;\n\n  if (metadata) {\n    if (!metadata.registration_endpoint) {\n      throw new Error(\"Incompatible auth server: does not support dynamic client registration\");\n    }\n\n    registrationUrl = new URL(metadata.registration_endpoint);\n  } else {\n    registrationUrl = new URL(\"/register\", authorizationServerUrl);\n  }\n\n  const response = await (fetchFn ?? fetch)(registrationUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(clientMetadata),\n  });\n\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n\n  return OAuthClientInformationFullSchema.parse(await response.json());\n}\n",
      "hash": "0b73bb1408fac9f1fa6535f5cc73686e86e739a645fb4e7d26ecde47c8751bda",
      "size": 35742
    },
    "/src/client/cross-spawn.test.ts": {
      "type": "content",
      "content": "import { StdioClientTransport, getDefaultEnvironment } from \"./stdio.js\";\nimport spawn from \"cross-spawn\";\nimport { JSONRPCMessage } from \"../types.js\";\nimport { ChildProcess } from \"node:child_process\";\n\n// mock cross-spawn\njest.mock(\"cross-spawn\");\nconst mockSpawn = spawn as jest.MockedFunction\u003Ctypeof spawn\u003E;\n\ndescribe(\"StdioClientTransport using cross-spawn\", () =\u003E {\n  beforeEach(() =\u003E {\n    // mock cross-spawn's return value\n    mockSpawn.mockImplementation(() =\u003E {\n      const mockProcess: {\n        on: jest.Mock;\n        stdin?: { on: jest.Mock; write: jest.Mock };\n        stdout?: { on: jest.Mock };\n        stderr?: null;\n      } = {\n        on: jest.fn((event: string, callback: () =\u003E void) =\u003E {\n          if (event === \"spawn\") {\n            callback();\n          }\n          return mockProcess;\n        }),\n        stdin: {\n          on: jest.fn(),\n          write: jest.fn().mockReturnValue(true)\n        },\n        stdout: {\n          on: jest.fn()\n        },\n        stderr: null\n      };\n      return mockProcess as unknown as ChildProcess;\n    });\n  });\n\n  afterEach(() =\u003E {\n    jest.clearAllMocks();\n  });\n\n  test(\"should call cross-spawn correctly\", async () =\u003E {\n    const transport = new StdioClientTransport({\n      command: \"test-command\",\n      args: [\"arg1\", \"arg2\"]\n    });\n\n    await transport.start();\n\n    // verify spawn is called correctly\n    expect(mockSpawn).toHaveBeenCalledWith(\n      \"test-command\",\n      [\"arg1\", \"arg2\"],\n      expect.objectContaining({\n        shell: false\n      })\n    );\n  });\n\n  test(\"should pass environment variables correctly\", async () =\u003E {\n    const customEnv = { TEST_VAR: \"test-value\" };\n    const transport = new StdioClientTransport({\n      command: \"test-command\",\n      env: customEnv\n    });\n\n    await transport.start();\n\n    // verify environment variables are merged correctly\n    expect(mockSpawn).toHaveBeenCalledWith(\n      \"test-command\",\n      [],\n      expect.objectContaining({\n        env: {\n          ...getDefaultEnvironment(),\n          ...customEnv\n        }\n      })\n    );\n  });\n\n  test(\"should use default environment when env is undefined\", async () =\u003E {\n    const transport = new StdioClientTransport({\n      command: \"test-command\",\n      env: undefined\n    });\n\n    await transport.start();\n\n    // verify default environment is used\n    expect(mockSpawn).toHaveBeenCalledWith(\n      \"test-command\",\n      [],\n      expect.objectContaining({\n        env: getDefaultEnvironment()\n      })\n    );\n  });\n\n  test(\"should send messages correctly\", async () =\u003E {\n    const transport = new StdioClientTransport({\n      command: \"test-command\"\n    });\n\n    // get the mock process object\n    const mockProcess: {\n      on: jest.Mock;\n      stdin: {\n        on: jest.Mock;\n        write: jest.Mock;\n        once: jest.Mock;\n      };\n      stdout: {\n        on: jest.Mock;\n      };\n      stderr: null;\n    } = {\n      on: jest.fn((event: string, callback: () =\u003E void) =\u003E {\n        if (event === \"spawn\") {\n          callback();\n        }\n        return mockProcess;\n      }),\n      stdin: {\n        on: jest.fn(),\n        write: jest.fn().mockReturnValue(true),\n        once: jest.fn()\n      },\n      stdout: {\n        on: jest.fn()\n      },\n      stderr: null\n    };\n\n    mockSpawn.mockReturnValue(mockProcess as unknown as ChildProcess);\n\n    await transport.start();\n\n    // 关键修复：确保 jsonrpc 是字面量 \"2.0\"\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      id: \"test-id\",\n      method: \"test-method\"\n    };\n\n    await transport.send(message);\n\n    // verify message is sent correctly\n    expect(mockProcess.stdin.write).toHaveBeenCalled();\n  });\n});",
      "hash": "7ae0743be46ab9be62b4ae5a418efbf4fc2bf9a65ede8d090b20ba400b750984",
      "size": 3674
    },
    "/src/client/index.test.ts": {
      "type": "content",
      "content": "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-constant-binary-expression */\n/* eslint-disable @typescript-eslint/no-unused-expressions */\nimport { Client } from \"./index.js\";\nimport { z } from \"zod\";\nimport {\n  RequestSchema,\n  NotificationSchema,\n  ResultSchema,\n  LATEST_PROTOCOL_VERSION,\n  SUPPORTED_PROTOCOL_VERSIONS,\n  InitializeRequestSchema,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  CallToolRequestSchema,\n  CreateMessageRequestSchema,\n  ElicitRequestSchema,\n  ListRootsRequestSchema,\n  ErrorCode,\n} from \"../types.js\";\nimport { Transport } from \"../shared/transport.js\";\nimport { Server } from \"../server/index.js\";\nimport { InMemoryTransport } from \"../inMemory.js\";\n\n/***\n * Test: Initialize with Matching Protocol Version\n */\ntest(\"should initialize with matching protocol version\", async () =\u003E {\n  const clientTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) =\u003E {\n      if (message.method === \"initialize\") {\n        clientTransport.onmessage?.({\n          jsonrpc: \"2.0\",\n          id: message.id,\n          result: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            serverInfo: {\n              name: \"test\",\n              version: \"1.0\",\n            },\n            instructions: \"test instructions\",\n          },\n        });\n      }\n      return Promise.resolve();\n    }),\n  };\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  await client.connect(clientTransport);\n\n  // Should have sent initialize with latest version\n  expect(clientTransport.send).toHaveBeenCalledWith(\n    expect.objectContaining({\n      method: \"initialize\",\n      params: expect.objectContaining({\n        protocolVersion: LATEST_PROTOCOL_VERSION,\n      }),\n    }),\n    expect.objectContaining({\n      relatedRequestId: undefined,\n    }),\n  );\n\n  // Should have the instructions returned\n  expect(client.getInstructions()).toEqual(\"test instructions\");\n});\n\n/***\n * Test: Initialize with Supported Older Protocol Version\n */\ntest(\"should initialize with supported older protocol version\", async () =\u003E {\n  const OLD_VERSION = SUPPORTED_PROTOCOL_VERSIONS[1];\n  const clientTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) =\u003E {\n      if (message.method === \"initialize\") {\n        clientTransport.onmessage?.({\n          jsonrpc: \"2.0\",\n          id: message.id,\n          result: {\n            protocolVersion: OLD_VERSION,\n            capabilities: {},\n            serverInfo: {\n              name: \"test\",\n              version: \"1.0\",\n            },\n          },\n        });\n      }\n      return Promise.resolve();\n    }),\n  };\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  await client.connect(clientTransport);\n\n  // Connection should succeed with the older version\n  expect(client.getServerVersion()).toEqual({\n    name: \"test\",\n    version: \"1.0\",\n  });\n\n  // Expect no instructions\n  expect(client.getInstructions()).toBeUndefined();\n});\n\n/***\n * Test: Reject Unsupported Protocol Version\n */\ntest(\"should reject unsupported protocol version\", async () =\u003E {\n  const clientTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) =\u003E {\n      if (message.method === \"initialize\") {\n        clientTransport.onmessage?.({\n          jsonrpc: \"2.0\",\n          id: message.id,\n          result: {\n            protocolVersion: \"invalid-version\",\n            capabilities: {},\n            serverInfo: {\n              name: \"test\",\n              version: \"1.0\",\n            },\n          },\n        });\n      }\n      return Promise.resolve();\n    }),\n  };\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  await expect(client.connect(clientTransport)).rejects.toThrow(\n    \"Server's protocol version is not supported: invalid-version\",\n  );\n\n  expect(clientTransport.close).toHaveBeenCalled();\n});\n\n/***\n * Test: Connect New Client to Old Supported Server Version\n */\ntest(\"should connect new client to old, supported server version\", async () =\u003E {\n  const OLD_VERSION = SUPPORTED_PROTOCOL_VERSIONS[1];\n  const server = new Server(\n      {\n        name: \"test server\",\n        version: \"1.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n          tools: {},\n        },\n      },\n  );\n\n  server.setRequestHandler(InitializeRequestSchema, (_request) =\u003E ({\n    protocolVersion: OLD_VERSION,\n    capabilities: {\n      resources: {},\n      tools: {},\n    },\n    serverInfo: {\n      name: \"old server\",\n      version: \"1.0\",\n    },\n  }));\n\n  server.setRequestHandler(ListResourcesRequestSchema, () =\u003E ({\n    resources: [],\n  }));\n\n  server.setRequestHandler(ListToolsRequestSchema, () =\u003E ({\n    tools: [],\n  }));\n\n  const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n  const client = new Client(\n      {\n        name: \"new client\",\n        version: \"1.0\",\n        protocolVersion: LATEST_PROTOCOL_VERSION,\n      },\n      {\n        capabilities: {\n          sampling: {},\n        },\n        enforceStrictCapabilities: true,\n      },\n  );\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  expect(client.getServerVersion()).toEqual({\n    name: \"old server\",\n    version: \"1.0\",\n  });\n});\n\n/***\n * Test: Version Negotiation with Old Client and Newer Server\n */\ntest(\"should negotiate version when client is old, and newer server supports its version\", async () =\u003E {\n  const OLD_VERSION = SUPPORTED_PROTOCOL_VERSIONS[1];\n  const server = new Server(\n      {\n        name: \"new server\",\n        version: \"1.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n          tools: {},\n        },\n      },\n  );\n\n  server.setRequestHandler(InitializeRequestSchema, (_request) =\u003E ({\n    protocolVersion: LATEST_PROTOCOL_VERSION,\n    capabilities: {\n      resources: {},\n      tools: {},\n    },\n    serverInfo: {\n      name: \"new server\",\n      version: \"1.0\",\n    },\n  }));\n\n  server.setRequestHandler(ListResourcesRequestSchema, () =\u003E ({\n    resources: [],\n  }));\n\n  server.setRequestHandler(ListToolsRequestSchema, () =\u003E ({\n    tools: [],\n  }));\n\n  const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n  const client = new Client(\n      {\n        name: \"old client\",\n        version: \"1.0\",\n        protocolVersion: OLD_VERSION,\n      },\n      {\n        capabilities: {\n          sampling: {},\n        },\n        enforceStrictCapabilities: true,\n      },\n  );\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  expect(client.getServerVersion()).toEqual({\n    name: \"new server\",\n    version: \"1.0\",\n  });\n});\n\n/***\n * Test: Throw when Old Client and Server Version Mismatch\n */\ntest(\"should throw when client is old, and server doesn't support its version\", async () =\u003E {\n  const OLD_VERSION = SUPPORTED_PROTOCOL_VERSIONS[1];\n  const FUTURE_VERSION = \"FUTURE_VERSION\";\n  const server = new Server(\n      {\n        name: \"new server\",\n        version: \"1.0\",\n      },\n      {\n        capabilities: {\n          resources: {},\n          tools: {},\n        },\n      },\n  );\n\n  server.setRequestHandler(InitializeRequestSchema, (_request) =\u003E ({\n    protocolVersion: FUTURE_VERSION,\n    capabilities: {\n      resources: {},\n      tools: {},\n    },\n    serverInfo: {\n      name: \"new server\",\n      version: \"1.0\",\n    },\n  }));\n\n  server.setRequestHandler(ListResourcesRequestSchema, () =\u003E ({\n    resources: [],\n  }));\n\n  server.setRequestHandler(ListToolsRequestSchema, () =\u003E ({\n    tools: [],\n  }));\n\n  const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n  const client = new Client(\n      {\n        name: \"old client\",\n        version: \"1.0\",\n        protocolVersion: OLD_VERSION,\n      },\n      {\n        capabilities: {\n          sampling: {},\n        },\n        enforceStrictCapabilities: true,\n      },\n  );\n\n  await Promise.all([\n    expect(client.connect(clientTransport)).rejects.toThrow(\n        \"Server's protocol version is not supported: FUTURE_VERSION\"\n    ),\n    server.connect(serverTransport),\n  ]);\n\n});\n\n/***\n * Test: Respect Server Capabilities\n */\ntest(\"should respect server capabilities\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        resources: {},\n        tools: {},\n      },\n    },\n  );\n\n  server.setRequestHandler(InitializeRequestSchema, (_request) =\u003E ({\n    protocolVersion: LATEST_PROTOCOL_VERSION,\n    capabilities: {\n      resources: {},\n      tools: {},\n    },\n    serverInfo: {\n      name: \"test\",\n      version: \"1.0\",\n    },\n  }));\n\n  server.setRequestHandler(ListResourcesRequestSchema, () =\u003E ({\n    resources: [],\n  }));\n\n  server.setRequestHandler(ListToolsRequestSchema, () =\u003E ({\n    tools: [],\n  }));\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Server supports resources and tools, but not prompts\n  expect(client.getServerCapabilities()).toEqual({\n    resources: {},\n    tools: {},\n  });\n\n  // These should work\n  await expect(client.listResources()).resolves.not.toThrow();\n  await expect(client.listTools()).resolves.not.toThrow();\n\n  // These should throw because prompts, logging, and completions are not supported\n  await expect(client.listPrompts()).rejects.toThrow(\n    \"Server does not support prompts\",\n  );\n  await expect(client.setLoggingLevel(\"error\")).rejects.toThrow(\n    \"Server does not support logging\",\n  );\n  await expect(\n    client.complete({\n      ref: { type: \"ref/prompt\", name: \"test\" },\n      argument: { name: \"test\", value: \"test\" },\n    }),\n  ).rejects.toThrow(\"Server does not support completions\");\n});\n\n/***\n * Test: Respect Client Notification Capabilities\n */\ntest(\"should respect client notification capabilities\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        roots: {\n          listChanged: true,\n        },\n      },\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // This should work because the client has the roots.listChanged capability\n  await expect(client.sendRootsListChanged()).resolves.not.toThrow();\n\n  // Create a new client without the roots.listChanged capability\n  const clientWithoutCapability = new Client(\n    {\n      name: \"test client without capability\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  await clientWithoutCapability.connect(clientTransport);\n\n  // This should throw because the client doesn't have the roots.listChanged capability\n  await expect(clientWithoutCapability.sendRootsListChanged()).rejects.toThrow(\n    /^Client does not support/,\n  );\n});\n\n/***\n * Test: Respect Server Notification Capabilities\n */\ntest(\"should respect server notification capabilities\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        logging: {},\n        resources: {\n          listChanged: true,\n        },\n      },\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // These should work because the server has the corresponding capabilities\n  await expect(\n    server.sendLoggingMessage({ level: \"info\", data: \"Test\" }),\n  ).resolves.not.toThrow();\n  await expect(server.sendResourceListChanged()).resolves.not.toThrow();\n\n  // This should throw because the server doesn't have the tools capability\n  await expect(server.sendToolListChanged()).rejects.toThrow(\n    \"Server does not support notifying of tool list changes\",\n  );\n});\n\n/***\n * Test: Only Allow setRequestHandler for Declared Capabilities\n */\ntest(\"should only allow setRequestHandler for declared capabilities\", () =\u003E {\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  // This should work because sampling is a declared capability\n  expect(() =\u003E {\n    client.setRequestHandler(CreateMessageRequestSchema, () =\u003E ({\n      model: \"test-model\",\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"Test response\",\n      },\n    }));\n  }).not.toThrow();\n\n  // This should throw because roots listing is not a declared capability\n  expect(() =\u003E {\n    client.setRequestHandler(ListRootsRequestSchema, () =\u003E ({}));\n  }).toThrow(\"Client does not support roots capability\");\n});\n\ntest(\"should allow setRequestHandler for declared elicitation capability\", () =\u003E {\n  const client = new Client(\n    {\n      name: \"test-client\",\n      version: \"1.0.0\",\n    },\n    {\n      capabilities: {\n        elicitation: {},\n      },\n    },\n  );\n\n  // This should work because elicitation is a declared capability\n  expect(() =\u003E {\n    client.setRequestHandler(ElicitRequestSchema, () =\u003E ({\n      action: \"accept\",\n      content: {\n        username: \"test-user\",\n        confirmed: true,\n      },\n    }));\n  }).not.toThrow();\n\n  // This should throw because sampling is not a declared capability\n  expect(() =\u003E {\n    client.setRequestHandler(CreateMessageRequestSchema, () =\u003E ({\n      model: \"test-model\",\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"Test response\",\n      },\n    }));\n  }).toThrow(\"Client does not support sampling capability\");\n});\n\n/***\n * Test: Type Checking\n * Test that custom request/notification/result schemas can be used with the Client class.\n */\ntest(\"should typecheck\", () =\u003E {\n  const GetWeatherRequestSchema = RequestSchema.extend({\n    method: z.literal(\"weather/get\"),\n    params: z.object({\n      city: z.string(),\n    }),\n  });\n\n  const GetForecastRequestSchema = RequestSchema.extend({\n    method: z.literal(\"weather/forecast\"),\n    params: z.object({\n      city: z.string(),\n      days: z.number(),\n    }),\n  });\n\n  const WeatherForecastNotificationSchema = NotificationSchema.extend({\n    method: z.literal(\"weather/alert\"),\n    params: z.object({\n      severity: z.enum([\"warning\", \"watch\"]),\n      message: z.string(),\n    }),\n  });\n\n  const WeatherRequestSchema = GetWeatherRequestSchema.or(\n    GetForecastRequestSchema,\n  );\n  const WeatherNotificationSchema = WeatherForecastNotificationSchema;\n  const WeatherResultSchema = ResultSchema.extend({\n    temperature: z.number(),\n    conditions: z.string(),\n  });\n\n  type WeatherRequest = z.infer\u003Ctypeof WeatherRequestSchema\u003E;\n  type WeatherNotification = z.infer\u003Ctypeof WeatherNotificationSchema\u003E;\n  type WeatherResult = z.infer\u003Ctypeof WeatherResultSchema\u003E;\n\n  // Create a typed Client for weather data\n  const weatherClient = new Client\u003C\n    WeatherRequest,\n    WeatherNotification,\n    WeatherResult\n  \u003E(\n    {\n      name: \"WeatherClient\",\n      version: \"1.0.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  // Typecheck that only valid weather requests/notifications/results are allowed\n  false &&\n    weatherClient.request(\n      {\n        method: \"weather/get\",\n        params: {\n          city: \"Seattle\",\n        },\n      },\n      WeatherResultSchema,\n    );\n\n  false &&\n    weatherClient.notification({\n      method: \"weather/alert\",\n      params: {\n        severity: \"warning\",\n        message: \"Storm approaching\",\n      },\n    });\n});\n\n/***\n * Test: Handle Client Cancelling a Request\n */\ntest(\"should handle client cancelling a request\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        resources: {},\n      },\n    },\n  );\n\n  // Set up server to delay responding to listResources\n  server.setRequestHandler(\n    ListResourcesRequestSchema,\n    async (request, extra) =\u003E {\n      await new Promise((resolve) =\u003E setTimeout(resolve, 1000));\n      return {\n        resources: [],\n      };\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n    },\n  );\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Set up abort controller\n  const controller = new AbortController();\n\n  // Issue request but cancel it immediately\n  const listResourcesPromise = client.listResources(undefined, {\n    signal: controller.signal,\n  });\n  controller.abort(\"Cancelled by test\");\n\n  // Request should be rejected\n  await expect(listResourcesPromise).rejects.toBe(\"Cancelled by test\");\n});\n\n/***\n * Test: Handle Request Timeout\n */\ntest(\"should handle request timeout\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        resources: {},\n      },\n    },\n  );\n\n  // Set up server with a delayed response\n  server.setRequestHandler(\n    ListResourcesRequestSchema,\n    async (_request, extra) =\u003E {\n      const timer = new Promise((resolve) =\u003E {\n        const timeout = setTimeout(resolve, 100);\n        extra.signal.addEventListener(\"abort\", () =\u003E clearTimeout(timeout));\n      });\n\n      await timer;\n      return {\n        resources: [],\n      };\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n    },\n  );\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Request with 0 msec timeout should fail immediately\n  await expect(\n    client.listResources(undefined, { timeout: 0 }),\n  ).rejects.toMatchObject({\n    code: ErrorCode.RequestTimeout,\n  });\n});\n\ndescribe('outputSchema validation', () =\u003E {\n  /***\n   * Test: Validate structuredContent Against outputSchema\n   */\n  test('should validate structuredContent against outputSchema', async () =\u003E {\n    const server = new Server({\n      name: 'test-server',\n      version: '1.0.0',\n    }, {\n      capabilities: {\n        tools: {},\n      },\n    });\n\n    // Set up server handlers\n    server.setRequestHandler(InitializeRequestSchema, async (request) =\u003E ({\n      protocolVersion: request.params.protocolVersion,\n      capabilities: {},\n      serverInfo: {\n        name: 'test-server',\n        version: '1.0.0',\n      }\n    }));\n\n    server.setRequestHandler(ListToolsRequestSchema, async () =\u003E ({\n      tools: [\n        {\n          name: 'test-tool',\n          description: 'A test tool',\n          inputSchema: {\n            type: 'object',\n            properties: {},\n          },\n          outputSchema: {\n            type: 'object',\n            properties: {\n              result: { type: 'string' },\n              count: { type: 'number' },\n            },\n            required: ['result', 'count'],\n            additionalProperties: false,\n          },\n        },\n      ],\n    }));\n\n    server.setRequestHandler(CallToolRequestSchema, async (request) =\u003E {\n      if (request.params.name === 'test-tool') {\n        return {\n          structuredContent: { result: 'success', count: 42 },\n        };\n      }\n      throw new Error('Unknown tool');\n    });\n\n    const client = new Client({\n      name: 'test-client',\n      version: '1.0.0',\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      server.connect(serverTransport),\n    ]);\n\n    // List tools to cache the schemas\n    await client.listTools();\n\n    // Call the tool - should validate successfully\n    const result = await client.callTool({ name: 'test-tool' });\n    expect(result.structuredContent).toEqual({ result: 'success', count: 42 });\n  });\n\n  /***\n   * Test: Throw Error when structuredContent Does Not Match Schema\n   */\n  test('should throw error when structuredContent does not match schema', async () =\u003E {\n    const server = new Server({\n      name: 'test-server',\n      version: '1.0.0',\n    }, {\n      capabilities: {\n        tools: {},\n      },\n    });\n\n    // Set up server handlers\n    server.setRequestHandler(InitializeRequestSchema, async (request) =\u003E ({\n      protocolVersion: request.params.protocolVersion,\n      capabilities: {},\n      serverInfo: {\n        name: 'test-server',\n        version: '1.0.0',\n      }\n    }));\n\n    server.setRequestHandler(ListToolsRequestSchema, async () =\u003E ({\n      tools: [\n        {\n          name: 'test-tool',\n          description: 'A test tool',\n          inputSchema: {\n            type: 'object',\n            properties: {},\n          },\n          outputSchema: {\n            type: 'object',\n            properties: {\n              result: { type: 'string' },\n              count: { type: 'number' },\n            },\n            required: ['result', 'count'],\n            additionalProperties: false,\n          },\n        },\n      ],\n    }));\n\n    server.setRequestHandler(CallToolRequestSchema, async (request) =\u003E {\n      if (request.params.name === 'test-tool') {\n        // Return invalid structured content (count is string instead of number)\n        return {\n          structuredContent: { result: 'success', count: 'not a number' },\n        };\n      }\n      throw new Error('Unknown tool');\n    });\n\n    const client = new Client({\n      name: 'test-client',\n      version: '1.0.0',\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      server.connect(serverTransport),\n    ]);\n\n    // List tools to cache the schemas\n    await client.listTools();\n\n    // Call the tool - should throw validation error\n    await expect(client.callTool({ name: 'test-tool' })).rejects.toThrow(\n      /Structured content does not match the tool's output schema/\n    );\n  });\n\n  /***\n   * Test: Throw Error when Tool with outputSchema Returns No structuredContent\n   */\n  test('should throw error when tool with outputSchema returns no structuredContent', async () =\u003E {\n    const server = new Server({\n      name: 'test-server',\n      version: '1.0.0',\n    }, {\n      capabilities: {\n        tools: {},\n      },\n    });\n\n    // Set up server handlers\n    server.setRequestHandler(InitializeRequestSchema, async (request) =\u003E ({\n      protocolVersion: request.params.protocolVersion,\n      capabilities: {},\n      serverInfo: {\n        name: 'test-server',\n        version: '1.0.0',\n      }\n    }));\n\n    server.setRequestHandler(ListToolsRequestSchema, async () =\u003E ({\n      tools: [\n        {\n          name: 'test-tool',\n          description: 'A test tool',\n          inputSchema: {\n            type: 'object',\n            properties: {},\n          },\n          outputSchema: {\n            type: 'object',\n            properties: {\n              result: { type: 'string' },\n            },\n            required: ['result'],\n          },\n        },\n      ],\n    }));\n\n    server.setRequestHandler(CallToolRequestSchema, async (request) =\u003E {\n      if (request.params.name === 'test-tool') {\n        // Return content instead of structuredContent\n        return {\n          content: [{ type: 'text', text: 'This should be structured content' }],\n        };\n      }\n      throw new Error('Unknown tool');\n    });\n\n    const client = new Client({\n      name: 'test-client',\n      version: '1.0.0',\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      server.connect(serverTransport),\n    ]);\n\n    // List tools to cache the schemas\n    await client.listTools();\n\n    // Call the tool - should throw error\n    await expect(client.callTool({ name: 'test-tool' })).rejects.toThrow(\n      /Tool test-tool has an output schema but did not return structured content/\n    );\n  });\n\n  /***\n   * Test: Handle Tools Without outputSchema Normally\n   */\n  test('should handle tools without outputSchema normally', async () =\u003E {\n    const server = new Server({\n      name: 'test-server',\n      version: '1.0.0',\n    }, {\n      capabilities: {\n        tools: {},\n      },\n    });\n\n    // Set up server handlers\n    server.setRequestHandler(InitializeRequestSchema, async (request) =\u003E ({\n      protocolVersion: request.params.protocolVersion,\n      capabilities: {},\n      serverInfo: {\n        name: 'test-server',\n        version: '1.0.0',\n      }\n    }));\n\n    server.setRequestHandler(ListToolsRequestSchema, async () =\u003E ({\n      tools: [\n        {\n          name: 'test-tool',\n          description: 'A test tool',\n          inputSchema: {\n            type: 'object',\n            properties: {},\n          },\n          // No outputSchema\n        },\n      ],\n    }));\n\n    server.setRequestHandler(CallToolRequestSchema, async (request) =\u003E {\n      if (request.params.name === 'test-tool') {\n        // Return regular content\n        return {\n          content: [{ type: 'text', text: 'Normal response' }],\n        };\n      }\n      throw new Error('Unknown tool');\n    });\n\n    const client = new Client({\n      name: 'test-client',\n      version: '1.0.0',\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      server.connect(serverTransport),\n    ]);\n\n    // List tools to cache the schemas\n    await client.listTools();\n\n    // Call the tool - should work normally without validation\n    const result = await client.callTool({ name: 'test-tool' });\n    expect(result.content).toEqual([{ type: 'text', text: 'Normal response' }]);\n  });\n\n  /***\n   * Test: Handle Complex JSON Schema Validation\n   */\n  test('should handle complex JSON schema validation', async () =\u003E {\n    const server = new Server({\n      name: 'test-server',\n      version: '1.0.0',\n    }, {\n      capabilities: {\n        tools: {},\n      },\n    });\n\n    // Set up server handlers\n    server.setRequestHandler(InitializeRequestSchema, async (request) =\u003E ({\n      protocolVersion: request.params.protocolVersion,\n      capabilities: {},\n      serverInfo: {\n        name: 'test-server',\n        version: '1.0.0',\n      }\n    }));\n\n    server.setRequestHandler(ListToolsRequestSchema, async () =\u003E ({\n      tools: [\n        {\n          name: 'complex-tool',\n          description: 'A tool with complex schema',\n          inputSchema: {\n            type: 'object',\n            properties: {},\n          },\n          outputSchema: {\n            type: 'object',\n            properties: {\n              name: { type: 'string', minLength: 3 },\n              age: { type: 'integer', minimum: 0, maximum: 120 },\n              active: { type: 'boolean' },\n              tags: {\n                type: 'array',\n                items: { type: 'string' },\n                minItems: 1,\n              },\n              metadata: {\n                type: 'object',\n                properties: {\n                  created: { type: 'string' },\n                },\n                required: ['created'],\n              },\n            },\n            required: ['name', 'age', 'active', 'tags', 'metadata'],\n            additionalProperties: false,\n          },\n        },\n      ],\n    }));\n\n    server.setRequestHandler(CallToolRequestSchema, async (request) =\u003E {\n      if (request.params.name === 'complex-tool') {\n        return {\n          structuredContent: {\n            name: 'John Doe',\n            age: 30,\n            active: true,\n            tags: ['user', 'admin'],\n            metadata: {\n              created: '2023-01-01T00:00:00Z',\n            },\n          },\n        };\n      }\n      throw new Error('Unknown tool');\n    });\n\n    const client = new Client({\n      name: 'test-client',\n      version: '1.0.0',\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      server.connect(serverTransport),\n    ]);\n\n    // List tools to cache the schemas\n    await client.listTools();\n\n    // Call the tool - should validate successfully\n    const result = await client.callTool({ name: 'complex-tool' });\n    expect(result.structuredContent).toBeDefined();\n    const structuredContent = result.structuredContent as { name: string; age: number };\n    expect(structuredContent.name).toBe('John Doe');\n    expect(structuredContent.age).toBe(30);\n  });\n\n  /***\n   * Test: Fail Validation with Additional Properties When Not Allowed\n   */\n  test('should fail validation with additional properties when not allowed', async () =\u003E {\n    const server = new Server({\n      name: 'test-server',\n      version: '1.0.0',\n    }, {\n      capabilities: {\n        tools: {},\n      },\n    });\n\n    // Set up server handlers\n    server.setRequestHandler(InitializeRequestSchema, async (request) =\u003E ({\n      protocolVersion: request.params.protocolVersion,\n      capabilities: {},\n      serverInfo: {\n        name: 'test-server',\n        version: '1.0.0',\n      }\n    }));\n\n    server.setRequestHandler(ListToolsRequestSchema, async () =\u003E ({\n      tools: [\n        {\n          name: 'strict-tool',\n          description: 'A tool with strict schema',\n          inputSchema: {\n            type: 'object',\n            properties: {},\n          },\n          outputSchema: {\n            type: 'object',\n            properties: {\n              name: { type: 'string' },\n            },\n            required: ['name'],\n            additionalProperties: false,\n          },\n        },\n      ],\n    }));\n\n    server.setRequestHandler(CallToolRequestSchema, async (request) =\u003E {\n      if (request.params.name === 'strict-tool') {\n        // Return structured content with extra property\n        return {\n          structuredContent: {\n            name: 'John',\n            extraField: 'not allowed',\n          },\n        };\n      }\n      throw new Error('Unknown tool');\n    });\n\n    const client = new Client({\n      name: 'test-client',\n      version: '1.0.0',\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      server.connect(serverTransport),\n    ]);\n\n    // List tools to cache the schemas\n    await client.listTools();\n\n    // Call the tool - should throw validation error due to additional property\n    await expect(client.callTool({ name: 'strict-tool' })).rejects.toThrow(\n      /Structured content does not match the tool's output schema/\n    );\n  });\n\n\n});\n",
      "hash": "e931143d15aa56d1f4977c303e3c739ebe1472fbbbad20a4eaa95bac0e48a6fb",
      "size": 31981
    },
    "/src/client/index.ts": {
      "type": "content",
      "content": "import {\n  mergeCapabilities,\n  Protocol,\n  ProtocolOptions,\n  RequestOptions,\n} from \"../shared/protocol.js\";\nimport { Transport } from \"../shared/transport.js\";\nimport {\n  CallToolRequest,\n  CallToolResultSchema,\n  ClientCapabilities,\n  ClientNotification,\n  ClientRequest,\n  ClientResult,\n  CompatibilityCallToolResultSchema,\n  CompleteRequest,\n  CompleteResultSchema,\n  EmptyResultSchema,\n  GetPromptRequest,\n  GetPromptResultSchema,\n  Implementation,\n  InitializeResultSchema,\n  LATEST_PROTOCOL_VERSION,\n  ListPromptsRequest,\n  ListPromptsResultSchema,\n  ListResourcesRequest,\n  ListResourcesResultSchema,\n  ListResourceTemplatesRequest,\n  ListResourceTemplatesResultSchema,\n  ListToolsRequest,\n  ListToolsResultSchema,\n  LoggingLevel,\n  Notification,\n  ReadResourceRequest,\n  ReadResourceResultSchema,\n  Request,\n  Result,\n  ServerCapabilities,\n  SubscribeRequest,\n  SUPPORTED_PROTOCOL_VERSIONS,\n  UnsubscribeRequest,\n  Tool,\n  ErrorCode,\n  McpError,\n} from \"../types.js\";\nimport Ajv from \"ajv\";\nimport type { ValidateFunction } from \"ajv\";\n\nexport type ClientOptions = ProtocolOptions & {\n  /**\n   * Capabilities to advertise as being supported by this client.\n   */\n  capabilities?: ClientCapabilities;\n};\n\n/**\n * An MCP client on top of a pluggable transport.\n *\n * The client will automatically begin the initialization flow with the server when connect() is called.\n *\n * To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:\n *\n * ```typescript\n * // Custom schemas\n * const CustomRequestSchema = RequestSchema.extend({...})\n * const CustomNotificationSchema = NotificationSchema.extend({...})\n * const CustomResultSchema = ResultSchema.extend({...})\n *\n * // Type aliases\n * type CustomRequest = z.infer\u003Ctypeof CustomRequestSchema\u003E\n * type CustomNotification = z.infer\u003Ctypeof CustomNotificationSchema\u003E\n * type CustomResult = z.infer\u003Ctypeof CustomResultSchema\u003E\n *\n * // Create typed client\n * const client = new Client\u003CCustomRequest, CustomNotification, CustomResult\u003E({\n *   name: \"CustomClient\",\n *   version: \"1.0.0\"\n * })\n * ```\n */\nexport class Client\u003C\n  RequestT extends Request = Request,\n  NotificationT extends Notification = Notification,\n  ResultT extends Result = Result,\n\u003E extends Protocol\u003C\n  ClientRequest | RequestT,\n  ClientNotification | NotificationT,\n  ClientResult | ResultT\n\u003E {\n  private _serverCapabilities?: ServerCapabilities;\n  private _serverVersion?: Implementation;\n  private _capabilities: ClientCapabilities;\n  private _instructions?: string;\n  private _cachedToolOutputValidators: Map\u003Cstring, ValidateFunction\u003E = new Map();\n  private _ajv: InstanceType\u003Ctypeof Ajv\u003E;\n\n  /**\n   * Initializes this client with the given name and version information.\n   */\n  constructor(\n    private _clientInfo: Implementation,\n    options?: ClientOptions,\n  ) {\n    super(options);\n    this._capabilities = options?.capabilities ?? {};\n    this._ajv = new Ajv();\n  }\n\n  /**\n   * Registers new capabilities. This can only be called before connecting to a transport.\n   *\n   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).\n   */\n  public registerCapabilities(capabilities: ClientCapabilities): void {\n    if (this.transport) {\n      throw new Error(\n        \"Cannot register capabilities after connecting to transport\",\n      );\n    }\n\n    this._capabilities = mergeCapabilities(this._capabilities, capabilities);\n  }\n\n  protected assertCapability(\n    capability: keyof ServerCapabilities,\n    method: string,\n  ): void {\n    if (!this._serverCapabilities?.[capability]) {\n      throw new Error(\n        `Server does not support ${capability} (required for ${method})`,\n      );\n    }\n  }\n\n  override async connect(transport: Transport, options?: RequestOptions): Promise\u003Cvoid\u003E {\n    await super.connect(transport);\n    // When transport sessionId is already set this means we are trying to reconnect.\n    // In this case we don't need to initialize again.\n    if (transport.sessionId !== undefined) {\n      return;\n    }\n    try {\n      const result = await this.request(\n        {\n          method: \"initialize\",\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: this._capabilities,\n            clientInfo: this._clientInfo,\n          },\n        },\n        InitializeResultSchema,\n        options\n      );\n\n      if (result === undefined) {\n        throw new Error(`Server sent invalid initialize result: ${result}`);\n      }\n\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new Error(\n          `Server's protocol version is not supported: ${result.protocolVersion}`,\n        );\n      }\n\n      this._serverCapabilities = result.capabilities;\n      this._serverVersion = result.serverInfo;\n      // HTTP transports must set the protocol version in each header after initialization.\n      if (transport.setProtocolVersion) {\n        transport.setProtocolVersion(result.protocolVersion);\n      }\n\n      this._instructions = result.instructions;\n\n      await this.notification({\n        method: \"notifications/initialized\",\n      });\n    } catch (error) {\n      // Disconnect if initialization fails.\n      void this.close();\n      throw error;\n    }\n  }\n\n  /**\n   * After initialization has completed, this will be populated with the server's reported capabilities.\n   */\n  getServerCapabilities(): ServerCapabilities | undefined {\n    return this._serverCapabilities;\n  }\n\n  /**\n   * After initialization has completed, this will be populated with information about the server's name and version.\n   */\n  getServerVersion(): Implementation | undefined {\n    return this._serverVersion;\n  }\n\n  /**\n   * After initialization has completed, this may be populated with information about the server's instructions.\n   */\n  getInstructions(): string | undefined {\n    return this._instructions;\n  }\n\n  protected assertCapabilityForMethod(method: RequestT[\"method\"]): void {\n    switch (method as ClientRequest[\"method\"]) {\n      case \"logging/setLevel\":\n        if (!this._serverCapabilities?.logging) {\n          throw new Error(\n            `Server does not support logging (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"prompts/get\":\n      case \"prompts/list\":\n        if (!this._serverCapabilities?.prompts) {\n          throw new Error(\n            `Server does not support prompts (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"resources/list\":\n      case \"resources/templates/list\":\n      case \"resources/read\":\n      case \"resources/subscribe\":\n      case \"resources/unsubscribe\":\n        if (!this._serverCapabilities?.resources) {\n          throw new Error(\n            `Server does not support resources (required for ${method})`,\n          );\n        }\n\n        if (\n          method === \"resources/subscribe\" &&\n          !this._serverCapabilities.resources.subscribe\n        ) {\n          throw new Error(\n            `Server does not support resource subscriptions (required for ${method})`,\n          );\n        }\n\n        break;\n\n      case \"tools/call\":\n      case \"tools/list\":\n        if (!this._serverCapabilities?.tools) {\n          throw new Error(\n            `Server does not support tools (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"completion/complete\":\n        if (!this._serverCapabilities?.completions) {\n          throw new Error(\n            `Server does not support completions (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"initialize\":\n        // No specific capability required for initialize\n        break;\n\n      case \"ping\":\n        // No specific capability required for ping\n        break;\n    }\n  }\n\n  protected assertNotificationCapability(\n    method: NotificationT[\"method\"],\n  ): void {\n    switch (method as ClientNotification[\"method\"]) {\n      case \"notifications/roots/list_changed\":\n        if (!this._capabilities.roots?.listChanged) {\n          throw new Error(\n            `Client does not support roots list changed notifications (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"notifications/initialized\":\n        // No specific capability required for initialized\n        break;\n\n      case \"notifications/cancelled\":\n        // Cancellation notifications are always allowed\n        break;\n\n      case \"notifications/progress\":\n        // Progress notifications are always allowed\n        break;\n    }\n  }\n\n  protected assertRequestHandlerCapability(method: string): void {\n    switch (method) {\n      case \"sampling/createMessage\":\n        if (!this._capabilities.sampling) {\n          throw new Error(\n            `Client does not support sampling capability (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"elicitation/create\":\n        if (!this._capabilities.elicitation) {\n          throw new Error(\n            `Client does not support elicitation capability (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"roots/list\":\n        if (!this._capabilities.roots) {\n          throw new Error(\n            `Client does not support roots capability (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"ping\":\n        // No specific capability required for ping\n        break;\n    }\n  }\n\n  async ping(options?: RequestOptions) {\n    return this.request({ method: \"ping\" }, EmptyResultSchema, options);\n  }\n\n  async complete(params: CompleteRequest[\"params\"], options?: RequestOptions) {\n    return this.request(\n      { method: \"completion/complete\", params },\n      CompleteResultSchema,\n      options,\n    );\n  }\n\n  async setLoggingLevel(level: LoggingLevel, options?: RequestOptions) {\n    return this.request(\n      { method: \"logging/setLevel\", params: { level } },\n      EmptyResultSchema,\n      options,\n    );\n  }\n\n  async getPrompt(\n    params: GetPromptRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"prompts/get\", params },\n      GetPromptResultSchema,\n      options,\n    );\n  }\n\n  async listPrompts(\n    params?: ListPromptsRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"prompts/list\", params },\n      ListPromptsResultSchema,\n      options,\n    );\n  }\n\n  async listResources(\n    params?: ListResourcesRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"resources/list\", params },\n      ListResourcesResultSchema,\n      options,\n    );\n  }\n\n  async listResourceTemplates(\n    params?: ListResourceTemplatesRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"resources/templates/list\", params },\n      ListResourceTemplatesResultSchema,\n      options,\n    );\n  }\n\n  async readResource(\n    params: ReadResourceRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"resources/read\", params },\n      ReadResourceResultSchema,\n      options,\n    );\n  }\n\n  async subscribeResource(\n    params: SubscribeRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"resources/subscribe\", params },\n      EmptyResultSchema,\n      options,\n    );\n  }\n\n  async unsubscribeResource(\n    params: UnsubscribeRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"resources/unsubscribe\", params },\n      EmptyResultSchema,\n      options,\n    );\n  }\n\n  async callTool(\n    params: CallToolRequest[\"params\"],\n    resultSchema:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema = CallToolResultSchema,\n    options?: RequestOptions,\n  ) {\n    const result = await this.request(\n      { method: \"tools/call\", params },\n      resultSchema,\n      options,\n    );\n\n    // Check if the tool has an outputSchema\n    const validator = this.getToolOutputValidator(params.name);\n    if (validator) {\n      // If tool has outputSchema, it MUST return structuredContent (unless it's an error)\n      if (!result.structuredContent && !result.isError) {\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          `Tool ${params.name} has an output schema but did not return structured content`\n        );\n      }\n\n      // Only validate structured content if present (not when there's an error)\n      if (result.structuredContent) {\n        try {\n          // Validate the structured content (which is already an object) against the schema\n          const isValid = validator(result.structuredContent);\n\n          if (!isValid) {\n            throw new McpError(\n              ErrorCode.InvalidParams,\n              `Structured content does not match the tool's output schema: ${this._ajv.errorsText(validator.errors)}`\n            );\n          }\n        } catch (error) {\n          if (error instanceof McpError) {\n            throw error;\n          }\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`\n          );\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private cacheToolOutputSchemas(tools: Tool[]) {\n    this._cachedToolOutputValidators.clear();\n\n    for (const tool of tools) {\n      // If the tool has an outputSchema, create and cache the Ajv validator\n      if (tool.outputSchema) {\n        try {\n          const validator = this._ajv.compile(tool.outputSchema);\n          this._cachedToolOutputValidators.set(tool.name, validator);\n        } catch {\n          // Ignore schema compilation errors\n        }\n      }\n    }\n  }\n\n  private getToolOutputValidator(toolName: string): ValidateFunction | undefined {\n    return this._cachedToolOutputValidators.get(toolName);\n  }\n\n  async listTools(\n    params?: ListToolsRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    const result = await this.request(\n      { method: \"tools/list\", params },\n      ListToolsResultSchema,\n      options,\n    );\n\n    // Cache the tools and their output schemas for future validation\n    this.cacheToolOutputSchemas(result.tools);\n\n    return result;\n  }\n\n  async sendRootsListChanged() {\n    return this.notification({ method: \"notifications/roots/list_changed\" });\n  }\n}\n",
      "hash": "39404523db5e978460a5fdc1f664abd3b18682c2f8437c749154d1e86297700f",
      "size": 14369
    },
    "/src/client/middleware.test.ts": {
      "type": "content",
      "content": "import {\n    withOAuth,\n    withLogging,\n    applyMiddlewares,\n    createMiddleware,\n} from \"./middleware.js\";\nimport { OAuthClientProvider } from \"./auth.js\";\nimport { FetchLike } from \"../shared/transport.js\";\n\njest.mock(\"../client/auth.js\", () =\u003E {\n  const actual = jest.requireActual(\"../client/auth.js\");\n  return {\n    ...actual,\n    auth: jest.fn(),\n    extractResourceMetadataUrl: jest.fn(),\n  };\n});\n\nimport { auth, extractResourceMetadataUrl } from \"./auth.js\";\n\nconst mockAuth = auth as jest.MockedFunction\u003Ctypeof auth\u003E;\nconst mockExtractResourceMetadataUrl =\n  extractResourceMetadataUrl as jest.MockedFunction\u003C\n    typeof extractResourceMetadataUrl\n  \u003E;\n\ndescribe(\"withOAuth\", () =\u003E {\n  let mockProvider: jest.Mocked\u003COAuthClientProvider\u003E;\n  let mockFetch: jest.MockedFunction\u003CFetchLike\u003E;\n\n  beforeEach(() =\u003E {\n    jest.clearAllMocks();\n\n    mockProvider = {\n      get redirectUrl() {\n        return \"http://localhost/callback\";\n      },\n      get clientMetadata() {\n        return { redirect_uris: [\"http://localhost/callback\"] };\n      },\n      tokens: jest.fn(),\n      saveTokens: jest.fn(),\n      clientInformation: jest.fn(),\n      redirectToAuthorization: jest.fn(),\n      saveCodeVerifier: jest.fn(),\n      codeVerifier: jest.fn(),\n      invalidateCredentials: jest.fn(),\n    };\n\n    mockFetch = jest.fn();\n  });\n\n  it(\"should add Authorization header when tokens are available (with explicit baseUrl)\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    mockFetch.mockResolvedValue(new Response(\"success\", { status: 200 }));\n\n    const enhancedFetch = withOAuth(\n      mockProvider,\n      \"https://api.example.com\",\n    )(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(mockFetch).toHaveBeenCalledWith(\n      \"https://api.example.com/data\",\n      expect.objectContaining({\n        headers: expect.any(Headers),\n      }),\n    );\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"Authorization\")).toBe(\"Bearer test-token\");\n  });\n\n  it(\"should add Authorization header when tokens are available (without baseUrl)\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    mockFetch.mockResolvedValue(new Response(\"success\", { status: 200 }));\n\n    // Test without baseUrl - should extract from request URL\n    const enhancedFetch = withOAuth(mockProvider)(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(mockFetch).toHaveBeenCalledWith(\n      \"https://api.example.com/data\",\n      expect.objectContaining({\n        headers: expect.any(Headers),\n      }),\n    );\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"Authorization\")).toBe(\"Bearer test-token\");\n  });\n\n  it(\"should handle requests without tokens (without baseUrl)\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue(undefined);\n    mockFetch.mockResolvedValue(new Response(\"success\", { status: 200 }));\n\n    // Test without baseUrl\n    const enhancedFetch = withOAuth(mockProvider)(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"Authorization\")).toBeNull();\n  });\n\n  it(\"should retry request after successful auth on 401 response (with explicit baseUrl)\", async () =\u003E {\n    mockProvider.tokens\n      .mockResolvedValueOnce({\n        access_token: \"old-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n      })\n      .mockResolvedValueOnce({\n        access_token: \"new-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n      });\n\n    const unauthorizedResponse = new Response(\"Unauthorized\", {\n      status: 401,\n      headers: { \"www-authenticate\": 'Bearer realm=\"oauth\"' },\n    });\n    const successResponse = new Response(\"success\", { status: 200 });\n\n    mockFetch\n      .mockResolvedValueOnce(unauthorizedResponse)\n      .mockResolvedValueOnce(successResponse);\n\n    const mockResourceUrl = new URL(\n      \"https://oauth.example.com/.well-known/oauth-protected-resource\",\n    );\n    mockExtractResourceMetadataUrl.mockReturnValue(mockResourceUrl);\n    mockAuth.mockResolvedValue(\"AUTHORIZED\");\n\n    const enhancedFetch = withOAuth(\n      mockProvider,\n      \"https://api.example.com\",\n    )(mockFetch);\n\n    const result = await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(result).toBe(successResponse);\n    expect(mockFetch).toHaveBeenCalledTimes(2);\n    expect(mockAuth).toHaveBeenCalledWith(mockProvider, {\n      serverUrl: \"https://api.example.com\",\n      resourceMetadataUrl: mockResourceUrl,\n      fetchFn: mockFetch,\n    });\n\n    // Verify the retry used the new token\n    const retryCallArgs = mockFetch.mock.calls[1];\n    const retryHeaders = retryCallArgs[1]?.headers as Headers;\n    expect(retryHeaders.get(\"Authorization\")).toBe(\"Bearer new-token\");\n  });\n\n  it(\"should retry request after successful auth on 401 response (without baseUrl)\", async () =\u003E {\n    mockProvider.tokens\n      .mockResolvedValueOnce({\n        access_token: \"old-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n      })\n      .mockResolvedValueOnce({\n        access_token: \"new-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n      });\n\n    const unauthorizedResponse = new Response(\"Unauthorized\", {\n      status: 401,\n      headers: { \"www-authenticate\": 'Bearer realm=\"oauth\"' },\n    });\n    const successResponse = new Response(\"success\", { status: 200 });\n\n    mockFetch\n      .mockResolvedValueOnce(unauthorizedResponse)\n      .mockResolvedValueOnce(successResponse);\n\n    const mockResourceUrl = new URL(\n      \"https://oauth.example.com/.well-known/oauth-protected-resource\",\n    );\n    mockExtractResourceMetadataUrl.mockReturnValue(mockResourceUrl);\n    mockAuth.mockResolvedValue(\"AUTHORIZED\");\n\n    // Test without baseUrl - should extract from request URL\n    const enhancedFetch = withOAuth(mockProvider)(mockFetch);\n\n    const result = await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(result).toBe(successResponse);\n    expect(mockFetch).toHaveBeenCalledTimes(2);\n    expect(mockAuth).toHaveBeenCalledWith(mockProvider, {\n      serverUrl: \"https://api.example.com\", // Should be extracted from request URL\n      resourceMetadataUrl: mockResourceUrl,\n      fetchFn: mockFetch,\n    });\n\n    // Verify the retry used the new token\n    const retryCallArgs = mockFetch.mock.calls[1];\n    const retryHeaders = retryCallArgs[1]?.headers as Headers;\n    expect(retryHeaders.get(\"Authorization\")).toBe(\"Bearer new-token\");\n  });\n\n  it(\"should throw UnauthorizedError when auth returns REDIRECT (without baseUrl)\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    mockFetch.mockResolvedValue(new Response(\"Unauthorized\", { status: 401 }));\n    mockExtractResourceMetadataUrl.mockReturnValue(undefined);\n    mockAuth.mockResolvedValue(\"REDIRECT\");\n\n    // Test without baseUrl\n    const enhancedFetch = withOAuth(mockProvider)(mockFetch);\n\n    await expect(enhancedFetch(\"https://api.example.com/data\")).rejects.toThrow(\n      \"Authentication requires user authorization - redirect initiated\",\n    );\n  });\n\n  it(\"should throw UnauthorizedError when auth fails\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    mockFetch.mockResolvedValue(new Response(\"Unauthorized\", { status: 401 }));\n    mockExtractResourceMetadataUrl.mockReturnValue(undefined);\n    mockAuth.mockRejectedValue(new Error(\"Network error\"));\n\n    const enhancedFetch = withOAuth(\n      mockProvider,\n      \"https://api.example.com\",\n    )(mockFetch);\n\n    await expect(enhancedFetch(\"https://api.example.com/data\")).rejects.toThrow(\n      \"Failed to re-authenticate: Network error\",\n    );\n  });\n\n  it(\"should handle persistent 401 responses after auth\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    // Always return 401\n    mockFetch.mockResolvedValue(new Response(\"Unauthorized\", { status: 401 }));\n    mockExtractResourceMetadataUrl.mockReturnValue(undefined);\n    mockAuth.mockResolvedValue(\"AUTHORIZED\");\n\n    const enhancedFetch = withOAuth(\n      mockProvider,\n      \"https://api.example.com\",\n    )(mockFetch);\n\n    await expect(enhancedFetch(\"https://api.example.com/data\")).rejects.toThrow(\n      \"Authentication failed for https://api.example.com/data\",\n    );\n\n    // Should have made initial request + 1 retry after auth = 2 total\n    expect(mockFetch).toHaveBeenCalledTimes(2);\n    expect(mockAuth).toHaveBeenCalledTimes(1);\n  });\n\n  it(\"should preserve original request method and body\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    mockFetch.mockResolvedValue(new Response(\"success\", { status: 200 }));\n\n    const enhancedFetch = withOAuth(\n      mockProvider,\n      \"https://api.example.com\",\n    )(mockFetch);\n\n    const requestBody = JSON.stringify({ data: \"test\" });\n    await enhancedFetch(\"https://api.example.com/data\", {\n      method: \"POST\",\n      body: requestBody,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n\n    expect(mockFetch).toHaveBeenCalledWith(\n      \"https://api.example.com/data\",\n      expect.objectContaining({\n        method: \"POST\",\n        body: requestBody,\n        headers: expect.any(Headers),\n      }),\n    );\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"Content-Type\")).toBe(\"application/json\");\n    expect(headers.get(\"Authorization\")).toBe(\"Bearer test-token\");\n  });\n\n  it(\"should handle non-401 errors normally\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    const serverErrorResponse = new Response(\"Server Error\", { status: 500 });\n    mockFetch.mockResolvedValue(serverErrorResponse);\n\n    const enhancedFetch = withOAuth(\n      mockProvider,\n      \"https://api.example.com\",\n    )(mockFetch);\n\n    const result = await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(result).toBe(serverErrorResponse);\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n    expect(mockAuth).not.toHaveBeenCalled();\n  });\n\n  it(\"should handle URL object as input (without baseUrl)\", async () =\u003E {\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    mockFetch.mockResolvedValue(new Response(\"success\", { status: 200 }));\n\n    // Test URL object without baseUrl - should extract origin from URL object\n    const enhancedFetch = withOAuth(mockProvider)(mockFetch);\n\n    await enhancedFetch(new URL(\"https://api.example.com/data\"));\n\n    expect(mockFetch).toHaveBeenCalledWith(\n      expect.any(URL),\n      expect.objectContaining({\n        headers: expect.any(Headers),\n      }),\n    );\n  });\n\n  it(\"should handle URL object in auth retry (without baseUrl)\", async () =\u003E {\n    mockProvider.tokens\n      .mockResolvedValueOnce({\n        access_token: \"old-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n      })\n      .mockResolvedValueOnce({\n        access_token: \"new-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n      });\n\n    const unauthorizedResponse = new Response(\"Unauthorized\", { status: 401 });\n    const successResponse = new Response(\"success\", { status: 200 });\n\n    mockFetch\n      .mockResolvedValueOnce(unauthorizedResponse)\n      .mockResolvedValueOnce(successResponse);\n\n    mockExtractResourceMetadataUrl.mockReturnValue(undefined);\n    mockAuth.mockResolvedValue(\"AUTHORIZED\");\n\n    const enhancedFetch = withOAuth(mockProvider)(mockFetch);\n\n    const result = await enhancedFetch(new URL(\"https://api.example.com/data\"));\n\n    expect(result).toBe(successResponse);\n    expect(mockFetch).toHaveBeenCalledTimes(2);\n    expect(mockAuth).toHaveBeenCalledWith(mockProvider, {\n      serverUrl: \"https://api.example.com\", // Should extract origin from URL object\n      resourceMetadataUrl: undefined,\n      fetchFn: mockFetch,\n    });\n  });\n});\n\ndescribe(\"withLogging\", () =\u003E {\n  let mockFetch: jest.MockedFunction\u003CFetchLike\u003E;\n  let mockLogger: jest.MockedFunction\u003C\n    (input: {\n      method: string;\n      url: string | URL;\n      status: number;\n      statusText: string;\n      duration: number;\n      requestHeaders?: Headers;\n      responseHeaders?: Headers;\n      error?: Error;\n    }) =\u003E void\n  \u003E;\n  let consoleErrorSpy: jest.SpyInstance;\n  let consoleLogSpy: jest.SpyInstance;\n\n  beforeEach(() =\u003E {\n    jest.clearAllMocks();\n\n    consoleErrorSpy = jest.spyOn(console, \"error\").mockImplementation(() =\u003E {});\n    consoleLogSpy = jest.spyOn(console, \"log\").mockImplementation(() =\u003E {});\n\n    mockFetch = jest.fn();\n    mockLogger = jest.fn();\n  });\n\n  afterEach(() =\u003E {\n    consoleErrorSpy.mockRestore();\n    consoleLogSpy.mockRestore();\n  });\n\n  it(\"should log successful requests with default logger\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200, statusText: \"OK\" });\n    mockFetch.mockResolvedValue(response);\n\n    const enhancedFetch = withLogging()(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(consoleLogSpy).toHaveBeenCalledWith(\n      expect.stringMatching(\n        /HTTP GET https:\\/\\/api\\.example\\.com\\/data 200 OK \\(\\d+\\.\\d+ms\\)/,\n      ),\n    );\n  });\n\n  it(\"should log error responses with default logger\", async () =\u003E {\n    const response = new Response(\"Not Found\", {\n      status: 404,\n      statusText: \"Not Found\",\n    });\n    mockFetch.mockResolvedValue(response);\n\n    const enhancedFetch = withLogging()(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(consoleErrorSpy).toHaveBeenCalledWith(\n      expect.stringMatching(\n        /HTTP GET https:\\/\\/api\\.example\\.com\\/data 404 Not Found \\(\\d+\\.\\d+ms\\)/,\n      ),\n    );\n  });\n\n  it(\"should log network errors with default logger\", async () =\u003E {\n    const networkError = new Error(\"Network connection failed\");\n    mockFetch.mockRejectedValue(networkError);\n\n    const enhancedFetch = withLogging()(mockFetch);\n\n    await expect(enhancedFetch(\"https://api.example.com/data\")).rejects.toThrow(\n      \"Network connection failed\",\n    );\n\n    expect(consoleErrorSpy).toHaveBeenCalledWith(\n      expect.stringMatching(\n        /HTTP GET https:\\/\\/api\\.example\\.com\\/data failed: Network connection failed \\(\\d+\\.\\d+ms\\)/,\n      ),\n    );\n  });\n\n  it(\"should use custom logger when provided\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200, statusText: \"OK\" });\n    mockFetch.mockResolvedValue(response);\n\n    const enhancedFetch = withLogging({ logger: mockLogger })(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\", { method: \"POST\" });\n\n    expect(mockLogger).toHaveBeenCalledWith({\n      method: \"POST\",\n      url: \"https://api.example.com/data\",\n      status: 200,\n      statusText: \"OK\",\n      duration: expect.any(Number),\n      requestHeaders: undefined,\n      responseHeaders: undefined,\n    });\n\n    expect(consoleLogSpy).not.toHaveBeenCalled();\n  });\n\n  it(\"should include request headers when configured\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200, statusText: \"OK\" });\n    mockFetch.mockResolvedValue(response);\n\n    const enhancedFetch = withLogging({\n      logger: mockLogger,\n      includeRequestHeaders: true,\n    })(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\", {\n      headers: {\n        Authorization: \"Bearer token\",\n        \"Content-Type\": \"application/json\",\n      },\n    });\n\n    expect(mockLogger).toHaveBeenCalledWith({\n      method: \"GET\",\n      url: \"https://api.example.com/data\",\n      status: 200,\n      statusText: \"OK\",\n      duration: expect.any(Number),\n      requestHeaders: expect.any(Headers),\n      responseHeaders: undefined,\n    });\n\n    const logCall = mockLogger.mock.calls[0][0];\n    expect(logCall.requestHeaders?.get(\"Authorization\")).toBe(\"Bearer token\");\n    expect(logCall.requestHeaders?.get(\"Content-Type\")).toBe(\n      \"application/json\",\n    );\n  });\n\n  it(\"should include response headers when configured\", async () =\u003E {\n    const response = new Response(\"success\", {\n      status: 200,\n      statusText: \"OK\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Cache-Control\": \"no-cache\",\n      },\n    });\n    mockFetch.mockResolvedValue(response);\n\n    const enhancedFetch = withLogging({\n      logger: mockLogger,\n      includeResponseHeaders: true,\n    })(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    const logCall = mockLogger.mock.calls[0][0];\n    expect(logCall.responseHeaders?.get(\"Content-Type\")).toBe(\n      \"application/json\",\n    );\n    expect(logCall.responseHeaders?.get(\"Cache-Control\")).toBe(\"no-cache\");\n  });\n\n  it(\"should respect statusLevel option\", async () =\u003E {\n    const successResponse = new Response(\"success\", {\n      status: 200,\n      statusText: \"OK\",\n    });\n    const errorResponse = new Response(\"Server Error\", {\n      status: 500,\n      statusText: \"Internal Server Error\",\n    });\n\n    mockFetch\n      .mockResolvedValueOnce(successResponse)\n      .mockResolvedValueOnce(errorResponse);\n\n    const enhancedFetch = withLogging({\n      logger: mockLogger,\n      statusLevel: 400,\n    })(mockFetch);\n\n    // 200 response should not be logged (below statusLevel 400)\n    await enhancedFetch(\"https://api.example.com/success\");\n    expect(mockLogger).not.toHaveBeenCalled();\n\n    // 500 response should be logged (above statusLevel 400)\n    await enhancedFetch(\"https://api.example.com/error\");\n    expect(mockLogger).toHaveBeenCalledWith({\n      method: \"GET\",\n      url: \"https://api.example.com/error\",\n      status: 500,\n      statusText: \"Internal Server Error\",\n      duration: expect.any(Number),\n      requestHeaders: undefined,\n      responseHeaders: undefined,\n    });\n  });\n\n  it(\"should always log network errors regardless of statusLevel\", async () =\u003E {\n    const networkError = new Error(\"Connection timeout\");\n    mockFetch.mockRejectedValue(networkError);\n\n    const enhancedFetch = withLogging({\n      logger: mockLogger,\n      statusLevel: 500, // Very high log level\n    })(mockFetch);\n\n    await expect(enhancedFetch(\"https://api.example.com/data\")).rejects.toThrow(\n      \"Connection timeout\",\n    );\n\n    expect(mockLogger).toHaveBeenCalledWith({\n      method: \"GET\",\n      url: \"https://api.example.com/data\",\n      status: 0,\n      statusText: \"Network Error\",\n      duration: expect.any(Number),\n      requestHeaders: undefined,\n      error: networkError,\n    });\n  });\n\n  it(\"should include headers in default logger message when configured\", async () =\u003E {\n    const response = new Response(\"success\", {\n      status: 200,\n      statusText: \"OK\",\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n    mockFetch.mockResolvedValue(response);\n\n    const enhancedFetch = withLogging({\n      includeRequestHeaders: true,\n      includeResponseHeaders: true,\n    })(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\", {\n      headers: { Authorization: \"Bearer token\" },\n    });\n\n    expect(consoleLogSpy).toHaveBeenCalledWith(\n      expect.stringContaining(\"Request Headers: {authorization: Bearer token}\"),\n    );\n    expect(consoleLogSpy).toHaveBeenCalledWith(\n      expect.stringContaining(\n        \"Response Headers: {content-type: application/json}\",\n      ),\n    );\n  });\n\n  it(\"should measure request duration accurately\", async () =\u003E {\n    // Mock a slow response\n    const response = new Response(\"success\", { status: 200 });\n    mockFetch.mockImplementation(async () =\u003E {\n      await new Promise((resolve) =\u003E setTimeout(resolve, 100));\n      return response;\n    });\n\n    const enhancedFetch = withLogging({ logger: mockLogger })(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    const logCall = mockLogger.mock.calls[0][0];\n    expect(logCall.duration).toBeGreaterThanOrEqual(90); // Allow some margin for timing\n  });\n});\n\ndescribe(\"applyMiddleware\", () =\u003E {\n  let mockFetch: jest.MockedFunction\u003CFetchLike\u003E;\n\n  beforeEach(() =\u003E {\n    jest.clearAllMocks();\n    mockFetch = jest.fn();\n  });\n\n  it(\"should compose no middleware correctly\", () =\u003E {\n    const response = new Response(\"success\", { status: 200 });\n    mockFetch.mockResolvedValue(response);\n\n    const composedFetch = applyMiddlewares()(mockFetch);\n\n    expect(composedFetch).toBe(mockFetch);\n  });\n\n  it(\"should compose single middleware correctly\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200 });\n    mockFetch.mockResolvedValue(response);\n\n    // Create a middleware that adds a header\n    const middleware1 =\n      (next: FetchLike) =\u003E async (input: string | URL, init?: RequestInit) =\u003E {\n        const headers = new Headers(init?.headers);\n        headers.set(\"X-Middleware-1\", \"applied\");\n        return next(input, { ...init, headers });\n      };\n\n    const composedFetch = applyMiddlewares(middleware1)(mockFetch);\n\n    await composedFetch(\"https://api.example.com/data\");\n\n    expect(mockFetch).toHaveBeenCalledWith(\n      \"https://api.example.com/data\",\n      expect.objectContaining({\n        headers: expect.any(Headers),\n      }),\n    );\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"X-Middleware-1\")).toBe(\"applied\");\n  });\n\n  it(\"should compose multiple middleware in order\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200 });\n    mockFetch.mockResolvedValue(response);\n\n    // Create middleware that add identifying headers\n    const middleware1 =\n      (next: FetchLike) =\u003E async (input: string | URL, init?: RequestInit) =\u003E {\n        const headers = new Headers(init?.headers);\n        headers.set(\"X-Middleware-1\", \"applied\");\n        return next(input, { ...init, headers });\n      };\n\n    const middleware2 =\n      (next: FetchLike) =\u003E async (input: string | URL, init?: RequestInit) =\u003E {\n        const headers = new Headers(init?.headers);\n        headers.set(\"X-Middleware-2\", \"applied\");\n        return next(input, { ...init, headers });\n      };\n\n    const middleware3 =\n      (next: FetchLike) =\u003E async (input: string | URL, init?: RequestInit) =\u003E {\n        const headers = new Headers(init?.headers);\n        headers.set(\"X-Middleware-3\", \"applied\");\n        return next(input, { ...init, headers });\n      };\n\n    const composedFetch = applyMiddlewares(\n      middleware1,\n      middleware2,\n      middleware3,\n    )(mockFetch);\n\n    await composedFetch(\"https://api.example.com/data\");\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"X-Middleware-1\")).toBe(\"applied\");\n    expect(headers.get(\"X-Middleware-2\")).toBe(\"applied\");\n    expect(headers.get(\"X-Middleware-3\")).toBe(\"applied\");\n  });\n\n  it(\"should work with real fetch middleware functions\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200, statusText: \"OK\" });\n    mockFetch.mockResolvedValue(response);\n\n    // Create middleware that add identifying headers\n    const oauthMiddleware =\n      (next: FetchLike) =\u003E async (input: string | URL, init?: RequestInit) =\u003E {\n        const headers = new Headers(init?.headers);\n        headers.set(\"Authorization\", \"Bearer test-token\");\n        return next(input, { ...init, headers });\n      };\n\n    // Use custom logger to avoid console output\n    const mockLogger = jest.fn();\n    const composedFetch = applyMiddlewares(\n      oauthMiddleware,\n      withLogging({ logger: mockLogger, statusLevel: 0 }),\n    )(mockFetch);\n\n    await composedFetch(\"https://api.example.com/data\");\n\n    // Should have both Authorization header and logging\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"Authorization\")).toBe(\"Bearer test-token\");\n    expect(mockLogger).toHaveBeenCalledWith({\n      method: \"GET\",\n      url: \"https://api.example.com/data\",\n      status: 200,\n      statusText: \"OK\",\n      duration: expect.any(Number),\n      requestHeaders: undefined,\n      responseHeaders: undefined,\n    });\n  });\n\n  it(\"should preserve error propagation through middleware\", async () =\u003E {\n    const errorMiddleware =\n      (next: FetchLike) =\u003E async (input: string | URL, init?: RequestInit) =\u003E {\n        try {\n          return await next(input, init);\n        } catch (error) {\n          // Add context to the error\n          throw new Error(\n            `Middleware error: ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      };\n\n    const originalError = new Error(\"Network failure\");\n    mockFetch.mockRejectedValue(originalError);\n\n    const composedFetch = applyMiddlewares(errorMiddleware)(mockFetch);\n\n    await expect(composedFetch(\"https://api.example.com/data\")).rejects.toThrow(\n      \"Middleware error: Network failure\",\n    );\n  });\n});\n\ndescribe(\"Integration Tests\", () =\u003E {\n  let mockProvider: jest.Mocked\u003COAuthClientProvider\u003E;\n  let mockFetch: jest.MockedFunction\u003CFetchLike\u003E;\n\n  beforeEach(() =\u003E {\n    jest.clearAllMocks();\n\n    mockProvider = {\n      get redirectUrl() {\n        return \"http://localhost/callback\";\n      },\n      get clientMetadata() {\n        return { redirect_uris: [\"http://localhost/callback\"] };\n      },\n      tokens: jest.fn(),\n      saveTokens: jest.fn(),\n      clientInformation: jest.fn(),\n      redirectToAuthorization: jest.fn(),\n      saveCodeVerifier: jest.fn(),\n      codeVerifier: jest.fn(),\n      invalidateCredentials: jest.fn(),\n    };\n\n    mockFetch = jest.fn();\n  });\n\n  it(\"should work with SSE transport pattern\", async () =\u003E {\n    // Simulate how SSE transport might use the middleware\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"sse-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    const response = new Response('{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{}}', {\n      status: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n    mockFetch.mockResolvedValue(response);\n\n    // Use custom logger to avoid console output\n    const mockLogger = jest.fn();\n    const enhancedFetch = applyMiddlewares(\n      withOAuth(\n        mockProvider as OAuthClientProvider,\n        \"https://mcp-server.example.com\",\n      ),\n      withLogging({ logger: mockLogger, statusLevel: 400 }), // Only log errors\n    )(mockFetch);\n\n    // Simulate SSE POST request\n    await enhancedFetch(\"https://mcp-server.example.com/endpoint\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: \"tools/list\",\n        id: 1,\n      }),\n    });\n\n    expect(mockFetch).toHaveBeenCalledWith(\n      \"https://mcp-server.example.com/endpoint\",\n      expect.objectContaining({\n        method: \"POST\",\n        headers: expect.any(Headers),\n        body: expect.any(String),\n      }),\n    );\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"Authorization\")).toBe(\"Bearer sse-token\");\n    expect(headers.get(\"Content-Type\")).toBe(\"application/json\");\n  });\n\n  it(\"should work with StreamableHTTP transport pattern\", async () =\u003E {\n    // Simulate how StreamableHTTP transport might use the middleware\n    mockProvider.tokens.mockResolvedValue({\n      access_token: \"streamable-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n    });\n\n    const response = new Response(null, {\n      status: 202,\n      headers: { \"mcp-session-id\": \"session-123\" },\n    });\n    mockFetch.mockResolvedValue(response);\n\n    // Use custom logger to avoid console output\n    const mockLogger = jest.fn();\n    const enhancedFetch = applyMiddlewares(\n      withOAuth(\n        mockProvider as OAuthClientProvider,\n        \"https://streamable-server.example.com\",\n      ),\n      withLogging({\n        logger: mockLogger,\n        includeResponseHeaders: true,\n        statusLevel: 0,\n      }),\n    )(mockFetch);\n\n    // Simulate StreamableHTTP initialization request\n    await enhancedFetch(\"https://streamable-server.example.com/mcp\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json, text/event-stream\",\n      },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: \"initialize\",\n        params: { protocolVersion: \"2025-03-26\", clientInfo: { name: \"test\" } },\n        id: 1,\n      }),\n    });\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"Authorization\")).toBe(\"Bearer streamable-token\");\n    expect(headers.get(\"Accept\")).toBe(\"application/json, text/event-stream\");\n  });\n\n  it(\"should handle auth retry in transport-like scenario\", async () =\u003E {\n    mockProvider.tokens\n      .mockResolvedValueOnce({\n        access_token: \"expired-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n      })\n      .mockResolvedValueOnce({\n        access_token: \"fresh-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n      });\n\n    const unauthorizedResponse = new Response('{\"error\":\"invalid_token\"}', {\n      status: 401,\n      headers: { \"www-authenticate\": 'Bearer realm=\"mcp\"' },\n    });\n    const successResponse = new Response(\n      '{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{}}',\n      {\n        status: 200,\n      },\n    );\n\n    mockFetch\n      .mockResolvedValueOnce(unauthorizedResponse)\n      .mockResolvedValueOnce(successResponse);\n\n    mockExtractResourceMetadataUrl.mockReturnValue(\n      new URL(\"https://auth.example.com/.well-known/oauth-protected-resource\"),\n    );\n    mockAuth.mockResolvedValue(\"AUTHORIZED\");\n\n    // Use custom logger to avoid console output\n    const mockLogger = jest.fn();\n    const enhancedFetch = applyMiddlewares(\n      withOAuth(\n        mockProvider as OAuthClientProvider,\n        \"https://mcp-server.example.com\",\n      ),\n      withLogging({ logger: mockLogger, statusLevel: 0 }),\n    )(mockFetch);\n\n    const result = await enhancedFetch(\n      \"https://mcp-server.example.com/endpoint\",\n      {\n        method: \"POST\",\n        body: JSON.stringify({ jsonrpc: \"2.0\", method: \"test\", id: 1 }),\n      },\n    );\n\n    expect(result).toBe(successResponse);\n    expect(mockFetch).toHaveBeenCalledTimes(2);\n    expect(mockAuth).toHaveBeenCalledWith(mockProvider, {\n      serverUrl: \"https://mcp-server.example.com\",\n      resourceMetadataUrl: new URL(\n        \"https://auth.example.com/.well-known/oauth-protected-resource\",\n      ),\n      fetchFn: mockFetch,\n    });\n  });\n});\n\ndescribe(\"createMiddleware\", () =\u003E {\n  let mockFetch: jest.MockedFunction\u003CFetchLike\u003E;\n\n  beforeEach(() =\u003E {\n    jest.clearAllMocks();\n    mockFetch = jest.fn();\n  });\n\n  it(\"should create middleware with cleaner syntax\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200 });\n    mockFetch.mockResolvedValue(response);\n\n    const customMiddleware = createMiddleware(async (next, input, init) =\u003E {\n      const headers = new Headers(init?.headers);\n      headers.set(\"X-Custom-Header\", \"custom-value\");\n      return next(input, { ...init, headers });\n    });\n\n    const enhancedFetch = customMiddleware(mockFetch);\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(mockFetch).toHaveBeenCalledWith(\n      \"https://api.example.com/data\",\n      expect.objectContaining({\n        headers: expect.any(Headers),\n      }),\n    );\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"X-Custom-Header\")).toBe(\"custom-value\");\n  });\n\n  it(\"should support conditional middleware logic\", async () =\u003E {\n    const apiResponse = new Response(\"api response\", { status: 200 });\n    const publicResponse = new Response(\"public response\", { status: 200 });\n    mockFetch\n      .mockResolvedValueOnce(apiResponse)\n      .mockResolvedValueOnce(publicResponse);\n\n    const conditionalMiddleware = createMiddleware(\n      async (next, input, init) =\u003E {\n        const url = typeof input === \"string\" ? input : input.toString();\n\n        if (url.includes(\"/api/\")) {\n          const headers = new Headers(init?.headers);\n          headers.set(\"X-API-Version\", \"v2\");\n          return next(input, { ...init, headers });\n        }\n\n        return next(input, init);\n      },\n    );\n\n    const enhancedFetch = conditionalMiddleware(mockFetch);\n\n    // Test API route\n    await enhancedFetch(\"https://example.com/api/users\");\n    let callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"X-API-Version\")).toBe(\"v2\");\n\n    // Test non-API route\n    await enhancedFetch(\"https://example.com/public/page\");\n    callArgs = mockFetch.mock.calls[1];\n    const maybeHeaders = callArgs[1]?.headers as Headers | undefined;\n    expect(maybeHeaders?.get(\"X-API-Version\")).toBeUndefined();\n  });\n\n  it(\"should support short-circuit responses\", async () =\u003E {\n    const customMiddleware = createMiddleware(async (next, input, init) =\u003E {\n      const url = typeof input === \"string\" ? input : input.toString();\n\n      // Short-circuit for specific URL\n      if (url.includes(\"/cached\")) {\n        return new Response(\"cached data\", { status: 200 });\n      }\n\n      return next(input, init);\n    });\n\n    const enhancedFetch = customMiddleware(mockFetch);\n\n    // Test cached route (should not call mockFetch)\n    const cachedResponse = await enhancedFetch(\n      \"https://example.com/cached/data\",\n    );\n    expect(await cachedResponse.text()).toBe(\"cached data\");\n    expect(mockFetch).not.toHaveBeenCalled();\n\n    // Test normal route\n    mockFetch.mockResolvedValue(new Response(\"fresh data\", { status: 200 }));\n    const normalResponse = await enhancedFetch(\"https://example.com/normal/data\");\n    expect(await normalResponse.text()).toBe(\"fresh data\");\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n\n  it(\"should handle response transformation\", async () =\u003E {\n    const originalResponse = new Response('{\"data\": \"original\"}', {\n      status: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n    mockFetch.mockResolvedValue(originalResponse);\n\n    const transformMiddleware = createMiddleware(async (next, input, init) =\u003E {\n      const response = await next(input, init);\n\n      if (response.headers.get(\"content-type\")?.includes(\"application/json\")) {\n        const data = await response.json();\n        const transformed = { ...data, timestamp: 123456789 };\n\n        return new Response(JSON.stringify(transformed), {\n          status: response.status,\n          statusText: response.statusText,\n          headers: response.headers,\n        });\n      }\n\n      return response;\n    });\n\n    const enhancedFetch = transformMiddleware(mockFetch);\n    const response = await enhancedFetch(\"https://api.example.com/data\");\n    const result = await response.json();\n\n    expect(result).toEqual({\n      data: \"original\",\n      timestamp: 123456789,\n    });\n  });\n\n  it(\"should support error handling and recovery\", async () =\u003E {\n    let attemptCount = 0;\n    mockFetch.mockImplementation(async () =\u003E {\n      attemptCount++;\n      if (attemptCount === 1) {\n        throw new Error(\"Network error\");\n      }\n      return new Response(\"success\", { status: 200 });\n    });\n\n    const retryMiddleware = createMiddleware(async (next, input, init) =\u003E {\n      try {\n        return await next(input, init);\n      } catch (error) {\n        // Retry once on network error\n        console.log(\"Retrying request after error:\", error);\n        return await next(input, init);\n      }\n    });\n\n    const enhancedFetch = retryMiddleware(mockFetch);\n    const response = await enhancedFetch(\"https://api.example.com/data\");\n\n    expect(await response.text()).toBe(\"success\");\n    expect(mockFetch).toHaveBeenCalledTimes(2);\n  });\n\n  it(\"should compose well with other middleware\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200 });\n    mockFetch.mockResolvedValue(response);\n\n    // Create custom middleware using createMiddleware\n    const customAuth = createMiddleware(async (next, input, init) =\u003E {\n      const headers = new Headers(init?.headers);\n      headers.set(\"Authorization\", \"Custom token\");\n      return next(input, { ...init, headers });\n    });\n\n    const customLogging = createMiddleware(async (next, input, init) =\u003E {\n      const url = typeof input === \"string\" ? input : input.toString();\n      console.log(`Request to: ${url}`);\n      const response = await next(input, init);\n      console.log(`Response status: ${response.status}`);\n      return response;\n    });\n\n    // Compose with existing middleware\n    const enhancedFetch = applyMiddlewares(\n      customAuth,\n      customLogging,\n      withLogging({ statusLevel: 400 }),\n    )(mockFetch);\n\n    await enhancedFetch(\"https://api.example.com/data\");\n\n    const callArgs = mockFetch.mock.calls[0];\n    const headers = callArgs[1]?.headers as Headers;\n    expect(headers.get(\"Authorization\")).toBe(\"Custom token\");\n  });\n\n  it(\"should have access to both input types (string and URL)\", async () =\u003E {\n    const response = new Response(\"success\", { status: 200 });\n    mockFetch.mockResolvedValue(response);\n\n    let capturedInputType: string | undefined;\n    const inspectMiddleware = createMiddleware(async (next, input, init) =\u003E {\n      capturedInputType = typeof input === \"string\" ? \"string\" : \"URL\";\n      return next(input, init);\n    });\n\n    const enhancedFetch = inspectMiddleware(mockFetch);\n\n    // Test with string input\n    await enhancedFetch(\"https://api.example.com/data\");\n    expect(capturedInputType).toBe(\"string\");\n\n    // Test with URL input\n    await enhancedFetch(new URL(\"https://api.example.com/data\"));\n    expect(capturedInputType).toBe(\"URL\");\n  });\n});\n",
      "hash": "a4c3a2ce9975c6db4466224aabd0fe272b6bf7cca756017c178fb183f7255162",
      "size": 38540
    },
    "/src/client/middleware.ts": {
      "type": "content",
      "content": "import {\n  auth,\n  extractResourceMetadataUrl,\n  OAuthClientProvider,\n  UnauthorizedError,\n} from \"./auth.js\";\nimport { FetchLike } from \"../shared/transport.js\";\n\n/**\n * Middleware function that wraps and enhances fetch functionality.\n * Takes a fetch handler and returns an enhanced fetch handler.\n */\nexport type Middleware = (next: FetchLike) =\u003E FetchLike;\n\n/**\n * Creates a fetch wrapper that handles OAuth authentication automatically.\n *\n * This wrapper will:\n * - Add Authorization headers with access tokens\n * - Handle 401 responses by attempting re-authentication\n * - Retry the original request after successful auth\n * - Handle OAuth errors appropriately (InvalidClientError, etc.)\n *\n * The baseUrl parameter is optional and defaults to using the domain from the request URL.\n * However, you should explicitly provide baseUrl when:\n * - Making requests to multiple subdomains (e.g., api.example.com, cdn.example.com)\n * - Using API paths that differ from OAuth discovery paths (e.g., requesting /api/v1/data but OAuth is at /)\n * - The OAuth server is on a different domain than your API requests\n * - You want to ensure consistent OAuth behavior regardless of request URLs\n *\n * For MCP transports, set baseUrl to the same URL you pass to the transport constructor.\n *\n * Note: This wrapper is designed for general-purpose fetch operations.\n * MCP transports (SSE and StreamableHTTP) already have built-in OAuth handling\n * and should not need this wrapper.\n *\n * @param provider - OAuth client provider for authentication\n * @param baseUrl - Base URL for OAuth server discovery (defaults to request URL domain)\n * @returns A fetch middleware function\n */\nexport const withOAuth =\n  (provider: OAuthClientProvider, baseUrl?: string | URL): Middleware =\u003E\n  (next) =\u003E {\n    return async (input, init) =\u003E {\n      const makeRequest = async (): Promise\u003CResponse\u003E =\u003E {\n        const headers = new Headers(init?.headers);\n\n        // Add authorization header if tokens are available\n        const tokens = await provider.tokens();\n        if (tokens) {\n          headers.set(\"Authorization\", `Bearer ${tokens.access_token}`);\n        }\n\n        return await next(input, { ...init, headers });\n      };\n\n      let response = await makeRequest();\n\n      // Handle 401 responses by attempting re-authentication\n      if (response.status === 401) {\n        try {\n          const resourceMetadataUrl = extractResourceMetadataUrl(response);\n\n          // Use provided baseUrl or extract from request URL\n          const serverUrl =\n            baseUrl ||\n            (typeof input === \"string\" ? new URL(input).origin : input.origin);\n\n          const result = await auth(provider, {\n            serverUrl,\n            resourceMetadataUrl,\n            fetchFn: next,\n          });\n\n          if (result === \"REDIRECT\") {\n            throw new UnauthorizedError(\n              \"Authentication requires user authorization - redirect initiated\",\n            );\n          }\n\n          if (result !== \"AUTHORIZED\") {\n            throw new UnauthorizedError(\n              `Authentication failed with result: ${result}`,\n            );\n          }\n\n          // Retry the request with fresh tokens\n          response = await makeRequest();\n        } catch (error) {\n          if (error instanceof UnauthorizedError) {\n            throw error;\n          }\n          throw new UnauthorizedError(\n            `Failed to re-authenticate: ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      }\n\n      // If we still have a 401 after re-auth attempt, throw an error\n      if (response.status === 401) {\n        const url = typeof input === \"string\" ? input : input.toString();\n        throw new UnauthorizedError(`Authentication failed for ${url}`);\n      }\n\n      return response;\n    };\n  };\n\n/**\n * Logger function type for HTTP requests\n */\nexport type RequestLogger = (input: {\n  method: string;\n  url: string | URL;\n  status: number;\n  statusText: string;\n  duration: number;\n  requestHeaders?: Headers;\n  responseHeaders?: Headers;\n  error?: Error;\n}) =\u003E void;\n\n/**\n * Configuration options for the logging middleware\n */\nexport type LoggingOptions = {\n  /**\n   * Custom logger function, defaults to console logging\n   */\n  logger?: RequestLogger;\n\n  /**\n   * Whether to include request headers in logs\n   * @default false\n   */\n  includeRequestHeaders?: boolean;\n\n  /**\n   * Whether to include response headers in logs\n   * @default false\n   */\n  includeResponseHeaders?: boolean;\n\n  /**\n   * Status level filter - only log requests with status \u003E= this value\n   * Set to 0 to log all requests, 400 to log only errors\n   * @default 0\n   */\n  statusLevel?: number;\n};\n\n/**\n * Creates a fetch middleware that logs HTTP requests and responses.\n *\n * When called without arguments `withLogging()`, it uses the default logger that:\n * - Logs successful requests (2xx) to `console.log`\n * - Logs error responses (4xx/5xx) and network errors to `console.error`\n * - Logs all requests regardless of status (statusLevel: 0)\n * - Does not include request or response headers in logs\n * - Measures and displays request duration in milliseconds\n *\n * Important: the default logger uses both `console.log` and `console.error` so it should not be used with\n * `stdio` transports and applications.\n *\n * @param options - Logging configuration options\n * @returns A fetch middleware function\n */\nexport const withLogging = (options: LoggingOptions = {}): Middleware =\u003E {\n  const {\n    logger,\n    includeRequestHeaders = false,\n    includeResponseHeaders = false,\n    statusLevel = 0,\n  } = options;\n\n  const defaultLogger: RequestLogger = (input) =\u003E {\n    const {\n      method,\n      url,\n      status,\n      statusText,\n      duration,\n      requestHeaders,\n      responseHeaders,\n      error,\n    } = input;\n\n    let message = error\n      ? `HTTP ${method} ${url} failed: ${error.message} (${duration}ms)`\n      : `HTTP ${method} ${url} ${status} ${statusText} (${duration}ms)`;\n\n    // Add headers to message if requested\n    if (includeRequestHeaders && requestHeaders) {\n      const reqHeaders = Array.from(requestHeaders.entries())\n        .map(([key, value]) =\u003E `${key}: ${value}`)\n        .join(\", \");\n      message += `\\n  Request Headers: {${reqHeaders}}`;\n    }\n\n    if (includeResponseHeaders && responseHeaders) {\n      const resHeaders = Array.from(responseHeaders.entries())\n        .map(([key, value]) =\u003E `${key}: ${value}`)\n        .join(\", \");\n      message += `\\n  Response Headers: {${resHeaders}}`;\n    }\n\n    if (error || status \u003E= 400) {\n      // eslint-disable-next-line no-console\n      console.error(message);\n    } else {\n      // eslint-disable-next-line no-console\n      console.log(message);\n    }\n  };\n\n  const logFn = logger || defaultLogger;\n\n  return (next) =\u003E async (input, init) =\u003E {\n    const startTime = performance.now();\n    const method = init?.method || \"GET\";\n    const url = typeof input === \"string\" ? input : input.toString();\n    const requestHeaders = includeRequestHeaders\n      ? new Headers(init?.headers)\n      : undefined;\n\n    try {\n      const response = await next(input, init);\n      const duration = performance.now() - startTime;\n\n      // Only log if status meets the log level threshold\n      if (response.status \u003E= statusLevel) {\n        logFn({\n          method,\n          url,\n          status: response.status,\n          statusText: response.statusText,\n          duration,\n          requestHeaders,\n          responseHeaders: includeResponseHeaders\n            ? response.headers\n            : undefined,\n        });\n      }\n\n      return response;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n\n      // Always log errors regardless of log level\n      logFn({\n        method,\n        url,\n        status: 0,\n        statusText: \"Network Error\",\n        duration,\n        requestHeaders,\n        error: error as Error,\n      });\n\n      throw error;\n    }\n  };\n};\n\n/**\n * Composes multiple fetch middleware functions into a single middleware pipeline.\n * Middleware are applied in the order they appear, creating a chain of handlers.\n *\n * @example\n * ```typescript\n * // Create a middleware pipeline that handles both OAuth and logging\n * const enhancedFetch = applyMiddlewares(\n *   withOAuth(oauthProvider, 'https://api.example.com'),\n *   withLogging({ statusLevel: 400 })\n * )(fetch);\n *\n * // Use the enhanced fetch - it will handle auth and log errors\n * const response = await enhancedFetch('https://api.example.com/data');\n * ```\n *\n * @param middleware - Array of fetch middleware to compose into a pipeline\n * @returns A single composed middleware function\n */\nexport const applyMiddlewares = (\n  ...middleware: Middleware[]\n): Middleware =\u003E {\n  return (next) =\u003E {\n    return middleware.reduce((handler, mw) =\u003E mw(handler), next);\n  };\n};\n\n/**\n * Helper function to create custom fetch middleware with cleaner syntax.\n * Provides the next handler and request details as separate parameters for easier access.\n *\n * @example\n * ```typescript\n * // Create custom authentication middleware\n * const customAuthMiddleware = createMiddleware(async (next, input, init) =\u003E {\n *   const headers = new Headers(init?.headers);\n *   headers.set('X-Custom-Auth', 'my-token');\n *\n *   const response = await next(input, { ...init, headers });\n *\n *   if (response.status === 401) {\n *     console.log('Authentication failed');\n *   }\n *\n *   return response;\n * });\n *\n * // Create conditional middleware\n * const conditionalMiddleware = createMiddleware(async (next, input, init) =\u003E {\n *   const url = typeof input === 'string' ? input : input.toString();\n *\n *   // Only add headers for API routes\n *   if (url.includes('/api/')) {\n *     const headers = new Headers(init?.headers);\n *     headers.set('X-API-Version', 'v2');\n *     return next(input, { ...init, headers });\n *   }\n *\n *   // Pass through for non-API routes\n *   return next(input, init);\n * });\n *\n * // Create caching middleware\n * const cacheMiddleware = createMiddleware(async (next, input, init) =\u003E {\n *   const cacheKey = typeof input === 'string' ? input : input.toString();\n *\n *   // Check cache first\n *   const cached = await getFromCache(cacheKey);\n *   if (cached) {\n *     return new Response(cached, { status: 200 });\n *   }\n *\n *   // Make request and cache result\n *   const response = await next(input, init);\n *   if (response.ok) {\n *     await saveToCache(cacheKey, await response.clone().text());\n *   }\n *\n *   return response;\n * });\n * ```\n *\n * @param handler - Function that receives the next handler and request parameters\n * @returns A fetch middleware function\n */\nexport const createMiddleware = (\n  handler: (\n    next: FetchLike,\n    input: string | URL,\n    init?: RequestInit,\n  ) =\u003E Promise\u003CResponse\u003E,\n): Middleware =\u003E {\n  return (next) =\u003E (input, init) =\u003E handler(next, input as string | URL, init);\n};\n",
      "hash": "50d3bf4766e21f1247826b683722c7376b52fc4b73a46eba46b7e697553a7b47",
      "size": 10919
    },
    "/src/client/sse.test.ts": {
      "type": "content",
      "content": "import { createServer, ServerResponse, type IncomingMessage, type Server } from \"http\";\nimport { AddressInfo } from \"net\";\nimport { JSONRPCMessage } from \"../types.js\";\nimport { SSEClientTransport } from \"./sse.js\";\nimport { OAuthClientProvider, UnauthorizedError } from \"./auth.js\";\nimport { OAuthTokens } from \"../shared/auth.js\";\nimport { InvalidClientError, InvalidGrantError, UnauthorizedClientError } from \"../server/auth/errors.js\";\n\ndescribe(\"SSEClientTransport\", () =\u003E {\n  let resourceServer: Server;\n  let authServer: Server;\n  let transport: SSEClientTransport;\n  let resourceBaseUrl: URL;\n  let authBaseUrl: URL;\n  let lastServerRequest: IncomingMessage;\n  let sendServerMessage: ((message: string) =\u003E void) | null = null;\n\n  beforeEach((done) =\u003E {\n    // Reset state\n    lastServerRequest = null as unknown as IncomingMessage;\n    sendServerMessage = null;\n\n    authServer = createServer((req, res) =\u003E {\n      if (req.url === \"/.well-known/oauth-authorization-server\") {\n        res.writeHead(200, {\n          \"Content-Type\": \"application/json\"\n        });\n        res.end(JSON.stringify({\n          issuer: \"https://auth.example.com\",\n          authorization_endpoint: \"https://auth.example.com/authorize\",\n          token_endpoint: \"https://auth.example.com/token\",\n          registration_endpoint: \"https://auth.example.com/register\",\n          response_types_supported: [\"code\"],\n          code_challenge_methods_supported: [\"S256\"],\n        }));\n        return;\n      }\n      res.writeHead(401).end();\n    });\n\n    // Create a test server that will receive the EventSource connection\n    resourceServer = createServer((req, res) =\u003E {\n      lastServerRequest = req;\n\n      // Send SSE headers\n      res.writeHead(200, {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache, no-transform\",\n        Connection: \"keep-alive\",\n      });\n\n      // Send the endpoint event\n      res.write(\"event: endpoint\\n\");\n      res.write(`data: ${resourceBaseUrl.href}\\n\\n`);\n\n      // Store reference to send function for tests\n      sendServerMessage = (message: string) =\u003E {\n        res.write(`data: ${message}\\n\\n`);\n      };\n\n      // Handle request body for POST endpoints\n      if (req.method === \"POST\") {\n        let body = \"\";\n        req.on(\"data\", (chunk) =\u003E {\n          body += chunk;\n        });\n        req.on(\"end\", () =\u003E {\n          (req as IncomingMessage & { body: string }).body = body;\n          res.end();\n        });\n      }\n    });\n\n    // Start server on random port\n    resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n      const addr = resourceServer.address() as AddressInfo;\n      resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n      done();\n    });\n\n    jest.spyOn(console, 'error').mockImplementation(() =\u003E {});\n  });\n\n  afterEach(async () =\u003E {\n    await transport.close();\n    await resourceServer.close();\n    await authServer.close();\n\n    jest.clearAllMocks();\n  });\n\n  describe(\"connection handling\", () =\u003E {\n    it(\"establishes SSE connection and receives endpoint\", async () =\u003E {\n      transport = new SSEClientTransport(resourceBaseUrl);\n      await transport.start();\n\n      expect(lastServerRequest.headers.accept).toBe(\"text/event-stream\");\n      expect(lastServerRequest.method).toBe(\"GET\");\n    });\n\n    it(\"rejects if server returns non-200 status\", async () =\u003E {\n      // Create a server that returns 403\n      await resourceServer.close();\n\n      resourceServer = createServer((req, res) =\u003E {\n        res.writeHead(403);\n        res.end();\n      });\n\n      await new Promise\u003Cvoid\u003E((resolve) =\u003E {\n        resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = resourceServer.address() as AddressInfo;\n          resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl);\n      await expect(transport.start()).rejects.toThrow();\n    });\n\n    it(\"closes EventSource connection on close()\", async () =\u003E {\n      transport = new SSEClientTransport(resourceBaseUrl);\n      await transport.start();\n\n      const closePromise = new Promise((resolve) =\u003E {\n        lastServerRequest.on(\"close\", resolve);\n      });\n\n      await transport.close();\n      await closePromise;\n    });\n  });\n\n  describe(\"message handling\", () =\u003E {\n    it(\"receives and parses JSON-RPC messages\", async () =\u003E {\n      const receivedMessages: JSONRPCMessage[] = [];\n      transport = new SSEClientTransport(resourceBaseUrl);\n      transport.onmessage = (msg) =\u003E receivedMessages.push(msg);\n\n      await transport.start();\n\n      const testMessage: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"test-1\",\n        method: \"test\",\n        params: { foo: \"bar\" },\n      };\n\n      sendServerMessage!(JSON.stringify(testMessage));\n\n      // Wait for message processing\n      await new Promise((resolve) =\u003E setTimeout(resolve, 50));\n\n      expect(receivedMessages).toHaveLength(1);\n      expect(receivedMessages[0]).toEqual(testMessage);\n    });\n\n    it(\"handles malformed JSON messages\", async () =\u003E {\n      const errors: Error[] = [];\n      transport = new SSEClientTransport(resourceBaseUrl);\n      transport.onerror = (err) =\u003E errors.push(err);\n\n      await transport.start();\n\n      sendServerMessage!(\"invalid json\");\n\n      // Wait for message processing\n      await new Promise((resolve) =\u003E setTimeout(resolve, 50));\n\n      expect(errors).toHaveLength(1);\n      expect(errors[0].message).toMatch(/JSON/);\n    });\n\n    it(\"handles messages via POST requests\", async () =\u003E {\n      transport = new SSEClientTransport(resourceBaseUrl);\n      await transport.start();\n\n      const testMessage: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"test-1\",\n        method: \"test\",\n        params: { foo: \"bar\" },\n      };\n\n      await transport.send(testMessage);\n\n      // Wait for request processing\n      await new Promise((resolve) =\u003E setTimeout(resolve, 50));\n\n      expect(lastServerRequest.method).toBe(\"POST\");\n      expect(lastServerRequest.headers[\"content-type\"]).toBe(\n        \"application/json\",\n      );\n      expect(\n        JSON.parse(\n          (lastServerRequest as IncomingMessage & { body: string }).body,\n        ),\n      ).toEqual(testMessage);\n    });\n\n    it(\"handles POST request failures\", async () =\u003E {\n      // Create a server that returns 500 for POST\n      await resourceServer.close();\n\n      resourceServer = createServer((req, res) =\u003E {\n        if (req.method === \"GET\") {\n          res.writeHead(200, {\n            \"Content-Type\": \"text/event-stream\",\n            \"Cache-Control\": \"no-cache, no-transform\",\n            Connection: \"keep-alive\",\n          });\n          res.write(\"event: endpoint\\n\");\n          res.write(`data: ${resourceBaseUrl.href}\\n\\n`);\n        } else {\n          res.writeHead(500);\n          res.end(\"Internal error\");\n        }\n      });\n\n      await new Promise\u003Cvoid\u003E((resolve) =\u003E {\n        resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = resourceServer.address() as AddressInfo;\n          resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl);\n      await transport.start();\n\n      const testMessage: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"test-1\",\n        method: \"test\",\n        params: {},\n      };\n\n      await expect(transport.send(testMessage)).rejects.toThrow(/500/);\n    });\n  });\n\n  describe(\"header handling\", () =\u003E {\n    it(\"uses custom fetch implementation from EventSourceInit to add auth headers\", async () =\u003E {\n      const authToken = \"Bearer test-token\";\n\n      // Create a fetch wrapper that adds auth header\n      const fetchWithAuth = (url: string | URL, init?: RequestInit) =\u003E {\n        const headers = new Headers(init?.headers);\n        headers.set(\"Authorization\", authToken);\n        return fetch(url.toString(), { ...init, headers });\n      };\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        eventSourceInit: {\n          fetch: fetchWithAuth,\n        },\n      });\n\n      await transport.start();\n\n      // Verify the auth header was received by the server\n      expect(lastServerRequest.headers.authorization).toBe(authToken);\n    });\n\n    it(\"uses custom fetch implementation from options\", async () =\u003E {\n      const authToken = \"Bearer custom-token\";\n\n      const fetchWithAuth = jest.fn((url: string | URL, init?: RequestInit) =\u003E {\n        const headers = new Headers(init?.headers);\n        headers.set(\"Authorization\", authToken);\n        return fetch(url.toString(), { ...init, headers });\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        fetch: fetchWithAuth,\n      });\n\n      await transport.start();\n\n      expect(lastServerRequest.headers.authorization).toBe(authToken);\n\n      // Send a message to verify fetchWithAuth used for POST as well\n      const message: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"1\",\n        method: \"test\",\n        params: {},\n      };\n\n      await transport.send(message);\n\n      expect(fetchWithAuth).toHaveBeenCalledTimes(2);\n      expect(lastServerRequest.method).toBe(\"POST\");\n      expect(lastServerRequest.headers.authorization).toBe(authToken);\n    });\n\n    it(\"passes custom headers to fetch requests\", async () =\u003E {\n      const customHeaders = {\n        Authorization: \"Bearer test-token\",\n        \"X-Custom-Header\": \"custom-value\",\n      };\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        requestInit: {\n          headers: customHeaders,\n        },\n      });\n\n      await transport.start();\n\n      // Store original fetch\n      const originalFetch = global.fetch;\n\n      try {\n        // Mock fetch for the message sending test\n        global.fetch = jest.fn().mockResolvedValue({\n          ok: true,\n        });\n\n        const message: JSONRPCMessage = {\n          jsonrpc: \"2.0\",\n          id: \"1\",\n          method: \"test\",\n          params: {},\n        };\n\n        await transport.send(message);\n\n        // Verify fetch was called with correct headers\n        expect(global.fetch).toHaveBeenCalledWith(\n          expect.any(URL),\n          expect.objectContaining({\n            headers: expect.any(Headers),\n          }),\n        );\n\n        const calledHeaders = (global.fetch as jest.Mock).mock.calls[0][1]\n          .headers;\n        expect(calledHeaders.get(\"Authorization\")).toBe(\n          customHeaders.Authorization,\n        );\n        expect(calledHeaders.get(\"X-Custom-Header\")).toBe(\n          customHeaders[\"X-Custom-Header\"],\n        );\n        expect(calledHeaders.get(\"content-type\")).toBe(\"application/json\");\n      } finally {\n        // Restore original fetch\n        global.fetch = originalFetch;\n      }\n    });\n  });\n\n  describe(\"auth handling\", () =\u003E {\n    const authServerMetadataUrls = [\n      \"/.well-known/oauth-authorization-server\",\n      \"/.well-known/openid-configuration\",\n    ];\n\n    let mockAuthProvider: jest.Mocked\u003COAuthClientProvider\u003E;\n\n    beforeEach(() =\u003E {\n      mockAuthProvider = {\n        get redirectUrl() { return \"http://localhost/callback\"; },\n        get clientMetadata() { return { redirect_uris: [\"http://localhost/callback\"] }; },\n        clientInformation: jest.fn(() =\u003E ({ client_id: \"test-client-id\", client_secret: \"test-client-secret\" })),\n        tokens: jest.fn(),\n        saveTokens: jest.fn(),\n        redirectToAuthorization: jest.fn(),\n        saveCodeVerifier: jest.fn(),\n        codeVerifier: jest.fn(),\n        invalidateCredentials: jest.fn(),\n      };\n    });\n\n    it(\"attaches auth header from provider on SSE connection\", async () =\u003E {\n      mockAuthProvider.tokens.mockResolvedValue({\n        access_token: \"test-token\",\n        token_type: \"Bearer\"\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await transport.start();\n\n      expect(lastServerRequest.headers.authorization).toBe(\"Bearer test-token\");\n      expect(mockAuthProvider.tokens).toHaveBeenCalled();\n    });\n\n    it(\"attaches custom header from provider on initial SSE connection\", async () =\u003E {\n      mockAuthProvider.tokens.mockResolvedValue({\n        access_token: \"test-token\",\n        token_type: \"Bearer\"\n      });\n      const customHeaders = {\n        \"X-Custom-Header\": \"custom-value\",\n      };\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n        requestInit: {\n          headers: customHeaders,\n        },\n      });\n\n      await transport.start();\n\n      expect(lastServerRequest.headers.authorization).toBe(\"Bearer test-token\");\n      expect(lastServerRequest.headers[\"x-custom-header\"]).toBe(\"custom-value\");\n      expect(mockAuthProvider.tokens).toHaveBeenCalled();\n    });\n\n    it(\"attaches auth header from provider on POST requests\", async () =\u003E {\n      mockAuthProvider.tokens.mockResolvedValue({\n        access_token: \"test-token\",\n        token_type: \"Bearer\"\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await transport.start();\n\n      const message: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"1\",\n        method: \"test\",\n        params: {},\n      };\n\n      await transport.send(message);\n\n      expect(lastServerRequest.headers.authorization).toBe(\"Bearer test-token\");\n      expect(mockAuthProvider.tokens).toHaveBeenCalled();\n    });\n\n    it(\"attempts auth flow on 401 during SSE connection\", async () =\u003E {\n\n      // Create server that returns 401s\n      resourceServer.close();\n      authServer.close();\n\n      // Start auth server on random port\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        authServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = authServer.address() as AddressInfo;\n          authBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      resourceServer = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        if (req.url === \"/.well-known/oauth-protected-resource\") {\n          res.writeHead(200, {\n            'Content-Type': 'application/json',\n          })\n          .end(JSON.stringify({\n            resource: resourceBaseUrl.href,\n            authorization_servers: [`${authBaseUrl}`],\n          }));\n          return;\n        }\n\n        if (req.url !== \"/\") {\n            res.writeHead(404).end();\n        } else {\n          res.writeHead(401).end();\n        }\n      });\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = resourceServer.address() as AddressInfo;\n          resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await expect(() =\u003E transport.start()).rejects.toThrow(UnauthorizedError);\n      expect(mockAuthProvider.redirectToAuthorization.mock.calls).toHaveLength(1);\n    });\n\n    it(\"attempts auth flow on 401 during POST request\", async () =\u003E {\n      // Create server that accepts SSE but returns 401 on POST\n      resourceServer.close();\n      authServer.close();\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        authServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = authServer.address() as AddressInfo;\n          authBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      resourceServer = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        switch (req.method) {\n          case \"GET\":\n            if (req.url === \"/.well-known/oauth-protected-resource\") {\n              res.writeHead(200, {\n                'Content-Type': 'application/json',\n              })\n              .end(JSON.stringify({\n                resource: resourceBaseUrl.href,\n                authorization_servers: [`${authBaseUrl}`],\n              }));\n              return;\n            }\n\n            if (req.url !== \"/\") {\n              res.writeHead(404).end();\n              return;\n            }\n\n            res.writeHead(200, {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache, no-transform\",\n              Connection: \"keep-alive\",\n            });\n            res.write(\"event: endpoint\\n\");\n            res.write(`data: ${resourceBaseUrl.href}\\n\\n`);\n            break;\n\n          case \"POST\":\n          res.writeHead(401);\n          res.end();\n            break;\n        }\n      });\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = resourceServer.address() as AddressInfo;\n          resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await transport.start();\n\n      const message: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"1\",\n        method: \"test\",\n        params: {},\n      };\n\n      await expect(() =\u003E transport.send(message)).rejects.toThrow(UnauthorizedError);\n      expect(mockAuthProvider.redirectToAuthorization.mock.calls).toHaveLength(1);\n    });\n\n    it(\"respects custom headers when using auth provider\", async () =\u003E {\n      mockAuthProvider.tokens.mockResolvedValue({\n        access_token: \"test-token\",\n        token_type: \"Bearer\"\n      });\n\n      const customHeaders = {\n        \"X-Custom-Header\": \"custom-value\",\n      };\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n        requestInit: {\n          headers: customHeaders,\n        },\n      });\n\n      await transport.start();\n\n      const message: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"1\",\n        method: \"test\",\n        params: {},\n      };\n\n      await transport.send(message);\n\n      expect(lastServerRequest.headers.authorization).toBe(\"Bearer test-token\");\n      expect(lastServerRequest.headers[\"x-custom-header\"]).toBe(\"custom-value\");\n    });\n\n    it(\"refreshes expired token during SSE connection\", async () =\u003E {\n      // Mock tokens() to return expired token until saveTokens is called\n      let currentTokens: OAuthTokens = {\n        access_token: \"expired-token\",\n        token_type: \"Bearer\",\n        refresh_token: \"refresh-token\"\n      };\n      mockAuthProvider.tokens.mockImplementation(() =\u003E currentTokens);\n      mockAuthProvider.saveTokens.mockImplementation((tokens) =\u003E {\n        currentTokens = tokens;\n      });\n\n      // Create server that returns 401 for expired token, then accepts new token\n      resourceServer.close();\n      authServer.close();\n\n      authServer = createServer((req, res) =\u003E {\n        if (req.url && authServerMetadataUrls.includes(req.url)) {\n          res.writeHead(404).end();\n          return;\n        }\n\n        if (req.url === \"/token\" && req.method === \"POST\") {\n          // Handle token refresh request\n          let body = \"\";\n          req.on(\"data\", chunk =\u003E { body += chunk; });\n          req.on(\"end\", () =\u003E {\n            const params = new URLSearchParams(body);\n            if (params.get(\"grant_type\") === \"refresh_token\" &&\n              params.get(\"refresh_token\") === \"refresh-token\" &&\n              params.get(\"client_id\") === \"test-client-id\" &&\n              params.get(\"client_secret\") === \"test-client-secret\") {\n              res.writeHead(200, { \"Content-Type\": \"application/json\" });\n              res.end(JSON.stringify({\n                access_token: \"new-token\",\n                token_type: \"Bearer\",\n                refresh_token: \"new-refresh-token\"\n              }));\n            } else {\n              res.writeHead(400).end();\n            }\n          });\n          return;\n        }\n\n        res.writeHead(401).end();\n\n      });\n\n      // Start auth server on random port\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        authServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = authServer.address() as AddressInfo;\n          authBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      let connectionAttempts = 0;\n      resourceServer = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        if (req.url === \"/.well-known/oauth-protected-resource\") {\n          res.writeHead(200, {\n            'Content-Type': 'application/json',\n          })\n          .end(JSON.stringify({\n            resource: resourceBaseUrl.href,\n            authorization_servers: [`${authBaseUrl}`],\n          }));\n          return;\n        }\n\n        if (req.url !== \"/\") {\n          res.writeHead(404).end();\n          return;\n        }\n\n          const auth = req.headers.authorization;\n          if (auth === \"Bearer expired-token\") {\n            res.writeHead(401).end();\n            return;\n          }\n\n        if (auth === \"Bearer new-token\") {\n          res.writeHead(200, {\n            \"Content-Type\": \"text/event-stream\",\n            \"Cache-Control\": \"no-cache, no-transform\",\n            Connection: \"keep-alive\",\n          });\n          res.write(\"event: endpoint\\n\");\n          res.write(`data: ${resourceBaseUrl.href}\\n\\n`);\n          connectionAttempts++;\n          return;\n        }\n\n          res.writeHead(401).end();\n      });\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = resourceServer.address() as AddressInfo;\n          resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await transport.start();\n\n      expect(mockAuthProvider.saveTokens).toHaveBeenCalledWith({\n        access_token: \"new-token\",\n        token_type: \"Bearer\",\n        refresh_token: \"new-refresh-token\"\n      });\n      expect(connectionAttempts).toBe(1);\n      expect(lastServerRequest.headers.authorization).toBe(\"Bearer new-token\");\n    });\n\n    it(\"refreshes expired token during POST request\", async () =\u003E {\n      // Mock tokens() to return expired token until saveTokens is called\n      let currentTokens: OAuthTokens = {\n        access_token: \"expired-token\",\n        token_type: \"Bearer\",\n        refresh_token: \"refresh-token\"\n      };\n      mockAuthProvider.tokens.mockImplementation(() =\u003E currentTokens);\n      mockAuthProvider.saveTokens.mockImplementation((tokens) =\u003E {\n        currentTokens = tokens;\n      });\n\n      // Create server that returns 401 for expired token, then accepts new token\n      resourceServer.close();\n      authServer.close();\n\n      authServer = createServer((req, res) =\u003E {\n        if (req.url && authServerMetadataUrls.includes(req.url)) {\n          res.writeHead(404).end();\n          return;\n        }\n\n        if (req.url === \"/token\" && req.method === \"POST\") {\n          // Handle token refresh request\n          let body = \"\";\n          req.on(\"data\", chunk =\u003E { body += chunk; });\n          req.on(\"end\", () =\u003E {\n            const params = new URLSearchParams(body);\n            if (params.get(\"grant_type\") === \"refresh_token\" &&\n              params.get(\"refresh_token\") === \"refresh-token\" &&\n              params.get(\"client_id\") === \"test-client-id\" &&\n              params.get(\"client_secret\") === \"test-client-secret\") {\n              res.writeHead(200, { \"Content-Type\": \"application/json\" });\n              res.end(JSON.stringify({\n                access_token: \"new-token\",\n                token_type: \"Bearer\",\n                refresh_token: \"new-refresh-token\"\n              }));\n            } else {\n              res.writeHead(400).end();\n            }\n          });\n          return;\n        }\n\n        res.writeHead(401).end();\n\n      });\n\n      // Start auth server on random port\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        authServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = authServer.address() as AddressInfo;\n          authBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      let postAttempts = 0;\n      resourceServer = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        if (req.url === \"/.well-known/oauth-protected-resource\") {\n          res.writeHead(200, {\n            'Content-Type': 'application/json',\n          })\n          .end(JSON.stringify({\n            resource: resourceBaseUrl.href,\n            authorization_servers: [`${authBaseUrl}`],\n          }));\n          return;\n        }\n\n        switch (req.method) {\n          case \"GET\":\n            if (req.url !== \"/\") {\n              res.writeHead(404).end();\n              return;\n            }\n\n            res.writeHead(200, {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache, no-transform\",\n              Connection: \"keep-alive\",\n            });\n            res.write(\"event: endpoint\\n\");\n            res.write(`data: ${resourceBaseUrl.href}\\n\\n`);\n            break;\n\n          case \"POST\": {\n            if (req.url !== \"/\") {\n              res.writeHead(404).end();\n              return;\n            }\n\n          const auth = req.headers.authorization;\n          if (auth === \"Bearer expired-token\") {\n            res.writeHead(401).end();\n            return;\n          }\n\n          if (auth === \"Bearer new-token\") {\n            res.writeHead(200).end();\n            postAttempts++;\n            return;\n          }\n\n          res.writeHead(401).end();\n            break;\n          }\n        }\n      });\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = resourceServer.address() as AddressInfo;\n          resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await transport.start();\n\n      const message: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"1\",\n        method: \"test\",\n        params: {},\n      };\n\n      await transport.send(message);\n\n      expect(mockAuthProvider.saveTokens).toHaveBeenCalledWith({\n        access_token: \"new-token\",\n        token_type: \"Bearer\",\n        refresh_token: \"new-refresh-token\"\n      });\n      expect(postAttempts).toBe(1);\n      expect(lastServerRequest.headers.authorization).toBe(\"Bearer new-token\");\n    });\n\n    it(\"redirects to authorization if refresh token flow fails\", async () =\u003E {\n      // Mock tokens() to return expired token until saveTokens is called\n      let currentTokens: OAuthTokens = {\n        access_token: \"expired-token\",\n        token_type: \"Bearer\",\n        refresh_token: \"refresh-token\"\n      };\n      mockAuthProvider.tokens.mockImplementation(() =\u003E currentTokens);\n      mockAuthProvider.saveTokens.mockImplementation((tokens) =\u003E {\n        currentTokens = tokens;\n      });\n\n      // Create server that returns 401 for all tokens\n      resourceServer.close();\n      authServer.close();\n\n      authServer = createServer((req, res) =\u003E {\n        if (req.url && authServerMetadataUrls.includes(req.url)) {\n          res.writeHead(404).end();\n          return;\n        }\n\n        if (req.url === \"/token\" && req.method === \"POST\") {\n          // Handle token refresh request - always fail\n          res.writeHead(400).end();\n          return;\n        }\n\n        res.writeHead(401).end();\n\n      });\n\n\n      // Start auth server on random port\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        authServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = authServer.address() as AddressInfo;\n          authBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      resourceServer = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        if (req.url === \"/.well-known/oauth-protected-resource\") {\n          res.writeHead(200, {\n            'Content-Type': 'application/json',\n          })\n          .end(JSON.stringify({\n            resource: resourceBaseUrl.href,\n            authorization_servers: [`${authBaseUrl}`],\n          }));\n          return;\n        }\n\n        if (req.url !== \"/\") {\n          res.writeHead(404).end();\n          return;\n        }\n        res.writeHead(401).end();\n      });\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = resourceServer.address() as AddressInfo;\n          resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await expect(() =\u003E transport.start()).rejects.toThrow(UnauthorizedError);\n      expect(mockAuthProvider.redirectToAuthorization).toHaveBeenCalled();\n    });\n\n    it(\"invalidates all credentials on InvalidClientError during token refresh\", async () =\u003E {\n      // Mock tokens() to return token with refresh token\n      mockAuthProvider.tokens.mockResolvedValue({\n        access_token: \"expired-token\",\n        token_type: \"Bearer\",\n        refresh_token: \"refresh-token\"\n      });\n\n      let baseUrl = resourceBaseUrl;\n\n      // Create server that returns InvalidClientError on token refresh\n      const server = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        // Handle OAuth metadata discovery\n        if (req.url === \"/.well-known/oauth-authorization-server\" && req.method === \"GET\") {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            issuer: baseUrl.href,\n            authorization_endpoint: `${baseUrl.href}authorize`,\n            token_endpoint: `${baseUrl.href}token`,\n            response_types_supported: [\"code\"],\n            code_challenge_methods_supported: [\"S256\"],\n          }));\n          return;\n        }\n\n        if (req.url === \"/token\" && req.method === \"POST\") {\n          // Handle token refresh request - return InvalidClientError\n          const error = new InvalidClientError(\"Client authentication failed\");\n          res.writeHead(400, { 'Content-Type': 'application/json' })\n            .end(JSON.stringify(error.toResponseObject()));\n          return;\n        }\n\n        if (req.url !== \"/\") {\n          res.writeHead(404).end();\n          return;\n        }\n        res.writeHead(401).end();\n      });\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        server.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = server.address() as AddressInfo;\n          baseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(baseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await expect(() =\u003E transport.start()).rejects.toThrow(InvalidClientError);\n      expect(mockAuthProvider.invalidateCredentials).toHaveBeenCalledWith('all');\n    });\n\n    it(\"invalidates all credentials on UnauthorizedClientError during token refresh\", async () =\u003E {\n      // Mock tokens() to return token with refresh token\n      mockAuthProvider.tokens.mockResolvedValue({\n        access_token: \"expired-token\",\n        token_type: \"Bearer\",\n        refresh_token: \"refresh-token\"\n      });\n\n      let baseUrl = resourceBaseUrl;\n\n      const server = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        // Handle OAuth metadata discovery\n        if (req.url === \"/.well-known/oauth-authorization-server\" && req.method === \"GET\") {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            issuer: baseUrl.href,\n            authorization_endpoint: `${baseUrl.href}authorize`,\n            token_endpoint: `${baseUrl.href}token`,\n            response_types_supported: [\"code\"],\n            code_challenge_methods_supported: [\"S256\"],\n          }));\n          return;\n        }\n\n        if (req.url === \"/token\" && req.method === \"POST\") {\n          // Handle token refresh request - return UnauthorizedClientError\n          const error = new UnauthorizedClientError(\"Client not authorized\");\n          res.writeHead(400, { 'Content-Type': 'application/json' })\n            .end(JSON.stringify(error.toResponseObject()));\n          return;\n        }\n\n        if (req.url !== \"/\") {\n          res.writeHead(404).end();\n          return;\n        }\n        res.writeHead(401).end();\n      });\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        server.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = server.address() as AddressInfo;\n          baseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(baseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await expect(() =\u003E transport.start()).rejects.toThrow(UnauthorizedClientError);\n      expect(mockAuthProvider.invalidateCredentials).toHaveBeenCalledWith('all');\n    });\n\n    it(\"invalidates tokens on InvalidGrantError during token refresh\", async () =\u003E {\n      // Mock tokens() to return token with refresh token\n      mockAuthProvider.tokens.mockResolvedValue({\n        access_token: \"expired-token\",\n        token_type: \"Bearer\",\n        refresh_token: \"refresh-token\"\n      });\n      let baseUrl = resourceBaseUrl;\n\n      const server = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        // Handle OAuth metadata discovery\n        if (req.url === \"/.well-known/oauth-authorization-server\" && req.method === \"GET\") {\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            issuer: baseUrl.href,\n            authorization_endpoint: `${baseUrl.href}authorize`,\n            token_endpoint: `${baseUrl.href}token`,\n            response_types_supported: [\"code\"],\n            code_challenge_methods_supported: [\"S256\"],\n          }));\n          return;\n        }\n\n        if (req.url === \"/token\" && req.method === \"POST\") {\n          // Handle token refresh request - return InvalidGrantError\n          const error = new InvalidGrantError(\"Invalid refresh token\");\n          res.writeHead(400, { 'Content-Type': 'application/json' })\n            .end(JSON.stringify(error.toResponseObject()));\n          return;\n        }\n\n        if (req.url !== \"/\") {\n          res.writeHead(404).end();\n          return;\n        }\n        res.writeHead(401).end();\n      });\n\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        server.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = server.address() as AddressInfo;\n          baseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n\n      transport = new SSEClientTransport(baseUrl, {\n        authProvider: mockAuthProvider,\n      });\n\n      await expect(() =\u003E transport.start()).rejects.toThrow(InvalidGrantError);\n      expect(mockAuthProvider.invalidateCredentials).toHaveBeenCalledWith('tokens');\n    });\n  });\n\n  describe(\"custom fetch in auth code paths\", () =\u003E {\n    let customFetch: jest.MockedFunction\u003Ctypeof fetch\u003E;\n    let globalFetchSpy: jest.SpyInstance;\n    let mockAuthProvider: jest.Mocked\u003COAuthClientProvider\u003E;\n    let resourceServerHandler: jest.Mock\u003Cvoid, [IncomingMessage, ServerResponse\u003CIncomingMessage\u003E & {\n      req: IncomingMessage;\n    }], void\u003E;\n\n    /**\n     * Helper function to create a mock auth provider with configurable behavior\n     */\n    const createMockAuthProvider = (config: {\n      hasTokens?: boolean;\n      tokensExpired?: boolean;\n      hasRefreshToken?: boolean;\n      clientRegistered?: boolean;\n      authorizationCode?: string;\n    } = {}): jest.Mocked\u003COAuthClientProvider\u003E =\u003E {\n      const tokens = config.hasTokens ? {\n        access_token: config.tokensExpired ? \"expired-token\" : \"valid-token\",\n        token_type: \"Bearer\" as const,\n        ...(config.hasRefreshToken && { refresh_token: \"refresh-token\" })\n      } : undefined;\n\n      const clientInfo = config.clientRegistered ? {\n        client_id: \"test-client-id\",\n        client_secret: \"test-client-secret\"\n      } : undefined;\n\n      return {\n        get redirectUrl() { return \"http://localhost/callback\"; },\n        get clientMetadata() { \n          return { \n            redirect_uris: [\"http://localhost/callback\"],\n            client_name: \"Test Client\"\n          }; \n        },\n        clientInformation: jest.fn().mockResolvedValue(clientInfo),\n        tokens: jest.fn().mockResolvedValue(tokens),\n        saveTokens: jest.fn(),\n        redirectToAuthorization: jest.fn(),\n        saveCodeVerifier: jest.fn(),\n        codeVerifier: jest.fn().mockResolvedValue(\"test-verifier\"),\n        invalidateCredentials: jest.fn(),\n      };\n    };\n\n    const createCustomFetchMockAuthServer = async () =\u003E {\n      authServer = createServer((req, res) =\u003E {\n        if (req.url === \"/.well-known/oauth-authorization-server\") {\n          res.writeHead(200, { \"Content-Type\": \"application/json\" });\n          res.end(JSON.stringify({\n            issuer: `http://127.0.0.1:${(authServer.address() as AddressInfo).port}`,\n            authorization_endpoint: `http://127.0.0.1:${(authServer.address() as AddressInfo).port}/authorize`,\n            token_endpoint: `http://127.0.0.1:${(authServer.address() as AddressInfo).port}/token`,\n            registration_endpoint: `http://127.0.0.1:${(authServer.address() as AddressInfo).port}/register`,\n            response_types_supported: [\"code\"],\n            code_challenge_methods_supported: [\"S256\"],\n          }));\n          return;\n        }\n  \n        if (req.url === \"/token\" && req.method === \"POST\") {\n          // Handle token exchange request\n          let body = \"\";\n          req.on(\"data\", chunk =\u003E { body += chunk; });\n          req.on(\"end\", () =\u003E {\n            const params = new URLSearchParams(body);\n            if (params.get(\"grant_type\") === \"authorization_code\" &&\n                params.get(\"code\") === \"test-auth-code\" &&\n                params.get(\"client_id\") === \"test-client-id\") {\n              res.writeHead(200, { \"Content-Type\": \"application/json\" });\n              res.end(JSON.stringify({\n                access_token: \"new-access-token\",\n                token_type: \"Bearer\",\n                expires_in: 3600,\n                refresh_token: \"new-refresh-token\"\n              }));\n            } else {\n              res.writeHead(400).end();\n            }\n          });\n          return;\n        }\n  \n        res.writeHead(404).end();\n      });\n\n      // Start auth server on random port\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        authServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = authServer.address() as AddressInfo;\n          authBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n    };\n\n    const createCustomFetchMockResourceServer = async () =\u003E {\n      // Set up resource server that provides OAuth metadata\n      resourceServer = createServer((req, res) =\u003E {\n        lastServerRequest = req;\n\n        if (req.url === \"/.well-known/oauth-protected-resource\") {\n          res.writeHead(200, { \"Content-Type\": \"application/json\" });\n          res.end(JSON.stringify({\n            resource: resourceBaseUrl.href,\n            authorization_servers: [authBaseUrl.href],\n          }));\n          return;\n        }\n\n        resourceServerHandler(req, res);\n      });\n\n      // Start resource server on random port\n      await new Promise\u003Cvoid\u003E(resolve =\u003E {\n        resourceServer.listen(0, \"127.0.0.1\", () =\u003E {\n          const addr = resourceServer.address() as AddressInfo;\n          resourceBaseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n          resolve();\n        });\n      });\n    };\n\n    beforeEach(async () =\u003E {\n      // Close existing servers to set up custom auth flow servers\n      resourceServer.close();\n      authServer.close();\n\n      const originalFetch = fetch;\n\n      // Create custom fetch spy that delegates to real fetch\n      customFetch = jest.fn((url, init) =\u003E {\n        return originalFetch(url.toString(), init);\n      });\n\n      // Spy on global fetch to detect unauthorized usage\n      globalFetchSpy = jest.spyOn(global, 'fetch');\n\n      // Create mock auth provider with default configuration\n      mockAuthProvider = createMockAuthProvider({\n        hasTokens: false,\n        clientRegistered: true\n      });\n\n      // Set up auth server that handles OAuth discovery and token requests\n      await createCustomFetchMockAuthServer();\n\n      // Set up resource server\n      resourceServerHandler = jest.fn((_req: IncomingMessage, res: ServerResponse\u003CIncomingMessage\u003E & {\n        req: IncomingMessage;\n      }) =\u003E {\n        res.writeHead(404).end();\n      });\n      await createCustomFetchMockResourceServer();\n    });\n\n    afterEach(() =\u003E {\n      globalFetchSpy.mockRestore();\n    });\n\n    it(\"uses custom fetch during auth flow on SSE connection 401 - no global fetch fallback\", async () =\u003E {\n      // Set up resource server that returns 401 on SSE connection and provides OAuth metadata\n      resourceServerHandler.mockImplementation((req, res) =\u003E {\n        if (req.url === \"/\") {\n          // Return 401 to trigger auth flow\n          res.writeHead(401, {\n            \"WWW-Authenticate\": `Bearer realm=\"mcp\", resource_metadata=\"${resourceBaseUrl.href}.well-known/oauth-protected-resource\"`\n          });\n          res.end();\n          return;\n        }\n\n        res.writeHead(404).end();\n      });\n\n      // Create transport with custom fetch and auth provider\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n        fetch: customFetch,\n      });\n\n      // Attempt to start - should trigger auth flow and eventually fail with UnauthorizedError\n      await expect(transport.start()).rejects.toThrow(UnauthorizedError);\n\n      // Verify custom fetch was used\n      expect(customFetch).toHaveBeenCalled();\n      \n      // Verify specific OAuth endpoints were called with custom fetch\n      const customFetchCalls = customFetch.mock.calls;\n      const callUrls = customFetchCalls.map(([url]) =\u003E url.toString());\n      \n      // Should have called resource metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-protected-resource'))).toBe(true);\n      \n      // Should have called OAuth authorization server metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-authorization-server'))).toBe(true);\n\n      // Verify auth provider was called to redirect to authorization\n      expect(mockAuthProvider.redirectToAuthorization).toHaveBeenCalled();\n\n      // Global fetch should never have been called\n      expect(globalFetchSpy).not.toHaveBeenCalled();\n    });\n\n    it(\"uses custom fetch during auth flow on POST request 401 - no global fetch fallback\", async () =\u003E {\n      // Set up resource server that accepts SSE connection but returns 401 on POST\n      resourceServerHandler.mockImplementation((req, res) =\u003E {\n        switch (req.method) {\n          case \"GET\":\n            if (req.url === \"/\") {\n              // Accept SSE connection\n              res.writeHead(200, {\n                \"Content-Type\": \"text/event-stream\",\n                \"Cache-Control\": \"no-cache, no-transform\",\n                Connection: \"keep-alive\",\n              });\n              res.write(\"event: endpoint\\n\");\n              res.write(`data: ${resourceBaseUrl.href}\\n\\n`);\n              return;\n            }\n            break;\n\n          case \"POST\":\n            if (req.url === \"/\") {\n              // Return 401 to trigger auth retry\n              res.writeHead(401, {\n                \"WWW-Authenticate\": `Bearer realm=\"mcp\", resource_metadata=\"${resourceBaseUrl.href}.well-known/oauth-protected-resource\"`\n              });\n              res.end();\n              return;\n            }\n            break;\n        }\n\n        res.writeHead(404).end();\n      });\n\n      // Create transport with custom fetch and auth provider\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: mockAuthProvider,\n        fetch: customFetch,\n      });\n\n      // Start the transport (should succeed)\n      await transport.start();\n\n      // Send a message that should trigger 401 and auth retry\n      const message: JSONRPCMessage = {\n        jsonrpc: \"2.0\",\n        id: \"1\",\n        method: \"test\",\n        params: {},\n      };\n\n      // Attempt to send message - should trigger auth flow and eventually fail\n      await expect(transport.send(message)).rejects.toThrow(UnauthorizedError);\n\n      // Verify custom fetch was used\n      expect(customFetch).toHaveBeenCalled();\n      \n      // Verify specific OAuth endpoints were called with custom fetch\n      const customFetchCalls = customFetch.mock.calls;\n      const callUrls = customFetchCalls.map(([url]) =\u003E url.toString());\n      \n      // Should have called resource metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-protected-resource'))).toBe(true);\n      \n      // Should have called OAuth authorization server metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-authorization-server'))).toBe(true);\n\n      // Should have attempted the POST request that triggered the 401\n      const postCalls = customFetchCalls.filter(([url, options]) =\u003E \n        url.toString() === resourceBaseUrl.href && options?.method === \"POST\"\n      );\n      expect(postCalls.length).toBeGreaterThan(0);\n\n      // Verify auth provider was called to redirect to authorization\n      expect(mockAuthProvider.redirectToAuthorization).toHaveBeenCalled();\n\n      // Global fetch should never have been called\n      expect(globalFetchSpy).not.toHaveBeenCalled();\n    });\n\n    it(\"uses custom fetch in finishAuth method - no global fetch fallback\", async () =\u003E {\n      // Create mock auth provider that expects to save tokens\n      const authProviderWithCode = createMockAuthProvider({\n        clientRegistered: true,\n        authorizationCode: \"test-auth-code\"\n      });\n\n      // Create transport with custom fetch and auth provider\n      transport = new SSEClientTransport(resourceBaseUrl, {\n        authProvider: authProviderWithCode,\n        fetch: customFetch,\n      });\n\n      // Call finishAuth with authorization code\n      await transport.finishAuth(\"test-auth-code\");\n\n      // Verify custom fetch was used\n      expect(customFetch).toHaveBeenCalled();\n      \n      // Verify specific OAuth endpoints were called with custom fetch\n      const customFetchCalls = customFetch.mock.calls;\n      const callUrls = customFetchCalls.map(([url]) =\u003E url.toString());\n      \n      // Should have called resource metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-protected-resource'))).toBe(true);\n      \n      // Should have called OAuth authorization server metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-authorization-server'))).toBe(true);\n\n      // Should have called token endpoint for authorization code exchange\n      const tokenCalls = customFetchCalls.filter(([url, options]) =\u003E \n        url.toString().includes('/token') && options?.method === \"POST\"\n      );\n      expect(tokenCalls.length).toBeGreaterThan(0);\n\n      // Verify tokens were saved\n      expect(authProviderWithCode.saveTokens).toHaveBeenCalledWith({\n        access_token: \"new-access-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n        refresh_token: \"new-refresh-token\"\n      });\n\n      // Global fetch should never have been called\n      expect(globalFetchSpy).not.toHaveBeenCalled();\n    });\n  });\n});\n",
      "hash": "2b260a8de9109ae5ebe99c86182f5c2a82abf6b73dde73b535e9b1454334cebe",
      "size": 47729
    },
    "/src/client/sse.ts": {
      "type": "content",
      "content": "import { EventSource, type ErrorEvent, type EventSourceInit } from \"eventsource\";\nimport { Transport, FetchLike } from \"../shared/transport.js\";\nimport { JSONRPCMessage, JSONRPCMessageSchema } from \"../types.js\";\nimport { auth, AuthResult, extractResourceMetadataUrl, OAuthClientProvider, UnauthorizedError } from \"./auth.js\";\n\nexport class SseError extends Error {\n  constructor(\n    public readonly code: number | undefined,\n    message: string | undefined,\n    public readonly event: ErrorEvent,\n  ) {\n    super(`SSE error: ${message}`);\n  }\n}\n\n/**\n * Configuration options for the `SSEClientTransport`.\n */\nexport type SSEClientTransportOptions = {\n  /**\n   * An OAuth client provider to use for authentication.\n   *\n   * When an `authProvider` is specified and the SSE connection is started:\n   * 1. The connection is attempted with any existing access token from the `authProvider`.\n   * 2. If the access token has expired, the `authProvider` is used to refresh the token.\n   * 3. If token refresh fails or no access token exists, and auth is required, `OAuthClientProvider.redirectToAuthorization` is called, and an `UnauthorizedError` will be thrown from `connect`/`start`.\n   *\n   * After the user has finished authorizing via their user agent, and is redirected back to the MCP client application, call `SSEClientTransport.finishAuth` with the authorization code before retrying the connection.\n   *\n   * If an `authProvider` is not provided, and auth is required, an `UnauthorizedError` will be thrown.\n   *\n   * `UnauthorizedError` might also be thrown when sending any message over the SSE transport, indicating that the session has expired, and needs to be re-authed and reconnected.\n   */\n  authProvider?: OAuthClientProvider;\n\n  /**\n   * Customizes the initial SSE request to the server (the request that begins the stream).\n   *\n   * NOTE: Setting this property will prevent an `Authorization` header from\n   * being automatically attached to the SSE request, if an `authProvider` is\n   * also given. This can be worked around by setting the `Authorization` header\n   * manually.\n   */\n  eventSourceInit?: EventSourceInit;\n\n  /**\n   * Customizes recurring POST requests to the server.\n   */\n  requestInit?: RequestInit;\n\n  /**\n   * Custom fetch implementation used for all network requests.\n   */\n  fetch?: FetchLike;\n};\n\n/**\n * Client transport for SSE: this will connect to a server using Server-Sent Events for receiving\n * messages and make separate POST requests for sending messages.\n */\nexport class SSEClientTransport implements Transport {\n  private _eventSource?: EventSource;\n  private _endpoint?: URL;\n  private _abortController?: AbortController;\n  private _url: URL;\n  private _resourceMetadataUrl?: URL;\n  private _eventSourceInit?: EventSourceInit;\n  private _requestInit?: RequestInit;\n  private _authProvider?: OAuthClientProvider;\n  private _fetch?: FetchLike;\n  private _protocolVersion?: string;\n\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: JSONRPCMessage) =\u003E void;\n\n  constructor(\n    url: URL,\n    opts?: SSEClientTransportOptions,\n  ) {\n    this._url = url;\n    this._resourceMetadataUrl = undefined;\n    this._eventSourceInit = opts?.eventSourceInit;\n    this._requestInit = opts?.requestInit;\n    this._authProvider = opts?.authProvider;\n    this._fetch = opts?.fetch;\n  }\n\n  private async _authThenStart(): Promise\u003Cvoid\u003E {\n    if (!this._authProvider) {\n      throw new UnauthorizedError(\"No auth provider\");\n    }\n\n    let result: AuthResult;\n    try {\n      result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n\n    if (result !== \"AUTHORIZED\") {\n      throw new UnauthorizedError();\n    }\n\n    return await this._startOrAuth();\n  }\n\n  private async _commonHeaders(): Promise\u003CHeaders\u003E {\n    const headers: HeadersInit = {};\n    if (this._authProvider) {\n      const tokens = await this._authProvider.tokens();\n      if (tokens) {\n        headers[\"Authorization\"] = `Bearer ${tokens.access_token}`;\n      }\n    }\n    if (this._protocolVersion) {\n      headers[\"mcp-protocol-version\"] = this._protocolVersion;\n    }\n\n    return new Headers(\n      { ...headers, ...this._requestInit?.headers }\n    );\n  }\n\n  private _startOrAuth(): Promise\u003Cvoid\u003E {\n    const fetchImpl = (this?._eventSourceInit?.fetch ?? this._fetch ?? fetch) as typeof fetch\n    return new Promise((resolve, reject) =\u003E {\n      this._eventSource = new EventSource(\n        this._url.href,\n        {\n          ...this._eventSourceInit,\n          fetch: async (url, init) =\u003E {\n            const headers = await this._commonHeaders();\n            headers.set(\"Accept\", \"text/event-stream\");\n            const response = await fetchImpl(url, {\n              ...init,\n              headers,\n            })\n\n            if (response.status === 401 && response.headers.has('www-authenticate')) {\n              this._resourceMetadataUrl = extractResourceMetadataUrl(response);\n            }\n\n            return response\n          },\n        },\n      );\n      this._abortController = new AbortController();\n\n      this._eventSource.onerror = (event) =\u003E {\n        if (event.code === 401 && this._authProvider) {\n\n          this._authThenStart().then(resolve, reject);\n          return;\n        }\n\n        const error = new SseError(event.code, event.message, event);\n        reject(error);\n        this.onerror?.(error);\n      };\n\n      this._eventSource.onopen = () =\u003E {\n        // The connection is open, but we need to wait for the endpoint to be received.\n      };\n\n      this._eventSource.addEventListener(\"endpoint\", (event: Event) =\u003E {\n        const messageEvent = event as MessageEvent;\n\n        try {\n          this._endpoint = new URL(messageEvent.data, this._url);\n          if (this._endpoint.origin !== this._url.origin) {\n            throw new Error(\n              `Endpoint origin does not match connection origin: ${this._endpoint.origin}`,\n            );\n          }\n        } catch (error) {\n          reject(error);\n          this.onerror?.(error as Error);\n\n          void this.close();\n          return;\n        }\n\n        resolve();\n      });\n\n      this._eventSource.onmessage = (event: Event) =\u003E {\n        const messageEvent = event as MessageEvent;\n        let message: JSONRPCMessage;\n        try {\n          message = JSONRPCMessageSchema.parse(JSON.parse(messageEvent.data));\n        } catch (error) {\n          this.onerror?.(error as Error);\n          return;\n        }\n\n        this.onmessage?.(message);\n      };\n    });\n  }\n\n  async start() {\n    if (this._eventSource) {\n      throw new Error(\n        \"SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.\",\n      );\n    }\n\n    return await this._startOrAuth();\n  }\n\n  /**\n   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.\n   */\n  async finishAuth(authorizationCode: string): Promise\u003Cvoid\u003E {\n    if (!this._authProvider) {\n      throw new UnauthorizedError(\"No auth provider\");\n    }\n\n    const result = await auth(this._authProvider, { serverUrl: this._url, authorizationCode, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });\n    if (result !== \"AUTHORIZED\") {\n      throw new UnauthorizedError(\"Failed to authorize\");\n    }\n  }\n\n  async close(): Promise\u003Cvoid\u003E {\n    this._abortController?.abort();\n    this._eventSource?.close();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise\u003Cvoid\u003E {\n    if (!this._endpoint) {\n      throw new Error(\"Not connected\");\n    }\n\n    try {\n      const headers = await this._commonHeaders();\n      headers.set(\"content-type\", \"application/json\");\n      const init = {\n        ...this._requestInit,\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(message),\n        signal: this._abortController?.signal,\n      };\n\n      const response = await (this._fetch ?? fetch)(this._endpoint, init);\n      if (!response.ok) {\n        if (response.status === 401 && this._authProvider) {\n\n          this._resourceMetadataUrl = extractResourceMetadataUrl(response);\n\n          const result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });\n          if (result !== \"AUTHORIZED\") {\n            throw new UnauthorizedError();\n          }\n\n          // Purposely _not_ awaited, so we don't call onerror twice\n          return this.send(message);\n        }\n\n        const text = await response.text().catch(() =\u003E null);\n        throw new Error(\n          `Error POSTing to endpoint (HTTP ${response.status}): ${text}`,\n        );\n      }\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  setProtocolVersion(version: string): void {\n    this._protocolVersion = version;\n  }\n}\n",
      "hash": "42310608d4532411d30410c3e5fa6658092f9dc6ba9e80909d48918a34fc4dda",
      "size": 9138
    },
    "/src/client/stdio.test.ts": {
      "type": "content",
      "content": "import { JSONRPCMessage } from \"../types.js\";\nimport { StdioClientTransport, StdioServerParameters } from \"./stdio.js\";\n\n// Configure default server parameters based on OS\n// Uses 'more' command for Windows and 'tee' command for Unix/Linux\nconst getDefaultServerParameters = (): StdioServerParameters =\u003E {\n  if (process.platform === \"win32\") {\n    return { command: \"more\" };\n  }\n  return { command: \"/usr/bin/tee\" };\n};\n\nconst serverParameters = getDefaultServerParameters();\n\ntest(\"should start then close cleanly\", async () =\u003E {\n  const client = new StdioClientTransport(serverParameters);\n  client.onerror = (error) =\u003E {\n    throw error;\n  };\n\n  let didClose = false;\n  client.onclose = () =\u003E {\n    didClose = true;\n  };\n\n  await client.start();\n  expect(didClose).toBeFalsy();\n  await client.close();\n  expect(didClose).toBeTruthy();\n});\n\ntest(\"should read messages\", async () =\u003E {\n  const client = new StdioClientTransport(serverParameters);\n  client.onerror = (error) =\u003E {\n    throw error;\n  };\n\n  const messages: JSONRPCMessage[] = [\n    {\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"ping\",\n    },\n    {\n      jsonrpc: \"2.0\",\n      method: \"notifications/initialized\",\n    },\n  ];\n\n  const readMessages: JSONRPCMessage[] = [];\n  const finished = new Promise\u003Cvoid\u003E((resolve) =\u003E {\n    client.onmessage = (message) =\u003E {\n      readMessages.push(message);\n\n      if (JSON.stringify(message) === JSON.stringify(messages[1])) {\n        resolve();\n      }\n    };\n  });\n\n  await client.start();\n  await client.send(messages[0]);\n  await client.send(messages[1]);\n  await finished;\n  expect(readMessages).toEqual(messages);\n\n  await client.close();\n});\n\ntest(\"should return child process pid\", async () =\u003E {\n  const client = new StdioClientTransport(serverParameters);\n\n  await client.start();\n  expect(client.pid).not.toBeNull();\n  await client.close();\n  expect(client.pid).toBeNull();\n});\n",
      "hash": "9319953f34a0b6db756657a755475d8926cc598917ea4df4f71d627489fced2f",
      "size": 1896
    },
    "/src/client/stdio.ts": {
      "type": "content",
      "content": "import { ChildProcess, IOType } from \"node:child_process\";\nimport spawn from \"cross-spawn\";\nimport process from \"node:process\";\nimport { Stream, PassThrough } from \"node:stream\";\nimport { ReadBuffer, serializeMessage } from \"../shared/stdio.js\";\nimport { Transport } from \"../shared/transport.js\";\nimport { JSONRPCMessage } from \"../types.js\";\n\nexport type StdioServerParameters = {\n  /**\n   * The executable to run to start the server.\n   */\n  command: string;\n\n  /**\n   * Command line arguments to pass to the executable.\n   */\n  args?: string[];\n\n  /**\n   * The environment to use when spawning the process.\n   *\n   * If not specified, the result of getDefaultEnvironment() will be used.\n   */\n  env?: Record\u003Cstring, string\u003E;\n\n  /**\n   * How to handle stderr of the child process. This matches the semantics of Node's `child_process.spawn`.\n   *\n   * The default is \"inherit\", meaning messages to stderr will be printed to the parent process's stderr.\n   */\n  stderr?: IOType | Stream | number;\n\n  /**\n   * The working directory to use when spawning the process.\n   *\n   * If not specified, the current working directory will be inherited.\n   */\n  cwd?: string;\n};\n\n/**\n * Environment variables to inherit by default, if an environment is not explicitly given.\n */\nexport const DEFAULT_INHERITED_ENV_VARS =\n  process.platform === \"win32\"\n    ? [\n        \"APPDATA\",\n        \"HOMEDRIVE\",\n        \"HOMEPATH\",\n        \"LOCALAPPDATA\",\n        \"PATH\",\n        \"PROCESSOR_ARCHITECTURE\",\n        \"SYSTEMDRIVE\",\n        \"SYSTEMROOT\",\n        \"TEMP\",\n        \"USERNAME\",\n        \"USERPROFILE\",\n        \"PROGRAMFILES\",\n      ]\n    : /* list inspired by the default env inheritance of sudo */\n      [\"HOME\", \"LOGNAME\", \"PATH\", \"SHELL\", \"TERM\", \"USER\"];\n\n/**\n * Returns a default environment object including only environment variables deemed safe to inherit.\n */\nexport function getDefaultEnvironment(): Record\u003Cstring, string\u003E {\n  const env: Record\u003Cstring, string\u003E = {};\n\n  for (const key of DEFAULT_INHERITED_ENV_VARS) {\n    const value = process.env[key];\n    if (value === undefined) {\n      continue;\n    }\n\n    if (value.startsWith(\"()\")) {\n      // Skip functions, which are a security risk.\n      continue;\n    }\n\n    env[key] = value;\n  }\n\n  return env;\n}\n\n/**\n * Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.\n *\n * This transport is only available in Node.js environments.\n */\nexport class StdioClientTransport implements Transport {\n  private _process?: ChildProcess;\n  private _abortController: AbortController = new AbortController();\n  private _readBuffer: ReadBuffer = new ReadBuffer();\n  private _serverParams: StdioServerParameters;\n  private _stderrStream: PassThrough | null = null;\n\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: JSONRPCMessage) =\u003E void;\n\n  constructor(server: StdioServerParameters) {\n    this._serverParams = server;\n    if (server.stderr === \"pipe\" || server.stderr === \"overlapped\") {\n      this._stderrStream = new PassThrough();\n    }\n  }\n\n  /**\n   * Starts the server process and prepares to communicate with it.\n   */\n  async start(): Promise\u003Cvoid\u003E {\n    if (this._process) {\n      throw new Error(\n        \"StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.\"\n      );\n    }\n\n    return new Promise((resolve, reject) =\u003E {\n      this._process = spawn(\n        this._serverParams.command,\n        this._serverParams.args ?? [],\n        {\n          // merge default env with server env because mcp server needs some env vars\n          env: {\n            ...getDefaultEnvironment(),\n            ...this._serverParams.env,\n          },\n          stdio: [\"pipe\", \"pipe\", this._serverParams.stderr ?? \"inherit\"],\n          shell: false,\n          signal: this._abortController.signal,\n          windowsHide: process.platform === \"win32\" && isElectron(),\n          cwd: this._serverParams.cwd,\n        }\n      );\n\n      this._process.on(\"error\", (error) =\u003E {\n        if (error.name === \"AbortError\") {\n          // Expected when close() is called.\n          this.onclose?.();\n          return;\n        }\n\n        reject(error);\n        this.onerror?.(error);\n      });\n\n      this._process.on(\"spawn\", () =\u003E {\n        resolve();\n      });\n\n      this._process.on(\"close\", (_code) =\u003E {\n        this._process = undefined;\n        this.onclose?.();\n      });\n\n      this._process.stdin?.on(\"error\", (error) =\u003E {\n        this.onerror?.(error);\n      });\n\n      this._process.stdout?.on(\"data\", (chunk) =\u003E {\n        this._readBuffer.append(chunk);\n        this.processReadBuffer();\n      });\n\n      this._process.stdout?.on(\"error\", (error) =\u003E {\n        this.onerror?.(error);\n      });\n\n      if (this._stderrStream && this._process.stderr) {\n        this._process.stderr.pipe(this._stderrStream);\n      }\n    });\n  }\n\n  /**\n   * The stderr stream of the child process, if `StdioServerParameters.stderr` was set to \"pipe\" or \"overlapped\".\n   *\n   * If stderr piping was requested, a PassThrough stream is returned _immediately_, allowing callers to\n   * attach listeners before the start method is invoked. This prevents loss of any early\n   * error output emitted by the child process.\n   */\n  get stderr(): Stream | null {\n    if (this._stderrStream) {\n      return this._stderrStream;\n    }\n\n    return this._process?.stderr ?? null;\n  }\n\n  /**\n   * The child process pid spawned by this transport.\n   *\n   * This is only available after the transport has been started.\n   */\n  get pid(): number | null {\n    return this._process?.pid ?? null;\n  }\n\n  private processReadBuffer() {\n    while (true) {\n      try {\n        const message = this._readBuffer.readMessage();\n        if (message === null) {\n          break;\n        }\n\n        this.onmessage?.(message);\n      } catch (error) {\n        this.onerror?.(error as Error);\n      }\n    }\n  }\n\n  async close(): Promise\u003Cvoid\u003E {\n    this._abortController.abort();\n    this._process = undefined;\n    this._readBuffer.clear();\n  }\n\n  send(message: JSONRPCMessage): Promise\u003Cvoid\u003E {\n    return new Promise((resolve) =\u003E {\n      if (!this._process?.stdin) {\n        throw new Error(\"Not connected\");\n      }\n\n      const json = serializeMessage(message);\n      if (this._process.stdin.write(json)) {\n        resolve();\n      } else {\n        this._process.stdin.once(\"drain\", resolve);\n      }\n    });\n  }\n}\n\nfunction isElectron() {\n  return \"type\" in process;\n}\n",
      "hash": "65a5a4a455306309ee9cfc17d7da926887e066403cf12b4fdab47bc4b8a5be78",
      "size": 6508
    },
    "/src/client/streamableHttp.test.ts": {
      "type": "content",
      "content": "import { StartSSEOptions, StreamableHTTPClientTransport, StreamableHTTPReconnectionOptions } from \"./streamableHttp.js\";\nimport { OAuthClientProvider, UnauthorizedError } from \"./auth.js\";\nimport { JSONRPCMessage, JSONRPCRequest } from \"../types.js\";\nimport { InvalidClientError, InvalidGrantError, UnauthorizedClientError } from \"../server/auth/errors.js\";\n\n\ndescribe(\"StreamableHTTPClientTransport\", () =\u003E {\n  let transport: StreamableHTTPClientTransport;\n  let mockAuthProvider: jest.Mocked\u003COAuthClientProvider\u003E;\n\n  beforeEach(() =\u003E {\n    mockAuthProvider = {\n      get redirectUrl() { return \"http://localhost/callback\"; },\n      get clientMetadata() { return { redirect_uris: [\"http://localhost/callback\"] }; },\n      clientInformation: jest.fn(() =\u003E ({ client_id: \"test-client-id\", client_secret: \"test-client-secret\" })),\n      tokens: jest.fn(),\n      saveTokens: jest.fn(),\n      redirectToAuthorization: jest.fn(),\n      saveCodeVerifier: jest.fn(),\n      codeVerifier: jest.fn(),\n      invalidateCredentials: jest.fn(),\n    };\n    transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), { authProvider: mockAuthProvider });\n    jest.spyOn(global, \"fetch\");\n  });\n\n  afterEach(async () =\u003E {\n    await transport.close().catch(() =\u003E { });\n    jest.clearAllMocks();\n  });\n\n  it(\"should send JSON-RPC messages via POST\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      params: {},\n      id: \"test-id\"\n    };\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 202,\n      headers: new Headers(),\n    });\n\n    await transport.send(message);\n\n    expect(global.fetch).toHaveBeenCalledWith(\n      expect.anything(),\n      expect.objectContaining({\n        method: \"POST\",\n        headers: expect.any(Headers),\n        body: JSON.stringify(message)\n      })\n    );\n  });\n\n  it(\"should send batch messages\", async () =\u003E {\n    const messages: JSONRPCMessage[] = [\n      { jsonrpc: \"2.0\", method: \"test1\", params: {}, id: \"id1\" },\n      { jsonrpc: \"2.0\", method: \"test2\", params: {}, id: \"id2\" }\n    ];\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      headers: new Headers({ \"content-type\": \"text/event-stream\" }),\n      body: null\n    });\n\n    await transport.send(messages);\n\n    expect(global.fetch).toHaveBeenCalledWith(\n      expect.anything(),\n      expect.objectContaining({\n        method: \"POST\",\n        headers: expect.any(Headers),\n        body: JSON.stringify(messages)\n      })\n    );\n  });\n\n  it(\"should store session ID received during initialization\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"initialize\",\n      params: {\n        clientInfo: { name: \"test-client\", version: \"1.0\" },\n        protocolVersion: \"2025-03-26\"\n      },\n      id: \"init-id\"\n    };\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      headers: new Headers({ \"content-type\": \"text/event-stream\", \"mcp-session-id\": \"test-session-id\" }),\n    });\n\n    await transport.send(message);\n\n    // Send a second message that should include the session ID\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 202,\n      headers: new Headers()\n    });\n\n    await transport.send({ jsonrpc: \"2.0\", method: \"test\", params: {} } as JSONRPCMessage);\n\n    // Check that second request included session ID header\n    const calls = (global.fetch as jest.Mock).mock.calls;\n    const lastCall = calls[calls.length - 1];\n    expect(lastCall[1].headers).toBeDefined();\n    expect(lastCall[1].headers.get(\"mcp-session-id\")).toBe(\"test-session-id\");\n  });\n\n  it(\"should terminate session with DELETE request\", async () =\u003E {\n    // First, simulate getting a session ID\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"initialize\",\n      params: {\n        clientInfo: { name: \"test-client\", version: \"1.0\" },\n        protocolVersion: \"2025-03-26\"\n      },\n      id: \"init-id\"\n    };\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      headers: new Headers({ \"content-type\": \"text/event-stream\", \"mcp-session-id\": \"test-session-id\" }),\n    });\n\n    await transport.send(message);\n    expect(transport.sessionId).toBe(\"test-session-id\");\n\n    // Now terminate the session\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      headers: new Headers()\n    });\n\n    await transport.terminateSession();\n\n    // Verify the DELETE request was sent with the session ID\n    const calls = (global.fetch as jest.Mock).mock.calls;\n    const lastCall = calls[calls.length - 1];\n    expect(lastCall[1].method).toBe(\"DELETE\");\n    expect(lastCall[1].headers.get(\"mcp-session-id\")).toBe(\"test-session-id\");\n\n    // The session ID should be cleared after successful termination\n    expect(transport.sessionId).toBeUndefined();\n  });\n\n  it(\"should handle 405 response when server doesn't support session termination\", async () =\u003E {\n    // First, simulate getting a session ID\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"initialize\",\n      params: {\n        clientInfo: { name: \"test-client\", version: \"1.0\" },\n        protocolVersion: \"2025-03-26\"\n      },\n      id: \"init-id\"\n    };\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      headers: new Headers({ \"content-type\": \"text/event-stream\", \"mcp-session-id\": \"test-session-id\" }),\n    });\n\n    await transport.send(message);\n\n    // Now terminate the session, but server responds with 405\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: false,\n      status: 405,\n      statusText: \"Method Not Allowed\",\n      headers: new Headers()\n    });\n\n    await expect(transport.terminateSession()).resolves.not.toThrow();\n  });\n\n  it(\"should handle 404 response when session expires\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      params: {},\n      id: \"test-id\"\n    };\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: false,\n      status: 404,\n      statusText: \"Not Found\",\n      text: () =\u003E Promise.resolve(\"Session not found\"),\n      headers: new Headers()\n    });\n\n    const errorSpy = jest.fn();\n    transport.onerror = errorSpy;\n\n    await expect(transport.send(message)).rejects.toThrow(\"Error POSTing to endpoint (HTTP 404)\");\n    expect(errorSpy).toHaveBeenCalled();\n  });\n\n  it(\"should handle non-streaming JSON response\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      params: {},\n      id: \"test-id\"\n    };\n\n    const responseMessage: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      result: { success: true },\n      id: \"test-id\"\n    };\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      headers: new Headers({ \"content-type\": \"application/json\" }),\n      json: () =\u003E Promise.resolve(responseMessage)\n    });\n\n    const messageSpy = jest.fn();\n    transport.onmessage = messageSpy;\n\n    await transport.send(message);\n\n    expect(messageSpy).toHaveBeenCalledWith(responseMessage);\n  });\n\n  it(\"should attempt initial GET connection and handle 405 gracefully\", async () =\u003E {\n    // Mock the server not supporting GET for SSE (returning 405)\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: false,\n      status: 405,\n      statusText: \"Method Not Allowed\"\n    });\n\n    // We expect the 405 error to be caught and handled gracefully\n    // This should not throw an error that breaks the transport\n    await transport.start();\n    await expect(transport[\"_startOrAuthSse\"]({})).resolves.not.toThrow(\"Failed to open SSE stream: Method Not Allowed\");\n    // Check that GET was attempted\n    expect(global.fetch).toHaveBeenCalledWith(\n      expect.anything(),\n      expect.objectContaining({\n        method: \"GET\",\n        headers: expect.any(Headers)\n      })\n    );\n\n    // Verify transport still works after 405\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 202,\n      headers: new Headers()\n    });\n\n    await transport.send({ jsonrpc: \"2.0\", method: \"test\", params: {} } as JSONRPCMessage);\n    expect(global.fetch).toHaveBeenCalledTimes(2);\n  });\n\n  it(\"should handle successful initial GET connection for SSE\", async () =\u003E {\n    // Set up readable stream for SSE events\n    const encoder = new TextEncoder();\n    const stream = new ReadableStream({\n      start(controller) {\n        // Send a server notification via SSE\n        const event = \"event: message\\ndata: {\\\"jsonrpc\\\": \\\"2.0\\\", \\\"method\\\": \\\"serverNotification\\\", \\\"params\\\": {}}\\n\\n\";\n        controller.enqueue(encoder.encode(event));\n      }\n    });\n\n    // Mock successful GET connection\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      headers: new Headers({ \"content-type\": \"text/event-stream\" }),\n      body: stream\n    });\n\n    const messageSpy = jest.fn();\n    transport.onmessage = messageSpy;\n\n    await transport.start();\n    await transport[\"_startOrAuthSse\"]({});\n\n    // Give time for the SSE event to be processed\n    await new Promise(resolve =\u003E setTimeout(resolve, 50));\n\n    expect(messageSpy).toHaveBeenCalledWith(\n      expect.objectContaining({\n        jsonrpc: \"2.0\",\n        method: \"serverNotification\",\n        params: {}\n      })\n    );\n  });\n\n  it(\"should handle multiple concurrent SSE streams\", async () =\u003E {\n    // Mock two POST requests that return SSE streams\n    const makeStream = (id: string) =\u003E {\n      const encoder = new TextEncoder();\n      return new ReadableStream({\n        start(controller) {\n          const event = `event: message\\ndata: {\"jsonrpc\": \"2.0\", \"result\": {\"id\": \"${id}\"}, \"id\": \"${id}\"}\\n\\n`;\n          controller.enqueue(encoder.encode(event));\n        }\n      });\n    };\n\n    (global.fetch as jest.Mock)\n      .mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        headers: new Headers({ \"content-type\": \"text/event-stream\" }),\n        body: makeStream(\"request1\")\n      })\n      .mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        headers: new Headers({ \"content-type\": \"text/event-stream\" }),\n        body: makeStream(\"request2\")\n      });\n\n    const messageSpy = jest.fn();\n    transport.onmessage = messageSpy;\n\n    // Send two concurrent requests\n    await Promise.all([\n      transport.send({ jsonrpc: \"2.0\", method: \"test1\", params: {}, id: \"request1\" }),\n      transport.send({ jsonrpc: \"2.0\", method: \"test2\", params: {}, id: \"request2\" })\n    ]);\n\n    // Give time for SSE processing\n    await new Promise(resolve =\u003E setTimeout(resolve, 100));\n\n    // Both streams should have delivered their messages\n    expect(messageSpy).toHaveBeenCalledTimes(2);\n\n    // Verify received messages without assuming specific order\n    expect(messageSpy.mock.calls.some(call =\u003E {\n      const msg = call[0];\n      return msg.id === \"request1\" && msg.result?.id === \"request1\";\n    })).toBe(true);\n\n    expect(messageSpy.mock.calls.some(call =\u003E {\n      const msg = call[0];\n      return msg.id === \"request2\" && msg.result?.id === \"request2\";\n    })).toBe(true);\n  });\n\n  it(\"should support custom reconnection options\", () =\u003E {\n    // Create a transport with custom reconnection options\n    transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n      reconnectionOptions: {\n        initialReconnectionDelay: 500,\n        maxReconnectionDelay: 10000,\n        reconnectionDelayGrowFactor: 2,\n        maxRetries: 5,\n      }\n    });\n\n    // Verify options were set correctly (checking implementation details)\n    // Access private properties for testing\n    const transportInstance = transport as unknown as {\n      _reconnectionOptions: StreamableHTTPReconnectionOptions;\n    };\n    expect(transportInstance._reconnectionOptions.initialReconnectionDelay).toBe(500);\n    expect(transportInstance._reconnectionOptions.maxRetries).toBe(5);\n  });\n\n  it(\"should pass lastEventId when reconnecting\", async () =\u003E {\n    // Create a fresh transport\n    transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"));\n\n    // Mock fetch to verify headers sent\n    const fetchSpy = global.fetch as jest.Mock;\n    fetchSpy.mockReset();\n    fetchSpy.mockResolvedValue({\n      ok: true,\n      status: 200,\n      headers: new Headers({ \"content-type\": \"text/event-stream\" }),\n      body: new ReadableStream()\n    });\n\n    // Call the reconnect method directly with a lastEventId\n    await transport.start();\n    // Type assertion to access private method\n    const transportWithPrivateMethods = transport as unknown as {\n      _startOrAuthSse: (options: { resumptionToken?: string }) =\u003E Promise\u003Cvoid\u003E\n    };\n    await transportWithPrivateMethods._startOrAuthSse({ resumptionToken: \"test-event-id\" });\n\n    // Verify fetch was called with the lastEventId header\n    expect(fetchSpy).toHaveBeenCalled();\n    const fetchCall = fetchSpy.mock.calls[0];\n    const headers = fetchCall[1].headers;\n    expect(headers.get(\"last-event-id\")).toBe(\"test-event-id\");\n  });\n\n  it(\"should throw error when invalid content-type is received\", async () =\u003E {\n    // Clear any previous state from other tests\n    jest.clearAllMocks();\n\n    // Create a fresh transport instance\n    transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"));\n\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      params: {},\n      id: \"test-id\"\n    };\n\n    const stream = new ReadableStream({\n      start(controller) {\n        controller.enqueue(new TextEncoder().encode(\"invalid text response\"));\n        controller.close();\n      }\n    });\n\n    const errorSpy = jest.fn();\n    transport.onerror = errorSpy;\n\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      status: 200,\n      headers: new Headers({ \"content-type\": \"text/plain\" }),\n      body: stream\n    });\n\n    await transport.start();\n    await expect(transport.send(message)).rejects.toThrow(\"Unexpected content type: text/plain\");\n    expect(errorSpy).toHaveBeenCalled();\n  });\n\n  it(\"uses custom fetch implementation if provided\", async () =\u003E {\n    // Create custom fetch\n    const customFetch = jest.fn()\n      .mockResolvedValueOnce(\n        new Response(null, { status: 200, headers: { \"content-type\": \"text/event-stream\" } })\n      )\n      .mockResolvedValueOnce(new Response(null, { status: 202 }));\n\n    // Create transport instance\n    transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n      fetch: customFetch\n    });\n\n    await transport.start();\n    await (transport as unknown as { _startOrAuthSse: (opts: StartSSEOptions) =\u003E Promise\u003Cvoid\u003E })._startOrAuthSse({});\n\n    await transport.send({ jsonrpc: \"2.0\", method: \"test\", params: {}, id: \"1\" } as JSONRPCMessage);\n\n    // Verify custom fetch was used\n    expect(customFetch).toHaveBeenCalled();\n\n    // Global fetch should never have been called\n    expect(global.fetch).not.toHaveBeenCalled();\n  });\n\n  it(\"should always send specified custom headers\", async () =\u003E {\n    const requestInit = {\n      headers: {\n        \"X-Custom-Header\": \"CustomValue\"\n      }\n    };\n    transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n      requestInit: requestInit\n    });\n\n    let actualReqInit: RequestInit = {};\n\n    ((global.fetch as jest.Mock)).mockImplementation(\n      async (_url, reqInit) =\u003E {\n        actualReqInit = reqInit;\n        return new Response(null, { status: 200, headers: { \"content-type\": \"text/event-stream\" } });\n      }\n    );\n\n    await transport.start();\n\n    await transport[\"_startOrAuthSse\"]({});\n    expect((actualReqInit.headers as Headers).get(\"x-custom-header\")).toBe(\"CustomValue\");\n\n    requestInit.headers[\"X-Custom-Header\"] = \"SecondCustomValue\";\n\n    await transport.send({ jsonrpc: \"2.0\", method: \"test\", params: {} } as JSONRPCMessage);\n    expect((actualReqInit.headers as Headers).get(\"x-custom-header\")).toBe(\"SecondCustomValue\");\n\n    expect(global.fetch).toHaveBeenCalledTimes(2);\n  });\n\n  it(\"should always send specified custom headers (Headers class)\", async () =\u003E {\n    const requestInit = {\n      headers: new Headers({\n        \"X-Custom-Header\": \"CustomValue\"\n      })\n    };\n    transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n      requestInit: requestInit\n    });\n\n    let actualReqInit: RequestInit = {};\n\n    ((global.fetch as jest.Mock)).mockImplementation(\n      async (_url, reqInit) =\u003E {\n        actualReqInit = reqInit;\n        return new Response(null, { status: 200, headers: { \"content-type\": \"text/event-stream\" } });\n      }\n    );\n\n    await transport.start();\n\n    await transport[\"_startOrAuthSse\"]({});\n    expect((actualReqInit.headers as Headers).get(\"x-custom-header\")).toBe(\"CustomValue\");\n\n    (requestInit.headers as Headers).set(\"X-Custom-Header\",\"SecondCustomValue\");\n\n    await transport.send({ jsonrpc: \"2.0\", method: \"test\", params: {} } as JSONRPCMessage);\n    expect((actualReqInit.headers as Headers).get(\"x-custom-header\")).toBe(\"SecondCustomValue\");\n\n    expect(global.fetch).toHaveBeenCalledTimes(2);\n  });\n\n  it(\"should have exponential backoff with configurable maxRetries\", () =\u003E {\n    // This test verifies the maxRetries and backoff calculation directly\n\n    // Create transport with specific options for testing\n    transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n      reconnectionOptions: {\n        initialReconnectionDelay: 100,\n        maxReconnectionDelay: 5000,\n        reconnectionDelayGrowFactor: 2,\n        maxRetries: 3,\n      }\n    });\n\n    // Get access to the internal implementation\n    const getDelay = transport[\"_getNextReconnectionDelay\"].bind(transport);\n\n    // First retry - should use initial delay\n    expect(getDelay(0)).toBe(100);\n\n    // Second retry - should double (2^1 * 100 = 200)\n    expect(getDelay(1)).toBe(200);\n\n    // Third retry - should double again (2^2 * 100 = 400)\n    expect(getDelay(2)).toBe(400);\n\n    // Fourth retry - should double again (2^3 * 100 = 800)\n    expect(getDelay(3)).toBe(800);\n\n    // Tenth retry - should be capped at maxReconnectionDelay\n    expect(getDelay(10)).toBe(5000);\n  });\n\n  it(\"attempts auth flow on 401 during POST request\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      params: {},\n      id: \"test-id\"\n    };\n\n    (global.fetch as jest.Mock)\n      .mockResolvedValueOnce({\n        ok: false,\n        status: 401,\n        statusText: \"Unauthorized\",\n        headers: new Headers()\n      })\n      .mockResolvedValue({\n        ok: false,\n        status: 404\n      });\n\n    await expect(transport.send(message)).rejects.toThrow(UnauthorizedError);\n    expect(mockAuthProvider.redirectToAuthorization.mock.calls).toHaveLength(1);\n  });\n\n  describe('Reconnection Logic', () =\u003E {\n    let transport: StreamableHTTPClientTransport;\n\n    // Use fake timers to control setTimeout and make the test instant.\n    beforeEach(() =\u003E jest.useFakeTimers());\n    afterEach(() =\u003E jest.useRealTimers());\n\n    it('should reconnect a GET-initiated notification stream that fails', async () =\u003E {\n      // ARRANGE\n      transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n        reconnectionOptions: {\n          initialReconnectionDelay: 10,\n          maxRetries: 1,\n          maxReconnectionDelay: 1000,  // Ensure it doesn't retry indefinitely\n          reconnectionDelayGrowFactor: 1  // No exponential backoff for simplicity\n         }\n      });\n\n      const errorSpy = jest.fn();\n      transport.onerror = errorSpy;\n\n      const failingStream = new ReadableStream({\n        start(controller) { controller.error(new Error(\"Network failure\")); }\n      });\n\n      const fetchMock = global.fetch as jest.Mock;\n      // Mock the initial GET request, which will fail.\n      fetchMock.mockResolvedValueOnce({\n        ok: true, status: 200,\n        headers: new Headers({ \"content-type\": \"text/event-stream\" }),\n        body: failingStream,\n      });\n      // Mock the reconnection GET request, which will succeed.\n      fetchMock.mockResolvedValueOnce({\n        ok: true, status: 200,\n        headers: new Headers({ \"content-type\": \"text/event-stream\" }),\n        body: new ReadableStream(),\n      });\n\n      // ACT\n      await transport.start();\n      // Trigger the GET stream directly using the internal method for a clean test.\n      await transport[\"_startOrAuthSse\"]({});\n      await jest.advanceTimersByTimeAsync(20); // Trigger reconnection timeout\n\n      // ASSERT\n      expect(errorSpy).toHaveBeenCalledWith(expect.objectContaining({\n        message: expect.stringContaining('SSE stream disconnected: Error: Network failure'),\n      }));\n      // THE KEY ASSERTION: A second fetch call proves reconnection was attempted.\n      expect(fetchMock).toHaveBeenCalledTimes(2);\n      expect(fetchMock.mock.calls[0][1]?.method).toBe('GET');\n      expect(fetchMock.mock.calls[1][1]?.method).toBe('GET');\n    });\n\n    it('should NOT reconnect a POST-initiated stream that fails', async () =\u003E {\n      // ARRANGE\n      transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n        reconnectionOptions: {\n          initialReconnectionDelay: 10,\n          maxRetries: 1,\n          maxReconnectionDelay: 1000,  // Ensure it doesn't retry indefinitely\n          reconnectionDelayGrowFactor: 1  // No exponential backoff for simplicity\n         }\n      });\n\n      const errorSpy = jest.fn();\n      transport.onerror = errorSpy;\n\n      const failingStream = new ReadableStream({\n        start(controller) { controller.error(new Error(\"Network failure\")); }\n      });\n\n      const fetchMock = global.fetch as jest.Mock;\n      // Mock the POST request. It returns a streaming content-type but a failing body.\n      fetchMock.mockResolvedValueOnce({\n        ok: true, status: 200,\n        headers: new Headers({ \"content-type\": \"text/event-stream\" }),\n        body: failingStream,\n      });\n\n      // A dummy request message to trigger the `send` logic.\n      const requestMessage: JSONRPCRequest = {\n        jsonrpc: '2.0',\n        method: 'long_running_tool',\n        id: 'request-1',\n        params: {},\n      };\n\n      // ACT\n      await transport.start();\n      // Use the public `send` method to initiate a POST that gets a stream response.\n      await transport.send(requestMessage);\n      await jest.advanceTimersByTimeAsync(20); // Advance time to check for reconnections\n\n      // ASSERT\n      expect(errorSpy).toHaveBeenCalledWith(expect.objectContaining({\n        message: expect.stringContaining('SSE stream disconnected: Error: Network failure'),\n      }));\n      // THE KEY ASSERTION: Fetch was only called ONCE. No reconnection was attempted.\n      expect(fetchMock).toHaveBeenCalledTimes(1);\n      expect(fetchMock.mock.calls[0][1]?.method).toBe('POST');\n    });\n  });\n\n  it(\"invalidates all credentials on InvalidClientError during auth\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      params: {},\n      id: \"test-id\"\n    };\n\n    mockAuthProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      refresh_token: \"test-refresh\"\n    });\n\n    const unauthedResponse = {\n      ok: false,\n      status: 401,\n      statusText: \"Unauthorized\",\n      headers: new Headers()\n    };\n    (global.fetch as jest.Mock)\n      // Initial connection\n      .mockResolvedValueOnce(unauthedResponse)\n      // Resource discovery, path aware\n      .mockResolvedValueOnce(unauthedResponse)\n      // Resource discovery, root\n      .mockResolvedValueOnce(unauthedResponse)\n      // OAuth metadata discovery\n      .mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          issuer: \"http://localhost:1234\",\n          authorization_endpoint: \"http://localhost:1234/authorize\",\n          token_endpoint: \"http://localhost:1234/token\",\n          response_types_supported: [\"code\"],\n          code_challenge_methods_supported: [\"S256\"],\n        }),\n      })\n      // Token refresh fails with InvalidClientError\n      .mockResolvedValueOnce(Response.json(\n        new InvalidClientError(\"Client authentication failed\").toResponseObject(),\n        { status: 400 }\n      ))\n      // Fallback should fail to complete the flow\n      .mockResolvedValue({\n        ok: false,\n        status: 404\n      });\n\n    await expect(transport.send(message)).rejects.toThrow(UnauthorizedError);\n    expect(mockAuthProvider.invalidateCredentials).toHaveBeenCalledWith('all');\n  });\n\n  it(\"invalidates all credentials on UnauthorizedClientError during auth\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      params: {},\n      id: \"test-id\"\n    };\n\n    mockAuthProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      refresh_token: \"test-refresh\"\n    });\n\n    const unauthedResponse = {\n      ok: false,\n      status: 401,\n      statusText: \"Unauthorized\",\n      headers: new Headers()\n    };\n    (global.fetch as jest.Mock)\n      // Initial connection\n      .mockResolvedValueOnce(unauthedResponse)\n      // Resource discovery, path aware\n      .mockResolvedValueOnce(unauthedResponse)\n      // Resource discovery, root\n      .mockResolvedValueOnce(unauthedResponse)\n      // OAuth metadata discovery\n      .mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          issuer: \"http://localhost:1234\",\n          authorization_endpoint: \"http://localhost:1234/authorize\",\n          token_endpoint: \"http://localhost:1234/token\",\n          response_types_supported: [\"code\"],\n          code_challenge_methods_supported: [\"S256\"],\n        }),\n      })\n      // Token refresh fails with UnauthorizedClientError\n      .mockResolvedValueOnce(Response.json(\n        new UnauthorizedClientError(\"Client not authorized\").toResponseObject(),\n        { status: 400 }\n      ))\n      // Fallback should fail to complete the flow\n      .mockResolvedValue({\n        ok: false,\n        status: 404\n      });\n\n    await expect(transport.send(message)).rejects.toThrow(UnauthorizedError);\n    expect(mockAuthProvider.invalidateCredentials).toHaveBeenCalledWith('all');\n  });\n\n  it(\"invalidates tokens on InvalidGrantError during auth\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      params: {},\n      id: \"test-id\"\n    };\n\n    mockAuthProvider.tokens.mockResolvedValue({\n      access_token: \"test-token\",\n      token_type: \"Bearer\",\n      refresh_token: \"test-refresh\"\n    });\n\n    const unauthedResponse = {\n      ok: false,\n      status: 401,\n      statusText: \"Unauthorized\",\n      headers: new Headers()\n    };\n    (global.fetch as jest.Mock)\n      // Initial connection\n      .mockResolvedValueOnce(unauthedResponse)\n      // Resource discovery, path aware\n      .mockResolvedValueOnce(unauthedResponse)\n      // Resource discovery, root\n      .mockResolvedValueOnce(unauthedResponse)\n      // OAuth metadata discovery\n      .mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () =\u003E ({\n          issuer: \"http://localhost:1234\",\n          authorization_endpoint: \"http://localhost:1234/authorize\",\n          token_endpoint: \"http://localhost:1234/token\",\n          response_types_supported: [\"code\"],\n          code_challenge_methods_supported: [\"S256\"],\n        }),\n      })\n      // Token refresh fails with InvalidGrantError\n      .mockResolvedValueOnce(Response.json(\n        new InvalidGrantError(\"Invalid refresh token\").toResponseObject(),\n        { status: 400 }\n      ))\n      // Fallback should fail to complete the flow\n      .mockResolvedValue({\n        ok: false,\n        status: 404\n      });\n\n    await expect(transport.send(message)).rejects.toThrow(UnauthorizedError);\n    expect(mockAuthProvider.invalidateCredentials).toHaveBeenCalledWith('tokens');\n  });\n\n  describe(\"custom fetch in auth code paths\", () =\u003E {\n    it(\"uses custom fetch during auth flow on 401 - no global fetch fallback\", async () =\u003E {\n      const unauthedResponse = {\n        ok: false,\n        status: 401,\n        statusText: \"Unauthorized\",\n        headers: new Headers()\n      };\n\n      // Create custom fetch\n      const customFetch = jest.fn()\n        // Initial connection\n        .mockResolvedValueOnce(unauthedResponse)\n        // Resource discovery\n        .mockResolvedValueOnce(unauthedResponse)\n        // OAuth metadata discovery\n        .mockResolvedValueOnce({\n          ok: true,\n          status: 200,\n          json: async () =\u003E ({\n            issuer: \"http://localhost:1234\",\n            authorization_endpoint: \"http://localhost:1234/authorize\",\n            token_endpoint: \"http://localhost:1234/token\",\n            response_types_supported: [\"code\"],\n            code_challenge_methods_supported: [\"S256\"],\n          }),\n        })\n        // Token refresh fails with InvalidClientError\n        .mockResolvedValueOnce(Response.json(\n          new InvalidClientError(\"Client authentication failed\").toResponseObject(),\n          { status: 400 }\n        ))\n        // Fallback should fail to complete the flow\n        .mockResolvedValue({\n          ok: false,\n          status: 404\n        });\n\n      // Create transport instance\n      transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n        authProvider: mockAuthProvider,\n        fetch: customFetch\n      });\n\n      // Attempt to start - should trigger auth flow and eventually fail with UnauthorizedError\n      await transport.start();\n      await expect((transport as unknown as { _startOrAuthSse: (opts: StartSSEOptions) =\u003E Promise\u003Cvoid\u003E })._startOrAuthSse({})).rejects.toThrow(UnauthorizedError);\n\n      // Verify custom fetch was used\n      expect(customFetch).toHaveBeenCalled();\n\n      // Verify specific OAuth endpoints were called with custom fetch\n      const customFetchCalls = customFetch.mock.calls;\n      const callUrls = customFetchCalls.map(([url]) =\u003E url.toString());\n\n      // Should have called resource metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-protected-resource'))).toBe(true);\n\n      // Should have called OAuth authorization server metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-authorization-server'))).toBe(true);\n\n      // Verify auth provider was called to redirect to authorization\n      expect(mockAuthProvider.redirectToAuthorization).toHaveBeenCalled();\n\n      // Global fetch should never have been called\n      expect(global.fetch).not.toHaveBeenCalled();\n    });\n\n    it(\"uses custom fetch in finishAuth method - no global fetch fallback\", async () =\u003E {\n      // Create custom fetch\n      const customFetch = jest.fn()\n        // Protected resource metadata discovery\n        .mockResolvedValueOnce({\n          ok: true,\n          status: 200,\n          json: async () =\u003E ({\n            authorization_servers: [\"http://localhost:1234\"],\n            resource: \"http://localhost:1234/mcp\"\n          }),\n        })\n        // OAuth metadata discovery\n        .mockResolvedValueOnce({\n          ok: true,\n          status: 200,\n          json: async () =\u003E ({\n            issuer: \"http://localhost:1234\",\n            authorization_endpoint: \"http://localhost:1234/authorize\",\n            token_endpoint: \"http://localhost:1234/token\",\n            response_types_supported: [\"code\"],\n            code_challenge_methods_supported: [\"S256\"],\n          }),\n        })\n        // Code exchange\n        .mockResolvedValueOnce({\n          ok: true,\n          status: 200,\n          json: async () =\u003E ({\n            access_token: \"new-access-token\",\n            refresh_token: \"new-refresh-token\",\n            token_type: \"Bearer\",\n            expires_in: 3600,\n          }),\n        });\n\n      // Create transport instance\n      transport = new StreamableHTTPClientTransport(new URL(\"http://localhost:1234/mcp\"), {\n        authProvider: mockAuthProvider,\n        fetch: customFetch\n      });\n\n      // Call finishAuth with authorization code\n      await transport.finishAuth(\"test-auth-code\");\n\n      // Verify custom fetch was used\n      expect(customFetch).toHaveBeenCalled();\n\n      // Verify specific OAuth endpoints were called with custom fetch\n      const customFetchCalls = customFetch.mock.calls;\n      const callUrls = customFetchCalls.map(([url]) =\u003E url.toString());\n\n      // Should have called resource metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-protected-resource'))).toBe(true);\n\n      // Should have called OAuth authorization server metadata discovery\n      expect(callUrls.some(url =\u003E url.includes('/.well-known/oauth-authorization-server'))).toBe(true);\n\n      // Should have called token endpoint for authorization code exchange\n      const tokenCalls = customFetchCalls.filter(([url, options]) =\u003E\n        url.toString().includes('/token') && options?.method === \"POST\"\n      );\n      expect(tokenCalls.length).toBeGreaterThan(0);\n\n      // Verify tokens were saved\n      expect(mockAuthProvider.saveTokens).toHaveBeenCalledWith({\n        access_token: \"new-access-token\",\n        token_type: \"Bearer\",\n        expires_in: 3600,\n        refresh_token: \"new-refresh-token\"\n      });\n\n      // Global fetch should never have been called\n      expect(global.fetch).not.toHaveBeenCalled();\n    });\n  });\n});\n",
      "hash": "1bb6d3eddc4bfea6d89f862d1a0b81c7672807e8c8d448ae71ce0f4f6b000ac8",
      "size": 33728
    },
    "/src/client/streamableHttp.ts": {
      "type": "content",
      "content": "import { Transport, FetchLike } from \"../shared/transport.js\";\nimport { isInitializedNotification, isJSONRPCRequest, isJSONRPCResponse, JSONRPCMessage, JSONRPCMessageSchema } from \"../types.js\";\nimport { auth, AuthResult, extractResourceMetadataUrl, OAuthClientProvider, UnauthorizedError } from \"./auth.js\";\nimport { EventSourceParserStream } from \"eventsource-parser/stream\";\n\n// Default reconnection options for StreamableHTTP connections\nconst DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS: StreamableHTTPReconnectionOptions = {\n  initialReconnectionDelay: 1000,\n  maxReconnectionDelay: 30000,\n  reconnectionDelayGrowFactor: 1.5,\n  maxRetries: 2,\n};\n\nexport class StreamableHTTPError extends Error {\n  constructor(\n    public readonly code: number | undefined,\n    message: string | undefined,\n  ) {\n    super(`Streamable HTTP error: ${message}`);\n  }\n}\n\n/**\n * Options for starting or authenticating an SSE connection\n */\nexport interface StartSSEOptions {\n  /**\n   * The resumption token used to continue long-running requests that were interrupted.\n   *\n   * This allows clients to reconnect and continue from where they left off.\n   */\n  resumptionToken?: string;\n\n  /**\n   * A callback that is invoked when the resumption token changes.\n   *\n   * This allows clients to persist the latest token for potential reconnection.\n   */\n  onresumptiontoken?: (token: string) =\u003E void;\n\n  /**\n  * Override Message ID to associate with the replay message\n  * so that response can be associate with the new resumed request.\n  */\n  replayMessageId?: string | number;\n}\n\n/**\n * Configuration options for reconnection behavior of the StreamableHTTPClientTransport.\n */\nexport interface StreamableHTTPReconnectionOptions {\n  /**\n   * Maximum backoff time between reconnection attempts in milliseconds.\n   * Default is 30000 (30 seconds).\n   */\n  maxReconnectionDelay: number;\n\n  /**\n   * Initial backoff time between reconnection attempts in milliseconds.\n   * Default is 1000 (1 second).\n   */\n  initialReconnectionDelay: number;\n\n  /**\n   * The factor by which the reconnection delay increases after each attempt.\n   * Default is 1.5.\n   */\n  reconnectionDelayGrowFactor: number;\n\n  /**\n   * Maximum number of reconnection attempts before giving up.\n   * Default is 2.\n   */\n  maxRetries: number;\n}\n\n/**\n * Configuration options for the `StreamableHTTPClientTransport`.\n */\nexport type StreamableHTTPClientTransportOptions = {\n  /**\n   * An OAuth client provider to use for authentication.\n   *\n   * When an `authProvider` is specified and the connection is started:\n   * 1. The connection is attempted with any existing access token from the `authProvider`.\n   * 2. If the access token has expired, the `authProvider` is used to refresh the token.\n   * 3. If token refresh fails or no access token exists, and auth is required, `OAuthClientProvider.redirectToAuthorization` is called, and an `UnauthorizedError` will be thrown from `connect`/`start`.\n   *\n   * After the user has finished authorizing via their user agent, and is redirected back to the MCP client application, call `StreamableHTTPClientTransport.finishAuth` with the authorization code before retrying the connection.\n   *\n   * If an `authProvider` is not provided, and auth is required, an `UnauthorizedError` will be thrown.\n   *\n   * `UnauthorizedError` might also be thrown when sending any message over the transport, indicating that the session has expired, and needs to be re-authed and reconnected.\n   */\n  authProvider?: OAuthClientProvider;\n\n  /**\n   * Customizes HTTP requests to the server.\n   */\n  requestInit?: RequestInit;\n\n  /**\n   * Custom fetch implementation used for all network requests.\n   */\n  fetch?: FetchLike;\n\n  /**\n   * Options to configure the reconnection behavior.\n   */\n  reconnectionOptions?: StreamableHTTPReconnectionOptions;\n\n  /**\n   * Session ID for the connection. This is used to identify the session on the server.\n   * When not provided and connecting to a server that supports session IDs, the server will generate a new session ID.\n   */\n  sessionId?: string;\n};\n\n/**\n * Client transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.\n * It will connect to a server using HTTP POST for sending messages and HTTP GET with Server-Sent Events\n * for receiving messages.\n */\nexport class StreamableHTTPClientTransport implements Transport {\n  private _abortController?: AbortController;\n  private _url: URL;\n  private _resourceMetadataUrl?: URL;\n  private _requestInit?: RequestInit;\n  private _authProvider?: OAuthClientProvider;\n  private _fetch?: FetchLike;\n  private _sessionId?: string;\n  private _reconnectionOptions: StreamableHTTPReconnectionOptions;\n  private _protocolVersion?: string;\n\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: JSONRPCMessage) =\u003E void;\n\n  constructor(\n    url: URL,\n    opts?: StreamableHTTPClientTransportOptions,\n  ) {\n    this._url = url;\n    this._resourceMetadataUrl = undefined;\n    this._requestInit = opts?.requestInit;\n    this._authProvider = opts?.authProvider;\n    this._fetch = opts?.fetch;\n    this._sessionId = opts?.sessionId;\n    this._reconnectionOptions = opts?.reconnectionOptions ?? DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;\n  }\n\n  private async _authThenStart(): Promise\u003Cvoid\u003E {\n    if (!this._authProvider) {\n      throw new UnauthorizedError(\"No auth provider\");\n    }\n\n    let result: AuthResult;\n    try {\n      result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n\n    if (result !== \"AUTHORIZED\") {\n      throw new UnauthorizedError();\n    }\n\n    return await this._startOrAuthSse({ resumptionToken: undefined });\n  }\n\n  private async _commonHeaders(): Promise\u003CHeaders\u003E {\n    const headers: HeadersInit & Record\u003Cstring, string\u003E = {};\n    if (this._authProvider) {\n      const tokens = await this._authProvider.tokens();\n      if (tokens) {\n        headers[\"Authorization\"] = `Bearer ${tokens.access_token}`;\n      }\n    }\n\n    if (this._sessionId) {\n      headers[\"mcp-session-id\"] = this._sessionId;\n    }\n    if (this._protocolVersion) {\n      headers[\"mcp-protocol-version\"] = this._protocolVersion;\n    }\n\n    const extraHeaders = this._normalizeHeaders(this._requestInit?.headers);\n\n    return new Headers({\n      ...headers,\n      ...extraHeaders,\n    });\n  }\n\n\n  private async _startOrAuthSse(options: StartSSEOptions): Promise\u003Cvoid\u003E {\n    const { resumptionToken } = options;\n    try {\n      // Try to open an initial SSE stream with GET to listen for server messages\n      // This is optional according to the spec - server may not support it\n      const headers = await this._commonHeaders();\n      headers.set(\"Accept\", \"text/event-stream\");\n\n      // Include Last-Event-ID header for resumable streams if provided\n      if (resumptionToken) {\n        headers.set(\"last-event-id\", resumptionToken);\n      }\n\n      const response = await (this._fetch ?? fetch)(this._url, {\n        method: \"GET\",\n        headers,\n        signal: this._abortController?.signal,\n      });\n\n      if (!response.ok) {\n        if (response.status === 401 && this._authProvider) {\n          // Need to authenticate\n          return await this._authThenStart();\n        }\n\n        // 405 indicates that the server does not offer an SSE stream at GET endpoint\n        // This is an expected case that should not trigger an error\n        if (response.status === 405) {\n          return;\n        }\n\n        throw new StreamableHTTPError(\n          response.status,\n          `Failed to open SSE stream: ${response.statusText}`,\n        );\n      }\n\n      this._handleSseStream(response.body, options, true);\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n\n  /**\n   * Calculates the next reconnection delay using  backoff algorithm\n   *\n   * @param attempt Current reconnection attempt count for the specific stream\n   * @returns Time to wait in milliseconds before next reconnection attempt\n   */\n  private _getNextReconnectionDelay(attempt: number): number {\n    // Access default values directly, ensuring they're never undefined\n    const initialDelay = this._reconnectionOptions.initialReconnectionDelay;\n    const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;\n    const maxDelay = this._reconnectionOptions.maxReconnectionDelay;\n\n    // Cap at maximum delay\n    return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);\n\n  }\n\n    private _normalizeHeaders(headers: HeadersInit | undefined): Record\u003Cstring, string\u003E {\n    if (!headers) return {};\n\n    if (headers instanceof Headers) {\n      return Object.fromEntries(headers.entries());\n    }\n\n    if (Array.isArray(headers)) {\n      return Object.fromEntries(headers);\n    }\n\n    return { ...headers as Record\u003Cstring, string\u003E };\n  }\n\n  /**\n   * Schedule a reconnection attempt with exponential backoff\n   *\n   * @param lastEventId The ID of the last received event for resumability\n   * @param attemptCount Current reconnection attempt count for this specific stream\n   */\n  private _scheduleReconnection(options: StartSSEOptions, attemptCount = 0): void {\n    // Use provided options or default options\n    const maxRetries = this._reconnectionOptions.maxRetries;\n\n    // Check if we've exceeded maximum retry attempts\n    if (maxRetries \u003E 0 && attemptCount \u003E= maxRetries) {\n      this.onerror?.(new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));\n      return;\n    }\n\n    // Calculate next delay based on current attempt count\n    const delay = this._getNextReconnectionDelay(attemptCount);\n\n    // Schedule the reconnection\n    setTimeout(() =\u003E {\n      // Use the last event ID to resume where we left off\n      this._startOrAuthSse(options).catch(error =\u003E {\n        this.onerror?.(new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));\n        // Schedule another attempt if this one failed, incrementing the attempt counter\n        this._scheduleReconnection(options, attemptCount + 1);\n      });\n    }, delay);\n  }\n\n  private _handleSseStream(\n    stream: ReadableStream\u003CUint8Array\u003E | null, \n    options: StartSSEOptions,\n    isReconnectable: boolean,\n  ): void {\n    if (!stream) {\n      return;\n    }\n    const { onresumptiontoken, replayMessageId } = options;\n\n    let lastEventId: string | undefined;\n    const processStream = async () =\u003E {\n      // this is the closest we can get to trying to catch network errors\n      // if something happens reader will throw\n      try {\n        // Create a pipeline: binary stream -\u003E text decoder -\u003E SSE parser\n        const reader = stream\n          .pipeThrough(new TextDecoderStream())\n          .pipeThrough(new EventSourceParserStream())\n          .getReader();\n\n\n        while (true) {\n          const { value: event, done } = await reader.read();\n          if (done) {\n            break;\n          }\n\n          // Update last event ID if provided\n          if (event.id) {\n            lastEventId = event.id;\n            onresumptiontoken?.(event.id);\n          }\n\n          if (!event.event || event.event === \"message\") {\n            try {\n              const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));\n              if (replayMessageId !== undefined && isJSONRPCResponse(message)) {\n                message.id = replayMessageId;\n              }\n              this.onmessage?.(message);\n            } catch (error) {\n              this.onerror?.(error as Error);\n            }\n          }\n        }\n      } catch (error) {\n        // Handle stream errors - likely a network disconnect\n        this.onerror?.(new Error(`SSE stream disconnected: ${error}`));\n\n        // Attempt to reconnect if the stream disconnects unexpectedly and we aren't closing\n        if (\n          isReconnectable && \n          this._abortController && \n          !this._abortController.signal.aborted\n        ) {\n          // Use the exponential backoff reconnection strategy\n          try {\n            this._scheduleReconnection({\n              resumptionToken: lastEventId,\n              onresumptiontoken,\n              replayMessageId\n            }, 0);\n          }\n          catch (error) {\n            this.onerror?.(new Error(`Failed to reconnect: ${error instanceof Error ? error.message : String(error)}`));\n\n          }\n        }\n      }\n    };\n    processStream();\n  }\n\n  async start() {\n    if (this._abortController) {\n      throw new Error(\n        \"StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.\",\n      );\n    }\n\n    this._abortController = new AbortController();\n  }\n\n  /**\n   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.\n   */\n  async finishAuth(authorizationCode: string): Promise\u003Cvoid\u003E {\n    if (!this._authProvider) {\n      throw new UnauthorizedError(\"No auth provider\");\n    }\n\n    const result = await auth(this._authProvider, { serverUrl: this._url, authorizationCode, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });\n    if (result !== \"AUTHORIZED\") {\n      throw new UnauthorizedError(\"Failed to authorize\");\n    }\n  }\n\n  async close(): Promise\u003Cvoid\u003E {\n    // Abort any pending requests\n    this._abortController?.abort();\n\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage | JSONRPCMessage[], options?: { resumptionToken?: string, onresumptiontoken?: (token: string) =\u003E void }): Promise\u003Cvoid\u003E {\n    try {\n      const { resumptionToken, onresumptiontoken } = options || {};\n\n      if (resumptionToken) {\n        // If we have at last event ID, we need to reconnect the SSE stream\n        this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : undefined }).catch(err =\u003E this.onerror?.(err));\n        return;\n      }\n\n      const headers = await this._commonHeaders();\n      headers.set(\"content-type\", \"application/json\");\n      headers.set(\"accept\", \"application/json, text/event-stream\");\n\n      const init = {\n        ...this._requestInit,\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(message),\n        signal: this._abortController?.signal,\n      };\n\n      const response = await (this._fetch ?? fetch)(this._url, init);\n\n      // Handle session ID received during initialization\n      const sessionId = response.headers.get(\"mcp-session-id\");\n      if (sessionId) {\n        this._sessionId = sessionId;\n      }\n\n      if (!response.ok) {\n        if (response.status === 401 && this._authProvider) {\n\n          this._resourceMetadataUrl = extractResourceMetadataUrl(response);\n\n          const result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl, fetchFn: this._fetch });\n          if (result !== \"AUTHORIZED\") {\n            throw new UnauthorizedError();\n          }\n\n          // Purposely _not_ awaited, so we don't call onerror twice\n          return this.send(message);\n        }\n\n        const text = await response.text().catch(() =\u003E null);\n        throw new Error(\n          `Error POSTing to endpoint (HTTP ${response.status}): ${text}`,\n        );\n      }\n\n      // If the response is 202 Accepted, there's no body to process\n      if (response.status === 202) {\n        // if the accepted notification is initialized, we start the SSE stream\n        // if it's supported by the server\n        if (isInitializedNotification(message)) {\n          // Start without a lastEventId since this is a fresh connection\n          this._startOrAuthSse({ resumptionToken: undefined }).catch(err =\u003E this.onerror?.(err));\n        }\n        return;\n      }\n\n      // Get original message(s) for detecting request IDs\n      const messages = Array.isArray(message) ? message : [message];\n\n      const hasRequests = messages.filter(msg =\u003E \"method\" in msg && \"id\" in msg && msg.id !== undefined).length \u003E 0;\n\n      // Check the response type\n      const contentType = response.headers.get(\"content-type\");\n\n      if (hasRequests) {\n        if (contentType?.includes(\"text/event-stream\")) {\n          // Handle SSE stream responses for requests\n          // We use the same handler as standalone streams, which now supports\n          // reconnection with the last event ID\n          this._handleSseStream(response.body, { onresumptiontoken }, false);\n        } else if (contentType?.includes(\"application/json\")) {\n          // For non-streaming servers, we might get direct JSON responses\n          const data = await response.json();\n          const responseMessages = Array.isArray(data)\n            ? data.map(msg =\u003E JSONRPCMessageSchema.parse(msg))\n            : [JSONRPCMessageSchema.parse(data)];\n\n          for (const msg of responseMessages) {\n            this.onmessage?.(msg);\n          }\n        } else {\n          throw new StreamableHTTPError(\n            -1,\n            `Unexpected content type: ${contentType}`,\n          );\n        }\n      }\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  get sessionId(): string | undefined {\n    return this._sessionId;\n  }\n\n  /**\n   * Terminates the current session by sending a DELETE request to the server.\n   *\n   * Clients that no longer need a particular session\n   * (e.g., because the user is leaving the client application) SHOULD send an\n   * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly\n   * terminate the session.\n   *\n   * The server MAY respond with HTTP 405 Method Not Allowed, indicating that\n   * the server does not allow clients to terminate sessions.\n   */\n  async terminateSession(): Promise\u003Cvoid\u003E {\n    if (!this._sessionId) {\n      return; // No session to terminate\n    }\n\n    try {\n      const headers = await this._commonHeaders();\n\n      const init = {\n        ...this._requestInit,\n        method: \"DELETE\",\n        headers,\n        signal: this._abortController?.signal,\n      };\n\n      const response = await (this._fetch ?? fetch)(this._url, init);\n\n      // We specifically handle 405 as a valid response according to the spec,\n      // meaning the server does not support explicit session termination\n      if (!response.ok && response.status !== 405) {\n        throw new StreamableHTTPError(\n          response.status,\n          `Failed to terminate session: ${response.statusText}`\n        );\n      }\n\n      this._sessionId = undefined;\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  setProtocolVersion(version: string): void {\n    this._protocolVersion = version;\n  }\n  get protocolVersion(): string | undefined {\n    return this._protocolVersion;\n  }\n}\n",
      "hash": "836ed5d694f5a6c52bdf40d02d913dacff695e864960579249c9e4f296ac52eb",
      "size": 18986
    },
    "/src/client/websocket.ts": {
      "type": "content",
      "content": "import { Transport } from \"../shared/transport.js\";\nimport { JSONRPCMessage, JSONRPCMessageSchema } from \"../types.js\";\n\nconst SUBPROTOCOL = \"mcp\";\n\n/**\n * Client transport for WebSocket: this will connect to a server over the WebSocket protocol.\n */\nexport class WebSocketClientTransport implements Transport {\n  private _socket?: WebSocket;\n  private _url: URL;\n\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: JSONRPCMessage) =\u003E void;\n\n  constructor(url: URL) {\n    this._url = url;\n  }\n\n  start(): Promise\u003Cvoid\u003E {\n    if (this._socket) {\n      throw new Error(\n        \"WebSocketClientTransport already started! If using Client class, note that connect() calls start() automatically.\",\n      );\n    }\n\n    return new Promise((resolve, reject) =\u003E {\n      this._socket = new WebSocket(this._url, SUBPROTOCOL);\n\n      this._socket.onerror = (event) =\u003E {\n        const error =\n          \"error\" in event\n            ? (event.error as Error)\n            : new Error(`WebSocket error: ${JSON.stringify(event)}`);\n        reject(error);\n        this.onerror?.(error);\n      };\n\n      this._socket.onopen = () =\u003E {\n        resolve();\n      };\n\n      this._socket.onclose = () =\u003E {\n        this.onclose?.();\n      };\n\n      this._socket.onmessage = (event: MessageEvent) =\u003E {\n        let message: JSONRPCMessage;\n        try {\n          message = JSONRPCMessageSchema.parse(JSON.parse(event.data));\n        } catch (error) {\n          this.onerror?.(error as Error);\n          return;\n        }\n\n        this.onmessage?.(message);\n      };\n    });\n  }\n\n  async close(): Promise\u003Cvoid\u003E {\n    this._socket?.close();\n  }\n\n  send(message: JSONRPCMessage): Promise\u003Cvoid\u003E {\n    return new Promise((resolve, reject) =\u003E {\n      if (!this._socket) {\n        reject(new Error(\"Not connected\"));\n        return;\n      }\n\n      this._socket?.send(JSON.stringify(message));\n      resolve();\n    });\n  }\n}\n",
      "hash": "22d298639028add43ba15aeecf2ad50aa194644bd93c6733e03fa9b787743b8e",
      "size": 1922
    },
    "/src/examples/README.md": {
      "type": "content",
      "content": "# MCP TypeScript SDK Examples\n\nThis directory contains example implementations of MCP clients and servers using the TypeScript SDK.\n\n## Table of Contents\n\n- [Client Implementations](#client-implementations)\n  - [Streamable HTTP Client](#streamable-http-client)\n  - [Backwards Compatible Client](#backwards-compatible-client)\n- [Server Implementations](#server-implementations)\n  - [Single Node Deployment](#single-node-deployment)\n    - [Streamable HTTP Transport](#streamable-http-transport)\n    - [Deprecated SSE Transport](#deprecated-sse-transport)\n    - [Backwards Compatible Server](#streamable-http-backwards-compatible-server-with-sse)\n  - [Multi-Node Deployment](#multi-node-deployment)\n- [Backwards Compatibility](#testing-streamable-http-backwards-compatibility-with-sse)\n\n## Client Implementations\n\n### Streamable HTTP Client\n\nA full-featured interactive client that connects to a Streamable HTTP server, demonstrating how to:\n\n- Establish and manage a connection to an MCP server\n- List and call tools with arguments\n- Handle notifications through the SSE stream\n- List and get prompts with arguments\n- List available resources\n- Handle session termination and reconnection\n- Support for resumability with Last-Event-ID tracking\n\n```bash\nnpx tsx src/examples/client/simpleStreamableHttp.ts\n```\n\nExample client with OAuth:\n\n```bash\nnpx tsx src/examples/client/simpleOAuthClient.js\n```\n\n### Backwards Compatible Client\n\nA client that implements backwards compatibility according to the [MCP specification](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#backwards-compatibility), allowing it to work with both new and legacy servers. This client demonstrates:\n\n- The client first POSTs an initialize request to the server URL:\n  - If successful, it uses the Streamable HTTP transport\n  - If it fails with a 4xx status, it attempts a GET request to establish an SSE stream\n\n```bash\nnpx tsx src/examples/client/streamableHttpWithSseFallbackClient.ts\n```\n\n## Server Implementations\n\n### Single Node Deployment\n\nThese examples demonstrate how to set up an MCP server on a single node with different transport options.\n\n#### Streamable HTTP Transport\n\n##### Simple Streamable HTTP Server\n\nA server that implements the Streamable HTTP transport (protocol version 2025-03-26). \n\n- Basic server setup with Express and the Streamable HTTP transport\n- Session management with an in-memory event store for resumability\n- Tool implementation with the `greet` and `multi-greet` tools\n- Prompt implementation with the `greeting-template` prompt\n- Static resource exposure\n- Support for notifications via SSE stream established by GET requests\n- Session termination via DELETE requests\n\n```bash\nnpx tsx src/examples/server/simpleStreamableHttp.ts\n\n# To add a demo of authentication to this example, use:\nnpx tsx src/examples/server/simpleStreamableHttp.ts --oauth\n\n# To mitigate impersonation risks, enable strict Resource Identifier verification:\nnpx tsx src/examples/server/simpleStreamableHttp.ts --oauth --oauth-strict\n```\n\n##### JSON Response Mode Server\n\nA server that uses Streamable HTTP transport with JSON response mode enabled (no SSE). \n\n- Streamable HTTP with JSON response mode, which returns responses directly in the response body\n- Limited support for notifications (since SSE is disabled)\n- Proper response handling according to the MCP specification for servers that don't support SSE\n- Returning appropriate HTTP status codes for unsupported methods\n\n```bash\nnpx tsx src/examples/server/jsonResponseStreamableHttp.ts\n```\n\n##### Streamable HTTP with server notifications\n\nA server that demonstrates server notifications using Streamable HTTP. \n\n- Resource list change notifications with dynamically added resources\n- Automatic resource creation on a timed interval\n\n\n```bash\nnpx tsx src/examples/server/standaloneSseWithGetStreamableHttp.ts\n```\n\n#### Deprecated SSE Transport\n\nA server that implements the deprecated HTTP+SSE transport (protocol version 2024-11-05). This example only used for testing backwards compatibility for clients.\n\n- Two separate endpoints: `/mcp` for the SSE stream (GET) and `/messages` for client messages (POST)\n- Tool implementation with a `start-notification-stream` tool that demonstrates sending periodic notifications\n\n```bash\nnpx tsx src/examples/server/simpleSseServer.ts\n```\n\n#### Streamable Http Backwards Compatible Server with SSE \n\nA server that supports both Streamable HTTP and SSE transports, adhering to the [MCP specification for backwards compatibility](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#backwards-compatibility). \n\n- Single MCP server instance with multiple transport options\n- Support for Streamable HTTP requests at `/mcp` endpoint (GET/POST/DELETE)\n- Support for deprecated SSE transport with `/sse` (GET) and `/messages` (POST)\n- Session type tracking to avoid mixing transport types\n- Notifications and tool execution across both transport types\n\n```bash\nnpx tsx src/examples/server/sseAndStreamableHttpCompatibleServer.ts\n```\n\n### Multi-Node Deployment\n\nWhen deploying MCP servers in a horizontally scaled environment (multiple server instances), there are a few different options that can be useful for different use cases:\n- **Stateless mode** - No need to maintain state between calls to MCP servers. Useful for simple API wrapper servers.\n- **Persistent storage mode** - No local state needed, but session data is stored in a database. Example: an MCP server for online ordering where the shopping cart is stored in a database.\n- **Local state with message routing** - Local state is needed, and all requests for a session must be routed to the correct node. This can be done with a message queue and pub/sub system.\n\n#### Stateless Mode\n\nThe Streamable HTTP transport can be configured to operate without tracking sessions. This is perfect for simple API proxies or when each request is completely independent.\n\n##### Implementation\n\nTo enable stateless mode, configure the `StreamableHTTPServerTransport` with:\n```typescript\nsessionIdGenerator: undefined\n```\n\nThis disables session management entirely, and the server won't generate or expect session IDs.\n\n- No session ID headers are sent or expected\n- Any server node can process any request\n- No state is preserved between requests\n- Perfect for RESTful or stateless API scenarios\n- Simplest deployment model with minimal infrastructure requirements\n\n```\n┌─────────────────────────────────────────────┐\n│                  Client                     │\n└─────────────────────────────────────────────┘\n                     │\n                     ▼\n┌─────────────────────────────────────────────┐\n│                Load Balancer                │\n└─────────────────────────────────────────────┘\n          │                       │\n          ▼                       ▼\n┌─────────────────┐     ┌─────────────────────┐\n│  MCP Server #1  │     │    MCP Server #2    │\n│ (Node.js)       │     │  (Node.js)          │\n└─────────────────┘     └─────────────────────┘\n```\n\n\n\n#### Persistent Storage Mode\n\nFor cases where you need session continuity but don't need to maintain in-memory state on specific nodes, you can use a database to persist session data while still allowing any node to handle requests.\n\n##### Implementation\n\nConfigure the transport with session management, but retrieve and store all state in an external persistent storage:\n\n```typescript\nsessionIdGenerator: () =\u003E randomUUID(),\neventStore: databaseEventStore\n```\n\nAll session state is stored in the database, and any node can serve any client by retrieving the state when needed.\n\n- Maintains sessions with unique IDs\n- Stores all session data in an external database\n- Provides resumability through the database-backed EventStore\n- Any node can handle any request for the same session\n- No node-specific memory state means no need for message routing\n- Good for applications where state can be fully externalized\n- Somewhat higher latency due to database access for each request\n\n\n```\n┌─────────────────────────────────────────────┐\n│                  Client                     │\n└─────────────────────────────────────────────┘\n                     │\n                     ▼\n┌─────────────────────────────────────────────┐\n│                Load Balancer                │\n└─────────────────────────────────────────────┘\n          │                       │\n          ▼                       ▼\n┌─────────────────┐     ┌─────────────────────┐\n│  MCP Server #1  │     │    MCP Server #2    │\n│ (Node.js)       │     │  (Node.js)          │\n└─────────────────┘     └─────────────────────┘\n          │                       │\n          │                       │\n          ▼                       ▼\n┌─────────────────────────────────────────────┐\n│           Database (PostgreSQL)             │\n│                                             │\n│  • Session state                            │\n│  • Event storage for resumability           │\n└─────────────────────────────────────────────┘\n```\n\n\n\n#### Streamable HTTP with Distributed Message Routing\n\nFor scenarios where local in-memory state must be maintained on specific nodes (such as Computer Use or complex session state), the Streamable HTTP transport can be combined with a pub/sub system to route messages to the correct node handling each session.\n\n1. **Bidirectional Message Queue Integration**:\n   - All nodes both publish to and subscribe from the message queue\n   - Each node registers the sessions it's actively handling\n   - Messages are routed based on session ownership\n\n2. **Request Handling Flow**:\n   - When a client connects to Node A with an existing `mcp-session-id`\n   - If Node A doesn't own this session, it:\n     - Establishes and maintains the SSE connection with the client\n     - Publishes the request to the message queue with the session ID\n     - Node B (which owns the session) receives the request from the queue\n     - Node B processes the request with its local session state\n     - Node B publishes responses/notifications back to the queue\n     - Node A subscribes to the response channel and forwards to the client\n\n3. **Channel Identification**:\n   - Each message channel combines both `mcp-session-id` and `stream-id`\n   - This ensures responses are correctly routed back to the originating connection\n\n```\n┌─────────────────────────────────────────────┐\n│                  Client                     │\n└─────────────────────────────────────────────┘\n                     │\n                     ▼\n┌─────────────────────────────────────────────┐\n│                Load Balancer                │\n└─────────────────────────────────────────────┘\n          │                       │\n          ▼                       ▼\n┌─────────────────┐     ┌─────────────────────┐\n│  MCP Server #1  │◄───►│    MCP Server #2    │\n│ (Has Session A) │     │  (Has Session B)    │\n└─────────────────┘     └─────────────────────┘\n          ▲│                     ▲│\n          │▼                     │▼\n┌─────────────────────────────────────────────┐\n│         Message Queue / Pub-Sub             │\n│                                             │\n│  • Session ownership registry               │\n│  • Bidirectional message routing            │\n│  • Request/response forwarding              │\n└─────────────────────────────────────────────┘\n```\n\n\n- Maintains session affinity for stateful operations without client redirection\n- Enables horizontal scaling while preserving complex in-memory state\n- Provides fault tolerance through the message queue as intermediary\n\n\n## Backwards Compatibility\n\n### Testing Streamable HTTP Backwards Compatibility with SSE\n\nTo test the backwards compatibility features:\n\n1. Start one of the server implementations:\n   ```bash\n   # Legacy SSE server (protocol version 2024-11-05)\n   npx tsx src/examples/server/simpleSseServer.ts\n   \n   # Streamable HTTP server (protocol version 2025-03-26)\n   npx tsx src/examples/server/simpleStreamableHttp.ts\n   \n   # Backwards compatible server (supports both protocols)\n   npx tsx src/examples/server/sseAndStreamableHttpCompatibleServer.ts\n   ```\n\n2. Then run the backwards compatible client:\n   ```bash\n   npx tsx src/examples/client/streamableHttpWithSseFallbackClient.ts\n   ```\n\nThis demonstrates how the MCP ecosystem ensures interoperability between clients and servers regardless of which protocol version they were built for.",
      "hash": "a1ecc535107651c65a75c93d79d2c9a67731993b5e8fac442f6c5d2050adbc85",
      "size": 14616
    },
    "/src/examples/client/multipleClientsParallel.ts": {
      "type": "content",
      "content": "import { Client } from '../../client/index.js';\nimport { StreamableHTTPClientTransport } from '../../client/streamableHttp.js';\nimport {\n  CallToolRequest,\n  CallToolResultSchema,\n  LoggingMessageNotificationSchema,\n  CallToolResult,\n} from '../../types.js';\n\n/**\n * Multiple Clients MCP Example\n * \n * This client demonstrates how to:\n * 1. Create multiple MCP clients in parallel\n * 2. Each client calls a single tool \n * 3. Track notifications from each client independently\n */\n\n// Command line args processing\nconst args = process.argv.slice(2);\nconst serverUrl = args[0] || 'http://localhost:3000/mcp';\n\ninterface ClientConfig {\n  id: string;\n  name: string;\n  toolName: string;\n  toolArguments: Record\u003Cstring, string | number | boolean\u003E;\n}\n\nasync function createAndRunClient(config: ClientConfig): Promise\u003C{ id: string; result: CallToolResult }\u003E {\n  console.log(`[${config.id}] Creating client: ${config.name}`);\n\n  const client = new Client({\n    name: config.name,\n    version: '1.0.0'\n  });\n\n  const transport = new StreamableHTTPClientTransport(new URL(serverUrl));\n\n  // Set up client-specific error handler\n  client.onerror = (error) =\u003E {\n    console.error(`[${config.id}] Client error:`, error);\n  };\n\n  // Set up client-specific notification handler\n  client.setNotificationHandler(LoggingMessageNotificationSchema, (notification) =\u003E {\n    console.log(`[${config.id}] Notification: ${notification.params.data}`);\n  });\n\n  try {\n    // Connect to the server\n    await client.connect(transport);\n    console.log(`[${config.id}] Connected to MCP server`);\n\n    // Call the specified tool\n    console.log(`[${config.id}] Calling tool: ${config.toolName}`);\n    const toolRequest: CallToolRequest = {\n      method: 'tools/call',\n      params: {\n        name: config.toolName,\n        arguments: {\n          ...config.toolArguments,\n          // Add client ID to arguments for identification in notifications\n          caller: config.id\n        }\n      }\n    };\n\n    const result = await client.request(toolRequest, CallToolResultSchema);\n    console.log(`[${config.id}] Tool call completed`);\n\n    // Keep the connection open for a bit to receive notifications\n    await new Promise(resolve =\u003E setTimeout(resolve, 5000));\n\n    // Disconnect\n    await transport.close();\n    console.log(`[${config.id}] Disconnected from MCP server`);\n\n    return { id: config.id, result };\n  } catch (error) {\n    console.error(`[${config.id}] Error:`, error);\n    throw error;\n  }\n}\n\nasync function main(): Promise\u003Cvoid\u003E {\n  console.log('MCP Multiple Clients Example');\n  console.log('============================');\n  console.log(`Server URL: ${serverUrl}`);\n  console.log('');\n\n  try {\n    // Define client configurations\n    const clientConfigs: ClientConfig[] = [\n      {\n        id: 'client1',\n        name: 'basic-client-1',\n        toolName: 'start-notification-stream',\n        toolArguments: {\n          interval: 3, // 1 second between notifications\n          count: 5     // Send 5 notifications\n        }\n      },\n      {\n        id: 'client2',\n        name: 'basic-client-2',\n        toolName: 'start-notification-stream',\n        toolArguments: {\n          interval: 2, // 2 seconds between notifications\n          count: 3     // Send 3 notifications\n        }\n      },\n      {\n        id: 'client3',\n        name: 'basic-client-3',\n        toolName: 'start-notification-stream',\n        toolArguments: {\n          interval: 1, // 0.5 second between notifications\n          count: 8       // Send 8 notifications\n        }\n      }\n    ];\n\n    // Start all clients in parallel\n    console.log(`Starting ${clientConfigs.length} clients in parallel...`);\n    console.log('');\n\n    const clientPromises = clientConfigs.map(config =\u003E createAndRunClient(config));\n    const results = await Promise.all(clientPromises);\n\n    // Display results from all clients\n    console.log('\\n=== Final Results ===');\n    results.forEach(({ id, result }) =\u003E {\n      console.log(`\\n[${id}] Tool result:`);\n      if (Array.isArray(result.content)) {\n        result.content.forEach((item: { type: string; text?: string }) =\u003E {\n          if (item.type === 'text' && item.text) {\n            console.log(`  ${item.text}`);\n          } else {\n            console.log(`  ${item.type} content:`, item);\n          }\n        });\n      } else {\n        console.log(`  Unexpected result format:`, result);\n      }\n    });\n\n    console.log('\\n=== All clients completed successfully ===');\n\n  } catch (error) {\n    console.error('Error running multiple clients:', error);\n    process.exit(1);\n  }\n}\n\n// Start the example\nmain().catch((error: unknown) =\u003E {\n  console.error('Error running MCP multiple clients example:', error);\n  process.exit(1);\n});",
      "hash": "7cb67657bcaa7ef0052465a22aa53ead98438b4ddfb08f96c23dcfb0f190b0e7",
      "size": 4724
    },
    "/src/examples/client/parallelToolCallsClient.ts": {
      "type": "content",
      "content": "import { Client } from '../../client/index.js';\nimport { StreamableHTTPClientTransport } from '../../client/streamableHttp.js';\nimport {\n  ListToolsRequest,\n  ListToolsResultSchema,\n  CallToolResultSchema,\n  LoggingMessageNotificationSchema,\n  CallToolResult,\n} from '../../types.js';\n\n/**\n * Parallel Tool Calls MCP Client\n * \n * This client demonstrates how to:\n * 1. Start multiple tool calls in parallel\n * 2. Track notifications from each tool call using a caller parameter\n */\n\n// Command line args processing\nconst args = process.argv.slice(2);\nconst serverUrl = args[0] || 'http://localhost:3000/mcp';\n\nasync function main(): Promise\u003Cvoid\u003E {\n  console.log('MCP Parallel Tool Calls Client');\n  console.log('==============================');\n  console.log(`Connecting to server at: ${serverUrl}`);\n\n  let client: Client;\n  let transport: StreamableHTTPClientTransport;\n\n  try {\n    // Create client with streamable HTTP transport\n    client = new Client({\n      name: 'parallel-tool-calls-client',\n      version: '1.0.0'\n    });\n\n    client.onerror = (error) =\u003E {\n      console.error('Client error:', error);\n    };\n\n    // Connect to the server\n    transport = new StreamableHTTPClientTransport(new URL(serverUrl));\n    await client.connect(transport);\n    console.log('Successfully connected to MCP server');\n\n    // Set up notification handler with caller identification\n    client.setNotificationHandler(LoggingMessageNotificationSchema, (notification) =\u003E {\n      console.log(`Notification: ${notification.params.data}`);\n    });\n\n    console.log(\"List tools\")\n    const toolsRequest = await listTools(client);\n    console.log(\"Tools: \", toolsRequest)\n\n\n    // 2. Start multiple notification tools in parallel\n    console.log('\\n=== Starting Multiple Notification Streams in Parallel ===');\n    const toolResults = await startParallelNotificationTools(client);\n\n    // Log the results from each tool call\n    for (const [caller, result] of Object.entries(toolResults)) {\n      console.log(`\\n=== Tool result for ${caller} ===`);\n      result.content.forEach((item: { type: string; text?: string; }) =\u003E {\n        if (item.type === 'text') {\n          console.log(`  ${item.text}`);\n        } else {\n          console.log(`  ${item.type} content:`, item);\n        }\n      });\n    }\n\n    // 3. Wait for all notifications (10 seconds)\n    console.log('\\n=== Waiting for all notifications ===');\n    await new Promise(resolve =\u003E setTimeout(resolve, 10000));\n\n    // 4. Disconnect\n    console.log('\\n=== Disconnecting ===');\n    await transport.close();\n    console.log('Disconnected from MCP server');\n\n  } catch (error) {\n    console.error('Error running client:', error);\n    process.exit(1);\n  }\n}\n\n/**\n * List available tools on the server\n */\nasync function listTools(client: Client): Promise\u003Cvoid\u003E {\n  try {\n    const toolsRequest: ListToolsRequest = {\n      method: 'tools/list',\n      params: {}\n    };\n    const toolsResult = await client.request(toolsRequest, ListToolsResultSchema);\n\n    console.log('Available tools:');\n    if (toolsResult.tools.length === 0) {\n      console.log('  No tools available');\n    } else {\n      for (const tool of toolsResult.tools) {\n        console.log(`  - ${tool.name}: ${tool.description}`);\n      }\n    }\n  } catch (error) {\n    console.log(`Tools not supported by this server: ${error}`);\n  }\n}\n\n/**\n * Start multiple notification tools in parallel with different configurations\n * Each tool call includes a caller parameter to identify its notifications\n */\nasync function startParallelNotificationTools(client: Client): Promise\u003CRecord\u003Cstring, CallToolResult\u003E\u003E {\n  try {\n    // Define multiple tool calls with different configurations\n    const toolCalls = [\n      {\n        caller: 'fast-notifier',\n        request: {\n          method: 'tools/call',\n          params: {\n            name: 'start-notification-stream',\n            arguments: {\n              interval: 2,  // 0.5 second between notifications\n              count: 10,      // Send 10 notifications\n              caller: 'fast-notifier' // Identify this tool call\n            }\n          }\n        }\n      },\n      {\n        caller: 'slow-notifier',\n        request: {\n          method: 'tools/call',\n          params: {\n            name: 'start-notification-stream',\n            arguments: {\n              interval: 5, // 2 seconds between notifications\n              count: 5,       // Send 5 notifications\n              caller: 'slow-notifier' // Identify this tool call\n            }\n          }\n        }\n      },\n      {\n        caller: 'burst-notifier',\n        request: {\n          method: 'tools/call',\n          params: {\n            name: 'start-notification-stream',\n            arguments: {\n              interval: 1,  // 0.1 second between notifications\n              count: 3,       // Send just 3 notifications\n              caller: 'burst-notifier' // Identify this tool call\n            }\n          }\n        }\n      }\n    ];\n\n    console.log(`Starting ${toolCalls.length} notification tools in parallel...`);\n\n    // Start all tool calls in parallel\n    const toolPromises = toolCalls.map(({ caller, request }) =\u003E {\n      console.log(`Starting tool call for ${caller}...`);\n      return client.request(request, CallToolResultSchema)\n        .then(result =\u003E ({ caller, result }))\n        .catch(error =\u003E {\n          console.error(`Error in tool call for ${caller}:`, error);\n          throw error;\n        });\n    });\n\n    // Wait for all tool calls to complete\n    const results = await Promise.all(toolPromises);\n\n    // Organize results by caller\n    const resultsByTool: Record\u003Cstring, CallToolResult\u003E = {};\n    results.forEach(({ caller, result }) =\u003E {\n      resultsByTool[caller] = result;\n    });\n\n    return resultsByTool;\n  } catch (error) {\n    console.error(`Error starting parallel notification tools:`, error);\n    throw error;\n  }\n}\n\n// Start the client\nmain().catch((error: unknown) =\u003E {\n  console.error('Error running MCP client:', error);\n  process.exit(1);\n});",
      "hash": "05883cc51c153c0cf8b6e26b9e4854ae890ea0504dd1332a1c924b87c48eb85d",
      "size": 6013
    },
    "/src/examples/client/simpleOAuthClient.ts": {
      "type": "content",
      "content": "#!/usr/bin/env node\n\nimport { createServer } from 'node:http';\nimport { createInterface } from 'node:readline';\nimport { URL } from 'node:url';\nimport { exec } from 'node:child_process';\nimport { Client } from '../../client/index.js';\nimport { StreamableHTTPClientTransport } from '../../client/streamableHttp.js';\nimport { OAuthClientInformation, OAuthClientInformationFull, OAuthClientMetadata, OAuthTokens } from '../../shared/auth.js';\nimport {\n  CallToolRequest,\n  ListToolsRequest,\n  CallToolResultSchema,\n  ListToolsResultSchema\n} from '../../types.js';\nimport { OAuthClientProvider, UnauthorizedError } from '../../client/auth.js';\n\n// Configuration\nconst DEFAULT_SERVER_URL = 'http://localhost:3000/mcp';\nconst CALLBACK_PORT = 8090; // Use different port than auth server (3001)\nconst CALLBACK_URL = `http://localhost:${CALLBACK_PORT}/callback`;\n\n/**\n * In-memory OAuth client provider for demonstration purposes\n * In production, you should persist tokens securely\n */\nclass InMemoryOAuthClientProvider implements OAuthClientProvider {\n  private _clientInformation?: OAuthClientInformationFull;\n  private _tokens?: OAuthTokens;\n  private _codeVerifier?: string;\n\n  constructor(\n    private readonly _redirectUrl: string | URL,\n    private readonly _clientMetadata: OAuthClientMetadata,\n    onRedirect?: (url: URL) =\u003E void\n  ) {\n    this._onRedirect = onRedirect || ((url) =\u003E {\n      console.log(`Redirect to: ${url.toString()}`);\n    });\n  }\n\n  private _onRedirect: (url: URL) =\u003E void;\n\n  get redirectUrl(): string | URL {\n    return this._redirectUrl;\n  }\n\n  get clientMetadata(): OAuthClientMetadata {\n    return this._clientMetadata;\n  }\n\n  clientInformation(): OAuthClientInformation | undefined {\n    return this._clientInformation;\n  }\n\n  saveClientInformation(clientInformation: OAuthClientInformationFull): void {\n    this._clientInformation = clientInformation;\n  }\n\n  tokens(): OAuthTokens | undefined {\n    return this._tokens;\n  }\n\n  saveTokens(tokens: OAuthTokens): void {\n    this._tokens = tokens;\n  }\n\n  redirectToAuthorization(authorizationUrl: URL): void {\n    this._onRedirect(authorizationUrl);\n  }\n\n  saveCodeVerifier(codeVerifier: string): void {\n    this._codeVerifier = codeVerifier;\n  }\n\n  codeVerifier(): string {\n    if (!this._codeVerifier) {\n      throw new Error('No code verifier saved');\n    }\n    return this._codeVerifier;\n  }\n}\n/**\n * Interactive MCP client with OAuth authentication\n * Demonstrates the complete OAuth flow with browser-based authorization\n */\nclass InteractiveOAuthClient {\n  private client: Client | null = null;\n  private readonly rl = createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  constructor(private serverUrl: string) { }\n\n  /**\n   * Prompts user for input via readline\n   */\n  private async question(query: string): Promise\u003Cstring\u003E {\n    return new Promise((resolve) =\u003E {\n      this.rl.question(query, resolve);\n    });\n  }\n\n  /**\n   * Opens the authorization URL in the user's default browser\n   */\n  private async openBrowser(url: string): Promise\u003Cvoid\u003E {\n    console.log(`🌐 Opening browser for authorization: ${url}`);\n\n    const command = `open \"${url}\"`;\n\n    exec(command, (error) =\u003E {\n      if (error) {\n        console.error(`Failed to open browser: ${error.message}`);\n        console.log(`Please manually open: ${url}`);\n      }\n    });\n  }\n  /**\n   * Example OAuth callback handler - in production, use a more robust approach\n   * for handling callbacks and storing tokens\n   */\n  /**\n   * Starts a temporary HTTP server to receive the OAuth callback\n   */\n  private async waitForOAuthCallback(): Promise\u003Cstring\u003E {\n    return new Promise\u003Cstring\u003E((resolve, reject) =\u003E {\n      const server = createServer((req, res) =\u003E {\n        // Ignore favicon requests\n        if (req.url === '/favicon.ico') {\n          res.writeHead(404);\n          res.end();\n          return;\n        }\n\n        console.log(`📥 Received callback: ${req.url}`);\n        const parsedUrl = new URL(req.url || '', 'http://localhost');\n        const code = parsedUrl.searchParams.get('code');\n        const error = parsedUrl.searchParams.get('error');\n\n        if (code) {\n          console.log(`✅ Authorization code received: ${code?.substring(0, 10)}...`);\n          res.writeHead(200, { 'Content-Type': 'text/html' });\n          res.end(`\n            \u003Chtml\u003E\n              \u003Cbody\u003E\n                \u003Ch1\u003EAuthorization Successful!\u003C/h1\u003E\n                \u003Cp\u003EYou can close this window and return to the terminal.\u003C/p\u003E\n                \u003Cscript\u003EsetTimeout(() =\u003E window.close(), 2000);\u003C/script\u003E\n              \u003C/body\u003E\n            \u003C/html\u003E\n          `);\n\n          resolve(code);\n          setTimeout(() =\u003E server.close(), 3000);\n        } else if (error) {\n          console.log(`❌ Authorization error: ${error}`);\n          res.writeHead(400, { 'Content-Type': 'text/html' });\n          res.end(`\n            \u003Chtml\u003E\n              \u003Cbody\u003E\n                \u003Ch1\u003EAuthorization Failed\u003C/h1\u003E\n                \u003Cp\u003EError: ${error}\u003C/p\u003E\n              \u003C/body\u003E\n            \u003C/html\u003E\n          `);\n          reject(new Error(`OAuth authorization failed: ${error}`));\n        } else {\n          console.log(`❌ No authorization code or error in callback`);\n          res.writeHead(400);\n          res.end('Bad request');\n          reject(new Error('No authorization code provided'));\n        }\n      });\n\n      server.listen(CALLBACK_PORT, () =\u003E {\n        console.log(`OAuth callback server started on http://localhost:${CALLBACK_PORT}`);\n      });\n    });\n  }\n\n  private async attemptConnection(oauthProvider: InMemoryOAuthClientProvider): Promise\u003Cvoid\u003E {\n    console.log('🚢 Creating transport with OAuth provider...');\n    const baseUrl = new URL(this.serverUrl);\n    const transport = new StreamableHTTPClientTransport(baseUrl, {\n      authProvider: oauthProvider\n    });\n    console.log('🚢 Transport created');\n\n    try {\n      console.log('🔌 Attempting connection (this will trigger OAuth redirect)...');\n      await this.client!.connect(transport);\n      console.log('✅ Connected successfully');\n    } catch (error) {\n      if (error instanceof UnauthorizedError) {\n        console.log('🔐 OAuth required - waiting for authorization...');\n        const callbackPromise = this.waitForOAuthCallback();\n        const authCode = await callbackPromise;\n        await transport.finishAuth(authCode);\n        console.log('🔐 Authorization code received:', authCode);\n        console.log('🔌 Reconnecting with authenticated transport...');\n        await this.attemptConnection(oauthProvider);\n      } else {\n        console.error('❌ Connection failed with non-auth error:', error);\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Establishes connection to the MCP server with OAuth authentication\n   */\n  async connect(): Promise\u003Cvoid\u003E {\n    console.log(`🔗 Attempting to connect to ${this.serverUrl}...`);\n\n    const clientMetadata: OAuthClientMetadata = {\n      client_name: 'Simple OAuth MCP Client',\n      redirect_uris: [CALLBACK_URL],\n      grant_types: ['authorization_code', 'refresh_token'],\n      response_types: ['code'],\n      token_endpoint_auth_method: 'client_secret_post',\n      scope: 'mcp:tools'\n    };\n\n    console.log('🔐 Creating OAuth provider...');\n    const oauthProvider = new InMemoryOAuthClientProvider(\n      CALLBACK_URL,\n      clientMetadata,\n      (redirectUrl: URL) =\u003E {\n        console.log(`📌 OAuth redirect handler called - opening browser`);\n        console.log(`Opening browser to: ${redirectUrl.toString()}`);\n        this.openBrowser(redirectUrl.toString());\n      }\n    );\n    console.log('🔐 OAuth provider created');\n\n    console.log('👤 Creating MCP client...');\n    this.client = new Client({\n      name: 'simple-oauth-client',\n      version: '1.0.0',\n    }, { capabilities: {} });\n    console.log('👤 Client created');\n\n    console.log('🔐 Starting OAuth flow...');\n\n    await this.attemptConnection(oauthProvider);\n\n    // Start interactive loop\n    await this.interactiveLoop();\n  }\n\n  /**\n   * Main interactive loop for user commands\n   */\n  async interactiveLoop(): Promise\u003Cvoid\u003E {\n    console.log('\\n🎯 Interactive MCP Client with OAuth');\n    console.log('Commands:');\n    console.log('  list - List available tools');\n    console.log('  call \u003Ctool_name\u003E [args] - Call a tool');\n    console.log('  quit - Exit the client');\n    console.log();\n\n    while (true) {\n      try {\n        const command = await this.question('mcp\u003E ');\n\n        if (!command.trim()) {\n          continue;\n        }\n\n        if (command === 'quit') {\n          console.log('\\n👋 Goodbye!');\n          this.close();\n          process.exit(0);\n        } else if (command === 'list') {\n          await this.listTools();\n        } else if (command.startsWith('call ')) {\n          await this.handleCallTool(command);\n        } else {\n          console.log('❌ Unknown command. Try \\'list\\', \\'call \u003Ctool_name\u003E\\', or \\'quit\\'');\n        }\n      } catch (error) {\n        if (error instanceof Error && error.message === 'SIGINT') {\n          console.log('\\n\\n👋 Goodbye!');\n          break;\n        }\n        console.error('❌ Error:', error);\n      }\n    }\n  }\n\n  private async listTools(): Promise\u003Cvoid\u003E {\n    if (!this.client) {\n      console.log('❌ Not connected to server');\n      return;\n    }\n\n    try {\n      const request: ListToolsRequest = {\n        method: 'tools/list',\n        params: {},\n      };\n\n      const result = await this.client.request(request, ListToolsResultSchema);\n\n      if (result.tools && result.tools.length \u003E 0) {\n        console.log('\\n📋 Available tools:');\n        result.tools.forEach((tool, index) =\u003E {\n          console.log(`${index + 1}. ${tool.name}`);\n          if (tool.description) {\n            console.log(`   Description: ${tool.description}`);\n          }\n          console.log();\n        });\n      } else {\n        console.log('No tools available');\n      }\n    } catch (error) {\n      console.error('❌ Failed to list tools:', error);\n    }\n  }\n\n  private async handleCallTool(command: string): Promise\u003Cvoid\u003E {\n    const parts = command.split(/\\s+/);\n    const toolName = parts[1];\n\n    if (!toolName) {\n      console.log('❌ Please specify a tool name');\n      return;\n    }\n\n    // Parse arguments (simple JSON-like format)\n    let toolArgs: Record\u003Cstring, unknown\u003E = {};\n    if (parts.length \u003E 2) {\n      const argsString = parts.slice(2).join(' ');\n      try {\n        toolArgs = JSON.parse(argsString);\n      } catch {\n        console.log('❌ Invalid arguments format (expected JSON)');\n        return;\n      }\n    }\n\n    await this.callTool(toolName, toolArgs);\n  }\n\n  private async callTool(toolName: string, toolArgs: Record\u003Cstring, unknown\u003E): Promise\u003Cvoid\u003E {\n    if (!this.client) {\n      console.log('❌ Not connected to server');\n      return;\n    }\n\n    try {\n      const request: CallToolRequest = {\n        method: 'tools/call',\n        params: {\n          name: toolName,\n          arguments: toolArgs,\n        },\n      };\n\n      const result = await this.client.request(request, CallToolResultSchema);\n\n      console.log(`\\n🔧 Tool '${toolName}' result:`);\n      if (result.content) {\n        result.content.forEach((content) =\u003E {\n          if (content.type === 'text') {\n            console.log(content.text);\n          } else {\n            console.log(content);\n          }\n        });\n      } else {\n        console.log(result);\n      }\n    } catch (error) {\n      console.error(`❌ Failed to call tool '${toolName}':`, error);\n    }\n  }\n\n  close(): void {\n    this.rl.close();\n    if (this.client) {\n      // Note: Client doesn't have a close method in the current implementation\n      // This would typically close the transport connection\n    }\n  }\n}\n\n/**\n * Main entry point\n */\nasync function main(): Promise\u003Cvoid\u003E {\n  const serverUrl = process.env.MCP_SERVER_URL || DEFAULT_SERVER_URL;\n\n  console.log('🚀 Simple MCP OAuth Client');\n  console.log(`Connecting to: ${serverUrl}`);\n  console.log();\n\n  const client = new InteractiveOAuthClient(serverUrl);\n\n  // Handle graceful shutdown\n  process.on('SIGINT', () =\u003E {\n    console.log('\\n\\n👋 Goodbye!');\n    client.close();\n    process.exit(0);\n  });\n\n  try {\n    await client.connect();\n  } catch (error) {\n    console.error('Failed to start client:', error);\n    process.exit(1);\n  } finally {\n    client.close();\n  }\n}\n\n// Run if this file is executed directly\nmain().catch((error) =\u003E {\n  console.error('Unhandled error:', error);\n  process.exit(1);\n});",
      "hash": "17ea3a5cbfbc2fe54c565a5262a306546133ba463bfc65e34053cd2a09b0edcb",
      "size": 12512
    },
    "/src/examples/client/simpleStreamableHttp.ts": {
      "type": "content",
      "content": "import { Client } from '../../client/index.js';\nimport { StreamableHTTPClientTransport } from '../../client/streamableHttp.js';\nimport { createInterface } from 'node:readline';\nimport {\n  ListToolsRequest,\n  ListToolsResultSchema,\n  CallToolRequest,\n  CallToolResultSchema,\n  ListPromptsRequest,\n  ListPromptsResultSchema,\n  GetPromptRequest,\n  GetPromptResultSchema,\n  ListResourcesRequest,\n  ListResourcesResultSchema,\n  LoggingMessageNotificationSchema,\n  ResourceListChangedNotificationSchema,\n  ElicitRequestSchema,\n  ResourceLink,\n  ReadResourceRequest,\n  ReadResourceResultSchema,\n} from '../../types.js';\nimport { getDisplayName } from '../../shared/metadataUtils.js';\nimport Ajv from \"ajv\";\n\n// Create readline interface for user input\nconst readline = createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// Track received notifications for debugging resumability\nlet notificationCount = 0;\n\n// Global client and transport for interactive commands\nlet client: Client | null = null;\nlet transport: StreamableHTTPClientTransport | null = null;\nlet serverUrl = 'http://localhost:3000/mcp';\nlet notificationsToolLastEventId: string | undefined = undefined;\nlet sessionId: string | undefined = undefined;\n\nasync function main(): Promise\u003Cvoid\u003E {\n  console.log('MCP Interactive Client');\n  console.log('=====================');\n\n  // Connect to server immediately with default settings\n  await connect();\n\n  // Print help and start the command loop\n  printHelp();\n  commandLoop();\n}\n\nfunction printHelp(): void {\n  console.log('\\nAvailable commands:');\n  console.log('  connect [url]              - Connect to MCP server (default: http://localhost:3000/mcp)');\n  console.log('  disconnect                 - Disconnect from server');\n  console.log('  terminate-session          - Terminate the current session');\n  console.log('  reconnect                  - Reconnect to the server');\n  console.log('  list-tools                 - List available tools');\n  console.log('  call-tool \u003Cname\u003E [args]    - Call a tool with optional JSON arguments');\n  console.log('  greet [name]               - Call the greet tool');\n  console.log('  multi-greet [name]         - Call the multi-greet tool with notifications');\n  console.log('  collect-info [type]        - Test elicitation with collect-user-info tool (contact/preferences/feedback)');\n  console.log('  start-notifications [interval] [count] - Start periodic notifications');\n  console.log('  run-notifications-tool-with-resumability [interval] [count] - Run notification tool with resumability');\n  console.log('  list-prompts               - List available prompts');\n  console.log('  get-prompt [name] [args]   - Get a prompt with optional JSON arguments');\n  console.log('  list-resources             - List available resources');\n  console.log('  read-resource \u003Curi\u003E        - Read a specific resource by URI');\n  console.log('  help                       - Show this help');\n  console.log('  quit                       - Exit the program');\n}\n\nfunction commandLoop(): void {\n  readline.question('\\n\u003E ', async (input) =\u003E {\n    const args = input.trim().split(/\\s+/);\n    const command = args[0]?.toLowerCase();\n\n    try {\n      switch (command) {\n        case 'connect':\n          await connect(args[1]);\n          break;\n\n        case 'disconnect':\n          await disconnect();\n          break;\n\n        case 'terminate-session':\n          await terminateSession();\n          break;\n\n        case 'reconnect':\n          await reconnect();\n          break;\n\n        case 'list-tools':\n          await listTools();\n          break;\n\n        case 'call-tool':\n          if (args.length \u003C 2) {\n            console.log('Usage: call-tool \u003Cname\u003E [args]');\n          } else {\n            const toolName = args[1];\n            let toolArgs = {};\n            if (args.length \u003E 2) {\n              try {\n                toolArgs = JSON.parse(args.slice(2).join(' '));\n              } catch {\n                console.log('Invalid JSON arguments. Using empty args.');\n              }\n            }\n            await callTool(toolName, toolArgs);\n          }\n          break;\n\n        case 'greet':\n          await callGreetTool(args[1] || 'MCP User');\n          break;\n\n        case 'multi-greet':\n          await callMultiGreetTool(args[1] || 'MCP User');\n          break;\n\n        case 'collect-info':\n          await callCollectInfoTool(args[1] || 'contact');\n          break;\n\n        case 'start-notifications': {\n          const interval = args[1] ? parseInt(args[1], 10) : 2000;\n          const count = args[2] ? parseInt(args[2], 10) : 10;\n          await startNotifications(interval, count);\n          break;\n        }\n\n        case 'run-notifications-tool-with-resumability': {\n          const interval = args[1] ? parseInt(args[1], 10) : 2000;\n          const count = args[2] ? parseInt(args[2], 10) : 10;\n          await runNotificationsToolWithResumability(interval, count);\n          break;\n        }\n\n        case 'list-prompts':\n          await listPrompts();\n          break;\n\n        case 'get-prompt':\n          if (args.length \u003C 2) {\n            console.log('Usage: get-prompt \u003Cname\u003E [args]');\n          } else {\n            const promptName = args[1];\n            let promptArgs = {};\n            if (args.length \u003E 2) {\n              try {\n                promptArgs = JSON.parse(args.slice(2).join(' '));\n              } catch {\n                console.log('Invalid JSON arguments. Using empty args.');\n              }\n            }\n            await getPrompt(promptName, promptArgs);\n          }\n          break;\n\n        case 'list-resources':\n          await listResources();\n          break;\n\n        case 'read-resource':\n          if (args.length \u003C 2) {\n            console.log('Usage: read-resource \u003Curi\u003E');\n          } else {\n            await readResource(args[1]);\n          }\n          break;\n\n        case 'help':\n          printHelp();\n          break;\n\n        case 'quit':\n        case 'exit':\n          await cleanup();\n          return;\n\n        default:\n          if (command) {\n            console.log(`Unknown command: ${command}`);\n          }\n          break;\n      }\n    } catch (error) {\n      console.error(`Error executing command: ${error}`);\n    }\n\n    // Continue the command loop\n    commandLoop();\n  });\n}\n\nasync function connect(url?: string): Promise\u003Cvoid\u003E {\n  if (client) {\n    console.log('Already connected. Disconnect first.');\n    return;\n  }\n\n  if (url) {\n    serverUrl = url;\n  }\n\n  console.log(`Connecting to ${serverUrl}...`);\n\n  try {\n    // Create a new client with elicitation capability\n    client = new Client({\n      name: 'example-client',\n      version: '1.0.0'\n    }, {\n      capabilities: {\n        elicitation: {},\n      },\n    });\n    client.onerror = (error) =\u003E {\n      console.error('\\x1b[31mClient error:', error, '\\x1b[0m');\n    }\n\n    // Set up elicitation request handler with proper validation\n    client.setRequestHandler(ElicitRequestSchema, async (request) =\u003E {\n      console.log('\\n🔔 Elicitation Request Received:');\n      console.log(`Message: ${request.params.message}`);\n      console.log('Requested Schema:');\n      console.log(JSON.stringify(request.params.requestedSchema, null, 2));\n\n      const schema = request.params.requestedSchema;\n      const properties = schema.properties;\n      const required = schema.required || [];\n\n      // Set up AJV validator for the requested schema\n      const ajv = new Ajv();\n      const validate = ajv.compile(schema);\n\n      let attempts = 0;\n      const maxAttempts = 3;\n\n      while (attempts \u003C maxAttempts) {\n        attempts++;\n        console.log(`\\nPlease provide the following information (attempt ${attempts}/${maxAttempts}):`);\n\n        const content: Record\u003Cstring, unknown\u003E = {};\n        let inputCancelled = false;\n\n        // Collect input for each field\n        for (const [fieldName, fieldSchema] of Object.entries(properties)) {\n          const field = fieldSchema as {\n            type?: string;\n            title?: string;\n            description?: string;\n            default?: unknown;\n            enum?: string[];\n            minimum?: number;\n            maximum?: number;\n            minLength?: number;\n            maxLength?: number;\n            format?: string;\n          };\n\n          const isRequired = required.includes(fieldName);\n          let prompt = `${field.title || fieldName}`;\n\n          // Add helpful information to the prompt\n          if (field.description) {\n            prompt += ` (${field.description})`;\n          }\n          if (field.enum) {\n            prompt += ` [options: ${field.enum.join(', ')}]`;\n          }\n          if (field.type === 'number' || field.type === 'integer') {\n            if (field.minimum !== undefined && field.maximum !== undefined) {\n              prompt += ` [${field.minimum}-${field.maximum}]`;\n            } else if (field.minimum !== undefined) {\n              prompt += ` [min: ${field.minimum}]`;\n            } else if (field.maximum !== undefined) {\n              prompt += ` [max: ${field.maximum}]`;\n            }\n          }\n          if (field.type === 'string' && field.format) {\n            prompt += ` [format: ${field.format}]`;\n          }\n          if (isRequired) {\n            prompt += ' *required*';\n          }\n          if (field.default !== undefined) {\n            prompt += ` [default: ${field.default}]`;\n          }\n\n          prompt += ': ';\n\n          const answer = await new Promise\u003Cstring\u003E((resolve) =\u003E {\n            readline.question(prompt, (input) =\u003E {\n              resolve(input.trim());\n            });\n          });\n\n          // Check for cancellation\n          if (answer.toLowerCase() === 'cancel' || answer.toLowerCase() === 'c') {\n            inputCancelled = true;\n            break;\n          }\n\n          // Parse and validate the input\n          try {\n            if (answer === '' && field.default !== undefined) {\n              content[fieldName] = field.default;\n            } else if (answer === '' && !isRequired) {\n              // Skip optional empty fields\n              continue;\n            } else if (answer === '') {\n              throw new Error(`${fieldName} is required`);\n            } else {\n              // Parse the value based on type\n              let parsedValue: unknown;\n\n              if (field.type === 'boolean') {\n                parsedValue = answer.toLowerCase() === 'true' || answer.toLowerCase() === 'yes' || answer === '1';\n              } else if (field.type === 'number') {\n                parsedValue = parseFloat(answer);\n                if (isNaN(parsedValue as number)) {\n                  throw new Error(`${fieldName} must be a valid number`);\n                }\n              } else if (field.type === 'integer') {\n                parsedValue = parseInt(answer, 10);\n                if (isNaN(parsedValue as number)) {\n                  throw new Error(`${fieldName} must be a valid integer`);\n                }\n              } else if (field.enum) {\n                if (!field.enum.includes(answer)) {\n                  throw new Error(`${fieldName} must be one of: ${field.enum.join(', ')}`);\n                }\n                parsedValue = answer;\n              } else {\n                parsedValue = answer;\n              }\n\n              content[fieldName] = parsedValue;\n            }\n          } catch (error) {\n            console.log(`❌ Error: ${error}`);\n            // Continue to next attempt\n            break;\n          }\n        }\n\n        if (inputCancelled) {\n          return { action: 'cancel' };\n        }\n\n        // If we didn't complete all fields due to an error, try again\n        if (Object.keys(content).length !== Object.keys(properties).filter(name =\u003E\n          required.includes(name) || content[name] !== undefined\n        ).length) {\n          if (attempts \u003C maxAttempts) {\n            console.log('Please try again...');\n            continue;\n          } else {\n            console.log('Maximum attempts reached. Declining request.');\n            return { action: 'decline' };\n          }\n        }\n\n        // Validate the complete object against the schema\n        const isValid = validate(content);\n\n        if (!isValid) {\n          console.log('❌ Validation errors:');\n          validate.errors?.forEach(error =\u003E {\n            console.log(`  - ${error.dataPath || 'root'}: ${error.message}`);\n          });\n\n          if (attempts \u003C maxAttempts) {\n            console.log('Please correct the errors and try again...');\n            continue;\n          } else {\n            console.log('Maximum attempts reached. Declining request.');\n            return { action: 'decline' };\n          }\n        }\n\n        // Show the collected data and ask for confirmation\n        console.log('\\n✅ Collected data:');\n        console.log(JSON.stringify(content, null, 2));\n\n        const confirmAnswer = await new Promise\u003Cstring\u003E((resolve) =\u003E {\n          readline.question('\\nSubmit this information? (yes/no/cancel): ', (input) =\u003E {\n            resolve(input.trim().toLowerCase());\n          });\n        });\n\n\n        if (confirmAnswer === 'yes' || confirmAnswer === 'y') {\n          return {\n            action: 'accept',\n            content,\n          };\n        } else if (confirmAnswer === 'cancel' || confirmAnswer === 'c') {\n          return { action: 'cancel' };\n        } else if (confirmAnswer === 'no' || confirmAnswer === 'n') {\n          if (attempts \u003C maxAttempts) {\n            console.log('Please re-enter the information...');\n            continue;\n          } else {\n            return { action: 'decline' };\n          }\n        }\n      }\n\n      console.log('Maximum attempts reached. Declining request.');\n      return { action: 'decline' };\n    });\n\n    transport = new StreamableHTTPClientTransport(\n      new URL(serverUrl),\n      {\n        sessionId: sessionId\n      }\n    );\n\n    // Set up notification handlers\n    client.setNotificationHandler(LoggingMessageNotificationSchema, (notification) =\u003E {\n      notificationCount++;\n      console.log(`\\nNotification #${notificationCount}: ${notification.params.level} - ${notification.params.data}`);\n      // Re-display the prompt\n      process.stdout.write('\u003E ');\n    });\n\n    client.setNotificationHandler(ResourceListChangedNotificationSchema, async (_) =\u003E {\n      console.log(`\\nResource list changed notification received!`);\n      try {\n        if (!client) {\n          console.log('Client disconnected, cannot fetch resources');\n          return;\n        }\n        const resourcesResult = await client.request({\n          method: 'resources/list',\n          params: {}\n        }, ListResourcesResultSchema);\n        console.log('Available resources count:', resourcesResult.resources.length);\n      } catch {\n        console.log('Failed to list resources after change notification');\n      }\n      // Re-display the prompt\n      process.stdout.write('\u003E ');\n    });\n\n    // Connect the client\n    await client.connect(transport);\n    sessionId = transport.sessionId\n    console.log('Transport created with session ID:', sessionId);\n    console.log('Connected to MCP server');\n  } catch (error) {\n    console.error('Failed to connect:', error);\n    client = null;\n    transport = null;\n  }\n}\n\nasync function disconnect(): Promise\u003Cvoid\u003E {\n  if (!client || !transport) {\n    console.log('Not connected.');\n    return;\n  }\n\n  try {\n    await transport.close();\n    console.log('Disconnected from MCP server');\n    client = null;\n    transport = null;\n  } catch (error) {\n    console.error('Error disconnecting:', error);\n  }\n}\n\nasync function terminateSession(): Promise\u003Cvoid\u003E {\n  if (!client || !transport) {\n    console.log('Not connected.');\n    return;\n  }\n\n  try {\n    console.log('Terminating session with ID:', transport.sessionId);\n    await transport.terminateSession();\n    console.log('Session terminated successfully');\n\n    // Check if sessionId was cleared after termination\n    if (!transport.sessionId) {\n      console.log('Session ID has been cleared');\n      sessionId = undefined;\n\n      // Also close the transport and clear client objects\n      await transport.close();\n      console.log('Transport closed after session termination');\n      client = null;\n      transport = null;\n    } else {\n      console.log('Server responded with 405 Method Not Allowed (session termination not supported)');\n      console.log('Session ID is still active:', transport.sessionId);\n    }\n  } catch (error) {\n    console.error('Error terminating session:', error);\n  }\n}\n\nasync function reconnect(): Promise\u003Cvoid\u003E {\n  if (client) {\n    await disconnect();\n  }\n  await connect();\n}\n\nasync function listTools(): Promise\u003Cvoid\u003E {\n  if (!client) {\n    console.log('Not connected to server.');\n    return;\n  }\n\n  try {\n    const toolsRequest: ListToolsRequest = {\n      method: 'tools/list',\n      params: {}\n    };\n    const toolsResult = await client.request(toolsRequest, ListToolsResultSchema);\n\n    console.log('Available tools:');\n    if (toolsResult.tools.length === 0) {\n      console.log('  No tools available');\n    } else {\n      for (const tool of toolsResult.tools) {\n        console.log(`  - id: ${tool.name}, name: ${getDisplayName(tool)}, description: ${tool.description}`);\n      }\n    }\n  } catch (error) {\n    console.log(`Tools not supported by this server (${error})`);\n  }\n}\n\nasync function callTool(name: string, args: Record\u003Cstring, unknown\u003E): Promise\u003Cvoid\u003E {\n  if (!client) {\n    console.log('Not connected to server.');\n    return;\n  }\n\n  try {\n    const request: CallToolRequest = {\n      method: 'tools/call',\n      params: {\n        name,\n        arguments: args\n      }\n    };\n\n    console.log(`Calling tool '${name}' with args:`, args);\n    const result = await client.request(request, CallToolResultSchema);\n\n    console.log('Tool result:');\n    const resourceLinks: ResourceLink[] = [];\n\n    result.content.forEach(item =\u003E {\n      if (item.type === 'text') {\n        console.log(`  ${item.text}`);\n      } else if (item.type === 'resource_link') {\n        const resourceLink = item as ResourceLink;\n        resourceLinks.push(resourceLink);\n        console.log(`  📁 Resource Link: ${resourceLink.name}`);\n        console.log(`     URI: ${resourceLink.uri}`);\n        if (resourceLink.mimeType) {\n          console.log(`     Type: ${resourceLink.mimeType}`);\n        }\n        if (resourceLink.description) {\n          console.log(`     Description: ${resourceLink.description}`);\n        }\n      } else if (item.type === 'resource') {\n        console.log(`  [Embedded Resource: ${item.resource.uri}]`);\n      } else if (item.type === 'image') {\n        console.log(`  [Image: ${item.mimeType}]`);\n      } else if (item.type === 'audio') {\n        console.log(`  [Audio: ${item.mimeType}]`);\n      } else {\n        console.log(`  [Unknown content type]:`, item);\n      }\n    });\n\n    // Offer to read resource links\n    if (resourceLinks.length \u003E 0) {\n      console.log(`\\nFound ${resourceLinks.length} resource link(s). Use 'read-resource \u003Curi\u003E' to read their content.`);\n    }\n  } catch (error) {\n    console.log(`Error calling tool ${name}: ${error}`);\n  }\n}\n\n\nasync function callGreetTool(name: string): Promise\u003Cvoid\u003E {\n  await callTool('greet', { name });\n}\n\nasync function callMultiGreetTool(name: string): Promise\u003Cvoid\u003E {\n  console.log('Calling multi-greet tool with notifications...');\n  await callTool('multi-greet', { name });\n}\n\nasync function callCollectInfoTool(infoType: string): Promise\u003Cvoid\u003E {\n  console.log(`Testing elicitation with collect-user-info tool (${infoType})...`);\n  await callTool('collect-user-info', { infoType });\n}\n\nasync function startNotifications(interval: number, count: number): Promise\u003Cvoid\u003E {\n  console.log(`Starting notification stream: interval=${interval}ms, count=${count || 'unlimited'}`);\n  await callTool('start-notification-stream', { interval, count });\n}\n\nasync function runNotificationsToolWithResumability(interval: number, count: number): Promise\u003Cvoid\u003E {\n  if (!client) {\n    console.log('Not connected to server.');\n    return;\n  }\n\n  try {\n    console.log(`Starting notification stream with resumability: interval=${interval}ms, count=${count || 'unlimited'}`);\n    console.log(`Using resumption token: ${notificationsToolLastEventId || 'none'}`);\n\n    const request: CallToolRequest = {\n      method: 'tools/call',\n      params: {\n        name: 'start-notification-stream',\n        arguments: { interval, count }\n      }\n    };\n\n    const onLastEventIdUpdate = (event: string) =\u003E {\n      notificationsToolLastEventId = event;\n      console.log(`Updated resumption token: ${event}`);\n    };\n\n    const result = await client.request(request, CallToolResultSchema, {\n      resumptionToken: notificationsToolLastEventId,\n      onresumptiontoken: onLastEventIdUpdate\n    });\n\n    console.log('Tool result:');\n    result.content.forEach(item =\u003E {\n      if (item.type === 'text') {\n        console.log(`  ${item.text}`);\n      } else {\n        console.log(`  ${item.type} content:`, item);\n      }\n    });\n  } catch (error) {\n    console.log(`Error starting notification stream: ${error}`);\n  }\n}\n\nasync function listPrompts(): Promise\u003Cvoid\u003E {\n  if (!client) {\n    console.log('Not connected to server.');\n    return;\n  }\n\n  try {\n    const promptsRequest: ListPromptsRequest = {\n      method: 'prompts/list',\n      params: {}\n    };\n    const promptsResult = await client.request(promptsRequest, ListPromptsResultSchema);\n    console.log('Available prompts:');\n    if (promptsResult.prompts.length === 0) {\n      console.log('  No prompts available');\n    } else {\n      for (const prompt of promptsResult.prompts) {\n        console.log(`  - id: ${prompt.name}, name: ${getDisplayName(prompt)}, description: ${prompt.description}`);\n      }\n    }\n  } catch (error) {\n    console.log(`Prompts not supported by this server (${error})`);\n  }\n}\n\nasync function getPrompt(name: string, args: Record\u003Cstring, unknown\u003E): Promise\u003Cvoid\u003E {\n  if (!client) {\n    console.log('Not connected to server.');\n    return;\n  }\n\n  try {\n    const promptRequest: GetPromptRequest = {\n      method: 'prompts/get',\n      params: {\n        name,\n        arguments: args as Record\u003Cstring, string\u003E\n      }\n    };\n\n    const promptResult = await client.request(promptRequest, GetPromptResultSchema);\n    console.log('Prompt template:');\n    promptResult.messages.forEach((msg, index) =\u003E {\n      console.log(`  [${index + 1}] ${msg.role}: ${msg.content.text}`);\n    });\n  } catch (error) {\n    console.log(`Error getting prompt ${name}: ${error}`);\n  }\n}\n\nasync function listResources(): Promise\u003Cvoid\u003E {\n  if (!client) {\n    console.log('Not connected to server.');\n    return;\n  }\n\n  try {\n    const resourcesRequest: ListResourcesRequest = {\n      method: 'resources/list',\n      params: {}\n    };\n    const resourcesResult = await client.request(resourcesRequest, ListResourcesResultSchema);\n\n    console.log('Available resources:');\n    if (resourcesResult.resources.length === 0) {\n      console.log('  No resources available');\n    } else {\n      for (const resource of resourcesResult.resources) {\n        console.log(`  - id: ${resource.name}, name: ${getDisplayName(resource)}, description: ${resource.uri}`);\n      }\n    }\n  } catch (error) {\n    console.log(`Resources not supported by this server (${error})`);\n  }\n}\n\nasync function readResource(uri: string): Promise\u003Cvoid\u003E {\n  if (!client) {\n    console.log('Not connected to server.');\n    return;\n  }\n\n  try {\n    const request: ReadResourceRequest = {\n      method: 'resources/read',\n      params: { uri }\n    };\n\n    console.log(`Reading resource: ${uri}`);\n    const result = await client.request(request, ReadResourceResultSchema);\n\n    console.log('Resource contents:');\n    for (const content of result.contents) {\n      console.log(`  URI: ${content.uri}`);\n      if (content.mimeType) {\n        console.log(`  Type: ${content.mimeType}`);\n      }\n\n      if ('text' in content && typeof content.text === 'string') {\n        console.log('  Content:');\n        console.log('  ---');\n        console.log(content.text.split('\\n').map((line: string) =\u003E '  ' + line).join('\\n'));\n        console.log('  ---');\n      } else if ('blob' in content && typeof content.blob === 'string') {\n        console.log(`  [Binary data: ${content.blob.length} bytes]`);\n      }\n    }\n  } catch (error) {\n    console.log(`Error reading resource ${uri}: ${error}`);\n  }\n}\n\nasync function cleanup(): Promise\u003Cvoid\u003E {\n  if (client && transport) {\n    try {\n      // First try to terminate the session gracefully\n      if (transport.sessionId) {\n        try {\n          console.log('Terminating session before exit...');\n          await transport.terminateSession();\n          console.log('Session terminated successfully');\n        } catch (error) {\n          console.error('Error terminating session:', error);\n        }\n      }\n\n      // Then close the transport\n      await transport.close();\n    } catch (error) {\n      console.error('Error closing transport:', error);\n    }\n  }\n\n  process.stdin.setRawMode(false);\n  readline.close();\n  console.log('\\nGoodbye!');\n  process.exit(0);\n}\n\n// Set up raw mode for keyboard input to capture Escape key\nprocess.stdin.setRawMode(true);\nprocess.stdin.on('data', async (data) =\u003E {\n  // Check for Escape key (27)\n  if (data.length === 1 && data[0] === 27) {\n    console.log('\\nESC key pressed. Disconnecting from server...');\n\n    // Abort current operation and disconnect from server\n    if (client && transport) {\n      await disconnect();\n      console.log('Disconnected. Press Enter to continue.');\n    } else {\n      console.log('Not connected to server.');\n    }\n\n    // Re-display the prompt\n    process.stdout.write('\u003E ');\n  }\n});\n\n// Handle Ctrl+C\nprocess.on('SIGINT', async () =\u003E {\n  console.log('\\nReceived SIGINT. Cleaning up...');\n  await cleanup();\n});\n\n// Start the interactive client\nmain().catch((error: unknown) =\u003E {\n  console.error('Error running MCP client:', error);\n  process.exit(1);\n});",
      "hash": "b42b46ae6c2a7b185e8b37475eb01a9e804f754da6efa546bae295f6a0005008",
      "size": 26021
    },
    "/src/examples/client/streamableHttpWithSseFallbackClient.ts": {
      "type": "content",
      "content": "import { Client } from '../../client/index.js';\nimport { StreamableHTTPClientTransport } from '../../client/streamableHttp.js';\nimport { SSEClientTransport } from '../../client/sse.js';\nimport {\n  ListToolsRequest,\n  ListToolsResultSchema,\n  CallToolRequest,\n  CallToolResultSchema,\n  LoggingMessageNotificationSchema,\n} from '../../types.js';\n\n/**\n * Simplified Backwards Compatible MCP Client\n * \n * This client demonstrates backward compatibility with both:\n * 1. Modern servers using Streamable HTTP transport (protocol version 2025-03-26)\n * 2. Older servers using HTTP+SSE transport (protocol version 2024-11-05)\n * \n * Following the MCP specification for backwards compatibility:\n * - Attempts to POST an initialize request to the server URL first (modern transport)\n * - If that fails with 4xx status, falls back to GET request for SSE stream (older transport)\n */\n\n// Command line args processing\nconst args = process.argv.slice(2);\nconst serverUrl = args[0] || 'http://localhost:3000/mcp';\n\nasync function main(): Promise\u003Cvoid\u003E {\n  console.log('MCP Backwards Compatible Client');\n  console.log('===============================');\n  console.log(`Connecting to server at: ${serverUrl}`);\n\n  let client: Client;\n  let transport: StreamableHTTPClientTransport | SSEClientTransport;\n\n  try {\n    // Try connecting with automatic transport detection\n    const connection = await connectWithBackwardsCompatibility(serverUrl);\n    client = connection.client;\n    transport = connection.transport;\n\n    // Set up notification handler\n    client.setNotificationHandler(LoggingMessageNotificationSchema, (notification) =\u003E {\n      console.log(`Notification: ${notification.params.level} - ${notification.params.data}`);\n    });\n\n    // DEMO WORKFLOW:\n    // 1. List available tools\n    console.log('\\n=== Listing Available Tools ===');\n    await listTools(client);\n\n    // 2. Call the notification tool\n    console.log('\\n=== Starting Notification Stream ===');\n    await startNotificationTool(client);\n\n    // 3. Wait for all notifications (5 seconds)\n    console.log('\\n=== Waiting for all notifications ===');\n    await new Promise(resolve =\u003E setTimeout(resolve, 5000));\n\n    // 4. Disconnect\n    console.log('\\n=== Disconnecting ===');\n    await transport.close();\n    console.log('Disconnected from MCP server');\n\n  } catch (error) {\n    console.error('Error running client:', error);\n    process.exit(1);\n  }\n}\n\n/**\n * Connect to an MCP server with backwards compatibility\n * Following the spec for client backward compatibility\n */\nasync function connectWithBackwardsCompatibility(url: string): Promise\u003C{\n  client: Client,\n  transport: StreamableHTTPClientTransport | SSEClientTransport,\n  transportType: 'streamable-http' | 'sse'\n}\u003E {\n  console.log('1. Trying Streamable HTTP transport first...');\n\n  // Step 1: Try Streamable HTTP transport first\n  const client = new Client({\n    name: 'backwards-compatible-client',\n    version: '1.0.0'\n  });\n\n  client.onerror = (error) =\u003E {\n    console.error('Client error:', error);\n  };\n  const baseUrl = new URL(url);\n\n  try {\n    // Create modern transport\n    const streamableTransport = new StreamableHTTPClientTransport(baseUrl);\n    await client.connect(streamableTransport);\n\n    console.log('Successfully connected using modern Streamable HTTP transport.');\n    return {\n      client,\n      transport: streamableTransport,\n      transportType: 'streamable-http'\n    };\n  } catch (error) {\n    // Step 2: If transport fails, try the older SSE transport\n    console.log(`StreamableHttp transport connection failed: ${error}`);\n    console.log('2. Falling back to deprecated HTTP+SSE transport...');\n\n    try {\n      // Create SSE transport pointing to /sse endpoint\n      const sseTransport = new SSEClientTransport(baseUrl);\n      const sseClient = new Client({\n        name: 'backwards-compatible-client',\n        version: '1.0.0'\n      });\n      await sseClient.connect(sseTransport);\n\n      console.log('Successfully connected using deprecated HTTP+SSE transport.');\n      return {\n        client: sseClient,\n        transport: sseTransport,\n        transportType: 'sse'\n      };\n    } catch (sseError) {\n      console.error(`Failed to connect with either transport method:\\n1. Streamable HTTP error: ${error}\\n2. SSE error: ${sseError}`);\n      throw new Error('Could not connect to server with any available transport');\n    }\n  }\n}\n\n/**\n * List available tools on the server\n */\nasync function listTools(client: Client): Promise\u003Cvoid\u003E {\n  try {\n    const toolsRequest: ListToolsRequest = {\n      method: 'tools/list',\n      params: {}\n    };\n    const toolsResult = await client.request(toolsRequest, ListToolsResultSchema);\n\n    console.log('Available tools:');\n    if (toolsResult.tools.length === 0) {\n      console.log('  No tools available');\n    } else {\n      for (const tool of toolsResult.tools) {\n        console.log(`  - ${tool.name}: ${tool.description}`);\n      }\n    }\n  } catch (error) {\n    console.log(`Tools not supported by this server: ${error}`);\n  }\n}\n\n/**\n * Start a notification stream by calling the notification tool\n */\nasync function startNotificationTool(client: Client): Promise\u003Cvoid\u003E {\n  try {\n    // Call the notification tool using reasonable defaults\n    const request: CallToolRequest = {\n      method: 'tools/call',\n      params: {\n        name: 'start-notification-stream',\n        arguments: {\n          interval: 1000, // 1 second between notifications\n          count: 5       // Send 5 notifications\n        }\n      }\n    };\n\n    console.log('Calling notification tool...');\n    const result = await client.request(request, CallToolResultSchema);\n\n    console.log('Tool result:');\n    result.content.forEach(item =\u003E {\n      if (item.type === 'text') {\n        console.log(`  ${item.text}`);\n      } else {\n        console.log(`  ${item.type} content:`, item);\n      }\n    });\n  } catch (error) {\n    console.log(`Error calling notification tool: ${error}`);\n  }\n}\n\n// Start the client\nmain().catch((error: unknown) =\u003E {\n  console.error('Error running MCP client:', error);\n  process.exit(1);\n});",
      "hash": "4ef429ad0acacf33916ca9e67bafbb91906fdb9bde7958c12c58f9bb56f0f9ea",
      "size": 6095
    },
    "/src/examples/server/demoInMemoryOAuthProvider.ts": {
      "type": "content",
      "content": "import { randomUUID } from 'node:crypto';\nimport { AuthorizationParams, OAuthServerProvider } from '../../server/auth/provider.js';\nimport { OAuthRegisteredClientsStore } from '../../server/auth/clients.js';\nimport { OAuthClientInformationFull, OAuthMetadata, OAuthTokens } from '../../shared/auth.js';\nimport express, { Request, Response } from \"express\";\nimport { AuthInfo } from '../../server/auth/types.js';\nimport { createOAuthMetadata, mcpAuthRouter } from '../../server/auth/router.js';\nimport { resourceUrlFromServerUrl } from '../../shared/auth-utils.js';\n\n\nexport class DemoInMemoryClientsStore implements OAuthRegisteredClientsStore {\n  private clients = new Map\u003Cstring, OAuthClientInformationFull\u003E();\n\n  async getClient(clientId: string) {\n    return this.clients.get(clientId);\n  }\n\n  async registerClient(clientMetadata: OAuthClientInformationFull) {\n    this.clients.set(clientMetadata.client_id, clientMetadata);\n    return clientMetadata;\n  }\n}\n\n/**\n * 🚨 DEMO ONLY - NOT FOR PRODUCTION\n *\n * This example demonstrates MCP OAuth flow but lacks some of the features required for production use,\n * for example:\n * - Persistent token storage\n * - Rate limiting\n */\nexport class DemoInMemoryAuthProvider implements OAuthServerProvider {\n  clientsStore = new DemoInMemoryClientsStore();\n  private codes = new Map\u003Cstring, {\n    params: AuthorizationParams,\n    client: OAuthClientInformationFull}\u003E();\n  private tokens = new Map\u003Cstring, AuthInfo\u003E();\n\n  constructor(private validateResource?: (resource?: URL) =\u003E boolean) {}\n\n  async authorize(\n    client: OAuthClientInformationFull,\n    params: AuthorizationParams,\n    res: Response\n  ): Promise\u003Cvoid\u003E {\n    const code = randomUUID();\n\n    const searchParams = new URLSearchParams({\n      code,\n    });\n    if (params.state !== undefined) {\n      searchParams.set('state', params.state);\n    }\n\n    this.codes.set(code, {\n      client,\n      params\n    });\n\n    const targetUrl = new URL(client.redirect_uris[0]);\n    targetUrl.search = searchParams.toString();\n    res.redirect(targetUrl.toString());\n  }\n\n  async challengeForAuthorizationCode(\n    client: OAuthClientInformationFull,\n    authorizationCode: string\n  ): Promise\u003Cstring\u003E {\n\n    // Store the challenge with the code data\n    const codeData = this.codes.get(authorizationCode);\n    if (!codeData) {\n      throw new Error('Invalid authorization code');\n    }\n\n    return codeData.params.codeChallenge;\n  }\n\n  async exchangeAuthorizationCode(\n    client: OAuthClientInformationFull,\n    authorizationCode: string,\n    // Note: code verifier is checked in token.ts by default\n    // it's unused here for that reason.\n    _codeVerifier?: string\n  ): Promise\u003COAuthTokens\u003E {\n    const codeData = this.codes.get(authorizationCode);\n    if (!codeData) {\n      throw new Error('Invalid authorization code');\n    }\n\n    if (codeData.client.client_id !== client.client_id) {\n      throw new Error(`Authorization code was not issued to this client, ${codeData.client.client_id} != ${client.client_id}`);\n    }\n\n    if (this.validateResource && !this.validateResource(codeData.params.resource)) {\n      throw new Error(`Invalid resource: ${codeData.params.resource}`);\n    }\n\n    this.codes.delete(authorizationCode);\n    const token = randomUUID();\n\n    const tokenData = {\n      token,\n      clientId: client.client_id,\n      scopes: codeData.params.scopes || [],\n      expiresAt: Date.now() + 3600000, // 1 hour\n      resource: codeData.params.resource,\n      type: 'access',\n    };\n\n    this.tokens.set(token, tokenData);\n\n    return {\n      access_token: token,\n      token_type: 'bearer',\n      expires_in: 3600,\n      scope: (codeData.params.scopes || []).join(' '),\n    };\n  }\n\n  async exchangeRefreshToken(\n    _client: OAuthClientInformationFull,\n    _refreshToken: string,\n    _scopes?: string[],\n    _resource?: URL\n  ): Promise\u003COAuthTokens\u003E {\n    throw new Error('Not implemented for example demo');\n  }\n\n  async verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E {\n    const tokenData = this.tokens.get(token);\n    if (!tokenData || !tokenData.expiresAt || tokenData.expiresAt \u003C Date.now()) {\n      throw new Error('Invalid or expired token');\n    }\n\n    return {\n      token,\n      clientId: tokenData.clientId,\n      scopes: tokenData.scopes,\n      expiresAt: Math.floor(tokenData.expiresAt / 1000),\n      resource: tokenData.resource,\n    };\n  }\n}\n\n\nexport const setupAuthServer = ({authServerUrl, mcpServerUrl, strictResource}: {authServerUrl: URL, mcpServerUrl: URL, strictResource: boolean}): OAuthMetadata =\u003E {\n  // Create separate auth server app\n  // NOTE: This is a separate app on a separate port to illustrate\n  // how to separate an OAuth Authorization Server from a Resource\n  // server in the SDK. The SDK is not intended to be provide a standalone\n  // authorization server.\n\n  const validateResource = strictResource ? (resource?: URL) =\u003E {\n    if (!resource) return false;\n    const expectedResource = resourceUrlFromServerUrl(mcpServerUrl);\n    return resource.toString() === expectedResource.toString();\n  } : undefined;\n\n  const provider = new DemoInMemoryAuthProvider(validateResource);\n  const authApp = express();\n  authApp.use(express.json());\n  // For introspection requests\n  authApp.use(express.urlencoded());\n\n  // Add OAuth routes to the auth server\n  // NOTE: this will also add a protected resource metadata route,\n  // but it won't be used, so leave it.\n  authApp.use(mcpAuthRouter({\n    provider,\n    issuerUrl: authServerUrl,\n    scopesSupported: ['mcp:tools'],\n  }));\n\n  authApp.post('/introspect', async (req: Request, res: Response) =\u003E {\n    try {\n      const { token } = req.body;\n      if (!token) {\n        res.status(400).json({ error: 'Token is required' });\n        return;\n      }\n\n      const tokenInfo = await provider.verifyAccessToken(token);\n      res.json({\n        active: true,\n        client_id: tokenInfo.clientId,\n        scope: tokenInfo.scopes.join(' '),\n        exp: tokenInfo.expiresAt,\n        aud: tokenInfo.resource,\n      });\n      return\n    } catch (error) {\n      res.status(401).json({\n        active: false,\n        error: 'Unauthorized',\n        error_description: `Invalid token: ${error}`\n      });\n    }\n  });\n\n  const auth_port = authServerUrl.port;\n  // Start the auth server\n  authApp.listen(auth_port, (error) =\u003E {\n    if (error) {\n      console.error('Failed to start server:', error);\n      process.exit(1);\n    }\n    console.log(`OAuth Authorization Server listening on port ${auth_port}`);\n  });\n\n  // Note: we could fetch this from the server, but then we end up\n  // with some top level async which gets annoying.\n  const oauthMetadata: OAuthMetadata = createOAuthMetadata({\n    provider,\n    issuerUrl: authServerUrl,\n    scopesSupported: ['mcp:tools'],\n  })\n\n  oauthMetadata.introspection_endpoint = new URL(\"/introspect\", authServerUrl).href;\n\n  return oauthMetadata;\n}\n",
      "hash": "e2263a49dcc2cfc7b0fdf8f152c2cebec1603627f618bdf7faa22a8ceb877f4f",
      "size": 6887
    },
    "/src/examples/server/jsonResponseStreamableHttp.ts": {
      "type": "content",
      "content": "import express, { Request, Response } from 'express';\nimport { randomUUID } from 'node:crypto';\nimport { McpServer } from '../../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../../server/streamableHttp.js';\nimport { z } from 'zod';\nimport { CallToolResult, isInitializeRequest } from '../../types.js';\nimport cors from 'cors';\n\n\n// Create an MCP server with implementation details\nconst getServer = () =\u003E {\n  const server = new McpServer({\n    name: 'json-response-streamable-http-server',\n    version: '1.0.0',\n  }, {\n    capabilities: {\n      logging: {},\n    }\n  });\n\n  // Register a simple tool that returns a greeting\n  server.tool(\n    'greet',\n    'A simple greeting tool',\n    {\n      name: z.string().describe('Name to greet'),\n    },\n    async ({ name }): Promise\u003CCallToolResult\u003E =\u003E {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Hello, ${name}!`,\n          },\n        ],\n      };\n    }\n  );\n\n  // Register a tool that sends multiple greetings with notifications\n  server.tool(\n    'multi-greet',\n    'A tool that sends different greetings with delays between them',\n    {\n      name: z.string().describe('Name to greet'),\n    },\n    async ({ name }, { sendNotification }): Promise\u003CCallToolResult\u003E =\u003E {\n      const sleep = (ms: number) =\u003E new Promise(resolve =\u003E setTimeout(resolve, ms));\n\n      await sendNotification({\n        method: \"notifications/message\",\n        params: { level: \"debug\", data: `Starting multi-greet for ${name}` }\n      });\n\n      await sleep(1000); // Wait 1 second before first greeting\n\n      await sendNotification({\n        method: \"notifications/message\",\n        params: { level: \"info\", data: `Sending first greeting to ${name}` }\n      });\n\n      await sleep(1000); // Wait another second before second greeting\n\n      await sendNotification({\n        method: \"notifications/message\",\n        params: { level: \"info\", data: `Sending second greeting to ${name}` }\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Good morning, ${name}!`,\n          }\n        ],\n      };\n    }\n  );\n  return server;\n}\n\nconst app = express();\napp.use(express.json());\n\n// Configure CORS to expose Mcp-Session-Id header for browser-based clients\napp.use(cors({\n  origin: '*', // Allow all origins - adjust as needed for production\n  exposedHeaders: ['Mcp-Session-Id']\n}));\n\n// Map to store transports by session ID\nconst transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};\n\napp.post('/mcp', async (req: Request, res: Response) =\u003E {\n  console.log('Received MCP request:', req.body);\n  try {\n    // Check for existing session ID\n    const sessionId = req.headers['mcp-session-id'] as string | undefined;\n    let transport: StreamableHTTPServerTransport;\n\n    if (sessionId && transports[sessionId]) {\n      // Reuse existing transport\n      transport = transports[sessionId];\n    } else if (!sessionId && isInitializeRequest(req.body)) {\n      // New initialization request - use JSON response mode\n      transport = new StreamableHTTPServerTransport({\n        sessionIdGenerator: () =\u003E randomUUID(),\n        enableJsonResponse: true, // Enable JSON response mode\n        onsessioninitialized: (sessionId) =\u003E {\n          // Store the transport by session ID when session is initialized\n          // This avoids race conditions where requests might come in before the session is stored\n          console.log(`Session initialized with ID: ${sessionId}`);\n          transports[sessionId] = transport;\n        }\n      });\n\n      // Connect the transport to the MCP server BEFORE handling the request\n      const server = getServer();\n      await server.connect(transport);\n      await transport.handleRequest(req, res, req.body);\n      return; // Already handled\n    } else {\n      // Invalid request - no session ID or not initialization request\n      res.status(400).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32000,\n          message: 'Bad Request: No valid session ID provided',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    // Handle the request with existing transport - no need to reconnect\n    await transport.handleRequest(req, res, req.body);\n  } catch (error) {\n    console.error('Error handling MCP request:', error);\n    if (!res.headersSent) {\n      res.status(500).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32603,\n          message: 'Internal server error',\n        },\n        id: null,\n      });\n    }\n  }\n});\n\n// Handle GET requests for SSE streams according to spec\napp.get('/mcp', async (req: Request, res: Response) =\u003E {\n  // Since this is a very simple example, we don't support GET requests for this server\n  // The spec requires returning 405 Method Not Allowed in this case\n  res.status(405).set('Allow', 'POST').send('Method Not Allowed');\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, (error) =\u003E {\n  if (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n  console.log(`MCP Streamable HTTP Server listening on port ${PORT}`);\n});\n\n// Handle server shutdown\nprocess.on('SIGINT', async () =\u003E {\n  console.log('Shutting down server...');\n  process.exit(0);\n});",
      "hash": "ac1eeb9a9c82adc4483dc819483bf2d36e793a84f62305505078a0aa3aeff67e",
      "size": 5250
    },
    "/src/examples/server/mcpServerOutputSchema.ts": {
      "type": "content",
      "content": "#!/usr/bin/env node\n/**\n * Example MCP server using the high-level McpServer API with outputSchema\n * This demonstrates how to easily create tools with structured output\n */\n\nimport { McpServer } from \"../../server/mcp.js\";\nimport { StdioServerTransport } from \"../../server/stdio.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer(\n  {\n    name: \"mcp-output-schema-high-level-example\",\n    version: \"1.0.0\",\n  }\n);\n\n// Define a tool with structured output - Weather data\nserver.registerTool(\n  \"get_weather\",\n  {\n    description: \"Get weather information for a city\",\n    inputSchema: {\n      city: z.string().describe(\"City name\"),\n      country: z.string().describe(\"Country code (e.g., US, UK)\")\n    },\n    outputSchema: {\n      temperature: z.object({\n        celsius: z.number(),\n        fahrenheit: z.number()\n      }),\n      conditions: z.enum([\"sunny\", \"cloudy\", \"rainy\", \"stormy\", \"snowy\"]),\n      humidity: z.number().min(0).max(100),\n      wind: z.object({\n        speed_kmh: z.number(),\n        direction: z.string()\n      })\n    },\n  },\n  async ({ city, country }) =\u003E {\n    // Parameters are available but not used in this example\n    void city;\n    void country;\n    // Simulate weather API call\n    const temp_c = Math.round((Math.random() * 35 - 5) * 10) / 10;\n    const conditions = [\"sunny\", \"cloudy\", \"rainy\", \"stormy\", \"snowy\"][Math.floor(Math.random() * 5)];\n\n    const structuredContent = {\n      temperature: {\n        celsius: temp_c,\n        fahrenheit: Math.round((temp_c * 9 / 5 + 32) * 10) / 10\n      },\n      conditions,\n      humidity: Math.round(Math.random() * 100),\n      wind: {\n        speed_kmh: Math.round(Math.random() * 50),\n        direction: [\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\"][Math.floor(Math.random() * 8)]\n      }\n    };\n\n    return {\n      content: [{\n        type: \"text\",\n        text: JSON.stringify(structuredContent, null, 2)\n      }],\n      structuredContent\n    };\n  }\n);\n\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error(\"High-level Output Schema Example Server running on stdio\");\n}\n\nmain().catch((error) =\u003E {\n  console.error(\"Server error:\", error);\n  process.exit(1);\n});",
      "hash": "ff75c876c39591310ef7378c8d0e3fc94d58dfa6a58f7b0300e8f5bfbdff16a5",
      "size": 2220
    },
    "/src/examples/server/simpleSseServer.ts": {
      "type": "content",
      "content": "import express, { Request, Response } from 'express';\nimport { McpServer } from '../../server/mcp.js';\nimport { SSEServerTransport } from '../../server/sse.js';\nimport { z } from 'zod';\nimport { CallToolResult } from '../../types.js';\n\n/**\n * This example server demonstrates the deprecated HTTP+SSE transport \n * (protocol version 2024-11-05). It mainly used for testing backward compatible clients.\n * \n * The server exposes two endpoints:\n * - /mcp: For establishing the SSE stream (GET)\n * - /messages: For receiving client messages (POST)\n * \n */\n\n// Create an MCP server instance\nconst getServer = () =\u003E {\n  const server = new McpServer({\n    name: 'simple-sse-server',\n    version: '1.0.0',\n  }, { capabilities: { logging: {} } });\n\n  server.tool(\n    'start-notification-stream',\n    'Starts sending periodic notifications',\n    {\n      interval: z.number().describe('Interval in milliseconds between notifications').default(1000),\n      count: z.number().describe('Number of notifications to send').default(10),\n    },\n    async ({ interval, count }, { sendNotification }): Promise\u003CCallToolResult\u003E =\u003E {\n      const sleep = (ms: number) =\u003E new Promise(resolve =\u003E setTimeout(resolve, ms));\n      let counter = 0;\n\n      // Send the initial notification\n      await sendNotification({\n        method: \"notifications/message\",\n        params: {\n          level: \"info\",\n          data: `Starting notification stream with ${count} messages every ${interval}ms`\n        }\n      });\n\n      // Send periodic notifications\n      while (counter \u003C count) {\n        counter++;\n        await sleep(interval);\n\n        try {\n          await sendNotification({\n            method: \"notifications/message\",\n            params: {\n              level: \"info\",\n              data: `Notification #${counter} at ${new Date().toISOString()}`\n            }\n          });\n        }\n        catch (error) {\n          console.error(\"Error sending notification:\", error);\n        }\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Completed sending ${count} notifications every ${interval}ms`,\n          }\n        ],\n      };\n    }\n  );\n  return server;\n};\n\nconst app = express();\napp.use(express.json());\n\n// Store transports by session ID\nconst transports: Record\u003Cstring, SSEServerTransport\u003E = {};\n\n// SSE endpoint for establishing the stream\napp.get('/mcp', async (req: Request, res: Response) =\u003E {\n  console.log('Received GET request to /sse (establishing SSE stream)');\n\n  try {\n    // Create a new SSE transport for the client\n    // The endpoint for POST messages is '/messages'\n    const transport = new SSEServerTransport('/messages', res);\n\n    // Store the transport by session ID\n    const sessionId = transport.sessionId;\n    transports[sessionId] = transport;\n\n    // Set up onclose handler to clean up transport when closed\n    transport.onclose = () =\u003E {\n      console.log(`SSE transport closed for session ${sessionId}`);\n      delete transports[sessionId];\n    };\n\n    // Connect the transport to the MCP server\n    const server = getServer();\n    await server.connect(transport);\n\n    console.log(`Established SSE stream with session ID: ${sessionId}`);\n  } catch (error) {\n    console.error('Error establishing SSE stream:', error);\n    if (!res.headersSent) {\n      res.status(500).send('Error establishing SSE stream');\n    }\n  }\n});\n\n// Messages endpoint for receiving client JSON-RPC requests\napp.post('/messages', async (req: Request, res: Response) =\u003E {\n  console.log('Received POST request to /messages');\n\n  // Extract session ID from URL query parameter\n  // In the SSE protocol, this is added by the client based on the endpoint event\n  const sessionId = req.query.sessionId as string | undefined;\n\n  if (!sessionId) {\n    console.error('No session ID provided in request URL');\n    res.status(400).send('Missing sessionId parameter');\n    return;\n  }\n\n  const transport = transports[sessionId];\n  if (!transport) {\n    console.error(`No active transport found for session ID: ${sessionId}`);\n    res.status(404).send('Session not found');\n    return;\n  }\n\n  try {\n    // Handle the POST message with the transport\n    await transport.handlePostMessage(req, res, req.body);\n  } catch (error) {\n    console.error('Error handling request:', error);\n    if (!res.headersSent) {\n      res.status(500).send('Error handling request');\n    }\n  }\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, (error) =\u003E {\n  if (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n  console.log(`Simple SSE Server (deprecated protocol version 2024-11-05) listening on port ${PORT}`);\n});\n\n// Handle server shutdown\nprocess.on('SIGINT', async () =\u003E {\n  console.log('Shutting down server...');\n\n  // Close all active transports to properly clean up resources\n  for (const sessionId in transports) {\n    try {\n      console.log(`Closing transport for session ${sessionId}`);\n      await transports[sessionId].close();\n      delete transports[sessionId];\n    } catch (error) {\n      console.error(`Error closing transport for session ${sessionId}:`, error);\n    }\n  }\n  console.log('Server shutdown complete');\n  process.exit(0);\n});",
      "hash": "731f4ea57a2bd707e6ae8b4a28bf9e42619e1d8e22f66845f568dfbd10a8fa54",
      "size": 5217
    },
    "/src/examples/server/simpleStatelessStreamableHttp.ts": {
      "type": "content",
      "content": "import express, { Request, Response } from 'express';\nimport { McpServer } from '../../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../../server/streamableHttp.js';\nimport { z } from 'zod';\nimport { CallToolResult, GetPromptResult, ReadResourceResult } from '../../types.js';\nimport cors from 'cors';\n\nconst getServer = () =\u003E {\n  // Create an MCP server with implementation details\n  const server = new McpServer({\n    name: 'stateless-streamable-http-server',\n    version: '1.0.0',\n  }, { capabilities: { logging: {} } });\n\n  // Register a simple prompt\n  server.prompt(\n    'greeting-template',\n    'A simple greeting prompt template',\n    {\n      name: z.string().describe('Name to include in greeting'),\n    },\n    async ({ name }): Promise\u003CGetPromptResult\u003E =\u003E {\n      return {\n        messages: [\n          {\n            role: 'user',\n            content: {\n              type: 'text',\n              text: `Please greet ${name} in a friendly manner.`,\n            },\n          },\n        ],\n      };\n    }\n  );\n\n  // Register a tool specifically for testing resumability\n  server.tool(\n    'start-notification-stream',\n    'Starts sending periodic notifications for testing resumability',\n    {\n      interval: z.number().describe('Interval in milliseconds between notifications').default(100),\n      count: z.number().describe('Number of notifications to send (0 for 100)').default(10),\n    },\n    async ({ interval, count }, { sendNotification }): Promise\u003CCallToolResult\u003E =\u003E {\n      const sleep = (ms: number) =\u003E new Promise(resolve =\u003E setTimeout(resolve, ms));\n      let counter = 0;\n\n      while (count === 0 || counter \u003C count) {\n        counter++;\n        try {\n          await sendNotification({\n            method: \"notifications/message\",\n            params: {\n              level: \"info\",\n              data: `Periodic notification #${counter} at ${new Date().toISOString()}`\n            }\n          });\n        }\n        catch (error) {\n          console.error(\"Error sending notification:\", error);\n        }\n        // Wait for the specified interval\n        await sleep(interval);\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Started sending periodic notifications every ${interval}ms`,\n          }\n        ],\n      };\n    }\n  );\n\n  // Create a simple resource at a fixed URI\n  server.resource(\n    'greeting-resource',\n    'https://example.com/greetings/default',\n    { mimeType: 'text/plain' },\n    async (): Promise\u003CReadResourceResult\u003E =\u003E {\n      return {\n        contents: [\n          {\n            uri: 'https://example.com/greetings/default',\n            text: 'Hello, world!',\n          },\n        ],\n      };\n    }\n  );\n  return server;\n}\n\nconst app = express();\napp.use(express.json());\n\n// Configure CORS to expose Mcp-Session-Id header for browser-based clients\napp.use(cors({\n  origin: '*', // Allow all origins - adjust as needed for production\n  exposedHeaders: ['Mcp-Session-Id']\n}));\n\napp.post('/mcp', async (req: Request, res: Response) =\u003E {\n  const server = getServer();\n  try {\n    const transport: StreamableHTTPServerTransport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: undefined,\n    });\n    await server.connect(transport);\n    await transport.handleRequest(req, res, req.body);\n    res.on('close', () =\u003E {\n      console.log('Request closed');\n      transport.close();\n      server.close();\n    });\n  } catch (error) {\n    console.error('Error handling MCP request:', error);\n    if (!res.headersSent) {\n      res.status(500).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32603,\n          message: 'Internal server error',\n        },\n        id: null,\n      });\n    }\n  }\n});\n\napp.get('/mcp', async (req: Request, res: Response) =\u003E {\n  console.log('Received GET MCP request');\n  res.writeHead(405).end(JSON.stringify({\n    jsonrpc: \"2.0\",\n    error: {\n      code: -32000,\n      message: \"Method not allowed.\"\n    },\n    id: null\n  }));\n});\n\napp.delete('/mcp', async (req: Request, res: Response) =\u003E {\n  console.log('Received DELETE MCP request');\n  res.writeHead(405).end(JSON.stringify({\n    jsonrpc: \"2.0\",\n    error: {\n      code: -32000,\n      message: \"Method not allowed.\"\n    },\n    id: null\n  }));\n});\n\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, (error) =\u003E {\n  if (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n  console.log(`MCP Stateless Streamable HTTP Server listening on port ${PORT}`);\n});\n\n// Handle server shutdown\nprocess.on('SIGINT', async () =\u003E {\n  console.log('Shutting down server...');\n  process.exit(0);\n});",
      "hash": "793902d7d6ac52118fb59eaf1b111b8d9d4bf19010a232296ae88ac37c8714f6",
      "size": 4640
    },
    "/src/examples/server/simpleStreamableHttp.ts": {
      "type": "content",
      "content": "import express, { Request, Response } from 'express';\nimport { randomUUID } from 'node:crypto';\nimport { z } from 'zod';\nimport { McpServer } from '../../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../../server/streamableHttp.js';\nimport { getOAuthProtectedResourceMetadataUrl, mcpAuthMetadataRouter } from '../../server/auth/router.js';\nimport { requireBearerAuth } from '../../server/auth/middleware/bearerAuth.js';\nimport { CallToolResult, GetPromptResult, isInitializeRequest, PrimitiveSchemaDefinition, ReadResourceResult, ResourceLink } from '../../types.js';\nimport { InMemoryEventStore } from '../shared/inMemoryEventStore.js';\nimport { setupAuthServer } from './demoInMemoryOAuthProvider.js';\nimport { OAuthMetadata } from 'src/shared/auth.js';\nimport { checkResourceAllowed } from 'src/shared/auth-utils.js';\n\nimport cors from 'cors';\n\n// Check for OAuth flag\nconst useOAuth = process.argv.includes('--oauth');\nconst strictOAuth = process.argv.includes('--oauth-strict');\n\n// Create an MCP server with implementation details\nconst getServer = () =\u003E {\n  const server = new McpServer({\n    name: 'simple-streamable-http-server',\n    version: '1.0.0'\n  }, { capabilities: { logging: {} } });\n\n  // Register a simple tool that returns a greeting\n  server.registerTool(\n    'greet',\n    {\n      title: 'Greeting Tool',  // Display name for UI\n      description: 'A simple greeting tool',\n      inputSchema: {\n        name: z.string().describe('Name to greet'),\n      },\n    },\n    async ({ name }): Promise\u003CCallToolResult\u003E =\u003E {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Hello, ${name}!`,\n          },\n        ],\n      };\n    }\n  );\n\n  // Register a tool that sends multiple greetings with notifications (with annotations)\n  server.tool(\n    'multi-greet',\n    'A tool that sends different greetings with delays between them',\n    {\n      name: z.string().describe('Name to greet'),\n    },\n    {\n      title: 'Multiple Greeting Tool',\n      readOnlyHint: true,\n      openWorldHint: false\n    },\n    async ({ name }, { sendNotification }): Promise\u003CCallToolResult\u003E =\u003E {\n      const sleep = (ms: number) =\u003E new Promise(resolve =\u003E setTimeout(resolve, ms));\n\n      await sendNotification({\n        method: \"notifications/message\",\n        params: { level: \"debug\", data: `Starting multi-greet for ${name}` }\n      });\n\n      await sleep(1000); // Wait 1 second before first greeting\n\n      await sendNotification({\n        method: \"notifications/message\",\n        params: { level: \"info\", data: `Sending first greeting to ${name}` }\n      });\n\n      await sleep(1000); // Wait another second before second greeting\n\n      await sendNotification({\n        method: \"notifications/message\",\n        params: { level: \"info\", data: `Sending second greeting to ${name}` }\n      });\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Good morning, ${name}!`,\n          }\n        ],\n      };\n    }\n  );\n  // Register a tool that demonstrates elicitation (user input collection)\n  // This creates a closure that captures the server instance\n  server.tool(\n    'collect-user-info',\n    'A tool that collects user information through elicitation',\n    {\n      infoType: z.enum(['contact', 'preferences', 'feedback']).describe('Type of information to collect'),\n    },\n    async ({ infoType }): Promise\u003CCallToolResult\u003E =\u003E {\n      let message: string;\n      let requestedSchema: {\n        type: 'object';\n        properties: Record\u003Cstring, PrimitiveSchemaDefinition\u003E;\n        required?: string[];\n      };\n\n      switch (infoType) {\n        case 'contact':\n          message = 'Please provide your contact information';\n          requestedSchema = {\n            type: 'object',\n            properties: {\n              name: {\n                type: 'string',\n                title: 'Full Name',\n                description: 'Your full name',\n              },\n              email: {\n                type: 'string',\n                title: 'Email Address',\n                description: 'Your email address',\n                format: 'email',\n              },\n              phone: {\n                type: 'string',\n                title: 'Phone Number',\n                description: 'Your phone number (optional)',\n              },\n            },\n            required: ['name', 'email'],\n          };\n          break;\n        case 'preferences':\n          message = 'Please set your preferences';\n          requestedSchema = {\n            type: 'object',\n            properties: {\n              theme: {\n                type: 'string',\n                title: 'Theme',\n                description: 'Choose your preferred theme',\n                enum: ['light', 'dark', 'auto'],\n                enumNames: ['Light', 'Dark', 'Auto'],\n              },\n              notifications: {\n                type: 'boolean',\n                title: 'Enable Notifications',\n                description: 'Would you like to receive notifications?',\n                default: true,\n              },\n              frequency: {\n                type: 'string',\n                title: 'Notification Frequency',\n                description: 'How often would you like notifications?',\n                enum: ['daily', 'weekly', 'monthly'],\n                enumNames: ['Daily', 'Weekly', 'Monthly'],\n              },\n            },\n            required: ['theme'],\n          };\n          break;\n        case 'feedback':\n          message = 'Please provide your feedback';\n          requestedSchema = {\n            type: 'object',\n            properties: {\n              rating: {\n                type: 'integer',\n                title: 'Rating',\n                description: 'Rate your experience (1-5)',\n                minimum: 1,\n                maximum: 5,\n              },\n              comments: {\n                type: 'string',\n                title: 'Comments',\n                description: 'Additional comments (optional)',\n                maxLength: 500,\n              },\n              recommend: {\n                type: 'boolean',\n                title: 'Would you recommend this?',\n                description: 'Would you recommend this to others?',\n              },\n            },\n            required: ['rating', 'recommend'],\n          };\n          break;\n        default:\n          throw new Error(`Unknown info type: ${infoType}`);\n      }\n\n      try {\n        // Use the underlying server instance to elicit input from the client\n        const result = await server.server.elicitInput({\n          message,\n          requestedSchema,\n        });\n\n        if (result.action === 'accept') {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: `Thank you! Collected ${infoType} information: ${JSON.stringify(result.content, null, 2)}`,\n              },\n            ],\n          };\n        } else if (result.action === 'decline') {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: `No information was collected. User declined ${infoType} information request.`,\n              },\n            ],\n          };\n        } else {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: `Information collection was cancelled by the user.`,\n              },\n            ],\n          };\n        }\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error collecting ${infoType} information: ${error}`,\n            },\n          ],\n        };\n      }\n    }\n  );\n\n  // Register a simple prompt with title\n  server.registerPrompt(\n    'greeting-template',\n    {\n      title: 'Greeting Template',  // Display name for UI\n      description: 'A simple greeting prompt template',\n      argsSchema: {\n        name: z.string().describe('Name to include in greeting'),\n      },\n    },\n    async ({ name }): Promise\u003CGetPromptResult\u003E =\u003E {\n      return {\n        messages: [\n          {\n            role: 'user',\n            content: {\n              type: 'text',\n              text: `Please greet ${name} in a friendly manner.`,\n            },\n          },\n        ],\n      };\n    }\n  );\n\n  // Register a tool specifically for testing resumability\n  server.tool(\n    'start-notification-stream',\n    'Starts sending periodic notifications for testing resumability',\n    {\n      interval: z.number().describe('Interval in milliseconds between notifications').default(100),\n      count: z.number().describe('Number of notifications to send (0 for 100)').default(50),\n    },\n    async ({ interval, count }, { sendNotification }): Promise\u003CCallToolResult\u003E =\u003E {\n      const sleep = (ms: number) =\u003E new Promise(resolve =\u003E setTimeout(resolve, ms));\n      let counter = 0;\n\n      while (count === 0 || counter \u003C count) {\n        counter++;\n        try {\n          await sendNotification({\n            method: \"notifications/message\",\n            params: {\n              level: \"info\",\n              data: `Periodic notification #${counter} at ${new Date().toISOString()}`\n            }\n          });\n        }\n        catch (error) {\n          console.error(\"Error sending notification:\", error);\n        }\n        // Wait for the specified interval\n        await sleep(interval);\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Started sending periodic notifications every ${interval}ms`,\n          }\n        ],\n      };\n    }\n  );\n\n  // Create a simple resource at a fixed URI\n  server.registerResource(\n    'greeting-resource',\n    'https://example.com/greetings/default',\n    {\n      title: 'Default Greeting',  // Display name for UI\n      description: 'A simple greeting resource',\n      mimeType: 'text/plain'\n    },\n    async (): Promise\u003CReadResourceResult\u003E =\u003E {\n      return {\n        contents: [\n          {\n            uri: 'https://example.com/greetings/default',\n            text: 'Hello, world!',\n          },\n        ],\n      };\n    }\n  );\n\n  // Create additional resources for ResourceLink demonstration\n  server.registerResource(\n    'example-file-1',\n    'file:///example/file1.txt',\n    {\n      title: 'Example File 1',\n      description: 'First example file for ResourceLink demonstration',\n      mimeType: 'text/plain'\n    },\n    async (): Promise\u003CReadResourceResult\u003E =\u003E {\n      return {\n        contents: [\n          {\n            uri: 'file:///example/file1.txt',\n            text: 'This is the content of file 1',\n          },\n        ],\n      };\n    }\n  );\n\n  server.registerResource(\n    'example-file-2',\n    'file:///example/file2.txt',\n    {\n      title: 'Example File 2',\n      description: 'Second example file for ResourceLink demonstration',\n      mimeType: 'text/plain'\n    },\n    async (): Promise\u003CReadResourceResult\u003E =\u003E {\n      return {\n        contents: [\n          {\n            uri: 'file:///example/file2.txt',\n            text: 'This is the content of file 2',\n          },\n        ],\n      };\n    }\n  );\n\n  // Register a tool that returns ResourceLinks\n  server.registerTool(\n    'list-files',\n    {\n      title: 'List Files with ResourceLinks',\n      description: 'Returns a list of files as ResourceLinks without embedding their content',\n      inputSchema: {\n        includeDescriptions: z.boolean().optional().describe('Whether to include descriptions in the resource links'),\n      },\n    },\n    async ({ includeDescriptions = true }): Promise\u003CCallToolResult\u003E =\u003E {\n      const resourceLinks: ResourceLink[] = [\n        {\n          type: 'resource_link',\n          uri: 'https://example.com/greetings/default',\n          name: 'Default Greeting',\n          mimeType: 'text/plain',\n          ...(includeDescriptions && { description: 'A simple greeting resource' })\n        },\n        {\n          type: 'resource_link',\n          uri: 'file:///example/file1.txt',\n          name: 'Example File 1',\n          mimeType: 'text/plain',\n          ...(includeDescriptions && { description: 'First example file for ResourceLink demonstration' })\n        },\n        {\n          type: 'resource_link',\n          uri: 'file:///example/file2.txt',\n          name: 'Example File 2',\n          mimeType: 'text/plain',\n          ...(includeDescriptions && { description: 'Second example file for ResourceLink demonstration' })\n        }\n      ];\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: 'Here are the available files as resource links:',\n          },\n          ...resourceLinks,\n          {\n            type: 'text',\n            text: '\\nYou can read any of these resources using their URI.',\n          }\n        ],\n      };\n    }\n  );\n\n  return server;\n};\n\nconst MCP_PORT = process.env.MCP_PORT ? parseInt(process.env.MCP_PORT, 10) : 3000;\nconst AUTH_PORT = process.env.MCP_AUTH_PORT ? parseInt(process.env.MCP_AUTH_PORT, 10) : 3001;\n\nconst app = express();\napp.use(express.json());\n\n// Allow CORS all domains, expose the Mcp-Session-Id header\napp.use(cors({\n  origin: '*', // Allow all origins\n  exposedHeaders: [\"Mcp-Session-Id\"]\n}));\n\n// Set up OAuth if enabled\nlet authMiddleware = null;\nif (useOAuth) {\n  // Create auth middleware for MCP endpoints\n  const mcpServerUrl = new URL(`http://localhost:${MCP_PORT}/mcp`);\n  const authServerUrl = new URL(`http://localhost:${AUTH_PORT}`);\n\n  const oauthMetadata: OAuthMetadata = setupAuthServer({ authServerUrl, mcpServerUrl, strictResource: strictOAuth });\n\n  const tokenVerifier = {\n    verifyAccessToken: async (token: string) =\u003E {\n      const endpoint = oauthMetadata.introspection_endpoint;\n\n      if (!endpoint) {\n        throw new Error('No token verification endpoint available in metadata');\n      }\n\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        body: new URLSearchParams({\n          token: token\n        }).toString()\n      });\n\n\n      if (!response.ok) {\n        throw new Error(`Invalid or expired token: ${await response.text()}`);\n      }\n\n      const data = await response.json();\n\n      if (strictOAuth) {\n        if (!data.aud) {\n          throw new Error(`Resource Indicator (RFC8707) missing`);\n        }\n        if (!checkResourceAllowed({ requestedResource: data.aud, configuredResource: mcpServerUrl })) {\n          throw new Error(`Expected resource indicator ${mcpServerUrl}, got: ${data.aud}`);\n        }\n      }\n\n      // Convert the response to AuthInfo format\n      return {\n        token,\n        clientId: data.client_id,\n        scopes: data.scope ? data.scope.split(' ') : [],\n        expiresAt: data.exp,\n      };\n    }\n  }\n  // Add metadata routes to the main MCP server\n  app.use(mcpAuthMetadataRouter({\n    oauthMetadata,\n    resourceServerUrl: mcpServerUrl,\n    scopesSupported: ['mcp:tools'],\n    resourceName: 'MCP Demo Server',\n  }));\n\n  authMiddleware = requireBearerAuth({\n    verifier: tokenVerifier,\n    requiredScopes: [],\n    resourceMetadataUrl: getOAuthProtectedResourceMetadataUrl(mcpServerUrl),\n  });\n}\n\n// Map to store transports by session ID\nconst transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};\n\n// MCP POST endpoint with optional auth\nconst mcpPostHandler = async (req: Request, res: Response) =\u003E {\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  if (sessionId) {\n    console.log(`Received MCP request for session: ${sessionId}`);\n  } else {\n    console.log('Request body:', req.body);\n  }\n\n  if (useOAuth && req.auth) {\n    console.log('Authenticated user:', req.auth);\n  }\n  try {\n    let transport: StreamableHTTPServerTransport;\n    if (sessionId && transports[sessionId]) {\n      // Reuse existing transport\n      transport = transports[sessionId];\n    } else if (!sessionId && isInitializeRequest(req.body)) {\n      // New initialization request\n      const eventStore = new InMemoryEventStore();\n      transport = new StreamableHTTPServerTransport({\n        sessionIdGenerator: () =\u003E randomUUID(),\n        eventStore, // Enable resumability\n        onsessioninitialized: (sessionId) =\u003E {\n          // Store the transport by session ID when session is initialized\n          // This avoids race conditions where requests might come in before the session is stored\n          console.log(`Session initialized with ID: ${sessionId}`);\n          transports[sessionId] = transport;\n        }\n      });\n\n      // Set up onclose handler to clean up transport when closed\n      transport.onclose = () =\u003E {\n        const sid = transport.sessionId;\n        if (sid && transports[sid]) {\n          console.log(`Transport closed for session ${sid}, removing from transports map`);\n          delete transports[sid];\n        }\n      };\n\n      // Connect the transport to the MCP server BEFORE handling the request\n      // so responses can flow back through the same transport\n      const server = getServer();\n      await server.connect(transport);\n\n      await transport.handleRequest(req, res, req.body);\n      return; // Already handled\n    } else {\n      // Invalid request - no session ID or not initialization request\n      res.status(400).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32000,\n          message: 'Bad Request: No valid session ID provided',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    // Handle the request with existing transport - no need to reconnect\n    // The existing transport is already connected to the server\n    await transport.handleRequest(req, res, req.body);\n  } catch (error) {\n    console.error('Error handling MCP request:', error);\n    if (!res.headersSent) {\n      res.status(500).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32603,\n          message: 'Internal server error',\n        },\n        id: null,\n      });\n    }\n  }\n};\n\n// Set up routes with conditional auth middleware\nif (useOAuth && authMiddleware) {\n  app.post('/mcp', authMiddleware, mcpPostHandler);\n} else {\n  app.post('/mcp', mcpPostHandler);\n}\n\n// Handle GET requests for SSE streams (using built-in support from StreamableHTTP)\nconst mcpGetHandler = async (req: Request, res: Response) =\u003E {\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  if (!sessionId || !transports[sessionId]) {\n    res.status(400).send('Invalid or missing session ID');\n    return;\n  }\n\n  if (useOAuth && req.auth) {\n    console.log('Authenticated SSE connection from user:', req.auth);\n  }\n\n  // Check for Last-Event-ID header for resumability\n  const lastEventId = req.headers['last-event-id'] as string | undefined;\n  if (lastEventId) {\n    console.log(`Client reconnecting with Last-Event-ID: ${lastEventId}`);\n  } else {\n    console.log(`Establishing new SSE stream for session ${sessionId}`);\n  }\n\n  const transport = transports[sessionId];\n  await transport.handleRequest(req, res);\n};\n\n// Set up GET route with conditional auth middleware\nif (useOAuth && authMiddleware) {\n  app.get('/mcp', authMiddleware, mcpGetHandler);\n} else {\n  app.get('/mcp', mcpGetHandler);\n}\n\n// Handle DELETE requests for session termination (according to MCP spec)\nconst mcpDeleteHandler = async (req: Request, res: Response) =\u003E {\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  if (!sessionId || !transports[sessionId]) {\n    res.status(400).send('Invalid or missing session ID');\n    return;\n  }\n\n  console.log(`Received session termination request for session ${sessionId}`);\n\n  try {\n    const transport = transports[sessionId];\n    await transport.handleRequest(req, res);\n  } catch (error) {\n    console.error('Error handling session termination:', error);\n    if (!res.headersSent) {\n      res.status(500).send('Error processing session termination');\n    }\n  }\n};\n\n// Set up DELETE route with conditional auth middleware\nif (useOAuth && authMiddleware) {\n  app.delete('/mcp', authMiddleware, mcpDeleteHandler);\n} else {\n  app.delete('/mcp', mcpDeleteHandler);\n}\n\napp.listen(MCP_PORT, (error) =\u003E {\n  if (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n  console.log(`MCP Streamable HTTP Server listening on port ${MCP_PORT}`);\n});\n\n// Handle server shutdown\nprocess.on('SIGINT', async () =\u003E {\n  console.log('Shutting down server...');\n\n  // Close all active transports to properly clean up resources\n  for (const sessionId in transports) {\n    try {\n      console.log(`Closing transport for session ${sessionId}`);\n      await transports[sessionId].close();\n      delete transports[sessionId];\n    } catch (error) {\n      console.error(`Error closing transport for session ${sessionId}:`, error);\n    }\n  }\n  console.log('Server shutdown complete');\n  process.exit(0);\n});\n",
      "hash": "076102e8e08e83de6b8bfef17cffebf3d2da9fc6164fd4321f82bbeaad2bb8e1",
      "size": 20801
    },
    "/src/examples/server/sseAndStreamableHttpCompatibleServer.ts": {
      "type": "content",
      "content": "import express, { Request, Response } from 'express';\nimport { randomUUID } from \"node:crypto\";\nimport { McpServer } from '../../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../../server/streamableHttp.js';\nimport { SSEServerTransport } from '../../server/sse.js';\nimport { z } from 'zod';\nimport { CallToolResult, isInitializeRequest } from '../../types.js';\nimport { InMemoryEventStore } from '../shared/inMemoryEventStore.js';\nimport cors from 'cors';\n\n/**\n * This example server demonstrates backwards compatibility with both:\n * 1. The deprecated HTTP+SSE transport (protocol version 2024-11-05)\n * 2. The Streamable HTTP transport (protocol version 2025-03-26)\n * \n * It maintains a single MCP server instance but exposes two transport options:\n * - /mcp: The new Streamable HTTP endpoint (supports GET/POST/DELETE)\n * - /sse: The deprecated SSE endpoint for older clients (GET to establish stream)\n * - /messages: The deprecated POST endpoint for older clients (POST to send messages)\n */\n\nconst getServer = () =\u003E {\n  const server = new McpServer({\n    name: 'backwards-compatible-server',\n    version: '1.0.0',\n  }, { capabilities: { logging: {} } });\n\n  // Register a simple tool that sends notifications over time\n  server.tool(\n    'start-notification-stream',\n    'Starts sending periodic notifications for testing resumability',\n    {\n      interval: z.number().describe('Interval in milliseconds between notifications').default(100),\n      count: z.number().describe('Number of notifications to send (0 for 100)').default(50),\n    },\n    async ({ interval, count }, { sendNotification }): Promise\u003CCallToolResult\u003E =\u003E {\n      const sleep = (ms: number) =\u003E new Promise(resolve =\u003E setTimeout(resolve, ms));\n      let counter = 0;\n\n      while (count === 0 || counter \u003C count) {\n        counter++;\n        try {\n          await sendNotification({\n            method: \"notifications/message\",\n            params: {\n              level: \"info\",\n              data: `Periodic notification #${counter} at ${new Date().toISOString()}`\n            }\n          });\n        }\n        catch (error) {\n          console.error(\"Error sending notification:\", error);\n        }\n        // Wait for the specified interval\n        await sleep(interval);\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Started sending periodic notifications every ${interval}ms`,\n          }\n        ],\n      };\n    }\n  );\n  return server;\n};\n\n// Create Express application\nconst app = express();\napp.use(express.json());\n\n// Configure CORS to expose Mcp-Session-Id header for browser-based clients\napp.use(cors({\n  origin: '*', // Allow all origins - adjust as needed for production\n  exposedHeaders: ['Mcp-Session-Id']\n}));\n\n// Store transports by session ID\nconst transports: Record\u003Cstring, StreamableHTTPServerTransport | SSEServerTransport\u003E = {};\n\n//=============================================================================\n// STREAMABLE HTTP TRANSPORT (PROTOCOL VERSION 2025-03-26)\n//=============================================================================\n\n// Handle all MCP Streamable HTTP requests (GET, POST, DELETE) on a single endpoint\napp.all('/mcp', async (req: Request, res: Response) =\u003E {\n  console.log(`Received ${req.method} request to /mcp`);\n\n  try {\n    // Check for existing session ID\n    const sessionId = req.headers['mcp-session-id'] as string | undefined;\n    let transport: StreamableHTTPServerTransport;\n\n    if (sessionId && transports[sessionId]) {\n      // Check if the transport is of the correct type\n      const existingTransport = transports[sessionId];\n      if (existingTransport instanceof StreamableHTTPServerTransport) {\n        // Reuse existing transport\n        transport = existingTransport;\n      } else {\n        // Transport exists but is not a StreamableHTTPServerTransport (could be SSEServerTransport)\n        res.status(400).json({\n          jsonrpc: '2.0',\n          error: {\n            code: -32000,\n            message: 'Bad Request: Session exists but uses a different transport protocol',\n          },\n          id: null,\n        });\n        return;\n      }\n    } else if (!sessionId && req.method === 'POST' && isInitializeRequest(req.body)) {\n      const eventStore = new InMemoryEventStore();\n      transport = new StreamableHTTPServerTransport({\n        sessionIdGenerator: () =\u003E randomUUID(),\n        eventStore, // Enable resumability\n        onsessioninitialized: (sessionId) =\u003E {\n          // Store the transport by session ID when session is initialized\n          console.log(`StreamableHTTP session initialized with ID: ${sessionId}`);\n          transports[sessionId] = transport;\n        }\n      });\n\n      // Set up onclose handler to clean up transport when closed\n      transport.onclose = () =\u003E {\n        const sid = transport.sessionId;\n        if (sid && transports[sid]) {\n          console.log(`Transport closed for session ${sid}, removing from transports map`);\n          delete transports[sid];\n        }\n      };\n\n      // Connect the transport to the MCP server\n      const server = getServer();\n      await server.connect(transport);\n    } else {\n      // Invalid request - no session ID or not initialization request\n      res.status(400).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32000,\n          message: 'Bad Request: No valid session ID provided',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    // Handle the request with the transport\n    await transport.handleRequest(req, res, req.body);\n  } catch (error) {\n    console.error('Error handling MCP request:', error);\n    if (!res.headersSent) {\n      res.status(500).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32603,\n          message: 'Internal server error',\n        },\n        id: null,\n      });\n    }\n  }\n});\n\n//=============================================================================\n// DEPRECATED HTTP+SSE TRANSPORT (PROTOCOL VERSION 2024-11-05)\n//=============================================================================\n\napp.get('/sse', async (req: Request, res: Response) =\u003E {\n  console.log('Received GET request to /sse (deprecated SSE transport)');\n  const transport = new SSEServerTransport('/messages', res);\n  transports[transport.sessionId] = transport;\n  res.on(\"close\", () =\u003E {\n    delete transports[transport.sessionId];\n  });\n  const server = getServer();\n  await server.connect(transport);\n});\n\napp.post(\"/messages\", async (req: Request, res: Response) =\u003E {\n  const sessionId = req.query.sessionId as string;\n  let transport: SSEServerTransport;\n  const existingTransport = transports[sessionId];\n  if (existingTransport instanceof SSEServerTransport) {\n    // Reuse existing transport\n    transport = existingTransport;\n  } else {\n    // Transport exists but is not a SSEServerTransport (could be StreamableHTTPServerTransport)\n    res.status(400).json({\n      jsonrpc: '2.0',\n      error: {\n        code: -32000,\n        message: 'Bad Request: Session exists but uses a different transport protocol',\n      },\n      id: null,\n    });\n    return;\n  }\n  if (transport) {\n    await transport.handlePostMessage(req, res, req.body);\n  } else {\n    res.status(400).send('No transport found for sessionId');\n  }\n});\n\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, (error) =\u003E {\n  if (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n  console.log(`Backwards compatible MCP server listening on port ${PORT}`);\n  console.log(`\n==============================================\nSUPPORTED TRANSPORT OPTIONS:\n\n1. Streamable Http(Protocol version: 2025-03-26)\n   Endpoint: /mcp\n   Methods: GET, POST, DELETE\n   Usage: \n     - Initialize with POST to /mcp\n     - Establish SSE stream with GET to /mcp\n     - Send requests with POST to /mcp\n     - Terminate session with DELETE to /mcp\n\n2. Http + SSE (Protocol version: 2024-11-05)\n   Endpoints: /sse (GET) and /messages (POST)\n   Usage:\n     - Establish SSE stream with GET to /sse\n     - Send requests with POST to /messages?sessionId=\u003Cid\u003E\n==============================================\n`);\n});\n\n// Handle server shutdown\nprocess.on('SIGINT', async () =\u003E {\n  console.log('Shutting down server...');\n\n  // Close all active transports to properly clean up resources\n  for (const sessionId in transports) {\n    try {\n      console.log(`Closing transport for session ${sessionId}`);\n      await transports[sessionId].close();\n      delete transports[sessionId];\n    } catch (error) {\n      console.error(`Error closing transport for session ${sessionId}:`, error);\n    }\n  }\n  console.log('Server shutdown complete');\n  process.exit(0);\n});",
      "hash": "6950a813615ae974066d04f8757502ef01b2c7e1cc250ffceeaedbbe145b60af",
      "size": 8706
    },
    "/src/examples/server/standaloneSseWithGetStreamableHttp.ts": {
      "type": "content",
      "content": "import express, { Request, Response } from 'express';\nimport { randomUUID } from 'node:crypto';\nimport { McpServer } from '../../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../../server/streamableHttp.js';\nimport { isInitializeRequest, ReadResourceResult } from '../../types.js';\n\n// Create an MCP server with implementation details\nconst server = new McpServer({\n  name: 'resource-list-changed-notification-server',\n  version: '1.0.0',\n});\n\n// Store transports by session ID to send notifications\nconst transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};\n\nconst addResource = (name: string, content: string) =\u003E {\n  const uri = `https://mcp-example.com/dynamic/${encodeURIComponent(name)}`;\n  server.resource(\n    name,\n    uri,\n    { mimeType: 'text/plain', description: `Dynamic resource: ${name}` },\n    async (): Promise\u003CReadResourceResult\u003E =\u003E {\n      return {\n        contents: [{ uri, text: content }],\n      };\n    }\n  );\n\n};\n\naddResource('example-resource', 'Initial content for example-resource');\n\nconst resourceChangeInterval = setInterval(() =\u003E {\n  const name = randomUUID();\n  addResource(name, `Content for ${name}`);\n}, 5000); // Change resources every 5 seconds for testing\n\nconst app = express();\napp.use(express.json());\n\napp.post('/mcp', async (req: Request, res: Response) =\u003E {\n  console.log('Received MCP request:', req.body);\n  try {\n    // Check for existing session ID\n    const sessionId = req.headers['mcp-session-id'] as string | undefined;\n    let transport: StreamableHTTPServerTransport;\n\n    if (sessionId && transports[sessionId]) {\n      // Reuse existing transport\n      transport = transports[sessionId];\n    } else if (!sessionId && isInitializeRequest(req.body)) {\n      // New initialization request\n      transport = new StreamableHTTPServerTransport({\n        sessionIdGenerator: () =\u003E randomUUID(),\n        onsessioninitialized: (sessionId) =\u003E {\n          // Store the transport by session ID when session is initialized\n          // This avoids race conditions where requests might come in before the session is stored\n          console.log(`Session initialized with ID: ${sessionId}`);\n          transports[sessionId] = transport;\n        }\n      });\n\n      // Connect the transport to the MCP server\n      await server.connect(transport);\n\n      // Handle the request - the onsessioninitialized callback will store the transport\n      await transport.handleRequest(req, res, req.body);\n      return; // Already handled\n    } else {\n      // Invalid request - no session ID or not initialization request\n      res.status(400).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32000,\n          message: 'Bad Request: No valid session ID provided',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    // Handle the request with existing transport\n    await transport.handleRequest(req, res, req.body);\n  } catch (error) {\n    console.error('Error handling MCP request:', error);\n    if (!res.headersSent) {\n      res.status(500).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32603,\n          message: 'Internal server error',\n        },\n        id: null,\n      });\n    }\n  }\n});\n\n// Handle GET requests for SSE streams (now using built-in support from StreamableHTTP)\napp.get('/mcp', async (req: Request, res: Response) =\u003E {\n  const sessionId = req.headers['mcp-session-id'] as string | undefined;\n  if (!sessionId || !transports[sessionId]) {\n    res.status(400).send('Invalid or missing session ID');\n    return;\n  }\n\n  console.log(`Establishing SSE stream for session ${sessionId}`);\n  const transport = transports[sessionId];\n  await transport.handleRequest(req, res);\n});\n\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, (error) =\u003E {\n  if (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n  console.log(`Server listening on port ${PORT}`);\n});\n\n// Handle server shutdown\nprocess.on('SIGINT', async () =\u003E {\n  console.log('Shutting down server...');\n  clearInterval(resourceChangeInterval);\n  await server.close();\n  process.exit(0);\n});",
      "hash": "b6e167655d7dfc20b68964f7e6927642f46471dd7cbc324298c40695186b4f96",
      "size": 4114
    },
    "/src/examples/server/toolWithSampleServer.ts": {
      "type": "content",
      "content": "\n// Run with: npx tsx src/examples/server/toolWithSampleServer.ts\n\nimport { McpServer } from \"../../server/mcp.js\";\nimport { StdioServerTransport } from \"../../server/stdio.js\";\nimport { z } from \"zod\";\n\nconst mcpServer = new McpServer({\n  name: \"tools-with-sample-server\",\n  version: \"1.0.0\",\n});\n\n// Tool that uses LLM sampling to summarize any text\nmcpServer.registerTool(\n  \"summarize\",\n  {\n    description: \"Summarize any text using an LLM\",\n    inputSchema: {\n      text: z.string().describe(\"Text to summarize\"),\n    },\n  },\n  async ({ text }) =\u003E {\n    // Call the LLM through MCP sampling\n    const response = await mcpServer.server.createMessage({\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Please summarize the following text concisely:\\n\\n${text}`,\n          },\n        },\n      ],\n      maxTokens: 500,\n    });\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: response.content.type === \"text\" ? response.content.text : \"Unable to generate summary\",\n        },\n      ],\n    };\n  }\n);\n\nasync function main() {\n  const transport = new StdioServerTransport();\n  await mcpServer.connect(transport);\n  console.log(\"MCP server is running...\");\n}\n\nmain().catch((error) =\u003E {\n  console.error(\"Server error:\", error);\n  process.exit(1);\n});",
      "hash": "1a36ed0c4331b111b1cd2a26052b02f71d560b52b17af60404ca48d8ea6ed4f6",
      "size": 1348
    },
    "/src/examples/shared/inMemoryEventStore.ts": {
      "type": "content",
      "content": "import { JSONRPCMessage } from '../../types.js';\nimport { EventStore } from '../../server/streamableHttp.js';\n\n/**\n * Simple in-memory implementation of the EventStore interface for resumability\n * This is primarily intended for examples and testing, not for production use\n * where a persistent storage solution would be more appropriate.\n */\nexport class InMemoryEventStore implements EventStore {\n  private events: Map\u003Cstring, { streamId: string, message: JSONRPCMessage }\u003E = new Map();\n\n  /**\n   * Generates a unique event ID for a given stream ID\n   */\n  private generateEventId(streamId: string): string {\n    return `${streamId}_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;\n  }\n\n  /**\n   * Extracts the stream ID from an event ID\n   */\n  private getStreamIdFromEventId(eventId: string): string {\n    const parts = eventId.split('_');\n    return parts.length \u003E 0 ? parts[0] : '';\n  }\n\n  /**\n   * Stores an event with a generated event ID\n   * Implements EventStore.storeEvent\n   */\n  async storeEvent(streamId: string, message: JSONRPCMessage): Promise\u003Cstring\u003E {\n    const eventId = this.generateEventId(streamId);\n    this.events.set(eventId, { streamId, message });\n    return eventId;\n  }\n\n  /**\n   * Replays events that occurred after a specific event ID\n   * Implements EventStore.replayEventsAfter\n   */\n  async replayEventsAfter(lastEventId: string,\n    { send }: { send: (eventId: string, message: JSONRPCMessage) =\u003E Promise\u003Cvoid\u003E }\n  ): Promise\u003Cstring\u003E {\n    if (!lastEventId || !this.events.has(lastEventId)) {\n      return '';\n    }\n\n    // Extract the stream ID from the event ID\n    const streamId = this.getStreamIdFromEventId(lastEventId);\n    if (!streamId) {\n      return '';\n    }\n\n    let foundLastEvent = false;\n\n    // Sort events by eventId for chronological ordering\n    const sortedEvents = [...this.events.entries()].sort((a, b) =\u003E a[0].localeCompare(b[0]));\n\n    for (const [eventId, { streamId: eventStreamId, message }] of sortedEvents) {\n      // Only include events from the same stream\n      if (eventStreamId !== streamId) {\n        continue;\n      }\n\n      // Start sending events after we find the lastEventId\n      if (eventId === lastEventId) {\n        foundLastEvent = true;\n        continue;\n      }\n\n      if (foundLastEvent) {\n        await send(eventId, message);\n      }\n    }\n    return streamId;\n  }\n}",
      "hash": "01d76ef539f57fffd425d0b56e7bd210779db20ae2450aa3597552569d23e0fd",
      "size": 2369
    },
    "/src/inMemory.test.ts": {
      "type": "content",
      "content": "import { InMemoryTransport } from \"./inMemory.js\";\nimport { JSONRPCMessage } from \"./types.js\";\nimport { AuthInfo } from \"./server/auth/types.js\";\n\ndescribe(\"InMemoryTransport\", () =\u003E {\n  let clientTransport: InMemoryTransport;\n  let serverTransport: InMemoryTransport;\n\n  beforeEach(() =\u003E {\n    [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n  });\n\n  test(\"should create linked pair\", () =\u003E {\n    expect(clientTransport).toBeDefined();\n    expect(serverTransport).toBeDefined();\n  });\n\n  test(\"should start without error\", async () =\u003E {\n    await expect(clientTransport.start()).resolves.not.toThrow();\n    await expect(serverTransport.start()).resolves.not.toThrow();\n  });\n\n  test(\"should send message from client to server\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      id: 1,\n    };\n\n    let receivedMessage: JSONRPCMessage | undefined;\n    serverTransport.onmessage = (msg) =\u003E {\n      receivedMessage = msg;\n    };\n\n    await clientTransport.send(message);\n    expect(receivedMessage).toEqual(message);\n  });\n\n  test(\"should send message with auth info from client to server\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      id: 1,\n    };\n\n    const authInfo: AuthInfo = {\n      token: \"test-token\",\n      clientId: \"test-client\",\n      scopes: [\"read\", \"write\"],\n      expiresAt: Date.now() / 1000 + 3600,\n    };\n\n    let receivedMessage: JSONRPCMessage | undefined;\n    let receivedAuthInfo: AuthInfo | undefined;\n    serverTransport.onmessage = (msg, extra) =\u003E {\n      receivedMessage = msg;\n      receivedAuthInfo = extra?.authInfo;\n    };\n\n    await clientTransport.send(message, { authInfo });\n    expect(receivedMessage).toEqual(message);\n    expect(receivedAuthInfo).toEqual(authInfo);\n  });\n\n  test(\"should send message from server to client\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      id: 1,\n    };\n\n    let receivedMessage: JSONRPCMessage | undefined;\n    clientTransport.onmessage = (msg) =\u003E {\n      receivedMessage = msg;\n    };\n\n    await serverTransport.send(message);\n    expect(receivedMessage).toEqual(message);\n  });\n\n  test(\"should handle close\", async () =\u003E {\n    let clientClosed = false;\n    let serverClosed = false;\n\n    clientTransport.onclose = () =\u003E {\n      clientClosed = true;\n    };\n\n    serverTransport.onclose = () =\u003E {\n      serverClosed = true;\n    };\n\n    await clientTransport.close();\n    expect(clientClosed).toBe(true);\n    expect(serverClosed).toBe(true);\n  });\n\n  test(\"should throw error when sending after close\", async () =\u003E {\n    await clientTransport.close();\n    await expect(\n      clientTransport.send({ jsonrpc: \"2.0\", method: \"test\", id: 1 }),\n    ).rejects.toThrow(\"Not connected\");\n  });\n\n  test(\"should queue messages sent before start\", async () =\u003E {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      id: 1,\n    };\n\n    let receivedMessage: JSONRPCMessage | undefined;\n    serverTransport.onmessage = (msg) =\u003E {\n      receivedMessage = msg;\n    };\n\n    await clientTransport.send(message);\n    await serverTransport.start();\n    expect(receivedMessage).toEqual(message);\n  });\n});\n",
      "hash": "7176d6d44c7495d57af8c2ac68c3cbb6dd6ad1c259191800e09f9b51ae17e0c3",
      "size": 3280
    },
    "/src/inMemory.ts": {
      "type": "content",
      "content": "import { Transport } from \"./shared/transport.js\";\nimport { JSONRPCMessage, RequestId } from \"./types.js\";\nimport { AuthInfo } from \"./server/auth/types.js\";\n\ninterface QueuedMessage {\n  message: JSONRPCMessage;\n  extra?: { authInfo?: AuthInfo };\n}\n\n/**\n * In-memory transport for creating clients and servers that talk to each other within the same process.\n */\nexport class InMemoryTransport implements Transport {\n  private _otherTransport?: InMemoryTransport;\n  private _messageQueue: QueuedMessage[] = [];\n\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: JSONRPCMessage, extra?: { authInfo?: AuthInfo }) =\u003E void;\n  sessionId?: string;\n\n  /**\n   * Creates a pair of linked in-memory transports that can communicate with each other. One should be passed to a Client and one to a Server.\n   */\n  static createLinkedPair(): [InMemoryTransport, InMemoryTransport] {\n    const clientTransport = new InMemoryTransport();\n    const serverTransport = new InMemoryTransport();\n    clientTransport._otherTransport = serverTransport;\n    serverTransport._otherTransport = clientTransport;\n    return [clientTransport, serverTransport];\n  }\n\n  async start(): Promise\u003Cvoid\u003E {\n    // Process any messages that were queued before start was called\n    while (this._messageQueue.length \u003E 0) {\n      const queuedMessage = this._messageQueue.shift()!;\n      this.onmessage?.(queuedMessage.message, queuedMessage.extra);\n    }\n  }\n\n  async close(): Promise\u003Cvoid\u003E {\n    const other = this._otherTransport;\n    this._otherTransport = undefined;\n    await other?.close();\n    this.onclose?.();\n  }\n\n  /**\n   * Sends a message with optional auth info.\n   * This is useful for testing authentication scenarios.\n   */\n  async send(message: JSONRPCMessage, options?: { relatedRequestId?: RequestId, authInfo?: AuthInfo }): Promise\u003Cvoid\u003E {\n    if (!this._otherTransport) {\n      throw new Error(\"Not connected\");\n    }\n\n    if (this._otherTransport.onmessage) {\n      this._otherTransport.onmessage(message, { authInfo: options?.authInfo });\n    } else {\n      this._otherTransport._messageQueue.push({ message, extra: { authInfo: options?.authInfo } });\n    }\n  }\n}\n",
      "hash": "be1138548ef7ebd81849fcbd6a30fce8fcdd8726f1b445fb2efc862f1e8b0bbb",
      "size": 2179
    },
    "/src/integration-tests/process-cleanup.test.ts": {
      "type": "content",
      "content": "import { Server } from \"../server/index.js\";\nimport { StdioServerTransport } from \"../server/stdio.js\";\n\ndescribe(\"Process cleanup\", () =\u003E {\n  jest.setTimeout(5000); // 5 second timeout\n\n  it(\"should exit cleanly after closing transport\", async () =\u003E {\n    const server = new Server(\n      {\n        name: \"test-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {},\n      }\n    );\n\n    const transport = new StdioServerTransport();\n    await server.connect(transport);\n\n    // Close the transport\n    await transport.close();\n\n    // If we reach here without hanging, the test passes\n    // The test runner will fail if the process hangs\n    expect(true).toBe(true);\n  });\n});",
      "hash": "261491e76ef85c3f845f18cf921f04be7af22ddd3eca4c780de6e840eb96469b",
      "size": 700
    },
    "/src/integration-tests/stateManagementStreamableHttp.test.ts": {
      "type": "content",
      "content": "import { createServer, type Server } from 'node:http';\nimport { AddressInfo } from 'node:net';\nimport { randomUUID } from 'node:crypto';\nimport { Client } from '../client/index.js';\nimport { StreamableHTTPClientTransport } from '../client/streamableHttp.js';\nimport { McpServer } from '../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../server/streamableHttp.js';\nimport { CallToolResultSchema, ListToolsResultSchema, ListResourcesResultSchema, ListPromptsResultSchema, LATEST_PROTOCOL_VERSION } from '../types.js';\nimport { z } from 'zod';\n\ndescribe('Streamable HTTP Transport Session Management', () =\u003E {\n  // Function to set up the server with optional session management\n  async function setupServer(withSessionManagement: boolean) {\n    const server: Server = createServer();\n    const mcpServer = new McpServer(\n      { name: 'test-server', version: '1.0.0' },\n      {\n        capabilities: {\n          logging: {},\n          tools: {},\n          resources: {},\n          prompts: {}\n        }\n      }\n    );\n\n    // Add a simple resource\n    mcpServer.resource(\n      'test-resource',\n      '/test',\n      { description: 'A test resource' },\n      async () =\u003E ({\n        contents: [{\n          uri: '/test',\n          text: 'This is a test resource content'\n        }]\n      })\n    );\n\n    mcpServer.prompt(\n      'test-prompt',\n      'A test prompt',\n      async () =\u003E ({\n        messages: [{\n          role: 'user',\n          content: {\n            type: 'text',\n            text: 'This is a test prompt'\n          }\n        }]\n      })\n    );\n\n    mcpServer.tool(\n      'greet',\n      'A simple greeting tool',\n      {\n        name: z.string().describe('Name to greet').default('World'),\n      },\n      async ({ name }) =\u003E {\n        return {\n          content: [{ type: 'text', text: `Hello, ${name}!` }]\n        };\n      }\n    );\n\n    // Create transport with or without session management\n    const serverTransport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: withSessionManagement\n        ? () =\u003E randomUUID()   // With session management, generate UUID\n        : undefined     // Without session management, return undefined\n    });\n\n    await mcpServer.connect(serverTransport);\n\n    server.on('request', async (req, res) =\u003E {\n      await serverTransport.handleRequest(req, res);\n    });\n\n    // Start the server on a random port\n    const baseUrl = await new Promise\u003CURL\u003E((resolve) =\u003E {\n      server.listen(0, '127.0.0.1', () =\u003E {\n        const addr = server.address() as AddressInfo;\n        resolve(new URL(`http://127.0.0.1:${addr.port}`));\n      });\n    });\n\n    return { server, mcpServer, serverTransport, baseUrl };\n  }\n\n  describe('Stateless Mode', () =\u003E {\n    let server: Server;\n    let mcpServer: McpServer;\n    let serverTransport: StreamableHTTPServerTransport;\n    let baseUrl: URL;\n\n    beforeEach(async () =\u003E {\n      const setup = await setupServer(false);\n      server = setup.server;\n      mcpServer = setup.mcpServer;\n      serverTransport = setup.serverTransport;\n      baseUrl = setup.baseUrl;\n    });\n\n    afterEach(async () =\u003E {\n      // Clean up resources\n      await mcpServer.close().catch(() =\u003E { });\n      await serverTransport.close().catch(() =\u003E { });\n      server.close();\n    });\n\n    it('should support multiple client connections', async () =\u003E {\n      // Create and connect a client\n      const client1 = new Client({\n        name: 'test-client',\n        version: '1.0.0'\n      });\n\n      const transport1 = new StreamableHTTPClientTransport(baseUrl);\n      await client1.connect(transport1);\n\n      // Verify that no session ID was set\n      expect(transport1.sessionId).toBeUndefined();\n\n      // List available tools\n      await client1.request({\n        method: 'tools/list',\n        params: {}\n      }, ListToolsResultSchema);\n\n      const client2 = new Client({\n        name: 'test-client',\n        version: '1.0.0'\n      });\n\n      const transport2 = new StreamableHTTPClientTransport(baseUrl);\n      await client2.connect(transport2);\n\n      // Verify that no session ID was set\n      expect(transport2.sessionId).toBeUndefined();\n\n      // List available tools\n      await client2.request({\n        method: 'tools/list',\n        params: {}\n      }, ListToolsResultSchema);\n\n\n    });\n    it('should operate without session management', async () =\u003E {\n      // Create and connect a client\n      const client = new Client({\n        name: 'test-client',\n        version: '1.0.0'\n      });\n\n      const transport = new StreamableHTTPClientTransport(baseUrl);\n      await client.connect(transport);\n\n      // Verify that no session ID was set\n      expect(transport.sessionId).toBeUndefined();\n\n      // List available tools\n      const toolsResult = await client.request({\n        method: 'tools/list',\n        params: {}\n      }, ListToolsResultSchema);\n\n      // Verify tools are accessible\n      expect(toolsResult.tools).toContainEqual(expect.objectContaining({\n        name: 'greet'\n      }));\n\n      // List available resources\n      const resourcesResult = await client.request({\n        method: 'resources/list',\n        params: {}\n      }, ListResourcesResultSchema);\n\n      // Verify resources result structure\n      expect(resourcesResult).toHaveProperty('resources');\n\n      // List available prompts\n      const promptsResult = await client.request({\n        method: 'prompts/list',\n        params: {}\n      }, ListPromptsResultSchema);\n\n      // Verify prompts result structure\n      expect(promptsResult).toHaveProperty('prompts');\n      expect(promptsResult.prompts).toContainEqual(expect.objectContaining({\n        name: 'test-prompt'\n      }));\n\n      // Call the greeting tool\n      const greetingResult = await client.request({\n        method: 'tools/call',\n        params: {\n          name: 'greet',\n          arguments: {\n            name: 'Stateless Transport'\n          }\n        }\n      }, CallToolResultSchema);\n\n      // Verify tool result\n      expect(greetingResult.content).toEqual([\n        { type: 'text', text: 'Hello, Stateless Transport!' }\n      ]);\n\n      // Clean up\n      await transport.close();\n    });\n\n    it('should set protocol version after connecting', async () =\u003E {\n      // Create and connect a client\n      const client = new Client({\n        name: 'test-client',\n        version: '1.0.0'\n      });\n\n      const transport = new StreamableHTTPClientTransport(baseUrl);\n\n      // Verify protocol version is not set before connecting\n      expect(transport.protocolVersion).toBeUndefined();\n\n      await client.connect(transport);\n\n      // Verify protocol version is set after connecting\n      expect(transport.protocolVersion).toBe(LATEST_PROTOCOL_VERSION);\n\n      // Clean up\n      await transport.close();\n    });\n  });\n\n  describe('Stateful Mode', () =\u003E {\n    let server: Server;\n    let mcpServer: McpServer;\n    let serverTransport: StreamableHTTPServerTransport;\n    let baseUrl: URL;\n\n    beforeEach(async () =\u003E {\n      const setup = await setupServer(true);\n      server = setup.server;\n      mcpServer = setup.mcpServer;\n      serverTransport = setup.serverTransport;\n      baseUrl = setup.baseUrl;\n    });\n\n    afterEach(async () =\u003E {\n      // Clean up resources\n      await mcpServer.close().catch(() =\u003E { });\n      await serverTransport.close().catch(() =\u003E { });\n      server.close();\n    });\n\n    it('should operate with session management', async () =\u003E {\n      // Create and connect a client\n      const client = new Client({\n        name: 'test-client',\n        version: '1.0.0'\n      });\n\n      const transport = new StreamableHTTPClientTransport(baseUrl);\n      await client.connect(transport);\n\n      // Verify that a session ID was set\n      expect(transport.sessionId).toBeDefined();\n      expect(typeof transport.sessionId).toBe('string');\n\n      // List available tools\n      const toolsResult = await client.request({\n        method: 'tools/list',\n        params: {}\n      }, ListToolsResultSchema);\n\n      // Verify tools are accessible\n      expect(toolsResult.tools).toContainEqual(expect.objectContaining({\n        name: 'greet'\n      }));\n\n      // List available resources\n      const resourcesResult = await client.request({\n        method: 'resources/list',\n        params: {}\n      }, ListResourcesResultSchema);\n\n      // Verify resources result structure\n      expect(resourcesResult).toHaveProperty('resources');\n\n      // List available prompts\n      const promptsResult = await client.request({\n        method: 'prompts/list',\n        params: {}\n      }, ListPromptsResultSchema);\n\n      // Verify prompts result structure\n      expect(promptsResult).toHaveProperty('prompts');\n      expect(promptsResult.prompts).toContainEqual(expect.objectContaining({\n        name: 'test-prompt'\n      }));\n\n      // Call the greeting tool\n      const greetingResult = await client.request({\n        method: 'tools/call',\n        params: {\n          name: 'greet',\n          arguments: {\n            name: 'Stateful Transport'\n          }\n        }\n      }, CallToolResultSchema);\n\n      // Verify tool result\n      expect(greetingResult.content).toEqual([\n        { type: 'text', text: 'Hello, Stateful Transport!' }\n      ]);\n\n      // Clean up\n      await transport.close();\n    });\n  });\n});",
      "hash": "add07f4b91867ed5b41d8e8e9cba8e00f879fba286e4590837338eeaa066715f",
      "size": 9258
    },
    "/src/integration-tests/taskResumability.test.ts": {
      "type": "content",
      "content": "import { createServer, type Server } from 'node:http';\nimport { AddressInfo } from 'node:net';\nimport { randomUUID } from 'node:crypto';\nimport { Client } from '../client/index.js';\nimport { StreamableHTTPClientTransport } from '../client/streamableHttp.js';\nimport { McpServer } from '../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../server/streamableHttp.js';\nimport { CallToolResultSchema, LoggingMessageNotificationSchema } from '../types.js';\nimport { z } from 'zod';\nimport { InMemoryEventStore } from '../examples/shared/inMemoryEventStore.js';\n\n\n\ndescribe('Transport resumability', () =\u003E {\n  let server: Server;\n  let mcpServer: McpServer;\n  let serverTransport: StreamableHTTPServerTransport;\n  let baseUrl: URL;\n  let eventStore: InMemoryEventStore;\n\n  beforeEach(async () =\u003E {\n    // Create event store for resumability\n    eventStore = new InMemoryEventStore();\n\n    // Create a simple MCP server\n    mcpServer = new McpServer(\n      { name: 'test-server', version: '1.0.0' },\n      { capabilities: { logging: {} } }\n    );\n\n    // Add a simple notification tool that completes quickly\n    mcpServer.tool(\n      'send-notification',\n      'Sends a single notification',\n      {\n        message: z.string().describe('Message to send').default('Test notification')\n      },\n      async ({ message }, { sendNotification }) =\u003E {\n        // Send notification immediately\n        await sendNotification({\n          method: \"notifications/message\",\n          params: {\n            level: \"info\",\n            data: message\n          }\n        });\n\n        return {\n          content: [{ type: 'text', text: 'Notification sent' }]\n        };\n      }\n    );\n\n    // Add a long-running tool that sends multiple notifications\n    mcpServer.tool(\n      'run-notifications',\n      'Sends multiple notifications over time',\n      {\n        count: z.number().describe('Number of notifications to send').default(10),\n        interval: z.number().describe('Interval between notifications in ms').default(50)\n      },\n      async ({ count, interval }, { sendNotification }) =\u003E {\n        // Send notifications at specified intervals\n        for (let i = 0; i \u003C count; i++) {\n          await sendNotification({\n            method: \"notifications/message\",\n            params: {\n              level: \"info\",\n              data: `Notification ${i + 1} of ${count}`\n            }\n          });\n\n          // Wait for the specified interval before sending next notification\n          if (i \u003C count - 1) {\n            await new Promise(resolve =\u003E setTimeout(resolve, interval));\n          }\n        }\n\n        return {\n          content: [{ type: 'text', text: `Sent ${count} notifications` }]\n        };\n      }\n    );\n\n    // Create a transport with the event store\n    serverTransport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      eventStore\n    });\n\n    // Connect the transport to the MCP server\n    await mcpServer.connect(serverTransport);\n\n    // Create and start an HTTP server\n    server = createServer(async (req, res) =\u003E {\n      await serverTransport.handleRequest(req, res);\n    });\n\n    // Start the server on a random port\n    baseUrl = await new Promise\u003CURL\u003E((resolve) =\u003E {\n      server.listen(0, '127.0.0.1', () =\u003E {\n        const addr = server.address() as AddressInfo;\n        resolve(new URL(`http://127.0.0.1:${addr.port}`));\n      });\n    });\n  });\n\n  afterEach(async () =\u003E {\n    // Clean up resources\n    await mcpServer.close().catch(() =\u003E { });\n    await serverTransport.close().catch(() =\u003E { });\n    server.close();\n  });\n\n  it('should store session ID when client connects', async () =\u003E {\n    // Create and connect a client\n    const client = new Client({\n      name: 'test-client',\n      version: '1.0.0'\n    });\n\n    const transport = new StreamableHTTPClientTransport(baseUrl);\n    await client.connect(transport);\n\n    // Verify session ID was generated\n    expect(transport.sessionId).toBeDefined();\n\n    // Clean up\n    await transport.close();\n  });\n\n  it('should have session ID functionality', async () =\u003E {\n    // The ability to store a session ID when connecting\n    const client = new Client({\n      name: 'test-client-reconnection',\n      version: '1.0.0'\n    });\n\n    const transport = new StreamableHTTPClientTransport(baseUrl);\n\n    // Make sure the client can connect and get a session ID\n    await client.connect(transport);\n    expect(transport.sessionId).toBeDefined();\n\n    // Clean up\n    await transport.close();\n  });\n\n  // This test demonstrates the capability to resume long-running tools\n  // across client disconnection/reconnection\n  it('should resume long-running notifications with lastEventId', async () =\u003E {\n    // Create unique client ID for this test\n    const clientId = 'test-client-long-running';\n    const notifications = [];\n    let lastEventId: string | undefined;\n\n    // Create first client\n    const client1 = new Client({\n      id: clientId,\n      name: 'test-client',\n      version: '1.0.0'\n    });\n\n    // Set up notification handler for first client\n    client1.setNotificationHandler(LoggingMessageNotificationSchema, (notification) =\u003E {\n      if (notification.method === 'notifications/message') {\n        notifications.push(notification.params);\n      }\n    });\n\n    // Connect first client\n    const transport1 = new StreamableHTTPClientTransport(baseUrl);\n    await client1.connect(transport1);\n    const sessionId = transport1.sessionId;\n    expect(sessionId).toBeDefined();\n\n    // Start a long-running notification stream with tracking of lastEventId\n    const onLastEventIdUpdate = jest.fn((eventId: string) =\u003E {\n      lastEventId = eventId;\n    });\n    expect(lastEventId).toBeUndefined();\n    // Start the notification tool with event tracking using request\n    const toolPromise = client1.request({\n      method: 'tools/call',\n      params: {\n        name: 'run-notifications',\n        arguments: {\n          count: 3,\n          interval: 10\n        }\n      }\n    }, CallToolResultSchema, {\n      resumptionToken: lastEventId,\n      onresumptiontoken: onLastEventIdUpdate\n    });\n\n    // Wait for some notifications to arrive (not all) - shorter wait time\n    await new Promise(resolve =\u003E setTimeout(resolve, 20));\n\n    // Verify we received some notifications and lastEventId was updated\n    expect(notifications.length).toBeGreaterThan(0);\n    expect(notifications.length).toBeLessThan(4);\n    expect(onLastEventIdUpdate).toHaveBeenCalled();\n    expect(lastEventId).toBeDefined();\n\n\n    // Disconnect first client without waiting for completion\n    // When we close the connection, it will cause a ConnectionClosed error for\n    // any in-progress requests, which is expected behavior\n    await transport1.close();\n    // Save the promise so we can catch it after closing\n    const catchPromise = toolPromise.catch(err =\u003E {\n      // This error is expected - the connection was intentionally closed\n      if (err?.code !== -32000) { // ConnectionClosed error code\n        console.error(\"Unexpected error type during transport close:\", err);\n      }\n    });\n\n\n\n    // Add a short delay to ensure clean disconnect before reconnecting\n    await new Promise(resolve =\u003E setTimeout(resolve, 10));\n\n    // Wait for the rejection to be handled\n    await catchPromise;\n\n\n    // Create second client with same client ID\n    const client2 = new Client({\n      id: clientId,\n      name: 'test-client',\n      version: '1.0.0'\n    });\n\n    // Set up notification handler for second client\n    client2.setNotificationHandler(LoggingMessageNotificationSchema, (notification) =\u003E {\n      if (notification.method === 'notifications/message') {\n        notifications.push(notification.params);\n      }\n    });\n\n    // Connect second client with same session ID\n    const transport2 = new StreamableHTTPClientTransport(baseUrl, {\n      sessionId\n    });\n    await client2.connect(transport2);\n\n    // Resume the notification stream using lastEventId\n    // This is the key part - we're resuming the same long-running tool using lastEventId\n    await client2.request({\n      method: 'tools/call',\n      params: {\n        name: 'run-notifications',\n        arguments: {\n          count: 1,\n          interval: 5\n        }\n      }\n    }, CallToolResultSchema, {\n      resumptionToken: lastEventId,  // Pass the lastEventId from the previous session\n      onresumptiontoken: onLastEventIdUpdate\n    });\n\n    // Verify we eventually received at leaset a few motifications\n    expect(notifications.length).toBeGreaterThan(1);\n\n\n    // Clean up\n    await transport2.close();\n\n  });\n});",
      "hash": "67d56d9d70145bb40f91a189367676ad2fbbf21bacdd3e555d611f70b4e3600a",
      "size": 8595
    },
    "/src/server/auth/clients.ts": {
      "type": "content",
      "content": "import { OAuthClientInformationFull } from \"../../shared/auth.js\";\n\n/**\n * Stores information about registered OAuth clients for this server.\n */\nexport interface OAuthRegisteredClientsStore {\n  /**\n   * Returns information about a registered client, based on its ID.\n   */\n  getClient(clientId: string): OAuthClientInformationFull | undefined | Promise\u003COAuthClientInformationFull | undefined\u003E;\n\n  /**\n   * Registers a new client with the server. The client ID and secret will be automatically generated by the library. A modified version of the client information can be returned to reflect specific values enforced by the server.\n   * \n   * NOTE: Implementations should NOT delete expired client secrets in-place. Auth middleware provided by this library will automatically check the `client_secret_expires_at` field and reject requests with expired secrets. Any custom logic for authenticating clients should check the `client_secret_expires_at` field as well.\n   * \n   * If unimplemented, dynamic client registration is unsupported.\n   */\n  registerClient?(client: Omit\u003COAuthClientInformationFull, \"client_id\" | \"client_id_issued_at\"\u003E): OAuthClientInformationFull | Promise\u003COAuthClientInformationFull\u003E;\n}",
      "hash": "6fe3f0715efc67790dc376d05a6da6a6ce8db2bdc3e283958e4964b36a6ec68e",
      "size": 1208
    },
    "/src/server/auth/errors.ts": {
      "type": "content",
      "content": "import { OAuthErrorResponse } from \"../../shared/auth.js\";\n\n/**\n * Base class for all OAuth errors\n */\nexport class OAuthError extends Error {\n  static errorCode: string;\n\n  constructor(\n    message: string,\n    public readonly errorUri?: string\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n  /**\n   * Converts the error to a standard OAuth error response object\n   */\n  toResponseObject(): OAuthErrorResponse {\n    const response: OAuthErrorResponse = {\n      error: this.errorCode,\n      error_description: this.message\n    };\n\n    if (this.errorUri) {\n      response.error_uri = this.errorUri;\n    }\n\n    return response;\n  }\n\n  get errorCode(): string {\n    return (this.constructor as typeof OAuthError).errorCode\n  }\n}\n\n/**\n * Invalid request error - The request is missing a required parameter,\n * includes an invalid parameter value, includes a parameter more than once,\n * or is otherwise malformed.\n */\nexport class InvalidRequestError extends OAuthError {\n  static errorCode = \"invalid_request\";\n}\n\n/**\n * Invalid client error - Client authentication failed (e.g., unknown client, no client\n * authentication included, or unsupported authentication method).\n */\nexport class InvalidClientError extends OAuthError {\n  static errorCode = \"invalid_client\";\n}\n\n/**\n * Invalid grant error - The provided authorization grant or refresh token is\n * invalid, expired, revoked, does not match the redirection URI used in the\n * authorization request, or was issued to another client.\n */\nexport class InvalidGrantError extends OAuthError {\n  static errorCode = \"invalid_grant\";\n}\n\n/**\n * Unauthorized client error - The authenticated client is not authorized to use\n * this authorization grant type.\n */\nexport class UnauthorizedClientError extends OAuthError {\n  static errorCode = \"unauthorized_client\";\n}\n\n/**\n * Unsupported grant type error - The authorization grant type is not supported\n * by the authorization server.\n */\nexport class UnsupportedGrantTypeError extends OAuthError {\n  static errorCode = \"unsupported_grant_type\";\n}\n\n/**\n * Invalid scope error - The requested scope is invalid, unknown, malformed, or\n * exceeds the scope granted by the resource owner.\n */\nexport class InvalidScopeError extends OAuthError {\n  static errorCode = \"invalid_scope\";\n}\n\n/**\n * Access denied error - The resource owner or authorization server denied the request.\n */\nexport class AccessDeniedError extends OAuthError {\n  static errorCode = \"access_denied\";\n}\n\n/**\n * Server error - The authorization server encountered an unexpected condition\n * that prevented it from fulfilling the request.\n */\nexport class ServerError extends OAuthError {\n  static errorCode = \"server_error\";\n}\n\n/**\n * Temporarily unavailable error - The authorization server is currently unable to\n * handle the request due to a temporary overloading or maintenance of the server.\n */\nexport class TemporarilyUnavailableError extends OAuthError {\n  static errorCode = \"temporarily_unavailable\";\n}\n\n/**\n * Unsupported response type error - The authorization server does not support\n * obtaining an authorization code using this method.\n */\nexport class UnsupportedResponseTypeError extends OAuthError {\n  static errorCode = \"unsupported_response_type\";\n}\n\n/**\n * Unsupported token type error - The authorization server does not support\n * the requested token type.\n */\nexport class UnsupportedTokenTypeError extends OAuthError {\n  static errorCode = \"unsupported_token_type\";\n}\n\n/**\n * Invalid token error - The access token provided is expired, revoked, malformed,\n * or invalid for other reasons.\n */\nexport class InvalidTokenError extends OAuthError {\n  static errorCode = \"invalid_token\";\n}\n\n/**\n * Method not allowed error - The HTTP method used is not allowed for this endpoint.\n * (Custom, non-standard error)\n */\nexport class MethodNotAllowedError extends OAuthError {\n  static errorCode = \"method_not_allowed\";\n}\n\n/**\n * Too many requests error - Rate limit exceeded.\n * (Custom, non-standard error based on RFC 6585)\n */\nexport class TooManyRequestsError extends OAuthError {\n  static errorCode = \"too_many_requests\";\n}\n\n/**\n * Invalid client metadata error - The client metadata is invalid.\n * (Custom error for dynamic client registration - RFC 7591)\n */\nexport class InvalidClientMetadataError extends OAuthError {\n  static errorCode = \"invalid_client_metadata\";\n}\n\n/**\n * Insufficient scope error - The request requires higher privileges than provided by the access token.\n */\nexport class InsufficientScopeError extends OAuthError {\n  static errorCode = \"insufficient_scope\";\n}\n\n/**\n * A utility class for defining one-off error codes\n */\nexport class CustomOAuthError extends OAuthError {\n  constructor(private readonly customErrorCode: string, message: string, errorUri?: string) {\n    super(message, errorUri);\n  }\n\n  get errorCode(): string {\n    return this.customErrorCode;\n  }\n}\n\n/**\n * A full list of all OAuthErrors, enabling parsing from error responses\n */\nexport const OAUTH_ERRORS = {\n  [InvalidRequestError.errorCode]: InvalidRequestError,\n  [InvalidClientError.errorCode]: InvalidClientError,\n  [InvalidGrantError.errorCode]: InvalidGrantError,\n  [UnauthorizedClientError.errorCode]: UnauthorizedClientError,\n  [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,\n  [InvalidScopeError.errorCode]: InvalidScopeError,\n  [AccessDeniedError.errorCode]: AccessDeniedError,\n  [ServerError.errorCode]: ServerError,\n  [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,\n  [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,\n  [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,\n  [InvalidTokenError.errorCode]: InvalidTokenError,\n  [MethodNotAllowedError.errorCode]: MethodNotAllowedError,\n  [TooManyRequestsError.errorCode]: TooManyRequestsError,\n  [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,\n  [InsufficientScopeError.errorCode]: InsufficientScopeError,\n} as const;\n",
      "hash": "93914d39e08be9dd82ead0cf7b5c0b60a210c08a32a03f529f1741b493c74c22",
      "size": 5978
    },
    "/src/server/auth/handlers/authorize.test.ts": {
      "type": "content",
      "content": "import { authorizationHandler, AuthorizationHandlerOptions } from './authorize.js';\nimport { OAuthServerProvider, AuthorizationParams } from '../provider.js';\nimport { OAuthRegisteredClientsStore } from '../clients.js';\nimport { OAuthClientInformationFull, OAuthTokens } from '../../../shared/auth.js';\nimport express, { Response } from 'express';\nimport supertest from 'supertest';\nimport { AuthInfo } from '../types.js';\nimport { InvalidTokenError } from '../errors.js';\n\ndescribe('Authorization Handler', () =\u003E {\n  // Mock client data\n  const validClient: OAuthClientInformationFull = {\n    client_id: 'valid-client',\n    client_secret: 'valid-secret',\n    redirect_uris: ['https://example.com/callback'],\n    scope: 'profile email'\n  };\n\n  const multiRedirectClient: OAuthClientInformationFull = {\n    client_id: 'multi-redirect-client',\n    client_secret: 'valid-secret',\n    redirect_uris: [\n      'https://example.com/callback1',\n      'https://example.com/callback2'\n    ],\n    scope: 'profile email'\n  };\n\n  // Mock client store\n  const mockClientStore: OAuthRegisteredClientsStore = {\n    async getClient(clientId: string): Promise\u003COAuthClientInformationFull | undefined\u003E {\n      if (clientId === 'valid-client') {\n        return validClient;\n      } else if (clientId === 'multi-redirect-client') {\n        return multiRedirectClient;\n      }\n      return undefined;\n    }\n  };\n\n  // Mock provider\n  const mockProvider: OAuthServerProvider = {\n    clientsStore: mockClientStore,\n\n    async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise\u003Cvoid\u003E {\n      // Mock implementation - redirects to redirectUri with code and state\n      const redirectUrl = new URL(params.redirectUri);\n      redirectUrl.searchParams.set('code', 'mock_auth_code');\n      if (params.state) {\n        redirectUrl.searchParams.set('state', params.state);\n      }\n      res.redirect(302, redirectUrl.toString());\n    },\n\n    async challengeForAuthorizationCode(): Promise\u003Cstring\u003E {\n      return 'mock_challenge';\n    },\n\n    async exchangeAuthorizationCode(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'mock_refresh_token'\n      };\n    },\n\n    async exchangeRefreshToken(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'new_mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'new_mock_refresh_token'\n      };\n    },\n\n    async verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E {\n      if (token === 'valid_token') {\n        return {\n          token,\n          clientId: 'valid-client',\n          scopes: ['read', 'write'],\n          expiresAt: Date.now() / 1000 + 3600\n        };\n      }\n      throw new InvalidTokenError('Token is invalid or expired');\n    },\n\n    async revokeToken(): Promise\u003Cvoid\u003E {\n      // Do nothing in mock\n    }\n  };\n\n  // Setup express app with handler\n  let app: express.Express;\n  let options: AuthorizationHandlerOptions;\n\n  beforeEach(() =\u003E {\n    app = express();\n    options = { provider: mockProvider };\n    const handler = authorizationHandler(options);\n    app.use('/authorize', handler);\n  });\n\n  describe('HTTP method validation', () =\u003E {\n    it('rejects non-GET/POST methods', async () =\u003E {\n      const response = await supertest(app)\n        .put('/authorize')\n        .query({ client_id: 'valid-client' });\n\n      expect(response.status).toBe(405); // Method not allowed response from handler\n    });\n  });\n\n  describe('Client validation', () =\u003E {\n    it('requires client_id parameter', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize');\n\n      expect(response.status).toBe(400);\n      expect(response.text).toContain('client_id');\n    });\n\n    it('validates that client exists', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({ client_id: 'nonexistent-client' });\n\n      expect(response.status).toBe(400);\n    });\n  });\n\n  describe('Redirect URI validation', () =\u003E {\n    it('uses the only redirect_uri if client has just one and none provided', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.origin + location.pathname).toBe('https://example.com/callback');\n    });\n\n    it('requires redirect_uri if client has multiple', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'multi-redirect-client',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(400);\n    });\n\n    it('validates redirect_uri against client registered URIs', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://malicious.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(400);\n    });\n\n    it('accepts valid redirect_uri that client registered with', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.origin + location.pathname).toBe('https://example.com/callback');\n    });\n  });\n\n  describe('Authorization request validation', () =\u003E {\n    it('requires response_type=code', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'token', // invalid - we only support code flow\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('error')).toBe('invalid_request');\n    });\n\n    it('requires code_challenge parameter', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge_method: 'S256'\n          // Missing code_challenge\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('error')).toBe('invalid_request');\n    });\n\n    it('requires code_challenge_method=S256', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'plain' // Only S256 is supported\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('error')).toBe('invalid_request');\n    });\n  });\n\n  describe('Scope validation', () =\u003E {\n    it('validates requested scopes against client registered scopes', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          scope: 'profile email admin' // 'admin' not in client scopes\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('error')).toBe('invalid_scope');\n    });\n\n    it('accepts valid scopes subset', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          scope: 'profile' // subset of client scopes\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.has('code')).toBe(true);\n    });\n  });\n\n  describe('Resource parameter validation', () =\u003E {\n    it('propagates resource parameter', async () =\u003E {\n      const mockProviderWithResource = jest.spyOn(mockProvider, 'authorize');\n      \n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          resource: 'https://api.example.com/resource'\n        });\n\n      expect(response.status).toBe(302);\n      expect(mockProviderWithResource).toHaveBeenCalledWith(\n        validClient,\n        expect.objectContaining({\n          resource: new URL('https://api.example.com/resource'),\n          redirectUri: 'https://example.com/callback',\n          codeChallenge: 'challenge123'\n        }),\n        expect.any(Object)\n      );\n    });\n  });\n\n  describe('Successful authorization', () =\u003E {\n    it('handles successful authorization with all parameters', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          scope: 'profile email',\n          state: 'xyz789'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.origin + location.pathname).toBe('https://example.com/callback');\n      expect(location.searchParams.get('code')).toBe('mock_auth_code');\n      expect(location.searchParams.get('state')).toBe('xyz789');\n    });\n\n    it('preserves state parameter in response', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          state: 'state-value-123'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('state')).toBe('state-value-123');\n    });\n\n    it('handles POST requests the same as GET', async () =\u003E {\n      const response = await supertest(app)\n        .post('/authorize')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.has('code')).toBe(true);\n    });\n  });\n});",
      "hash": "78bbe69d696d8967bd3e17b4bdcf7c6f31409f78b7ad809479b2ba13c23301a4",
      "size": 11965
    },
    "/src/server/auth/handlers/authorize.ts": {
      "type": "content",
      "content": "import { RequestHandler } from \"express\";\nimport { z } from \"zod\";\nimport express from \"express\";\nimport { OAuthServerProvider } from \"../provider.js\";\nimport { rateLimit, Options as RateLimitOptions } from \"express-rate-limit\";\nimport { allowedMethods } from \"../middleware/allowedMethods.js\";\nimport {\n  InvalidRequestError,\n  InvalidClientError,\n  InvalidScopeError,\n  ServerError,\n  TooManyRequestsError,\n  OAuthError\n} from \"../errors.js\";\n\nexport type AuthorizationHandlerOptions = {\n  provider: OAuthServerProvider;\n  /**\n   * Rate limiting configuration for the authorization endpoint.\n   * Set to false to disable rate limiting for this endpoint.\n   */\n  rateLimit?: Partial\u003CRateLimitOptions\u003E | false;\n};\n\n// Parameters that must be validated in order to issue redirects.\nconst ClientAuthorizationParamsSchema = z.object({\n  client_id: z.string(),\n  redirect_uri: z.string().optional().refine((value) =\u003E value === undefined || URL.canParse(value), { message: \"redirect_uri must be a valid URL\" }),\n});\n\n// Parameters that must be validated for a successful authorization request. Failure can be reported to the redirect URI.\nconst RequestAuthorizationParamsSchema = z.object({\n  response_type: z.literal(\"code\"),\n  code_challenge: z.string(),\n  code_challenge_method: z.literal(\"S256\"),\n  scope: z.string().optional(),\n  state: z.string().optional(),\n  resource: z.string().url().optional(),\n});\n\nexport function authorizationHandler({ provider, rateLimit: rateLimitConfig }: AuthorizationHandlerOptions): RequestHandler {\n  // Create a router to apply middleware\n  const router = express.Router();\n  router.use(allowedMethods([\"GET\", \"POST\"]));\n  router.use(express.urlencoded({ extended: false }));\n\n  // Apply rate limiting unless explicitly disabled\n  if (rateLimitConfig !== false) {\n    router.use(rateLimit({\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      max: 100, // 100 requests per windowMs\n      standardHeaders: true,\n      legacyHeaders: false,\n      message: new TooManyRequestsError('You have exceeded the rate limit for authorization requests').toResponseObject(),\n      ...rateLimitConfig\n    }));\n  }\n\n  router.all(\"/\", async (req, res) =\u003E {\n    res.setHeader('Cache-Control', 'no-store');\n\n    // In the authorization flow, errors are split into two categories:\n    // 1. Pre-redirect errors (direct response with 400)\n    // 2. Post-redirect errors (redirect with error parameters)\n\n    // Phase 1: Validate client_id and redirect_uri. Any errors here must be direct responses.\n    let client_id, redirect_uri, client;\n    try {\n      const result = ClientAuthorizationParamsSchema.safeParse(req.method === 'POST' ? req.body : req.query);\n      if (!result.success) {\n        throw new InvalidRequestError(result.error.message);\n      }\n\n      client_id = result.data.client_id;\n      redirect_uri = result.data.redirect_uri;\n\n      client = await provider.clientsStore.getClient(client_id);\n      if (!client) {\n        throw new InvalidClientError(\"Invalid client_id\");\n      }\n\n      if (redirect_uri !== undefined) {\n        if (!client.redirect_uris.includes(redirect_uri)) {\n          throw new InvalidRequestError(\"Unregistered redirect_uri\");\n        }\n      } else if (client.redirect_uris.length === 1) {\n        redirect_uri = client.redirect_uris[0];\n      } else {\n        throw new InvalidRequestError(\"redirect_uri must be specified when client has multiple registered URIs\");\n      }\n    } catch (error) {\n      // Pre-redirect errors - return direct response\n      //\n      // These don't need to be JSON encoded, as they'll be displayed in a user\n      // agent, but OTOH they all represent exceptional situations (arguably,\n      // \"programmer error\"), so presenting a nice HTML page doesn't help the\n      // user anyway.\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n\n      return;\n    }\n\n    // Phase 2: Validate other parameters. Any errors here should go into redirect responses.\n    let state;\n    try {\n      // Parse and validate authorization parameters\n      const parseResult = RequestAuthorizationParamsSchema.safeParse(req.method === 'POST' ? req.body : req.query);\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message);\n      }\n\n      const { scope, code_challenge, resource } = parseResult.data;\n      state = parseResult.data.state;\n\n      // Validate scopes\n      let requestedScopes: string[] = [];\n      if (scope !== undefined) {\n        requestedScopes = scope.split(\" \");\n        const allowedScopes = new Set(client.scope?.split(\" \"));\n\n        // Check each requested scope against allowed scopes\n        for (const scope of requestedScopes) {\n          if (!allowedScopes.has(scope)) {\n            throw new InvalidScopeError(`Client was not registered with scope ${scope}`);\n          }\n        }\n      }\n\n      // All validation passed, proceed with authorization\n      await provider.authorize(client, {\n        state,\n        scopes: requestedScopes,\n        redirectUri: redirect_uri,\n        codeChallenge: code_challenge,\n        resource: resource ? new URL(resource) : undefined,\n      }, res);\n    } catch (error) {\n      // Post-redirect errors - redirect with error parameters\n      if (error instanceof OAuthError) {\n        res.redirect(302, createErrorRedirect(redirect_uri, error, state));\n      } else {\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.redirect(302, createErrorRedirect(redirect_uri, serverError, state));\n      }\n    }\n  });\n\n  return router;\n}\n\n/**\n * Helper function to create redirect URL with error parameters\n */\nfunction createErrorRedirect(redirectUri: string, error: OAuthError, state?: string): string {\n  const errorUrl = new URL(redirectUri);\n  errorUrl.searchParams.set(\"error\", error.errorCode);\n  errorUrl.searchParams.set(\"error_description\", error.message);\n  if (error.errorUri) {\n    errorUrl.searchParams.set(\"error_uri\", error.errorUri);\n  }\n  if (state) {\n    errorUrl.searchParams.set(\"state\", state);\n  }\n  return errorUrl.href;\n}",
      "hash": "c3eb8cbe24cd5e0b90f82567187379e4b8f0529fe2f45f56a621f91b899f1251",
      "size": 6320
    },
    "/src/server/auth/handlers/metadata.test.ts": {
      "type": "content",
      "content": "import { metadataHandler } from './metadata.js';\nimport { OAuthMetadata } from '../../../shared/auth.js';\nimport express from 'express';\nimport supertest from 'supertest';\n\ndescribe('Metadata Handler', () =\u003E {\n  const exampleMetadata: OAuthMetadata = {\n    issuer: 'https://auth.example.com',\n    authorization_endpoint: 'https://auth.example.com/authorize',\n    token_endpoint: 'https://auth.example.com/token',\n    registration_endpoint: 'https://auth.example.com/register',\n    revocation_endpoint: 'https://auth.example.com/revoke',\n    scopes_supported: ['profile', 'email'],\n    response_types_supported: ['code'],\n    grant_types_supported: ['authorization_code', 'refresh_token'],\n    token_endpoint_auth_methods_supported: ['client_secret_basic'],\n    code_challenge_methods_supported: ['S256']\n  };\n\n  let app: express.Express;\n\n  beforeEach(() =\u003E {\n    // Setup express app with metadata handler\n    app = express();\n    app.use('/.well-known/oauth-authorization-server', metadataHandler(exampleMetadata));\n  });\n\n  it('requires GET method', async () =\u003E {\n    const response = await supertest(app)\n      .post('/.well-known/oauth-authorization-server')\n      .send({});\n\n    expect(response.status).toBe(405);\n    expect(response.headers.allow).toBe('GET');\n    expect(response.body).toEqual({\n      error: \"method_not_allowed\",\n      error_description: \"The method POST is not allowed for this endpoint\"\n    });\n  });\n\n  it('returns the metadata object', async () =\u003E {\n    const response = await supertest(app)\n      .get('/.well-known/oauth-authorization-server');\n\n    expect(response.status).toBe(200);\n    expect(response.body).toEqual(exampleMetadata);\n  });\n\n  it('includes CORS headers in response', async () =\u003E {\n    const response = await supertest(app)\n      .get('/.well-known/oauth-authorization-server')\n      .set('Origin', 'https://example.com');\n\n    expect(response.header['access-control-allow-origin']).toBe('*');\n  });\n\n  it('supports OPTIONS preflight requests', async () =\u003E {\n    const response = await supertest(app)\n      .options('/.well-known/oauth-authorization-server')\n      .set('Origin', 'https://example.com')\n      .set('Access-Control-Request-Method', 'GET');\n\n    expect(response.status).toBe(204);\n    expect(response.header['access-control-allow-origin']).toBe('*');\n  });\n\n  it('works with minimal metadata', async () =\u003E {\n    // Setup a new express app with minimal metadata\n    const minimalApp = express();\n    const minimalMetadata: OAuthMetadata = {\n      issuer: 'https://auth.example.com',\n      authorization_endpoint: 'https://auth.example.com/authorize',\n      token_endpoint: 'https://auth.example.com/token',\n      response_types_supported: ['code']\n    };\n    minimalApp.use('/.well-known/oauth-authorization-server', metadataHandler(minimalMetadata));\n\n    const response = await supertest(minimalApp)\n      .get('/.well-known/oauth-authorization-server');\n\n    expect(response.status).toBe(200);\n    expect(response.body).toEqual(minimalMetadata);\n  });\n});",
      "hash": "1fb7ac40e3e956bd680c1f2ee1479a46ded242b337d032d3a13b8e935b44682e",
      "size": 3022
    },
    "/src/server/auth/handlers/metadata.ts": {
      "type": "content",
      "content": "import express, { RequestHandler } from \"express\";\nimport { OAuthMetadata, OAuthProtectedResourceMetadata } from \"../../../shared/auth.js\";\nimport cors from 'cors';\nimport { allowedMethods } from \"../middleware/allowedMethods.js\";\n\nexport function metadataHandler(metadata: OAuthMetadata | OAuthProtectedResourceMetadata): RequestHandler {\n  // Nested router so we can configure middleware and restrict HTTP method\n  const router = express.Router();\n\n  // Configure CORS to allow any origin, to make accessible to web-based MCP clients\n  router.use(cors());\n\n  router.use(allowedMethods(['GET']));\n  router.get(\"/\", (req, res) =\u003E {\n    res.status(200).json(metadata);\n  });\n\n  return router;\n}\n",
      "hash": "932d26c6077695e5c6d9264583286cae3e1e05a4285c533a7dd92aca0338be6a",
      "size": 694
    },
    "/src/server/auth/handlers/register.test.ts": {
      "type": "content",
      "content": "import { clientRegistrationHandler, ClientRegistrationHandlerOptions } from './register.js';\nimport { OAuthRegisteredClientsStore } from '../clients.js';\nimport { OAuthClientInformationFull, OAuthClientMetadata } from '../../../shared/auth.js';\nimport express from 'express';\nimport supertest from 'supertest';\n\ndescribe('Client Registration Handler', () =\u003E {\n  // Mock client store with registration support\n  const mockClientStoreWithRegistration: OAuthRegisteredClientsStore = {\n    async getClient(_clientId: string): Promise\u003COAuthClientInformationFull | undefined\u003E {\n      return undefined;\n    },\n\n    async registerClient(client: OAuthClientInformationFull): Promise\u003COAuthClientInformationFull\u003E {\n      // Return the client info as-is in the mock\n      return client;\n    }\n  };\n\n  // Mock client store without registration support\n  const mockClientStoreWithoutRegistration: OAuthRegisteredClientsStore = {\n    async getClient(_clientId: string): Promise\u003COAuthClientInformationFull | undefined\u003E {\n      return undefined;\n    }\n    // No registerClient method\n  };\n\n  describe('Handler creation', () =\u003E {\n    it('throws error if client store does not support registration', () =\u003E {\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithoutRegistration\n      };\n\n      expect(() =\u003E clientRegistrationHandler(options)).toThrow('does not support registering clients');\n    });\n\n    it('creates handler if client store supports registration', () =\u003E {\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithRegistration\n      };\n\n      expect(() =\u003E clientRegistrationHandler(options)).not.toThrow();\n    });\n  });\n\n  describe('Request handling', () =\u003E {\n    let app: express.Express;\n    let spyRegisterClient: jest.SpyInstance;\n\n    beforeEach(() =\u003E {\n      // Setup express app with registration handler\n      app = express();\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithRegistration,\n        clientSecretExpirySeconds: 86400 // 1 day for testing\n      };\n\n      app.use('/register', clientRegistrationHandler(options));\n\n      // Spy on the registerClient method\n      spyRegisterClient = jest.spyOn(mockClientStoreWithRegistration, 'registerClient');\n    });\n\n    afterEach(() =\u003E {\n      spyRegisterClient.mockRestore();\n    });\n\n    it('requires POST method', async () =\u003E {\n      const response = await supertest(app)\n        .get('/register')\n        .send({\n          redirect_uris: ['https://example.com/callback']\n        });\n\n      expect(response.status).toBe(405);\n      expect(response.headers.allow).toBe('POST');\n      expect(response.body).toEqual({\n        error: \"method_not_allowed\",\n        error_description: \"The method GET is not allowed for this endpoint\"\n      });\n      expect(spyRegisterClient).not.toHaveBeenCalled();\n    });\n\n    it('validates required client metadata', async () =\u003E {\n      const response = await supertest(app)\n        .post('/register')\n        .send({\n          // Missing redirect_uris (required)\n          client_name: 'Test Client'\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_client_metadata');\n      expect(spyRegisterClient).not.toHaveBeenCalled();\n    });\n\n    it('validates redirect URIs format', async () =\u003E {\n      const response = await supertest(app)\n        .post('/register')\n        .send({\n          redirect_uris: ['invalid-url'] // Invalid URL format\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_client_metadata');\n      expect(response.body.error_description).toContain('redirect_uris');\n      expect(spyRegisterClient).not.toHaveBeenCalled();\n    });\n\n    it('successfully registers client with minimal metadata', async () =\u003E {\n      const clientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback']\n      };\n\n      const response = await supertest(app)\n        .post('/register')\n        .send(clientMetadata);\n\n      expect(response.status).toBe(201);\n\n      // Verify the generated client information\n      expect(response.body.client_id).toBeDefined();\n      expect(response.body.client_secret).toBeDefined();\n      expect(response.body.client_id_issued_at).toBeDefined();\n      expect(response.body.client_secret_expires_at).toBeDefined();\n      expect(response.body.redirect_uris).toEqual(['https://example.com/callback']);\n\n      // Verify client was registered\n      expect(spyRegisterClient).toHaveBeenCalledTimes(1);\n    });\n\n    it('sets client_secret to undefined for token_endpoint_auth_method=none', async () =\u003E {\n      const clientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback'],\n        token_endpoint_auth_method: 'none'\n      };\n\n      const response = await supertest(app)\n        .post('/register')\n        .send(clientMetadata);\n\n      expect(response.status).toBe(201);\n      expect(response.body.client_secret).toBeUndefined();\n      expect(response.body.client_secret_expires_at).toBeUndefined();\n    });\n    \n    it('sets client_secret_expires_at for public clients only', async () =\u003E {\n      // Test for public client (token_endpoint_auth_method not 'none')\n      const publicClientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback'],\n        token_endpoint_auth_method: 'client_secret_basic'\n      };\n\n      const publicResponse = await supertest(app)\n        .post('/register')\n        .send(publicClientMetadata);\n\n      expect(publicResponse.status).toBe(201);\n      expect(publicResponse.body.client_secret).toBeDefined();\n      expect(publicResponse.body.client_secret_expires_at).toBeDefined();\n      \n      // Test for non-public client (token_endpoint_auth_method is 'none')\n      const nonPublicClientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback'],\n        token_endpoint_auth_method: 'none'\n      };\n\n      const nonPublicResponse = await supertest(app)\n        .post('/register')\n        .send(nonPublicClientMetadata);\n\n      expect(nonPublicResponse.status).toBe(201);\n      expect(nonPublicResponse.body.client_secret).toBeUndefined();\n      expect(nonPublicResponse.body.client_secret_expires_at).toBeUndefined();\n    });\n\n    it('sets expiry based on clientSecretExpirySeconds', async () =\u003E {\n      // Create handler with custom expiry time\n      const customApp = express();\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithRegistration,\n        clientSecretExpirySeconds: 3600 // 1 hour\n      };\n\n      customApp.use('/register', clientRegistrationHandler(options));\n\n      const response = await supertest(customApp)\n        .post('/register')\n        .send({\n          redirect_uris: ['https://example.com/callback']\n        });\n\n      expect(response.status).toBe(201);\n\n      // Verify the expiration time (~1 hour from now)\n      const issuedAt = response.body.client_id_issued_at;\n      const expiresAt = response.body.client_secret_expires_at;\n      expect(expiresAt - issuedAt).toBe(3600);\n    });\n\n    it('sets no expiry when clientSecretExpirySeconds=0', async () =\u003E {\n      // Create handler with no expiry\n      const customApp = express();\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithRegistration,\n        clientSecretExpirySeconds: 0 // No expiry\n      };\n\n      customApp.use('/register', clientRegistrationHandler(options));\n\n      const response = await supertest(customApp)\n        .post('/register')\n        .send({\n          redirect_uris: ['https://example.com/callback']\n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body.client_secret_expires_at).toBe(0);\n    });\n\n    it('sets no client_id when clientIdGeneration=false', async () =\u003E {\n      // Create handler with no expiry\n      const customApp = express();\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithRegistration,\n        clientIdGeneration: false\n      };\n\n      customApp.use('/register', clientRegistrationHandler(options));\n\n      const response = await supertest(customApp)\n        .post('/register')\n        .send({\n          redirect_uris: ['https://example.com/callback']\n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body.client_id).toBeUndefined();\n      expect(response.body.client_id_issued_at).toBeUndefined();\n    });\n\n    it('handles client with all metadata fields', async () =\u003E {\n      const fullClientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback'],\n        token_endpoint_auth_method: 'client_secret_basic',\n        grant_types: ['authorization_code', 'refresh_token'],\n        response_types: ['code'],\n        client_name: 'Test Client',\n        client_uri: 'https://example.com',\n        logo_uri: 'https://example.com/logo.png',\n        scope: 'profile email',\n        contacts: ['dev@example.com'],\n        tos_uri: 'https://example.com/tos',\n        policy_uri: 'https://example.com/privacy',\n        jwks_uri: 'https://example.com/jwks',\n        software_id: 'test-software',\n        software_version: '1.0.0'\n      };\n\n      const response = await supertest(app)\n        .post('/register')\n        .send(fullClientMetadata);\n\n      expect(response.status).toBe(201);\n\n      // Verify all metadata was preserved\n      Object.entries(fullClientMetadata).forEach(([key, value]) =\u003E {\n        expect(response.body[key]).toEqual(value);\n      });\n    });\n\n    it('includes CORS headers in response', async () =\u003E {\n      const response = await supertest(app)\n        .post('/register')\n        .set('Origin', 'https://example.com')\n        .send({\n          redirect_uris: ['https://example.com/callback']\n        });\n\n      expect(response.header['access-control-allow-origin']).toBe('*');\n    });\n  });\n});",
      "hash": "8744aaf9b604d1fda7de54c6066bc3c7a29d58128dda04fa2efcca201aea6b5e",
      "size": 10001
    },
    "/src/server/auth/handlers/register.ts": {
      "type": "content",
      "content": "import express, { RequestHandler } from \"express\";\nimport { OAuthClientInformationFull, OAuthClientMetadataSchema } from \"../../../shared/auth.js\";\nimport crypto from 'node:crypto';\nimport cors from 'cors';\nimport { OAuthRegisteredClientsStore } from \"../clients.js\";\nimport { rateLimit, Options as RateLimitOptions } from \"express-rate-limit\";\nimport { allowedMethods } from \"../middleware/allowedMethods.js\";\nimport {\n  InvalidClientMetadataError,\n  ServerError,\n  TooManyRequestsError,\n  OAuthError\n} from \"../errors.js\";\n\nexport type ClientRegistrationHandlerOptions = {\n  /**\n   * A store used to save information about dynamically registered OAuth clients.\n   */\n  clientsStore: OAuthRegisteredClientsStore;\n\n  /**\n   * The number of seconds after which to expire issued client secrets, or 0 to prevent expiration of client secrets (not recommended).\n   * \n   * If not set, defaults to 30 days.\n   */\n  clientSecretExpirySeconds?: number;\n\n  /**\n   * Rate limiting configuration for the client registration endpoint.\n   * Set to false to disable rate limiting for this endpoint.\n   * Registration endpoints are particularly sensitive to abuse and should be rate limited.\n   */\n  rateLimit?: Partial\u003CRateLimitOptions\u003E | false;\n\n  /**\n   * Whether to generate a client ID before calling the client registration endpoint.\n   *\n   * If not set, defaults to true.\n   */\n  clientIdGeneration?: boolean;\n};\n\nconst DEFAULT_CLIENT_SECRET_EXPIRY_SECONDS = 30 * 24 * 60 * 60; // 30 days\n\nexport function clientRegistrationHandler({\n  clientsStore,\n  clientSecretExpirySeconds = DEFAULT_CLIENT_SECRET_EXPIRY_SECONDS,\n  rateLimit: rateLimitConfig,\n  clientIdGeneration = true,\n}: ClientRegistrationHandlerOptions): RequestHandler {\n  if (!clientsStore.registerClient) {\n    throw new Error(\"Client registration store does not support registering clients\");\n  }\n\n  // Nested router so we can configure middleware and restrict HTTP method\n  const router = express.Router();\n\n  // Configure CORS to allow any origin, to make accessible to web-based MCP clients\n  router.use(cors());\n\n  router.use(allowedMethods([\"POST\"]));\n  router.use(express.json());\n\n  // Apply rate limiting unless explicitly disabled - stricter limits for registration\n  if (rateLimitConfig !== false) {\n    router.use(rateLimit({\n      windowMs: 60 * 60 * 1000, // 1 hour\n      max: 20, // 20 requests per hour - stricter as registration is sensitive\n      standardHeaders: true,\n      legacyHeaders: false,\n      message: new TooManyRequestsError('You have exceeded the rate limit for client registration requests').toResponseObject(),\n      ...rateLimitConfig\n    }));\n  }\n\n  router.post(\"/\", async (req, res) =\u003E {\n    res.setHeader('Cache-Control', 'no-store');\n\n    try {\n      const parseResult = OAuthClientMetadataSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        throw new InvalidClientMetadataError(parseResult.error.message);\n      }\n\n      const clientMetadata = parseResult.data;\n      const isPublicClient = clientMetadata.token_endpoint_auth_method === 'none'\n\n      // Generate client credentials\n      const clientSecret = isPublicClient\n        ? undefined\n        : crypto.randomBytes(32).toString('hex');\n      const clientIdIssuedAt = Math.floor(Date.now() / 1000);\n\n      // Calculate client secret expiry time\n      const clientsDoExpire = clientSecretExpirySeconds \u003E 0\n      const secretExpiryTime = clientsDoExpire ? clientIdIssuedAt + clientSecretExpirySeconds : 0\n      const clientSecretExpiresAt = isPublicClient ? undefined : secretExpiryTime\n\n      let clientInfo: Omit\u003COAuthClientInformationFull, \"client_id\"\u003E & { client_id?: string } = {\n        ...clientMetadata,\n        client_secret: clientSecret,\n        client_secret_expires_at: clientSecretExpiresAt,\n      };\n\n      if (clientIdGeneration) {\n        clientInfo.client_id = crypto.randomUUID();\n        clientInfo.client_id_issued_at = clientIdIssuedAt;\n      }\n\n      clientInfo = await clientsStore.registerClient!(clientInfo);\n      res.status(201).json(clientInfo);\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n    }\n  });\n\n  return router;\n}",
      "hash": "63684754b0541d38aea2b29581ce8d332bc473ed7b72902ba040acb2c37d3584",
      "size": 4417
    },
    "/src/server/auth/handlers/revoke.test.ts": {
      "type": "content",
      "content": "import { revocationHandler, RevocationHandlerOptions } from './revoke.js';\nimport { OAuthServerProvider, AuthorizationParams } from '../provider.js';\nimport { OAuthRegisteredClientsStore } from '../clients.js';\nimport { OAuthClientInformationFull, OAuthTokenRevocationRequest, OAuthTokens } from '../../../shared/auth.js';\nimport express, { Response } from 'express';\nimport supertest from 'supertest';\nimport { AuthInfo } from '../types.js';\nimport { InvalidTokenError } from '../errors.js';\n\ndescribe('Revocation Handler', () =\u003E {\n  // Mock client data\n  const validClient: OAuthClientInformationFull = {\n    client_id: 'valid-client',\n    client_secret: 'valid-secret',\n    redirect_uris: ['https://example.com/callback']\n  };\n\n  // Mock client store\n  const mockClientStore: OAuthRegisteredClientsStore = {\n    async getClient(clientId: string): Promise\u003COAuthClientInformationFull | undefined\u003E {\n      if (clientId === 'valid-client') {\n        return validClient;\n      }\n      return undefined;\n    }\n  };\n\n  // Mock provider with revocation capability\n  const mockProviderWithRevocation: OAuthServerProvider = {\n    clientsStore: mockClientStore,\n\n    async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise\u003Cvoid\u003E {\n      res.redirect('https://example.com/callback?code=mock_auth_code');\n    },\n\n    async challengeForAuthorizationCode(): Promise\u003Cstring\u003E {\n      return 'mock_challenge';\n    },\n\n    async exchangeAuthorizationCode(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'mock_refresh_token'\n      };\n    },\n\n    async exchangeRefreshToken(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'new_mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'new_mock_refresh_token'\n      };\n    },\n\n    async verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E {\n      if (token === 'valid_token') {\n        return {\n          token,\n          clientId: 'valid-client',\n          scopes: ['read', 'write'],\n          expiresAt: Date.now() / 1000 + 3600\n        };\n      }\n      throw new InvalidTokenError('Token is invalid or expired');\n    },\n\n    async revokeToken(_client: OAuthClientInformationFull, _request: OAuthTokenRevocationRequest): Promise\u003Cvoid\u003E {\n      // Success - do nothing in mock\n    }\n  };\n\n  // Mock provider without revocation capability\n  const mockProviderWithoutRevocation: OAuthServerProvider = {\n    clientsStore: mockClientStore,\n\n    async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise\u003Cvoid\u003E {\n      res.redirect('https://example.com/callback?code=mock_auth_code');\n    },\n\n    async challengeForAuthorizationCode(): Promise\u003Cstring\u003E {\n      return 'mock_challenge';\n    },\n\n    async exchangeAuthorizationCode(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'mock_refresh_token'\n      };\n    },\n\n    async exchangeRefreshToken(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'new_mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'new_mock_refresh_token'\n      };\n    },\n\n    async verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E {\n      if (token === 'valid_token') {\n        return {\n          token,\n          clientId: 'valid-client',\n          scopes: ['read', 'write'],\n          expiresAt: Date.now() / 1000 + 3600\n        };\n      }\n      throw new InvalidTokenError('Token is invalid or expired');\n    }\n    // No revokeToken method\n  };\n\n  describe('Handler creation', () =\u003E {\n    it('throws error if provider does not support token revocation', () =\u003E {\n      const options: RevocationHandlerOptions = { provider: mockProviderWithoutRevocation };\n      expect(() =\u003E revocationHandler(options)).toThrow('does not support revoking tokens');\n    });\n\n    it('creates handler if provider supports token revocation', () =\u003E {\n      const options: RevocationHandlerOptions = { provider: mockProviderWithRevocation };\n      expect(() =\u003E revocationHandler(options)).not.toThrow();\n    });\n  });\n\n  describe('Request handling', () =\u003E {\n    let app: express.Express;\n    let spyRevokeToken: jest.SpyInstance;\n\n    beforeEach(() =\u003E {\n      // Setup express app with revocation handler\n      app = express();\n      const options: RevocationHandlerOptions = { provider: mockProviderWithRevocation };\n      app.use('/revoke', revocationHandler(options));\n\n      // Spy on the revokeToken method\n      spyRevokeToken = jest.spyOn(mockProviderWithRevocation, 'revokeToken');\n    });\n\n    afterEach(() =\u003E {\n      spyRevokeToken.mockRestore();\n    });\n\n    it('requires POST method', async () =\u003E {\n      const response = await supertest(app)\n        .get('/revoke')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          token: 'token_to_revoke'\n        });\n\n      expect(response.status).toBe(405);\n      expect(response.headers.allow).toBe('POST');\n      expect(response.body).toEqual({\n        error: \"method_not_allowed\",\n        error_description: \"The method GET is not allowed for this endpoint\"\n      });\n      expect(spyRevokeToken).not.toHaveBeenCalled();\n    });\n\n    it('requires token parameter', async () =\u003E {\n      const response = await supertest(app)\n        .post('/revoke')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret'\n          // Missing token\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_request');\n      expect(spyRevokeToken).not.toHaveBeenCalled();\n    });\n\n    it('authenticates client before revoking token', async () =\u003E {\n      const response = await supertest(app)\n        .post('/revoke')\n        .type('form')\n        .send({\n          client_id: 'invalid-client',\n          client_secret: 'wrong-secret',\n          token: 'token_to_revoke'\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_client');\n      expect(spyRevokeToken).not.toHaveBeenCalled();\n    });\n\n    it('successfully revokes token', async () =\u003E {\n      const response = await supertest(app)\n        .post('/revoke')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          token: 'token_to_revoke'\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body).toEqual({}); // Empty response on success\n      expect(spyRevokeToken).toHaveBeenCalledTimes(1);\n      expect(spyRevokeToken).toHaveBeenCalledWith(validClient, {\n        token: 'token_to_revoke'\n      });\n    });\n\n    it('accepts optional token_type_hint', async () =\u003E {\n      const response = await supertest(app)\n        .post('/revoke')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          token: 'token_to_revoke',\n          token_type_hint: 'refresh_token'\n        });\n\n      expect(response.status).toBe(200);\n      expect(spyRevokeToken).toHaveBeenCalledWith(validClient, {\n        token: 'token_to_revoke',\n        token_type_hint: 'refresh_token'\n      });\n    });\n\n    it('includes CORS headers in response', async () =\u003E {\n      const response = await supertest(app)\n        .post('/revoke')\n        .type('form')\n        .set('Origin', 'https://example.com')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          token: 'token_to_revoke'\n        });\n\n      expect(response.header['access-control-allow-origin']).toBe('*');\n    });\n  });\n});",
      "hash": "d80ee1652eca971269f0f8e3daecb3c1b36ca42798b0c858b3d1bd4d0b9be6f8",
      "size": 7835
    },
    "/src/server/auth/handlers/revoke.ts": {
      "type": "content",
      "content": "import { OAuthServerProvider } from \"../provider.js\";\nimport express, { RequestHandler } from \"express\";\nimport cors from \"cors\";\nimport { authenticateClient } from \"../middleware/clientAuth.js\";\nimport { OAuthTokenRevocationRequestSchema } from \"../../../shared/auth.js\";\nimport { rateLimit, Options as RateLimitOptions } from \"express-rate-limit\";\nimport { allowedMethods } from \"../middleware/allowedMethods.js\";\nimport {\n  InvalidRequestError,\n  ServerError,\n  TooManyRequestsError,\n  OAuthError,\n} from \"../errors.js\";\n\nexport type RevocationHandlerOptions = {\n  provider: OAuthServerProvider;\n  /**\n   * Rate limiting configuration for the token revocation endpoint.\n   * Set to false to disable rate limiting for this endpoint.\n   */\n  rateLimit?: Partial\u003CRateLimitOptions\u003E | false;\n};\n\nexport function revocationHandler({\n  provider,\n  rateLimit: rateLimitConfig,\n}: RevocationHandlerOptions): RequestHandler {\n  if (!provider.revokeToken) {\n    throw new Error(\"Auth provider does not support revoking tokens\");\n  }\n\n  // Nested router so we can configure middleware and restrict HTTP method\n  const router = express.Router();\n\n  // Configure CORS to allow any origin, to make accessible to web-based MCP clients\n  router.use(cors());\n\n  router.use(allowedMethods([\"POST\"]));\n  router.use(express.urlencoded({ extended: false }));\n\n  // Apply rate limiting unless explicitly disabled\n  if (rateLimitConfig !== false) {\n    router.use(\n      rateLimit({\n        windowMs: 15 * 60 * 1000, // 15 minutes\n        max: 50, // 50 requests per windowMs\n        standardHeaders: true,\n        legacyHeaders: false,\n        message: new TooManyRequestsError(\n          \"You have exceeded the rate limit for token revocation requests\"\n        ).toResponseObject(),\n        ...rateLimitConfig,\n      })\n    );\n  }\n\n  // Authenticate and extract client details\n  router.use(authenticateClient({ clientsStore: provider.clientsStore }));\n\n  router.post(\"/\", async (req, res) =\u003E {\n    res.setHeader(\"Cache-Control\", \"no-store\");\n\n    try {\n      const parseResult = OAuthTokenRevocationRequestSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message);\n      }\n\n      const client = req.client;\n      if (!client) {\n        // This should never happen\n        throw new ServerError(\"Internal Server Error\");\n      }\n\n      await provider.revokeToken!(client, parseResult.data);\n      res.status(200).json({});\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n    }\n  });\n\n  return router;\n}\n",
      "hash": "2d941eb911335db9cb09fe7e7c6b4a8f33a7bab659eec96fe3203c9e0e1e0de5",
      "size": 2846
    },
    "/src/server/auth/handlers/token.test.ts": {
      "type": "content",
      "content": "import { tokenHandler, TokenHandlerOptions } from './token.js';\nimport { OAuthServerProvider, AuthorizationParams } from '../provider.js';\nimport { OAuthRegisteredClientsStore } from '../clients.js';\nimport { OAuthClientInformationFull, OAuthTokenRevocationRequest, OAuthTokens } from '../../../shared/auth.js';\nimport express, { Response } from 'express';\nimport supertest from 'supertest';\nimport * as pkceChallenge from 'pkce-challenge';\nimport { InvalidGrantError, InvalidTokenError } from '../errors.js';\nimport { AuthInfo } from '../types.js';\nimport { ProxyOAuthServerProvider } from '../providers/proxyProvider.js';\n\n// Mock pkce-challenge\njest.mock('pkce-challenge', () =\u003E ({\n  verifyChallenge: jest.fn().mockImplementation(async (verifier, challenge) =\u003E {\n    return verifier === 'valid_verifier' && challenge === 'mock_challenge';\n  })\n}));\n\nconst mockTokens = {\n    access_token: 'mock_access_token',\n    token_type: 'bearer',\n    expires_in: 3600,\n    refresh_token: 'mock_refresh_token'\n};\n\nconst mockTokensWithIdToken = {\n    ...mockTokens,\n    id_token: 'mock_id_token'\n}\n\ndescribe('Token Handler', () =\u003E {\n  // Mock client data\n  const validClient: OAuthClientInformationFull = {\n    client_id: 'valid-client',\n    client_secret: 'valid-secret',\n    redirect_uris: ['https://example.com/callback']\n  };\n\n  // Mock client store\n  const mockClientStore: OAuthRegisteredClientsStore = {\n    async getClient(clientId: string): Promise\u003COAuthClientInformationFull | undefined\u003E {\n      if (clientId === 'valid-client') {\n        return validClient;\n      }\n      return undefined;\n    }\n  };\n\n  // Mock provider\n  let mockProvider: OAuthServerProvider;\n  let app: express.Express;\n\n  beforeEach(() =\u003E {\n    // Create fresh mocks for each test\n    mockProvider = {\n      clientsStore: mockClientStore,\n\n      async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise\u003Cvoid\u003E {\n        res.redirect('https://example.com/callback?code=mock_auth_code');\n      },\n\n      async challengeForAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string): Promise\u003Cstring\u003E {\n        if (authorizationCode === 'valid_code') {\n          return 'mock_challenge';\n        } else if (authorizationCode === 'expired_code') {\n          throw new InvalidGrantError('The authorization code has expired');\n        }\n        throw new InvalidGrantError('The authorization code is invalid');\n      },\n\n      async exchangeAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string): Promise\u003COAuthTokens\u003E {\n        if (authorizationCode === 'valid_code') {\n          return mockTokens;\n        }\n        throw new InvalidGrantError('The authorization code is invalid or has expired');\n      },\n\n      async exchangeRefreshToken(client: OAuthClientInformationFull, refreshToken: string, scopes?: string[]): Promise\u003COAuthTokens\u003E {\n        if (refreshToken === 'valid_refresh_token') {\n          const response: OAuthTokens = {\n            access_token: 'new_mock_access_token',\n            token_type: 'bearer',\n            expires_in: 3600,\n            refresh_token: 'new_mock_refresh_token'\n          };\n\n          if (scopes) {\n            response.scope = scopes.join(' ');\n          }\n\n          return response;\n        }\n        throw new InvalidGrantError('The refresh token is invalid or has expired');\n      },\n\n      async verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E {\n        if (token === 'valid_token') {\n          return {\n            token,\n            clientId: 'valid-client',\n            scopes: ['read', 'write'],\n            expiresAt: Date.now() / 1000 + 3600\n          };\n        }\n        throw new InvalidTokenError('Token is invalid or expired');\n      },\n\n      async revokeToken(_client: OAuthClientInformationFull, _request: OAuthTokenRevocationRequest): Promise\u003Cvoid\u003E {\n        // Do nothing in mock\n      }\n    };\n\n    // Mock PKCE verification\n    (pkceChallenge.verifyChallenge as jest.Mock).mockImplementation(\n      async (verifier: string, challenge: string) =\u003E {\n        return verifier === 'valid_verifier' && challenge === 'mock_challenge';\n      }\n    );\n\n    // Setup express app with token handler\n    app = express();\n    const options: TokenHandlerOptions = { provider: mockProvider };\n    app.use('/token', tokenHandler(options));\n  });\n\n  describe('Basic request validation', () =\u003E {\n    it('requires POST method', async () =\u003E {\n      const response = await supertest(app)\n        .get('/token')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'authorization_code'\n        });\n\n      expect(response.status).toBe(405);\n      expect(response.headers.allow).toBe('POST');\n      expect(response.body).toEqual({\n        error: \"method_not_allowed\",\n        error_description: \"The method GET is not allowed for this endpoint\"\n      });\n    });\n\n    it('requires grant_type parameter', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret'\n          // Missing grant_type\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_request');\n    });\n\n    it('rejects unsupported grant types', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'password' // Unsupported grant type\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('unsupported_grant_type');\n    });\n  });\n\n  describe('Client authentication', () =\u003E {\n    it('requires valid client credentials', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'invalid-client',\n          client_secret: 'wrong-secret',\n          grant_type: 'authorization_code'\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_client');\n    });\n\n    it('accepts valid client credentials', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'authorization_code',\n          code: 'valid_code',\n          code_verifier: 'valid_verifier'\n        });\n\n      expect(response.status).toBe(200);\n    });\n  });\n\n  describe('Authorization code grant', () =\u003E {\n    it('requires code parameter', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'authorization_code',\n          // Missing code\n          code_verifier: 'valid_verifier'\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_request');\n    });\n\n    it('requires code_verifier parameter', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'authorization_code',\n          code: 'valid_code'\n          // Missing code_verifier\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_request');\n    });\n\n    it('verifies code_verifier against challenge', async () =\u003E {\n      // Setup invalid verifier\n      (pkceChallenge.verifyChallenge as jest.Mock).mockResolvedValueOnce(false);\n\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'authorization_code',\n          code: 'valid_code',\n          code_verifier: 'invalid_verifier'\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_grant');\n      expect(response.body.error_description).toContain('code_verifier');\n    });\n\n    it('rejects expired or invalid authorization codes', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'authorization_code',\n          code: 'expired_code',\n          code_verifier: 'valid_verifier'\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_grant');\n    });\n\n    it('returns tokens for valid code exchange', async () =\u003E {\n      const mockExchangeCode = jest.spyOn(mockProvider, 'exchangeAuthorizationCode');\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          resource: 'https://api.example.com/resource',\n          grant_type: 'authorization_code',\n          code: 'valid_code',\n          code_verifier: 'valid_verifier'\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.access_token).toBe('mock_access_token');\n      expect(response.body.token_type).toBe('bearer');\n      expect(response.body.expires_in).toBe(3600);\n      expect(response.body.refresh_token).toBe('mock_refresh_token');\n      expect(mockExchangeCode).toHaveBeenCalledWith(\n        validClient,\n        'valid_code',\n        undefined, // code_verifier is undefined after PKCE validation\n        undefined, // redirect_uri\n        new URL('https://api.example.com/resource') // resource parameter\n      );\n    });\n\n      it('returns id token in code exchange if provided', async () =\u003E {\n          mockProvider.exchangeAuthorizationCode = async (client: OAuthClientInformationFull, authorizationCode: string): Promise\u003COAuthTokens\u003E =\u003E {\n              if (authorizationCode === 'valid_code') {\n                  return mockTokensWithIdToken;\n              }\n              throw new InvalidGrantError('The authorization code is invalid or has expired');\n          };\n\n          const response = await supertest(app)\n              .post('/token')\n              .type('form')\n              .send({\n                  client_id: 'valid-client',\n                  client_secret: 'valid-secret',\n                  grant_type: 'authorization_code',\n                  code: 'valid_code',\n                  code_verifier: 'valid_verifier'\n              });\n\n          expect(response.status).toBe(200);\n          expect(response.body.id_token).toBe('mock_id_token');\n      });\n\n    it('passes through code verifier when using proxy provider', async () =\u003E {\n      const originalFetch = global.fetch;\n\n      try {\n        global.fetch = jest.fn().mockResolvedValue({\n          ok: true,\n          json: () =\u003E Promise.resolve(mockTokens)\n        });\n\n        const proxyProvider = new ProxyOAuthServerProvider({\n          endpoints: {\n            authorizationUrl: 'https://example.com/authorize',\n            tokenUrl: 'https://example.com/token'\n          },\n          verifyAccessToken: async (token) =\u003E ({\n            token,\n            clientId: 'valid-client',\n            scopes: ['read', 'write'],\n            expiresAt: Date.now() / 1000 + 3600\n          }),\n          getClient: async (clientId) =\u003E clientId === 'valid-client' ? validClient : undefined\n        });\n\n        const proxyApp = express();\n        const options: TokenHandlerOptions = { provider: proxyProvider };\n        proxyApp.use('/token', tokenHandler(options));\n\n        const response = await supertest(proxyApp)\n          .post('/token')\n          .type('form')\n          .send({\n            client_id: 'valid-client',\n            client_secret: 'valid-secret',\n            grant_type: 'authorization_code',\n            code: 'valid_code',\n            code_verifier: 'any_verifier',\n            redirect_uri: 'https://example.com/callback'\n          });\n\n        expect(response.status).toBe(200);\n        expect(response.body.access_token).toBe('mock_access_token');\n\n        expect(global.fetch).toHaveBeenCalledWith(\n          'https://example.com/token',\n          expect.objectContaining({\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            body: expect.stringContaining('code_verifier=any_verifier')\n          })\n        );\n      } finally {\n        global.fetch = originalFetch;\n      }\n    });\n\n    it('passes through redirect_uri when using proxy provider', async () =\u003E {\n      const originalFetch = global.fetch;\n\n      try {\n        global.fetch = jest.fn().mockResolvedValue({\n          ok: true,\n          json: () =\u003E Promise.resolve(mockTokens)\n        });\n\n        const proxyProvider = new ProxyOAuthServerProvider({\n          endpoints: {\n            authorizationUrl: 'https://example.com/authorize',\n            tokenUrl: 'https://example.com/token'\n          },\n          verifyAccessToken: async (token) =\u003E ({\n            token,\n            clientId: 'valid-client',\n            scopes: ['read', 'write'],\n            expiresAt: Date.now() / 1000 + 3600\n          }),\n          getClient: async (clientId) =\u003E clientId === 'valid-client' ? validClient : undefined\n        });\n\n        const proxyApp = express();\n        const options: TokenHandlerOptions = { provider: proxyProvider };\n        proxyApp.use('/token', tokenHandler(options));\n\n        const redirectUri = 'https://example.com/callback';\n        const response = await supertest(proxyApp)\n          .post('/token')\n          .type('form')\n          .send({\n            client_id: 'valid-client',\n            client_secret: 'valid-secret',\n            grant_type: 'authorization_code',\n            code: 'valid_code',\n            code_verifier: 'any_verifier',\n            redirect_uri: redirectUri\n          });\n\n        expect(response.status).toBe(200);\n        expect(response.body.access_token).toBe('mock_access_token');\n\n        expect(global.fetch).toHaveBeenCalledWith(\n          'https://example.com/token',\n          expect.objectContaining({\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            body: expect.stringContaining(`redirect_uri=${encodeURIComponent(redirectUri)}`)\n          })\n        );\n      } finally {\n        global.fetch = originalFetch;\n      }\n    });\n  });\n\n  describe('Refresh token grant', () =\u003E {\n    it('requires refresh_token parameter', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'refresh_token'\n          // Missing refresh_token\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_request');\n    });\n\n    it('rejects invalid refresh tokens', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'refresh_token',\n          refresh_token: 'invalid_refresh_token'\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_grant');\n    });\n\n    it('returns new tokens for valid refresh token', async () =\u003E {\n      const mockExchangeRefresh = jest.spyOn(mockProvider, 'exchangeRefreshToken');\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          resource: 'https://api.example.com/resource',\n          grant_type: 'refresh_token',\n          refresh_token: 'valid_refresh_token'\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.access_token).toBe('new_mock_access_token');\n      expect(response.body.token_type).toBe('bearer');\n      expect(response.body.expires_in).toBe(3600);\n      expect(response.body.refresh_token).toBe('new_mock_refresh_token');\n      expect(mockExchangeRefresh).toHaveBeenCalledWith(\n        validClient,\n        'valid_refresh_token',\n        undefined, // scopes\n        new URL('https://api.example.com/resource') // resource parameter\n      );\n    });\n\n    it('respects requested scopes on refresh', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'refresh_token',\n          refresh_token: 'valid_refresh_token',\n          scope: 'profile email'\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.scope).toBe('profile email');\n    });\n  });\n\n  describe('CORS support', () =\u003E {\n    it('includes CORS headers in response', async () =\u003E {\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .set('Origin', 'https://example.com')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'authorization_code',\n          code: 'valid_code',\n          code_verifier: 'valid_verifier'\n        });\n\n      expect(response.header['access-control-allow-origin']).toBe('*');\n    });\n  });\n});",
      "hash": "e73f65d8153940bea935df982a20a210bd9b745b44b6048e50a7988f61c66d22",
      "size": 17664
    },
    "/src/server/auth/handlers/token.ts": {
      "type": "content",
      "content": "import { z } from \"zod\";\nimport express, { RequestHandler } from \"express\";\nimport { OAuthServerProvider } from \"../provider.js\";\nimport cors from \"cors\";\nimport { verifyChallenge } from \"pkce-challenge\";\nimport { authenticateClient } from \"../middleware/clientAuth.js\";\nimport { rateLimit, Options as RateLimitOptions } from \"express-rate-limit\";\nimport { allowedMethods } from \"../middleware/allowedMethods.js\";\nimport {\n  InvalidRequestError,\n  InvalidGrantError,\n  UnsupportedGrantTypeError,\n  ServerError,\n  TooManyRequestsError,\n  OAuthError\n} from \"../errors.js\";\n\nexport type TokenHandlerOptions = {\n  provider: OAuthServerProvider;\n  /**\n   * Rate limiting configuration for the token endpoint.\n   * Set to false to disable rate limiting for this endpoint.\n   */\n  rateLimit?: Partial\u003CRateLimitOptions\u003E | false;\n};\n\nconst TokenRequestSchema = z.object({\n  grant_type: z.string(),\n});\n\nconst AuthorizationCodeGrantSchema = z.object({\n  code: z.string(),\n  code_verifier: z.string(),\n  redirect_uri: z.string().optional(),\n  resource: z.string().url().optional(),\n});\n\nconst RefreshTokenGrantSchema = z.object({\n  refresh_token: z.string(),\n  scope: z.string().optional(),\n  resource: z.string().url().optional(),\n});\n\nexport function tokenHandler({ provider, rateLimit: rateLimitConfig }: TokenHandlerOptions): RequestHandler {\n  // Nested router so we can configure middleware and restrict HTTP method\n  const router = express.Router();\n\n  // Configure CORS to allow any origin, to make accessible to web-based MCP clients\n  router.use(cors());\n\n  router.use(allowedMethods([\"POST\"]));\n  router.use(express.urlencoded({ extended: false }));\n\n  // Apply rate limiting unless explicitly disabled\n  if (rateLimitConfig !== false) {\n    router.use(rateLimit({\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      max: 50, // 50 requests per windowMs \n      standardHeaders: true,\n      legacyHeaders: false,\n      message: new TooManyRequestsError('You have exceeded the rate limit for token requests').toResponseObject(),\n      ...rateLimitConfig\n    }));\n  }\n\n  // Authenticate and extract client details\n  router.use(authenticateClient({ clientsStore: provider.clientsStore }));\n\n  router.post(\"/\", async (req, res) =\u003E {\n    res.setHeader('Cache-Control', 'no-store');\n\n    try {\n      const parseResult = TokenRequestSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message);\n      }\n\n      const { grant_type } = parseResult.data;\n\n      const client = req.client;\n      if (!client) {\n        // This should never happen\n        throw new ServerError(\"Internal Server Error\");\n      }\n\n      switch (grant_type) {\n        case \"authorization_code\": {\n          const parseResult = AuthorizationCodeGrantSchema.safeParse(req.body);\n          if (!parseResult.success) {\n            throw new InvalidRequestError(parseResult.error.message);\n          }\n\n          const { code, code_verifier, redirect_uri, resource } = parseResult.data;\n\n          const skipLocalPkceValidation = provider.skipLocalPkceValidation;\n\n          // Perform local PKCE validation unless explicitly skipped \n          // (e.g. to validate code_verifier in upstream server)\n          if (!skipLocalPkceValidation) {\n            const codeChallenge = await provider.challengeForAuthorizationCode(client, code);\n            if (!(await verifyChallenge(code_verifier, codeChallenge))) {\n              throw new InvalidGrantError(\"code_verifier does not match the challenge\");\n            }\n          }\n\n          // Passes the code_verifier to the provider if PKCE validation didn't occur locally\n          const tokens = await provider.exchangeAuthorizationCode(\n            client, \n            code, \n            skipLocalPkceValidation ? code_verifier : undefined,\n            redirect_uri,\n            resource ? new URL(resource) : undefined\n          );\n          res.status(200).json(tokens);\n          break;\n        }\n\n        case \"refresh_token\": {\n          const parseResult = RefreshTokenGrantSchema.safeParse(req.body);\n          if (!parseResult.success) {\n            throw new InvalidRequestError(parseResult.error.message);\n          }\n\n          const { refresh_token, scope, resource } = parseResult.data;\n\n          const scopes = scope?.split(\" \");\n          const tokens = await provider.exchangeRefreshToken(client, refresh_token, scopes, resource ? new URL(resource) : undefined);\n          res.status(200).json(tokens);\n          break;\n        }\n\n        // Not supported right now\n        //case \"client_credentials\":\n\n        default:\n          throw new UnsupportedGrantTypeError(\n            \"The grant type is not supported by this authorization server.\"\n          );\n      }\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n    }\n  });\n\n  return router;\n}",
      "hash": "f5c1c5d1b33e0e59f3a36bedd6a30c997e1ed9cb900f2442f242836f0645eb0f",
      "size": 5134
    },
    "/src/server/auth/middleware/allowedMethods.test.ts": {
      "type": "content",
      "content": "import { allowedMethods } from \"./allowedMethods.js\";\nimport express, { Request, Response } from \"express\";\nimport request from \"supertest\";\n\ndescribe(\"allowedMethods\", () =\u003E {\n  let app: express.Express;\n\n  beforeEach(() =\u003E {\n    app = express();\n\n    // Set up a test router with a GET handler and 405 middleware\n    const router = express.Router();\n\n    router.get(\"/test\", (req, res) =\u003E {\n      res.status(200).send(\"GET success\");\n    });\n\n    // Add method not allowed middleware for all other methods\n    router.all(\"/test\", allowedMethods([\"GET\"]));\n\n    app.use(router);\n  });\n\n  test(\"allows specified HTTP method\", async () =\u003E {\n    const response = await request(app).get(\"/test\");\n    expect(response.status).toBe(200);\n    expect(response.text).toBe(\"GET success\");\n  });\n\n  test(\"returns 405 for unspecified HTTP methods\", async () =\u003E {\n    const methods = [\"post\", \"put\", \"delete\", \"patch\"];\n\n    for (const method of methods) {\n      // @ts-expect-error - dynamic method call\n      const response = await request(app)[method](\"/test\");\n      expect(response.status).toBe(405);\n      expect(response.body).toEqual({\n        error: \"method_not_allowed\",\n        error_description: `The method ${method.toUpperCase()} is not allowed for this endpoint`\n      });\n    }\n  });\n\n  test(\"includes Allow header with specified methods\", async () =\u003E {\n    const response = await request(app).post(\"/test\");\n    expect(response.headers.allow).toBe(\"GET\");\n  });\n\n  test(\"works with multiple allowed methods\", async () =\u003E {\n    const multiMethodApp = express();\n    const router = express.Router();\n\n    router.get(\"/multi\", (req: Request, res: Response) =\u003E {\n      res.status(200).send(\"GET\");\n    });\n    router.post(\"/multi\", (req: Request, res: Response) =\u003E {\n      res.status(200).send(\"POST\");\n    });\n    router.all(\"/multi\", allowedMethods([\"GET\", \"POST\"]));\n\n    multiMethodApp.use(router);\n\n    // Allowed methods should work\n    const getResponse = await request(multiMethodApp).get(\"/multi\");\n    expect(getResponse.status).toBe(200);\n\n    const postResponse = await request(multiMethodApp).post(\"/multi\");\n    expect(postResponse.status).toBe(200);\n\n    // Unallowed methods should return 405\n    const putResponse = await request(multiMethodApp).put(\"/multi\");\n    expect(putResponse.status).toBe(405);\n    expect(putResponse.headers.allow).toBe(\"GET, POST\");\n  });\n});",
      "hash": "aea9e9b6bfda9b75f8ea35cb2a17ff21d24c9c11aaf16eb0de52ed4caaa20360",
      "size": 2387
    },
    "/src/server/auth/middleware/allowedMethods.ts": {
      "type": "content",
      "content": "import { RequestHandler } from \"express\";\nimport { MethodNotAllowedError } from \"../errors.js\";\n\n/**\n * Middleware to handle unsupported HTTP methods with a 405 Method Not Allowed response.\n * \n * @param allowedMethods Array of allowed HTTP methods for this endpoint (e.g., ['GET', 'POST'])\n * @returns Express middleware that returns a 405 error if method not in allowed list\n */\nexport function allowedMethods(allowedMethods: string[]): RequestHandler {\n  return (req, res, next) =\u003E {\n    if (allowedMethods.includes(req.method)) {\n      next();\n      return;\n    }\n\n    const error = new MethodNotAllowedError(`The method ${req.method} is not allowed for this endpoint`);\n    res.status(405)\n      .set('Allow', allowedMethods.join(', '))\n      .json(error.toResponseObject());\n  };\n}",
      "hash": "ad8d0d373746591fcc765ade86f009db7249956ab12cbe4cae18434098293af9",
      "size": 787
    },
    "/src/server/auth/middleware/bearerAuth.test.ts": {
      "type": "content",
      "content": "import { Request, Response } from \"express\";\nimport { requireBearerAuth } from \"./bearerAuth.js\";\nimport { AuthInfo } from \"../types.js\";\nimport { InsufficientScopeError, InvalidTokenError, CustomOAuthError, ServerError } from \"../errors.js\";\nimport { OAuthTokenVerifier } from \"../provider.js\";\n\n// Mock verifier\nconst mockVerifyAccessToken = jest.fn();\nconst mockVerifier: OAuthTokenVerifier = {\n  verifyAccessToken: mockVerifyAccessToken,\n};\n\ndescribe(\"requireBearerAuth middleware\", () =\u003E {\n  let mockRequest: Partial\u003CRequest\u003E;\n  let mockResponse: Partial\u003CResponse\u003E;\n  let nextFunction: jest.Mock;\n\n  beforeEach(() =\u003E {\n    mockRequest = {\n      headers: {},\n    };\n    mockResponse = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn(),\n      set: jest.fn().mockReturnThis(),\n    };\n    nextFunction = jest.fn();\n    jest.spyOn(console, 'error').mockImplementation(() =\u003E {});\n  })\n\n  afterEach(() =\u003E {\n    jest.clearAllMocks();\n  });\n\n  it(\"should call next when token is valid\", async () =\u003E {\n    const validAuthInfo: AuthInfo = {\n      token: \"valid-token\",\n      clientId: \"client-123\",\n      scopes: [\"read\", \"write\"],\n      expiresAt: Math.floor(Date.now() / 1000) + 3600, // Token expires in an hour\n    };\n    mockVerifyAccessToken.mockResolvedValue(validAuthInfo);\n\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n    expect(mockRequest.auth).toEqual(validAuthInfo);\n    expect(nextFunction).toHaveBeenCalled();\n    expect(mockResponse.status).not.toHaveBeenCalled();\n    expect(mockResponse.json).not.toHaveBeenCalled();\n  });\n  \n  it.each([\n    [100], // Token expired 100 seconds ago\n    [0], // Token expires at the same time as now\n  ])(\"should reject expired tokens (expired %s seconds ago)\", async (expiredSecondsAgo: number) =\u003E {\n    const expiresAt = Math.floor(Date.now() / 1000) - expiredSecondsAgo;\n    const expiredAuthInfo: AuthInfo = {\n      token: \"expired-token\",\n      clientId: \"client-123\",\n      scopes: [\"read\", \"write\"],\n      expiresAt\n    };\n    mockVerifyAccessToken.mockResolvedValue(expiredAuthInfo);\n\n    mockRequest.headers = {\n      authorization: \"Bearer expired-token\",\n    };\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"expired-token\");\n    expect(mockResponse.status).toHaveBeenCalledWith(401);\n    expect(mockResponse.set).toHaveBeenCalledWith(\n      \"WWW-Authenticate\",\n      expect.stringContaining('Bearer error=\"invalid_token\"')\n    );\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"invalid_token\", error_description: \"Token has expired\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it.each([\n    [undefined], // Token has no expiration time\n    [NaN], // Token has no expiration time\n  ])(\"should reject tokens with no expiration time (expiresAt: %s)\", async (expiresAt: number | undefined) =\u003E {\n    const noExpirationAuthInfo: AuthInfo = {\n      token: \"no-expiration-token\",\n      clientId: \"client-123\",\n      scopes: [\"read\", \"write\"],\n      expiresAt\n    };\n    mockVerifyAccessToken.mockResolvedValue(noExpirationAuthInfo);\n\n    mockRequest.headers = {\n      authorization: \"Bearer expired-token\",\n    };\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"expired-token\");\n    expect(mockResponse.status).toHaveBeenCalledWith(401);\n    expect(mockResponse.set).toHaveBeenCalledWith(\n      \"WWW-Authenticate\",\n      expect.stringContaining('Bearer error=\"invalid_token\"')\n    );\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"invalid_token\", error_description: \"Token has no expiration time\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it(\"should accept non-expired tokens\", async () =\u003E {\n    const nonExpiredAuthInfo: AuthInfo = {\n      token: \"valid-token\",\n      clientId: \"client-123\",\n      scopes: [\"read\", \"write\"],\n      expiresAt: Math.floor(Date.now() / 1000) + 3600, // Token expires in an hour\n    };\n    mockVerifyAccessToken.mockResolvedValue(nonExpiredAuthInfo);\n\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n    expect(mockRequest.auth).toEqual(nonExpiredAuthInfo);\n    expect(nextFunction).toHaveBeenCalled();\n    expect(mockResponse.status).not.toHaveBeenCalled();\n    expect(mockResponse.json).not.toHaveBeenCalled();\n  });\n\n  it(\"should require specific scopes when configured\", async () =\u003E {\n    const authInfo: AuthInfo = {\n      token: \"valid-token\",\n      clientId: \"client-123\",\n      scopes: [\"read\"],\n    };\n    mockVerifyAccessToken.mockResolvedValue(authInfo);\n\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    const middleware = requireBearerAuth({\n      verifier: mockVerifier,\n      requiredScopes: [\"read\", \"write\"]\n    });\n\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n    expect(mockResponse.status).toHaveBeenCalledWith(403);\n    expect(mockResponse.set).toHaveBeenCalledWith(\n      \"WWW-Authenticate\",\n      expect.stringContaining('Bearer error=\"insufficient_scope\"')\n    );\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"insufficient_scope\", error_description: \"Insufficient scope\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it(\"should accept token with all required scopes\", async () =\u003E {\n    const authInfo: AuthInfo = {\n      token: \"valid-token\",\n      clientId: \"client-123\",\n      scopes: [\"read\", \"write\", \"admin\"],\n      expiresAt: Math.floor(Date.now() / 1000) + 3600, // Token expires in an hour\n    };\n    mockVerifyAccessToken.mockResolvedValue(authInfo);\n\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    const middleware = requireBearerAuth({\n      verifier: mockVerifier,\n      requiredScopes: [\"read\", \"write\"]\n    });\n\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n    expect(mockRequest.auth).toEqual(authInfo);\n    expect(nextFunction).toHaveBeenCalled();\n    expect(mockResponse.status).not.toHaveBeenCalled();\n    expect(mockResponse.json).not.toHaveBeenCalled();\n  });\n\n  it(\"should return 401 when no Authorization header is present\", async () =\u003E {\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).not.toHaveBeenCalled();\n    expect(mockResponse.status).toHaveBeenCalledWith(401);\n    expect(mockResponse.set).toHaveBeenCalledWith(\n      \"WWW-Authenticate\",\n      expect.stringContaining('Bearer error=\"invalid_token\"')\n    );\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"invalid_token\", error_description: \"Missing Authorization header\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it(\"should return 401 when Authorization header format is invalid\", async () =\u003E {\n    mockRequest.headers = {\n      authorization: \"InvalidFormat\",\n    };\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).not.toHaveBeenCalled();\n    expect(mockResponse.status).toHaveBeenCalledWith(401);\n    expect(mockResponse.set).toHaveBeenCalledWith(\n      \"WWW-Authenticate\",\n      expect.stringContaining('Bearer error=\"invalid_token\"')\n    );\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({\n        error: \"invalid_token\",\n        error_description: \"Invalid Authorization header format, expected 'Bearer TOKEN'\"\n      })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it(\"should return 401 when token verification fails with InvalidTokenError\", async () =\u003E {\n    mockRequest.headers = {\n      authorization: \"Bearer invalid-token\",\n    };\n\n    mockVerifyAccessToken.mockRejectedValue(new InvalidTokenError(\"Token expired\"));\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"invalid-token\");\n    expect(mockResponse.status).toHaveBeenCalledWith(401);\n    expect(mockResponse.set).toHaveBeenCalledWith(\n      \"WWW-Authenticate\",\n      expect.stringContaining('Bearer error=\"invalid_token\"')\n    );\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"invalid_token\", error_description: \"Token expired\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it(\"should return 403 when access token has insufficient scopes\", async () =\u003E {\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    mockVerifyAccessToken.mockRejectedValue(new InsufficientScopeError(\"Required scopes: read, write\"));\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n    expect(mockResponse.status).toHaveBeenCalledWith(403);\n    expect(mockResponse.set).toHaveBeenCalledWith(\n      \"WWW-Authenticate\",\n      expect.stringContaining('Bearer error=\"insufficient_scope\"')\n    );\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"insufficient_scope\", error_description: \"Required scopes: read, write\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it(\"should return 500 when a ServerError occurs\", async () =\u003E {\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    mockVerifyAccessToken.mockRejectedValue(new ServerError(\"Internal server issue\"));\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n    expect(mockResponse.status).toHaveBeenCalledWith(500);\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"server_error\", error_description: \"Internal server issue\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it(\"should return 400 for generic OAuthError\", async () =\u003E {\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    mockVerifyAccessToken.mockRejectedValue(new CustomOAuthError(\"custom_error\", \"Some OAuth error\"));\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n    expect(mockResponse.status).toHaveBeenCalledWith(400);\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"custom_error\", error_description: \"Some OAuth error\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  it(\"should return 500 when unexpected error occurs\", async () =\u003E {\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    mockVerifyAccessToken.mockRejectedValue(new Error(\"Unexpected error\"));\n\n    const middleware = requireBearerAuth({ verifier: mockVerifier });\n    await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n    expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n    expect(mockResponse.status).toHaveBeenCalledWith(500);\n    expect(mockResponse.json).toHaveBeenCalledWith(\n      expect.objectContaining({ error: \"server_error\", error_description: \"Internal Server Error\" })\n    );\n    expect(nextFunction).not.toHaveBeenCalled();\n  });\n\n  describe(\"with resourceMetadataUrl\", () =\u003E {\n    const resourceMetadataUrl = \"https://api.example.com/.well-known/oauth-protected-resource\";\n\n    it(\"should include resource_metadata in WWW-Authenticate header for 401 responses\", async () =\u003E {\n      mockRequest.headers = {};\n\n      const middleware = requireBearerAuth({ verifier: mockVerifier, resourceMetadataUrl });\n      await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n      expect(mockResponse.status).toHaveBeenCalledWith(401);\n      expect(mockResponse.set).toHaveBeenCalledWith(\n        \"WWW-Authenticate\",\n        `Bearer error=\"invalid_token\", error_description=\"Missing Authorization header\", resource_metadata=\"${resourceMetadataUrl}\"`\n      );\n      expect(nextFunction).not.toHaveBeenCalled();\n    });\n\n    it(\"should include resource_metadata in WWW-Authenticate header when token verification fails\", async () =\u003E {\n      mockRequest.headers = {\n        authorization: \"Bearer invalid-token\",\n      };\n\n      mockVerifyAccessToken.mockRejectedValue(new InvalidTokenError(\"Token expired\"));\n\n      const middleware = requireBearerAuth({ verifier: mockVerifier, resourceMetadataUrl });\n      await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n      expect(mockResponse.status).toHaveBeenCalledWith(401);\n      expect(mockResponse.set).toHaveBeenCalledWith(\n        \"WWW-Authenticate\",\n        `Bearer error=\"invalid_token\", error_description=\"Token expired\", resource_metadata=\"${resourceMetadataUrl}\"`\n      );\n      expect(nextFunction).not.toHaveBeenCalled();\n    });\n\n    it(\"should include resource_metadata in WWW-Authenticate header for insufficient scope errors\", async () =\u003E {\n      mockRequest.headers = {\n        authorization: \"Bearer valid-token\",\n      };\n\n      mockVerifyAccessToken.mockRejectedValue(new InsufficientScopeError(\"Required scopes: admin\"));\n\n      const middleware = requireBearerAuth({ verifier: mockVerifier, resourceMetadataUrl });\n      await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n      expect(mockResponse.status).toHaveBeenCalledWith(403);\n      expect(mockResponse.set).toHaveBeenCalledWith(\n        \"WWW-Authenticate\",\n        `Bearer error=\"insufficient_scope\", error_description=\"Required scopes: admin\", resource_metadata=\"${resourceMetadataUrl}\"`\n      );\n      expect(nextFunction).not.toHaveBeenCalled();\n    });\n\n    it(\"should include resource_metadata when token is expired\", async () =\u003E {\n      const expiredAuthInfo: AuthInfo = {\n        token: \"expired-token\",\n        clientId: \"client-123\",\n        scopes: [\"read\", \"write\"],\n        expiresAt: Math.floor(Date.now() / 1000) - 100,\n      };\n      mockVerifyAccessToken.mockResolvedValue(expiredAuthInfo);\n\n      mockRequest.headers = {\n        authorization: \"Bearer expired-token\",\n      };\n\n      const middleware = requireBearerAuth({ verifier: mockVerifier, resourceMetadataUrl });\n      await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n      expect(mockResponse.status).toHaveBeenCalledWith(401);\n      expect(mockResponse.set).toHaveBeenCalledWith(\n        \"WWW-Authenticate\",\n        `Bearer error=\"invalid_token\", error_description=\"Token has expired\", resource_metadata=\"${resourceMetadataUrl}\"`\n      );\n      expect(nextFunction).not.toHaveBeenCalled();\n    });\n\n    it(\"should include resource_metadata when scope check fails\", async () =\u003E {\n      const authInfo: AuthInfo = {\n        token: \"valid-token\",\n        clientId: \"client-123\",\n        scopes: [\"read\"],\n      };\n      mockVerifyAccessToken.mockResolvedValue(authInfo);\n\n      mockRequest.headers = {\n        authorization: \"Bearer valid-token\",\n      };\n\n      const middleware = requireBearerAuth({\n        verifier: mockVerifier,\n        requiredScopes: [\"read\", \"write\"],\n        resourceMetadataUrl\n      });\n\n      await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n      expect(mockResponse.status).toHaveBeenCalledWith(403);\n      expect(mockResponse.set).toHaveBeenCalledWith(\n        \"WWW-Authenticate\",\n        `Bearer error=\"insufficient_scope\", error_description=\"Insufficient scope\", resource_metadata=\"${resourceMetadataUrl}\"`\n      );\n      expect(nextFunction).not.toHaveBeenCalled();\n    });\n\n    it(\"should not affect server errors (no WWW-Authenticate header)\", async () =\u003E {\n      mockRequest.headers = {\n        authorization: \"Bearer valid-token\",\n      };\n\n      mockVerifyAccessToken.mockRejectedValue(new ServerError(\"Internal server issue\"));\n\n      const middleware = requireBearerAuth({ verifier: mockVerifier, resourceMetadataUrl });\n      await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n      expect(mockResponse.status).toHaveBeenCalledWith(500);\n      expect(mockResponse.set).not.toHaveBeenCalledWith(\"WWW-Authenticate\", expect.anything());\n      expect(nextFunction).not.toHaveBeenCalled();\n    });\n  });\n});\n",
      "hash": "b94c3def4e8aa08c7a8ab5eec0116c3912725e41e0a954a913988d895887f020",
      "size": 17677
    },
    "/src/server/auth/middleware/bearerAuth.ts": {
      "type": "content",
      "content": "import { RequestHandler } from \"express\";\nimport { InsufficientScopeError, InvalidTokenError, OAuthError, ServerError } from \"../errors.js\";\nimport { OAuthTokenVerifier } from \"../provider.js\";\nimport { AuthInfo } from \"../types.js\";\n\nexport type BearerAuthMiddlewareOptions = {\n  /**\n   * A provider used to verify tokens.\n   */\n  verifier: OAuthTokenVerifier;\n\n  /**\n   * Optional scopes that the token must have.\n   */\n  requiredScopes?: string[];\n\n  /**\n   * Optional resource metadata URL to include in WWW-Authenticate header.\n   */\n  resourceMetadataUrl?: string;\n};\n\ndeclare module \"express-serve-static-core\" {\n  interface Request {\n    /**\n     * Information about the validated access token, if the `requireBearerAuth` middleware was used.\n     */\n    auth?: AuthInfo;\n  }\n}\n\n/**\n * Middleware that requires a valid Bearer token in the Authorization header.\n *\n * This will validate the token with the auth provider and add the resulting auth info to the request object.\n *\n * If resourceMetadataUrl is provided, it will be included in the WWW-Authenticate header\n * for 401 responses as per the OAuth 2.0 Protected Resource Metadata spec.\n */\nexport function requireBearerAuth({ verifier, requiredScopes = [], resourceMetadataUrl }: BearerAuthMiddlewareOptions): RequestHandler {\n  return async (req, res, next) =\u003E {\n    try {\n      const authHeader = req.headers.authorization;\n      if (!authHeader) {\n        throw new InvalidTokenError(\"Missing Authorization header\");\n      }\n\n      const [type, token] = authHeader.split(' ');\n      if (type.toLowerCase() !== 'bearer' || !token) {\n        throw new InvalidTokenError(\"Invalid Authorization header format, expected 'Bearer TOKEN'\");\n      }\n\n      const authInfo = await verifier.verifyAccessToken(token);\n\n      // Check if token has the required scopes (if any)\n      if (requiredScopes.length \u003E 0) {\n        const hasAllScopes = requiredScopes.every(scope =\u003E\n          authInfo.scopes.includes(scope)\n        );\n\n        if (!hasAllScopes) {\n          throw new InsufficientScopeError(\"Insufficient scope\");\n        }\n      }\n\n      // Check if the token is set to expire or if it is expired\n      if (typeof authInfo.expiresAt !== 'number' || isNaN(authInfo.expiresAt)) {\n        throw new InvalidTokenError(\"Token has no expiration time\");\n      } else if (authInfo.expiresAt \u003C Date.now() / 1000) {\n        throw new InvalidTokenError(\"Token has expired\");\n      }\n\n      req.auth = authInfo;\n      next();\n    } catch (error) {\n      if (error instanceof InvalidTokenError) {\n        const wwwAuthValue = resourceMetadataUrl\n          ? `Bearer error=\"${error.errorCode}\", error_description=\"${error.message}\", resource_metadata=\"${resourceMetadataUrl}\"`\n          : `Bearer error=\"${error.errorCode}\", error_description=\"${error.message}\"`;\n        res.set(\"WWW-Authenticate\", wwwAuthValue);\n        res.status(401).json(error.toResponseObject());\n      } else if (error instanceof InsufficientScopeError) {\n        const wwwAuthValue = resourceMetadataUrl\n          ? `Bearer error=\"${error.errorCode}\", error_description=\"${error.message}\", resource_metadata=\"${resourceMetadataUrl}\"`\n          : `Bearer error=\"${error.errorCode}\", error_description=\"${error.message}\"`;\n        res.set(\"WWW-Authenticate\", wwwAuthValue);\n        res.status(403).json(error.toResponseObject());\n      } else if (error instanceof ServerError) {\n        res.status(500).json(error.toResponseObject());\n      } else if (error instanceof OAuthError) {\n        res.status(400).json(error.toResponseObject());\n      } else {\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n    }\n  };\n}\n",
      "hash": "f2ab661af8dac3c3d4154f041f8ffc0aa2c2458d05542b9a2ad3103856b1ef3c",
      "size": 3733
    },
    "/src/server/auth/middleware/clientAuth.test.ts": {
      "type": "content",
      "content": "import { authenticateClient, ClientAuthenticationMiddlewareOptions } from './clientAuth.js';\nimport { OAuthRegisteredClientsStore } from '../clients.js';\nimport { OAuthClientInformationFull } from '../../../shared/auth.js';\nimport express from 'express';\nimport supertest from 'supertest';\n\ndescribe('clientAuth middleware', () =\u003E {\n  // Mock client store\n  const mockClientStore: OAuthRegisteredClientsStore = {\n    async getClient(clientId: string): Promise\u003COAuthClientInformationFull | undefined\u003E {\n      if (clientId === 'valid-client') {\n        return {\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          redirect_uris: ['https://example.com/callback']\n        };\n      } else if (clientId === 'expired-client') {\n        // Client with no secret\n        return {\n          client_id: 'expired-client',\n          redirect_uris: ['https://example.com/callback']\n        };\n      } else if (clientId === 'client-with-expired-secret') {\n        // Client with an expired secret\n        return {\n          client_id: 'client-with-expired-secret',\n          client_secret: 'expired-secret',\n          client_secret_expires_at: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago\n          redirect_uris: ['https://example.com/callback']\n        };\n      }\n      return undefined;\n    }\n  };\n\n  // Setup Express app with middleware\n  let app: express.Express;\n  let options: ClientAuthenticationMiddlewareOptions;\n\n  beforeEach(() =\u003E {\n    app = express();\n    app.use(express.json());\n    \n    options = {\n      clientsStore: mockClientStore\n    };\n\n    // Setup route with client auth\n    app.post('/protected', authenticateClient(options), (req, res) =\u003E {\n      res.status(200).json({ success: true, client: req.client });\n    });\n  });\n\n  it('authenticates valid client credentials', async () =\u003E {\n    const response = await supertest(app)\n      .post('/protected')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret'\n      });\n\n    expect(response.status).toBe(200);\n    expect(response.body.success).toBe(true);\n    expect(response.body.client.client_id).toBe('valid-client');\n  });\n\n  it('rejects invalid client_id', async () =\u003E {\n    const response = await supertest(app)\n      .post('/protected')\n      .send({\n        client_id: 'non-existent-client',\n        client_secret: 'some-secret'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_client');\n    expect(response.body.error_description).toBe('Invalid client_id');\n  });\n\n  it('rejects invalid client_secret', async () =\u003E {\n    const response = await supertest(app)\n      .post('/protected')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'wrong-secret'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_client');\n    expect(response.body.error_description).toBe('Invalid client_secret');\n  });\n\n  it('rejects missing client_id', async () =\u003E {\n    const response = await supertest(app)\n      .post('/protected')\n      .send({\n        client_secret: 'valid-secret'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_request');\n  });\n\n  it('allows missing client_secret if client has none', async () =\u003E {\n    const response = await supertest(app)\n      .post('/protected')\n      .send({\n        client_id: 'expired-client'\n      });\n\n    // Since the client has no secret, this should pass without providing one\n    expect(response.status).toBe(200);\n  });\n  \n  it('rejects request when client secret has expired', async () =\u003E {\n    const response = await supertest(app)\n      .post('/protected')\n      .send({\n        client_id: 'client-with-expired-secret',\n        client_secret: 'expired-secret'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_client');\n    expect(response.body.error_description).toBe('Client secret has expired');\n  });\n\n  it('handles malformed request body', async () =\u003E {\n    const response = await supertest(app)\n      .post('/protected')\n      .send('not-json-format');\n\n    expect(response.status).toBe(400);\n  });\n\n  // Testing request with extra fields to ensure they're ignored\n  it('ignores extra fields in request', async () =\u003E {\n    const response = await supertest(app)\n      .post('/protected')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        extra_field: 'should be ignored'\n      });\n\n    expect(response.status).toBe(200);\n  });\n});",
      "hash": "c3469c433870aeec5c3d1ef8fa8cde14ef85ca4751089bcf39e71e099b0e21e9",
      "size": 4572
    },
    "/src/server/auth/middleware/clientAuth.ts": {
      "type": "content",
      "content": "import { z } from \"zod\";\nimport { RequestHandler } from \"express\";\nimport { OAuthRegisteredClientsStore } from \"../clients.js\";\nimport { OAuthClientInformationFull } from \"../../../shared/auth.js\";\nimport { InvalidRequestError, InvalidClientError, ServerError, OAuthError } from \"../errors.js\";\n\nexport type ClientAuthenticationMiddlewareOptions = {\n  /**\n   * A store used to read information about registered OAuth clients.\n   */\n  clientsStore: OAuthRegisteredClientsStore;\n}\n\nconst ClientAuthenticatedRequestSchema = z.object({\n  client_id: z.string(),\n  client_secret: z.string().optional(),\n});\n\ndeclare module \"express-serve-static-core\" {\n  interface Request {\n    /**\n     * The authenticated client for this request, if the `authenticateClient` middleware was used.\n     */\n    client?: OAuthClientInformationFull;\n  }\n}\n\nexport function authenticateClient({ clientsStore }: ClientAuthenticationMiddlewareOptions): RequestHandler {\n  return async (req, res, next) =\u003E {\n    try {\n      const result = ClientAuthenticatedRequestSchema.safeParse(req.body);\n      if (!result.success) {\n        throw new InvalidRequestError(String(result.error));\n      }\n\n      const { client_id, client_secret } = result.data;\n      const client = await clientsStore.getClient(client_id);\n      if (!client) {\n        throw new InvalidClientError(\"Invalid client_id\");\n      }\n\n      // If client has a secret, validate it\n      if (client.client_secret) {\n        // Check if client_secret is required but not provided\n        if (!client_secret) {\n          throw new InvalidClientError(\"Client secret is required\");\n        }\n\n        // Check if client_secret matches\n        if (client.client_secret !== client_secret) {\n          throw new InvalidClientError(\"Invalid client_secret\");\n        }\n\n        // Check if client_secret has expired\n        if (client.client_secret_expires_at && client.client_secret_expires_at \u003C Math.floor(Date.now() / 1000)) {\n          throw new InvalidClientError(\"Client secret has expired\");\n        }\n      }\n\n      req.client = client;\n      next();\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n    }\n  }\n}",
      "hash": "ec5918d590e214af46036a8d6f10073db516264194e2266c391ae214839fe16d",
      "size": 2436
    },
    "/src/server/auth/provider.ts": {
      "type": "content",
      "content": "import { Response } from \"express\";\nimport { OAuthRegisteredClientsStore } from \"./clients.js\";\nimport { OAuthClientInformationFull, OAuthTokenRevocationRequest, OAuthTokens } from \"../../shared/auth.js\";\nimport { AuthInfo } from \"./types.js\";\n\nexport type AuthorizationParams = {\n  state?: string;\n  scopes?: string[];\n  codeChallenge: string;\n  redirectUri: string;\n  resource?: URL;\n};\n\n/**\n * Implements an end-to-end OAuth server.\n */\nexport interface OAuthServerProvider {\n  /**\n   * A store used to read information about registered OAuth clients.\n   */\n  get clientsStore(): OAuthRegisteredClientsStore;\n\n  /**\n   * Begins the authorization flow, which can either be implemented by this server itself or via redirection to a separate authorization server.\n   *\n   * This server must eventually issue a redirect with an authorization response or an error response to the given redirect URI. Per OAuth 2.1:\n   * - In the successful case, the redirect MUST include the `code` and `state` (if present) query parameters.\n   * - In the error case, the redirect MUST include the `error` query parameter, and MAY include an optional `error_description` query parameter.\n   */\n  authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise\u003Cvoid\u003E;\n\n  /**\n   * Returns the `codeChallenge` that was used when the indicated authorization began.\n   */\n  challengeForAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string): Promise\u003Cstring\u003E;\n\n  /**\n   * Exchanges an authorization code for an access token.\n   */\n  exchangeAuthorizationCode(\n    client: OAuthClientInformationFull, \n    authorizationCode: string, \n    codeVerifier?: string,\n    redirectUri?: string,\n    resource?: URL\n  ): Promise\u003COAuthTokens\u003E;\n\n  /**\n   * Exchanges a refresh token for an access token.\n   */\n  exchangeRefreshToken(client: OAuthClientInformationFull, refreshToken: string, scopes?: string[], resource?: URL): Promise\u003COAuthTokens\u003E;\n\n  /**\n   * Verifies an access token and returns information about it.\n   */\n  verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E;\n\n  /**\n   * Revokes an access or refresh token. If unimplemented, token revocation is not supported (not recommended).\n   *\n   * If the given token is invalid or already revoked, this method should do nothing.\n   */\n  revokeToken?(client: OAuthClientInformationFull, request: OAuthTokenRevocationRequest): Promise\u003Cvoid\u003E;\n\n  /**\n   * Whether to skip local PKCE validation.\n   *\n   * If true, the server will not perform PKCE validation locally and will pass the code_verifier to the upstream server.\n   *\n   * NOTE: This should only be true if the upstream server is performing the actual PKCE validation.\n   */\n  skipLocalPkceValidation?: boolean;\n}\n\n\n/**\n * Slim implementation useful for token verification\n */\nexport interface OAuthTokenVerifier {\n  /**\n   * Verifies an access token and returns information about it.\n   */\n  verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E;\n}\n",
      "hash": "3e84aff03125a016c2bbeb5c70783b78bc8d619d6fd1ff804cb1e00d22e1fc63",
      "size": 2989
    },
    "/src/server/auth/providers/proxyProvider.test.ts": {
      "type": "content",
      "content": "import { Response } from \"express\";\nimport { ProxyOAuthServerProvider, ProxyOptions } from \"./proxyProvider.js\";\nimport { AuthInfo } from \"../types.js\";\nimport { OAuthClientInformationFull, OAuthTokens } from \"../../../shared/auth.js\";\nimport { ServerError } from \"../errors.js\";\nimport { InvalidTokenError } from \"../errors.js\";\nimport { InsufficientScopeError } from \"../errors.js\";\n\ndescribe(\"Proxy OAuth Server Provider\", () =\u003E {\n  // Mock client data\n  const validClient: OAuthClientInformationFull = {\n    client_id: \"test-client\",\n    client_secret: \"test-secret\",\n    redirect_uris: [\"https://example.com/callback\"],\n  };\n\n  // Mock response object\n  const mockResponse = {\n    redirect: jest.fn(),\n  } as unknown as Response;\n\n  // Mock provider functions\n  const mockVerifyToken = jest.fn();\n  const mockGetClient = jest.fn();\n\n  // Base provider options\n  const baseOptions: ProxyOptions = {\n    endpoints: {\n      authorizationUrl: \"https://auth.example.com/authorize\",\n      tokenUrl: \"https://auth.example.com/token\",\n      revocationUrl: \"https://auth.example.com/revoke\",\n      registrationUrl: \"https://auth.example.com/register\",\n    },\n    verifyAccessToken: mockVerifyToken,\n    getClient: mockGetClient,\n  };\n\n  let provider: ProxyOAuthServerProvider;\n  let originalFetch: typeof global.fetch;\n\n  beforeEach(() =\u003E {\n    provider = new ProxyOAuthServerProvider(baseOptions);\n    originalFetch = global.fetch;\n    global.fetch = jest.fn();\n\n    // Setup mock implementations\n    mockVerifyToken.mockImplementation(async (token: string) =\u003E {\n      if (token === \"valid-token\") {\n        return {\n          token,\n          clientId: \"test-client\",\n          scopes: [\"read\", \"write\"],\n          expiresAt: Date.now() / 1000 + 3600,\n        } as AuthInfo;\n      }\n      throw new InvalidTokenError(\"Invalid token\");\n    });\n\n    mockGetClient.mockImplementation(async (clientId: string) =\u003E {\n      if (clientId === \"test-client\") {\n        return validClient;\n      }\n      return undefined;\n    });\n  });\n\n  // Add helper function for failed responses\n  const mockFailedResponse = () =\u003E {\n    (global.fetch as jest.Mock).mockImplementation(() =\u003E\n      Promise.resolve({\n        ok: false,\n        status: 400,\n      })\n    );\n  };\n\n  afterEach(() =\u003E {\n    global.fetch = originalFetch;\n    jest.clearAllMocks();\n  });\n\n  describe(\"authorization\", () =\u003E {\n    it(\"redirects to authorization endpoint with correct parameters\", async () =\u003E {\n      await provider.authorize(\n        validClient,\n        {\n          redirectUri: \"https://example.com/callback\",\n          codeChallenge: \"test-challenge\",\n          state: \"test-state\",\n          scopes: [\"read\", \"write\"],\n          resource: new URL('https://api.example.com/resource'),\n        },\n        mockResponse\n      );\n\n      const expectedUrl = new URL(\"https://auth.example.com/authorize\");\n      expectedUrl.searchParams.set(\"client_id\", \"test-client\");\n      expectedUrl.searchParams.set(\"response_type\", \"code\");\n      expectedUrl.searchParams.set(\"redirect_uri\", \"https://example.com/callback\");\n      expectedUrl.searchParams.set(\"code_challenge\", \"test-challenge\");\n      expectedUrl.searchParams.set(\"code_challenge_method\", \"S256\");\n      expectedUrl.searchParams.set(\"state\", \"test-state\");\n      expectedUrl.searchParams.set(\"scope\", \"read write\");\n      expectedUrl.searchParams.set('resource', 'https://api.example.com/resource');\n\n      expect(mockResponse.redirect).toHaveBeenCalledWith(expectedUrl.toString());\n    });\n  });\n\n  describe(\"token exchange\", () =\u003E {\n    const mockTokenResponse: OAuthTokens = {\n      access_token: \"new-access-token\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n      refresh_token: \"new-refresh-token\",\n    };\n\n    beforeEach(() =\u003E {\n      (global.fetch as jest.Mock).mockImplementation(() =\u003E\n        Promise.resolve({\n          ok: true,\n          json: () =\u003E Promise.resolve(mockTokenResponse),\n        })\n      );\n    });\n\n    it(\"exchanges authorization code for tokens\", async () =\u003E {\n      const tokens = await provider.exchangeAuthorizationCode(\n        validClient,\n        \"test-code\",\n        \"test-verifier\"\n      );\n\n      expect(global.fetch).toHaveBeenCalledWith(\n        \"https://auth.example.com/token\",\n        expect.objectContaining({\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          },\n          body: expect.stringContaining(\"grant_type=authorization_code\")\n        })\n      );\n      expect(tokens).toEqual(mockTokenResponse);\n    });\n\n    it(\"includes redirect_uri in token request when provided\", async () =\u003E {\n      const redirectUri = \"https://example.com/callback\";\n      const tokens = await provider.exchangeAuthorizationCode(\n        validClient,\n        \"test-code\",\n        \"test-verifier\",\n        redirectUri\n      );\n\n      expect(global.fetch).toHaveBeenCalledWith(\n        \"https://auth.example.com/token\",\n        expect.objectContaining({\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          },\n          body: expect.stringContaining(`redirect_uri=${encodeURIComponent(redirectUri)}`)\n        })\n      );\n      expect(tokens).toEqual(mockTokenResponse);\n    });\n\n    it('includes resource parameter in authorization code exchange', async () =\u003E {\n      const tokens = await provider.exchangeAuthorizationCode(\n        validClient,\n        'test-code',\n        'test-verifier',\n        'https://example.com/callback',\n        new URL('https://api.example.com/resource')\n      );\n\n      expect(global.fetch).toHaveBeenCalledWith(\n        'https://auth.example.com/token',\n        expect.objectContaining({\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n          },\n          body: expect.stringContaining('resource=' + encodeURIComponent('https://api.example.com/resource'))\n        })\n      );\n      expect(tokens).toEqual(mockTokenResponse);\n    });\n\n    it('handles authorization code exchange without resource parameter', async () =\u003E {\n      const tokens = await provider.exchangeAuthorizationCode(\n        validClient,\n        'test-code',\n        'test-verifier'\n      );\n\n      const fetchCall = (global.fetch as jest.Mock).mock.calls[0];\n      const body = fetchCall[1].body as string;\n      expect(body).not.toContain('resource=');\n      expect(tokens).toEqual(mockTokenResponse);\n    });\n\n    it(\"exchanges refresh token for new tokens\", async () =\u003E {\n      const tokens = await provider.exchangeRefreshToken(\n        validClient,\n        \"test-refresh-token\",\n        [\"read\", \"write\"]\n      );\n\n      expect(global.fetch).toHaveBeenCalledWith(\n        \"https://auth.example.com/token\",\n        expect.objectContaining({\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          },\n          body: expect.stringContaining(\"grant_type=refresh_token\")\n        })\n      );\n      expect(tokens).toEqual(mockTokenResponse);\n    });\n\n    it('includes resource parameter in refresh token exchange', async () =\u003E {\n      const tokens = await provider.exchangeRefreshToken(\n        validClient,\n        'test-refresh-token',\n        ['read', 'write'],\n        new URL('https://api.example.com/resource')\n      );\n\n      expect(global.fetch).toHaveBeenCalledWith(\n        'https://auth.example.com/token',\n        expect.objectContaining({\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n          },\n          body: expect.stringContaining('resource=' + encodeURIComponent('https://api.example.com/resource'))\n        })\n      );\n      expect(tokens).toEqual(mockTokenResponse);\n    });\n  });\n\n  describe(\"client registration\", () =\u003E {\n    it(\"registers new client\", async () =\u003E {\n      const newClient: OAuthClientInformationFull = {\n        client_id: \"new-client\",\n        redirect_uris: [\"https://new-client.com/callback\"],\n      };\n\n      (global.fetch as jest.Mock).mockImplementation(() =\u003E\n        Promise.resolve({\n          ok: true,\n          json: () =\u003E Promise.resolve(newClient),\n        })\n      );\n\n      const result = await provider.clientsStore.registerClient!(newClient);\n\n      expect(global.fetch).toHaveBeenCalledWith(\n        \"https://auth.example.com/register\",\n        expect.objectContaining({\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(newClient),\n        })\n      );\n      expect(result).toEqual(newClient);\n    });\n\n    it(\"handles registration failure\", async () =\u003E {\n      mockFailedResponse();\n      const newClient: OAuthClientInformationFull = {\n        client_id: \"new-client\",\n        redirect_uris: [\"https://new-client.com/callback\"],\n      };\n\n      await expect(\n        provider.clientsStore.registerClient!(newClient)\n      ).rejects.toThrow(ServerError);\n    });\n  });\n\n  describe(\"token revocation\", () =\u003E {\n    it(\"revokes token\", async () =\u003E {\n      (global.fetch as jest.Mock).mockImplementation(() =\u003E\n        Promise.resolve({\n          ok: true,\n        })\n      );\n\n      await provider.revokeToken!(validClient, {\n        token: \"token-to-revoke\",\n        token_type_hint: \"access_token\",\n      });\n\n      expect(global.fetch).toHaveBeenCalledWith(\n        \"https://auth.example.com/revoke\",\n        expect.objectContaining({\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          },\n          body: expect.stringContaining(\"token=token-to-revoke\"),\n        })\n      );\n    });\n\n    it(\"handles revocation failure\", async () =\u003E {\n      mockFailedResponse();\n      await expect(\n        provider.revokeToken!(validClient, {\n          token: \"invalid-token\",\n        })\n      ).rejects.toThrow(ServerError);\n    });\n  });\n\n  describe(\"token verification\", () =\u003E {\n    it(\"verifies valid token\", async () =\u003E {\n      const validAuthInfo: AuthInfo = {\n        token: \"valid-token\",\n        clientId: \"test-client\",\n        scopes: [\"read\", \"write\"],\n        expiresAt: Date.now() / 1000 + 3600,\n      };\n      mockVerifyToken.mockResolvedValue(validAuthInfo);\n\n      const authInfo = await provider.verifyAccessToken(\"valid-token\");\n      expect(authInfo).toEqual(validAuthInfo);\n      expect(mockVerifyToken).toHaveBeenCalledWith(\"valid-token\");\n    });\n\n    it(\"passes through InvalidTokenError\", async () =\u003E {\n      const error = new InvalidTokenError(\"Token expired\");\n      mockVerifyToken.mockRejectedValue(error);\n\n      await expect(provider.verifyAccessToken(\"invalid-token\"))\n        .rejects.toBe(error);\n      expect(mockVerifyToken).toHaveBeenCalledWith(\"invalid-token\");\n    });\n\n    it(\"passes through InsufficientScopeError\", async () =\u003E {\n      const error = new InsufficientScopeError(\"Required scopes: read, write\");\n      mockVerifyToken.mockRejectedValue(error);\n\n      await expect(provider.verifyAccessToken(\"token-with-insufficient-scope\"))\n        .rejects.toBe(error);\n      expect(mockVerifyToken).toHaveBeenCalledWith(\"token-with-insufficient-scope\");\n    });\n\n    it(\"passes through unexpected errors\", async () =\u003E {\n      const error = new Error(\"Unexpected error\");\n      mockVerifyToken.mockRejectedValue(error);\n\n      await expect(provider.verifyAccessToken(\"valid-token\"))\n        .rejects.toBe(error);\n      expect(mockVerifyToken).toHaveBeenCalledWith(\"valid-token\");\n    });\n  });\n}); ",
      "hash": "c7d891e8d09ade04193536bf5a08261df056f4db746d1c54d3bc457dce0b86c4",
      "size": 11534
    },
    "/src/server/auth/providers/proxyProvider.ts": {
      "type": "content",
      "content": "import { Response } from \"express\";\nimport { OAuthRegisteredClientsStore } from \"../clients.js\";\nimport {\n  OAuthClientInformationFull,\n  OAuthClientInformationFullSchema,\n  OAuthTokenRevocationRequest,\n  OAuthTokens,\n  OAuthTokensSchema,\n} from \"../../../shared/auth.js\";\nimport { AuthInfo } from \"../types.js\";\nimport { AuthorizationParams, OAuthServerProvider } from \"../provider.js\";\nimport { ServerError } from \"../errors.js\";\nimport { FetchLike } from \"../../../shared/transport.js\";\n\nexport type ProxyEndpoints = {\n  authorizationUrl: string;\n  tokenUrl: string;\n  revocationUrl?: string;\n  registrationUrl?: string;\n};\n\nexport type ProxyOptions = {\n  /**\n   * Individual endpoint URLs for proxying specific OAuth operations\n   */\n  endpoints: ProxyEndpoints;\n\n  /**\n  * Function to verify access tokens and return auth info\n  */\n  verifyAccessToken: (token: string) =\u003E Promise\u003CAuthInfo\u003E;\n\n  /**\n  * Function to fetch client information from the upstream server\n  */\n  getClient: (clientId: string) =\u003E Promise\u003COAuthClientInformationFull | undefined\u003E;\n\n  /**\n   * Custom fetch implementation used for all network requests.\n   */\n  fetch?: FetchLike;\n};\n\n/**\n * Implements an OAuth server that proxies requests to another OAuth server.\n */\nexport class ProxyOAuthServerProvider implements OAuthServerProvider {\n  protected readonly _endpoints: ProxyEndpoints;\n  protected readonly _verifyAccessToken: (token: string) =\u003E Promise\u003CAuthInfo\u003E;\n  protected readonly _getClient: (clientId: string) =\u003E Promise\u003COAuthClientInformationFull | undefined\u003E;\n  protected readonly _fetch?: FetchLike;\n  \n  skipLocalPkceValidation = true;\n\n  revokeToken?: (\n    client: OAuthClientInformationFull,\n    request: OAuthTokenRevocationRequest\n  ) =\u003E Promise\u003Cvoid\u003E;\n\n  constructor(options: ProxyOptions) {\n    this._endpoints = options.endpoints;\n    this._verifyAccessToken = options.verifyAccessToken;\n    this._getClient = options.getClient;\n    this._fetch = options.fetch;\n    if (options.endpoints?.revocationUrl) {\n      this.revokeToken = async (\n        client: OAuthClientInformationFull,\n        request: OAuthTokenRevocationRequest\n      ) =\u003E {\n        const revocationUrl = this._endpoints.revocationUrl;\n\n        if (!revocationUrl) {\n          throw new Error(\"No revocation endpoint configured\");\n        }\n\n        const params = new URLSearchParams();\n        params.set(\"token\", request.token);\n        params.set(\"client_id\", client.client_id);\n        if (client.client_secret) {\n          params.set(\"client_secret\", client.client_secret);\n        }\n        if (request.token_type_hint) {\n          params.set(\"token_type_hint\", request.token_type_hint);\n        }\n\n        const response = await (this._fetch ?? fetch)(revocationUrl, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          },\n          body: params.toString(),\n        });\n\n        if (!response.ok) {\n          throw new ServerError(`Token revocation failed: ${response.status}`);\n        }\n      }\n    }\n  }\n\n  get clientsStore(): OAuthRegisteredClientsStore {\n    const registrationUrl = this._endpoints.registrationUrl;\n    return {\n      getClient: this._getClient,\n      ...(registrationUrl && {\n        registerClient: async (client: OAuthClientInformationFull) =\u003E {\n          const response = await (this._fetch ?? fetch)(registrationUrl, {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(client),\n          });\n\n          if (!response.ok) {\n            throw new ServerError(`Client registration failed: ${response.status}`);\n          }\n\n          const data = await response.json();\n          return OAuthClientInformationFullSchema.parse(data);\n        }\n      })\n    }\n  }\n\n  async authorize(\n    client: OAuthClientInformationFull,\n    params: AuthorizationParams,\n    res: Response\n  ): Promise\u003Cvoid\u003E {\n    // Start with required OAuth parameters\n    const targetUrl = new URL(this._endpoints.authorizationUrl);\n    const searchParams = new URLSearchParams({\n      client_id: client.client_id,\n      response_type: \"code\",\n      redirect_uri: params.redirectUri,\n      code_challenge: params.codeChallenge,\n      code_challenge_method: \"S256\"\n    });\n\n    // Add optional standard OAuth parameters\n    if (params.state) searchParams.set(\"state\", params.state);\n    if (params.scopes?.length) searchParams.set(\"scope\", params.scopes.join(\" \"));\n    if (params.resource) searchParams.set(\"resource\", params.resource.href);\n\n    targetUrl.search = searchParams.toString();\n    res.redirect(targetUrl.toString());\n  }\n\n  async challengeForAuthorizationCode(\n    _client: OAuthClientInformationFull,\n    _authorizationCode: string\n  ): Promise\u003Cstring\u003E {\n    // In a proxy setup, we don't store the code challenge ourselves\n    // Instead, we proxy the token request and let the upstream server validate it\n    return \"\";\n  }\n\n  async exchangeAuthorizationCode(\n    client: OAuthClientInformationFull,\n    authorizationCode: string,\n    codeVerifier?: string,\n    redirectUri?: string,\n    resource?: URL\n  ): Promise\u003COAuthTokens\u003E {\n    const params = new URLSearchParams({\n      grant_type: \"authorization_code\",\n      client_id: client.client_id,\n      code: authorizationCode,\n    });\n\n    if (client.client_secret) {\n      params.append(\"client_secret\", client.client_secret);\n    }\n\n    if (codeVerifier) {\n      params.append(\"code_verifier\", codeVerifier);\n    }\n\n    if (redirectUri) {\n      params.append(\"redirect_uri\", redirectUri);\n    }\n\n    if (resource) {\n      params.append(\"resource\", resource.href);\n    }\n\n    const response = await (this._fetch ?? fetch)(this._endpoints.tokenUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      body: params.toString(),\n    });\n\n\n    if (!response.ok) {\n      throw new ServerError(`Token exchange failed: ${response.status}`);\n    }\n\n    const data = await response.json();\n    return OAuthTokensSchema.parse(data);\n  }\n\n  async exchangeRefreshToken(\n    client: OAuthClientInformationFull,\n    refreshToken: string,\n    scopes?: string[],\n    resource?: URL\n  ): Promise\u003COAuthTokens\u003E {\n\n    const params = new URLSearchParams({\n      grant_type: \"refresh_token\",\n      client_id: client.client_id,\n      refresh_token: refreshToken,\n    });\n\n    if (client.client_secret) {\n      params.set(\"client_secret\", client.client_secret);\n    }\n\n    if (scopes?.length) {\n      params.set(\"scope\", scopes.join(\" \"));\n    }\n\n    if (resource) {\n      params.set(\"resource\", resource.href);\n    }\n\n    const response = await (this._fetch ?? fetch)(this._endpoints.tokenUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      body: params.toString(),\n    });\n\n    if (!response.ok) {\n      throw new ServerError(`Token refresh failed: ${response.status}`);\n    }\n\n    const data = await response.json();\n    return OAuthTokensSchema.parse(data);\n  }\n\n  async verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E {\n    return this._verifyAccessToken(token);\n  }\n} ",
      "hash": "a09d6130e09917231cb2ac224c53ebeff6c93a12782be57d94e041b20ca2f0c8",
      "size": 7194
    },
    "/src/server/auth/router.test.ts": {
      "type": "content",
      "content": "import { mcpAuthRouter, AuthRouterOptions, mcpAuthMetadataRouter, AuthMetadataOptions } from './router.js';\nimport { OAuthServerProvider, AuthorizationParams } from './provider.js';\nimport { OAuthRegisteredClientsStore } from './clients.js';\nimport { OAuthClientInformationFull, OAuthMetadata, OAuthTokenRevocationRequest, OAuthTokens } from '../../shared/auth.js';\nimport express, { Response } from 'express';\nimport supertest from 'supertest';\nimport { AuthInfo } from './types.js';\nimport { InvalidTokenError } from './errors.js';\n\n\ndescribe('MCP Auth Router', () =\u003E {\n  // Setup mock provider with full capabilities\n  const mockClientStore: OAuthRegisteredClientsStore = {\n    async getClient(clientId: string): Promise\u003COAuthClientInformationFull | undefined\u003E {\n      if (clientId === 'valid-client') {\n        return {\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          redirect_uris: ['https://example.com/callback']\n        };\n      }\n      return undefined;\n    },\n\n    async registerClient(client: OAuthClientInformationFull): Promise\u003COAuthClientInformationFull\u003E {\n      return client;\n    }\n  };\n\n  const mockProvider: OAuthServerProvider = {\n    clientsStore: mockClientStore,\n\n    async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise\u003Cvoid\u003E {\n      const redirectUrl = new URL(params.redirectUri);\n      redirectUrl.searchParams.set('code', 'mock_auth_code');\n      if (params.state) {\n        redirectUrl.searchParams.set('state', params.state);\n      }\n      res.redirect(302, redirectUrl.toString());\n    },\n\n    async challengeForAuthorizationCode(): Promise\u003Cstring\u003E {\n      return 'mock_challenge';\n    },\n\n    async exchangeAuthorizationCode(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'mock_refresh_token'\n      };\n    },\n\n    async exchangeRefreshToken(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'new_mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'new_mock_refresh_token'\n      };\n    },\n\n    async verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E {\n      if (token === 'valid_token') {\n        return {\n          token,\n          clientId: 'valid-client',\n          scopes: ['read', 'write'],\n          expiresAt: Date.now() / 1000 + 3600\n        };\n      }\n      throw new InvalidTokenError('Token is invalid or expired');\n    },\n\n    async revokeToken(_client: OAuthClientInformationFull, _request: OAuthTokenRevocationRequest): Promise\u003Cvoid\u003E {\n      // Success - do nothing in mock\n    }\n  };\n\n  // Provider without registration and revocation\n  const mockProviderMinimal: OAuthServerProvider = {\n    clientsStore: {\n      async getClient(clientId: string): Promise\u003COAuthClientInformationFull | undefined\u003E {\n        if (clientId === 'valid-client') {\n          return {\n            client_id: 'valid-client',\n            client_secret: 'valid-secret',\n            redirect_uris: ['https://example.com/callback']\n          };\n        }\n        return undefined;\n      }\n    },\n\n    async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise\u003Cvoid\u003E {\n      const redirectUrl = new URL(params.redirectUri);\n      redirectUrl.searchParams.set('code', 'mock_auth_code');\n      if (params.state) {\n        redirectUrl.searchParams.set('state', params.state);\n      }\n      res.redirect(302, redirectUrl.toString());\n    },\n\n    async challengeForAuthorizationCode(): Promise\u003Cstring\u003E {\n      return 'mock_challenge';\n    },\n\n    async exchangeAuthorizationCode(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'mock_refresh_token'\n      };\n    },\n\n    async exchangeRefreshToken(): Promise\u003COAuthTokens\u003E {\n      return {\n        access_token: 'new_mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'new_mock_refresh_token'\n      };\n    },\n\n    async verifyAccessToken(token: string): Promise\u003CAuthInfo\u003E {\n      if (token === 'valid_token') {\n        return {\n          token,\n          clientId: 'valid-client',\n          scopes: ['read'],\n          expiresAt: Date.now() / 1000 + 3600\n        };\n      }\n      throw new InvalidTokenError('Token is invalid or expired');\n    }\n  };\n\n  describe('Router creation', () =\u003E {\n    it('throws error for non-HTTPS issuer URL', () =\u003E {\n      const options: AuthRouterOptions = {\n        provider: mockProvider,\n        issuerUrl: new URL('http://auth.example.com')\n      };\n\n      expect(() =\u003E mcpAuthRouter(options)).toThrow('Issuer URL must be HTTPS');\n    });\n\n    it('allows localhost HTTP for development', () =\u003E {\n      const options: AuthRouterOptions = {\n        provider: mockProvider,\n        issuerUrl: new URL('http://localhost:3000')\n      };\n\n      expect(() =\u003E mcpAuthRouter(options)).not.toThrow();\n    });\n\n    it('throws error for issuer URL with fragment', () =\u003E {\n      const options: AuthRouterOptions = {\n        provider: mockProvider,\n        issuerUrl: new URL('https://auth.example.com#fragment')\n      };\n\n      expect(() =\u003E mcpAuthRouter(options)).toThrow('Issuer URL must not have a fragment');\n    });\n\n    it('throws error for issuer URL with query string', () =\u003E {\n      const options: AuthRouterOptions = {\n        provider: mockProvider,\n        issuerUrl: new URL('https://auth.example.com?param=value')\n      };\n\n      expect(() =\u003E mcpAuthRouter(options)).toThrow('Issuer URL must not have a query string');\n    });\n\n    it('successfully creates router with valid options', () =\u003E {\n      const options: AuthRouterOptions = {\n        provider: mockProvider,\n        issuerUrl: new URL('https://auth.example.com')\n      };\n\n      expect(() =\u003E mcpAuthRouter(options)).not.toThrow();\n    });\n  });\n\n  describe('Metadata endpoint', () =\u003E {\n    let app: express.Express;\n\n    beforeEach(() =\u003E {\n      // Setup full-featured router\n      app = express();\n      const options: AuthRouterOptions = {\n        provider: mockProvider,\n        issuerUrl: new URL('https://auth.example.com'),\n        serviceDocumentationUrl: new URL('https://docs.example.com')\n      };\n      app.use(mcpAuthRouter(options));\n    });\n\n    it('returns complete metadata for full-featured router', async () =\u003E {\n      const response = await supertest(app)\n        .get('/.well-known/oauth-authorization-server');\n\n      expect(response.status).toBe(200);\n\n      // Verify essential fields\n      expect(response.body.issuer).toBe('https://auth.example.com/');\n      expect(response.body.authorization_endpoint).toBe('https://auth.example.com/authorize');\n      expect(response.body.token_endpoint).toBe('https://auth.example.com/token');\n      expect(response.body.registration_endpoint).toBe('https://auth.example.com/register');\n      expect(response.body.revocation_endpoint).toBe('https://auth.example.com/revoke');\n\n      // Verify supported features\n      expect(response.body.response_types_supported).toEqual(['code']);\n      expect(response.body.grant_types_supported).toEqual(['authorization_code', 'refresh_token']);\n      expect(response.body.code_challenge_methods_supported).toEqual(['S256']);\n      expect(response.body.token_endpoint_auth_methods_supported).toEqual(['client_secret_post']);\n      expect(response.body.revocation_endpoint_auth_methods_supported).toEqual(['client_secret_post']);\n\n      // Verify optional fields\n      expect(response.body.service_documentation).toBe('https://docs.example.com/');\n    });\n\n    it('returns minimal metadata for minimal router', async () =\u003E {\n      // Setup minimal router\n      const minimalApp = express();\n      const options: AuthRouterOptions = {\n        provider: mockProviderMinimal,\n        issuerUrl: new URL('https://auth.example.com')\n      };\n      minimalApp.use(mcpAuthRouter(options));\n\n      const response = await supertest(minimalApp)\n        .get('/.well-known/oauth-authorization-server');\n\n      expect(response.status).toBe(200);\n\n      // Verify essential endpoints\n      expect(response.body.issuer).toBe('https://auth.example.com/');\n      expect(response.body.authorization_endpoint).toBe('https://auth.example.com/authorize');\n      expect(response.body.token_endpoint).toBe('https://auth.example.com/token');\n\n      // Verify missing optional endpoints\n      expect(response.body.registration_endpoint).toBeUndefined();\n      expect(response.body.revocation_endpoint).toBeUndefined();\n      expect(response.body.revocation_endpoint_auth_methods_supported).toBeUndefined();\n      expect(response.body.service_documentation).toBeUndefined();\n    });\n\n    it('provides protected resource metadata', async () =\u003E {\n      // Setup router with draft protocol version\n      const draftApp = express();\n      const options: AuthRouterOptions = {\n        provider: mockProvider,\n        issuerUrl: new URL('https://mcp.example.com'),\n        scopesSupported: ['read', 'write'],\n        resourceName: 'Test API'\n      };\n      draftApp.use(mcpAuthRouter(options));\n\n      const response = await supertest(draftApp)\n        .get('/.well-known/oauth-protected-resource');\n\n      expect(response.status).toBe(200);\n\n      // Verify protected resource metadata\n      expect(response.body.resource).toBe('https://mcp.example.com/');\n      expect(response.body.authorization_servers).toContain('https://mcp.example.com/');\n      expect(response.body.scopes_supported).toEqual(['read', 'write']);\n      expect(response.body.resource_name).toBe('Test API');\n    });\n  });\n\n  describe('Endpoint routing', () =\u003E {\n    let app: express.Express;\n\n    beforeEach(() =\u003E {\n      // Setup full-featured router\n      app = express();\n      const options: AuthRouterOptions = {\n        provider: mockProvider,\n        issuerUrl: new URL('https://auth.example.com')\n      };\n      app.use(mcpAuthRouter(options));\n      jest.spyOn(console, 'error').mockImplementation(() =\u003E {});\n    });\n\n    afterEach(() =\u003E {\n      jest.restoreAllMocks();\n    });\n\n    it('routes to authorization endpoint', async () =\u003E {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.has('code')).toBe(true);\n    });\n\n    it('routes to token endpoint', async () =\u003E {\n      // Setup verifyChallenge mock for token handler\n      jest.mock('pkce-challenge', () =\u003E ({\n        verifyChallenge: jest.fn().mockResolvedValue(true)\n      }));\n\n      const response = await supertest(app)\n        .post('/token')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          grant_type: 'authorization_code',\n          code: 'valid_code',\n          code_verifier: 'valid_verifier'\n        });\n\n      // The request will fail in testing due to mocking limitations,\n      // but we can verify the route was matched\n      expect(response.status).not.toBe(404);\n    });\n\n    it('routes to registration endpoint', async () =\u003E {\n      const response = await supertest(app)\n        .post('/register')\n        .send({\n          redirect_uris: ['https://example.com/callback']\n        });\n\n      // The request will fail in testing due to mocking limitations,\n      // but we can verify the route was matched\n      expect(response.status).not.toBe(404);\n    });\n\n    it('routes to revocation endpoint', async () =\u003E {\n      const response = await supertest(app)\n        .post('/revoke')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          token: 'token_to_revoke'\n        });\n\n      // The request will fail in testing due to mocking limitations,\n      // but we can verify the route was matched\n      expect(response.status).not.toBe(404);\n    });\n\n    it('excludes endpoints for unsupported features', async () =\u003E {\n      // Setup minimal router\n      const minimalApp = express();\n      const options: AuthRouterOptions = {\n        provider: mockProviderMinimal,\n        issuerUrl: new URL('https://auth.example.com')\n      };\n      minimalApp.use(mcpAuthRouter(options));\n\n      // Registration should not be available\n      const regResponse = await supertest(minimalApp)\n        .post('/register')\n        .send({\n          redirect_uris: ['https://example.com/callback']\n        });\n      expect(regResponse.status).toBe(404);\n\n      // Revocation should not be available\n      const revokeResponse = await supertest(minimalApp)\n        .post('/revoke')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          token: 'token_to_revoke'\n        });\n      expect(revokeResponse.status).toBe(404);\n    });\n  });\n});\n\ndescribe('MCP Auth Metadata Router', () =\u003E {\n\n  const mockOAuthMetadata : OAuthMetadata = {\n    issuer: 'https://auth.example.com/',\n    authorization_endpoint: \"https://auth.example.com/authorize\",\n    token_endpoint: \"https://auth.example.com/token\",\n    response_types_supported: [\"code\"],\n    grant_types_supported: [\"authorization_code\", \"refresh_token\"],\n    code_challenge_methods_supported: [\"S256\"],\n    token_endpoint_auth_methods_supported: [\"client_secret_post\"],\n  }\n\n  describe('Router creation', () =\u003E {\n    it('successfully creates router with valid options', () =\u003E {\n      const options: AuthMetadataOptions = {\n        oauthMetadata: mockOAuthMetadata,\n        resourceServerUrl: new URL('https://api.example.com'),\n      };\n\n      expect(() =\u003E mcpAuthMetadataRouter(options)).not.toThrow();\n    });\n  });\n\n  describe('Metadata endpoints', () =\u003E {\n    let app: express.Express;\n\n    beforeEach(() =\u003E {\n      app = express();\n      const options: AuthMetadataOptions = {\n        oauthMetadata: mockOAuthMetadata,\n        resourceServerUrl: new URL('https://api.example.com'),\n        serviceDocumentationUrl: new URL('https://docs.example.com'),\n        scopesSupported: ['read', 'write'],\n        resourceName: 'Test API'\n      };\n      app.use(mcpAuthMetadataRouter(options));\n    });\n\n    it('returns OAuth authorization server metadata', async () =\u003E {\n      const response = await supertest(app)\n        .get('/.well-known/oauth-authorization-server');\n\n      expect(response.status).toBe(200);\n\n      // Verify metadata points to authorization server\n      expect(response.body.issuer).toBe('https://auth.example.com/');\n      expect(response.body.authorization_endpoint).toBe('https://auth.example.com/authorize');\n      expect(response.body.token_endpoint).toBe('https://auth.example.com/token');\n      expect(response.body.response_types_supported).toEqual(['code']);\n      expect(response.body.grant_types_supported).toEqual(['authorization_code', 'refresh_token']);\n      expect(response.body.code_challenge_methods_supported).toEqual(['S256']);\n      expect(response.body.token_endpoint_auth_methods_supported).toEqual(['client_secret_post']);\n    });\n\n    it('returns OAuth protected resource metadata', async () =\u003E {\n      const response = await supertest(app)\n        .get('/.well-known/oauth-protected-resource');\n\n      expect(response.status).toBe(200);\n\n      // Verify protected resource metadata\n      expect(response.body.resource).toBe('https://api.example.com/');\n      expect(response.body.authorization_servers).toEqual(['https://auth.example.com/']);\n      expect(response.body.scopes_supported).toEqual(['read', 'write']);\n      expect(response.body.resource_name).toBe('Test API');\n      expect(response.body.resource_documentation).toBe('https://docs.example.com/');\n    });\n\n    it('works with minimal configuration', async () =\u003E {\n      const minimalApp = express();\n      const options: AuthMetadataOptions = {\n        oauthMetadata: mockOAuthMetadata,\n        resourceServerUrl: new URL('https://api.example.com'),\n      };\n      minimalApp.use(mcpAuthMetadataRouter(options));\n\n      const authResponse = await supertest(minimalApp)\n        .get('/.well-known/oauth-authorization-server');\n\n      expect(authResponse.status).toBe(200);\n      expect(authResponse.body.issuer).toBe('https://auth.example.com/');\n      expect(authResponse.body.service_documentation).toBeUndefined();\n      expect(authResponse.body.scopes_supported).toBeUndefined();\n\n      const resourceResponse = await supertest(minimalApp)\n        .get('/.well-known/oauth-protected-resource');\n\n      expect(resourceResponse.status).toBe(200);\n      expect(resourceResponse.body.resource).toBe('https://api.example.com/');\n      expect(resourceResponse.body.authorization_servers).toEqual(['https://auth.example.com/']);\n      expect(resourceResponse.body.scopes_supported).toBeUndefined();\n      expect(resourceResponse.body.resource_name).toBeUndefined();\n      expect(resourceResponse.body.resource_documentation).toBeUndefined();\n    });\n  });\n});\n",
      "hash": "fc256eebc61ab700814bd3a64821beeb5d3ed39e8376a22e1da60c510909a240",
      "size": 17177
    },
    "/src/server/auth/router.ts": {
      "type": "content",
      "content": "import express, { RequestHandler } from \"express\";\nimport { clientRegistrationHandler, ClientRegistrationHandlerOptions } from \"./handlers/register.js\";\nimport { tokenHandler, TokenHandlerOptions } from \"./handlers/token.js\";\nimport { authorizationHandler, AuthorizationHandlerOptions } from \"./handlers/authorize.js\";\nimport { revocationHandler, RevocationHandlerOptions } from \"./handlers/revoke.js\";\nimport { metadataHandler } from \"./handlers/metadata.js\";\nimport { OAuthServerProvider } from \"./provider.js\";\nimport { OAuthMetadata, OAuthProtectedResourceMetadata } from \"../../shared/auth.js\";\n\nexport type AuthRouterOptions = {\n  /**\n   * A provider implementing the actual authorization logic for this router.\n   */\n  provider: OAuthServerProvider;\n\n  /**\n   * The authorization server's issuer identifier, which is a URL that uses the \"https\" scheme and has no query or fragment components.\n   */\n  issuerUrl: URL;\n\n  /**\n   * The base URL of the authorization server to use for the metadata endpoints.\n   *\n   * If not provided, the issuer URL will be used as the base URL.\n   */\n  baseUrl?: URL;\n\n  /**\n   * An optional URL of a page containing human-readable information that developers might want or need to know when using the authorization server.\n   */\n  serviceDocumentationUrl?: URL;\n\n  /**\n   * An optional list of scopes supported by this authorization server\n   */\n  scopesSupported?: string[];\n\n\n  /**\n   * The resource name to be displayed in protected resource metadata\n   */\n  resourceName?: string;\n\n  // Individual options per route\n  authorizationOptions?: Omit\u003CAuthorizationHandlerOptions, \"provider\"\u003E;\n  clientRegistrationOptions?: Omit\u003CClientRegistrationHandlerOptions, \"clientsStore\"\u003E;\n  revocationOptions?: Omit\u003CRevocationHandlerOptions, \"provider\"\u003E;\n  tokenOptions?: Omit\u003CTokenHandlerOptions, \"provider\"\u003E;\n};\n\nconst checkIssuerUrl = (issuer: URL): void =\u003E {\n  // Technically RFC 8414 does not permit a localhost HTTPS exemption, but this will be necessary for ease of testing\n  if (issuer.protocol !== \"https:\" && issuer.hostname !== \"localhost\" && issuer.hostname !== \"127.0.0.1\") {\n    throw new Error(\"Issuer URL must be HTTPS\");\n  }\n  if (issuer.hash) {\n    throw new Error(`Issuer URL must not have a fragment: ${issuer}`);\n  }\n  if (issuer.search) {\n    throw new Error(`Issuer URL must not have a query string: ${issuer}`);\n  }\n}\n\nexport const createOAuthMetadata = (options: {\n  provider: OAuthServerProvider,\n  issuerUrl: URL,\n  baseUrl?: URL\n  serviceDocumentationUrl?: URL,\n  scopesSupported?: string[];\n}): OAuthMetadata =\u003E {\n  const issuer = options.issuerUrl;\n  const baseUrl = options.baseUrl;\n\n  checkIssuerUrl(issuer);\n\n  const authorization_endpoint = \"/authorize\";\n  const token_endpoint = \"/token\";\n  const registration_endpoint = options.provider.clientsStore.registerClient ? \"/register\" : undefined;\n  const revocation_endpoint = options.provider.revokeToken ? \"/revoke\" : undefined;\n\n  const metadata: OAuthMetadata = {\n    issuer: issuer.href,\n    service_documentation: options.serviceDocumentationUrl?.href,\n\n    authorization_endpoint: new URL(authorization_endpoint, baseUrl || issuer).href,\n    response_types_supported: [\"code\"],\n    code_challenge_methods_supported: [\"S256\"],\n\n    token_endpoint: new URL(token_endpoint, baseUrl || issuer).href,\n    token_endpoint_auth_methods_supported: [\"client_secret_post\"],\n    grant_types_supported: [\"authorization_code\", \"refresh_token\"],\n\n    scopes_supported: options.scopesSupported,\n\n    revocation_endpoint: revocation_endpoint ? new URL(revocation_endpoint, baseUrl || issuer).href : undefined,\n    revocation_endpoint_auth_methods_supported: revocation_endpoint ? [\"client_secret_post\"] : undefined,\n\n    registration_endpoint: registration_endpoint ? new URL(registration_endpoint, baseUrl || issuer).href : undefined,\n  };\n\n  return metadata\n}\n\n/**\n * Installs standard MCP authorization server endpoints, including dynamic client registration and token revocation (if supported).\n * Also advertises standard authorization server metadata, for easier discovery of supported configurations by clients.\n * Note: if your MCP server is only a resource server and not an authorization server, use mcpAuthMetadataRouter instead.\n *\n * By default, rate limiting is applied to all endpoints to prevent abuse.\n *\n * This router MUST be installed at the application root, like so:\n *\n *  const app = express();\n *  app.use(mcpAuthRouter(...));\n */\nexport function mcpAuthRouter(options: AuthRouterOptions): RequestHandler {\n  const oauthMetadata = createOAuthMetadata(options);\n\n  const router = express.Router();\n\n  router.use(\n    new URL(oauthMetadata.authorization_endpoint).pathname,\n    authorizationHandler({ provider: options.provider, ...options.authorizationOptions })\n  );\n\n  router.use(\n    new URL(oauthMetadata.token_endpoint).pathname,\n    tokenHandler({ provider: options.provider, ...options.tokenOptions })\n  );\n\n  router.use(mcpAuthMetadataRouter({\n    oauthMetadata,\n    // This router is used for AS+RS combo's, so the issuer is also the resource server\n    resourceServerUrl: new URL(oauthMetadata.issuer),\n    serviceDocumentationUrl: options.serviceDocumentationUrl,\n    scopesSupported: options.scopesSupported,\n    resourceName: options.resourceName\n  }));\n\n  if (oauthMetadata.registration_endpoint) {\n    router.use(\n      new URL(oauthMetadata.registration_endpoint).pathname,\n      clientRegistrationHandler({\n        clientsStore: options.provider.clientsStore,\n        ...options.clientRegistrationOptions,\n      })\n    );\n  }\n\n  if (oauthMetadata.revocation_endpoint) {\n    router.use(\n      new URL(oauthMetadata.revocation_endpoint).pathname,\n      revocationHandler({ provider: options.provider, ...options.revocationOptions })\n    );\n  }\n\n  return router;\n}\n\nexport type AuthMetadataOptions = {\n  /**\n   * OAuth Metadata as would be returned from the authorization server\n   * this MCP server relies on\n   */\n  oauthMetadata: OAuthMetadata;\n\n  /**\n   * The url of the MCP server, for use in protected resource metadata\n   */\n  resourceServerUrl: URL;\n\n  /**\n   * The url for documentation for the MCP server\n   */\n  serviceDocumentationUrl?: URL;\n\n  /**\n   * An optional list of scopes supported by this MCP server\n   */\n  scopesSupported?: string[];\n\n  /**\n   * An optional resource name to display in resource metadata\n   */\n  resourceName?: string;\n}\n\nexport function mcpAuthMetadataRouter(options: AuthMetadataOptions) {\n  checkIssuerUrl(new URL(options.oauthMetadata.issuer));\n\n  const router = express.Router();\n\n  const protectedResourceMetadata: OAuthProtectedResourceMetadata = {\n    resource: options.resourceServerUrl.href,\n\n    authorization_servers: [\n      options.oauthMetadata.issuer\n    ],\n\n    scopes_supported: options.scopesSupported,\n    resource_name: options.resourceName,\n    resource_documentation: options.serviceDocumentationUrl?.href,\n  };\n\n  router.use(\"/.well-known/oauth-protected-resource\", metadataHandler(protectedResourceMetadata));\n\n  // Always add this for backwards compatibility\n  router.use(\"/.well-known/oauth-authorization-server\", metadataHandler(options.oauthMetadata));\n\n  return router;\n}\n\n/**\n * Helper function to construct the OAuth 2.0 Protected Resource Metadata URL\n * from a given server URL. This replaces the path with the standard metadata endpoint.\n *\n * @param serverUrl - The base URL of the protected resource server\n * @returns The URL for the OAuth protected resource metadata endpoint\n *\n * @example\n * getOAuthProtectedResourceMetadataUrl(new URL('https://api.example.com/mcp'))\n * // Returns: 'https://api.example.com/.well-known/oauth-protected-resource'\n */\nexport function getOAuthProtectedResourceMetadataUrl(serverUrl: URL): string {\n  return new URL('/.well-known/oauth-protected-resource', serverUrl).href;\n}\n",
      "hash": "af9dde18a29d9e1a0bb990283ff3b5e9481066d9914ea1e45de8b450fc0acc81",
      "size": 7826
    },
    "/src/server/auth/types.ts": {
      "type": "content",
      "content": "/**\n * Information about a validated access token, provided to request handlers.\n */\nexport interface AuthInfo {\n  /**\n   * The access token.\n   */\n  token: string;\n\n  /**\n   * The client ID associated with this token.\n   */\n  clientId: string;\n\n  /**\n   * Scopes associated with this token.\n   */\n  scopes: string[];\n\n  /**\n   * When the token expires (in seconds since epoch).\n   */\n  expiresAt?: number;\n\n  /**\n   * The RFC 8707 resource server identifier for which this token is valid.\n   * If set, this MUST match the MCP server's resource identifier (minus hash fragment).\n   */\n  resource?: URL;\n\n  /**\n   * Additional data associated with the token.\n   * This field should be used for any additional data that needs to be attached to the auth info.\n  */\n  extra?: Record\u003Cstring, unknown\u003E;\n}",
      "hash": "247d847bcc4deb571941ff0cd9e862b1eeada98da7b306e5f3adcf08144404ec",
      "size": 798
    },
    "/src/server/completable.test.ts": {
      "type": "content",
      "content": "import { z } from \"zod\";\nimport { completable } from \"./completable.js\";\n\ndescribe(\"completable\", () =\u003E {\n  it(\"preserves types and values of underlying schema\", () =\u003E {\n    const baseSchema = z.string();\n    const schema = completable(baseSchema, () =\u003E []);\n\n    expect(schema.parse(\"test\")).toBe(\"test\");\n    expect(() =\u003E schema.parse(123)).toThrow();\n  });\n\n  it(\"provides access to completion function\", async () =\u003E {\n    const completions = [\"foo\", \"bar\", \"baz\"];\n    const schema = completable(z.string(), () =\u003E completions);\n\n    expect(await schema._def.complete(\"\")).toEqual(completions);\n  });\n\n  it(\"allows async completion functions\", async () =\u003E {\n    const completions = [\"foo\", \"bar\", \"baz\"];\n    const schema = completable(z.string(), async () =\u003E completions);\n\n    expect(await schema._def.complete(\"\")).toEqual(completions);\n  });\n\n  it(\"passes current value to completion function\", async () =\u003E {\n    const schema = completable(z.string(), (value) =\u003E [value + \"!\"]);\n\n    expect(await schema._def.complete(\"test\")).toEqual([\"test!\"]);\n  });\n\n  it(\"works with number schemas\", async () =\u003E {\n    const schema = completable(z.number(), () =\u003E [1, 2, 3]);\n\n    expect(schema.parse(1)).toBe(1);\n    expect(await schema._def.complete(0)).toEqual([1, 2, 3]);\n  });\n\n  it(\"preserves schema description\", () =\u003E {\n    const desc = \"test description\";\n    const schema = completable(z.string().describe(desc), () =\u003E []);\n\n    expect(schema.description).toBe(desc);\n  });\n});\n",
      "hash": "a5be415bcd5f0691301ffe6ee4d1b156e5cb876dd19d2c6e0f559d3e08ec8e05",
      "size": 1482
    },
    "/src/server/completable.ts": {
      "type": "content",
      "content": "import {\n  ZodTypeAny,\n  ZodTypeDef,\n  ZodType,\n  ParseInput,\n  ParseReturnType,\n  RawCreateParams,\n  ZodErrorMap,\n  ProcessedCreateParams,\n} from \"zod\";\n\nexport enum McpZodTypeKind {\n  Completable = \"McpCompletable\",\n}\n\nexport type CompleteCallback\u003CT extends ZodTypeAny = ZodTypeAny\u003E = (\n  value: T[\"_input\"],\n  context?: {\n    arguments?: Record\u003Cstring, string\u003E;\n  },\n) =\u003E T[\"_input\"][] | Promise\u003CT[\"_input\"][]\u003E;\n\nexport interface CompletableDef\u003CT extends ZodTypeAny = ZodTypeAny\u003E\n  extends ZodTypeDef {\n  type: T;\n  complete: CompleteCallback\u003CT\u003E;\n  typeName: McpZodTypeKind.Completable;\n}\n\nexport class Completable\u003CT extends ZodTypeAny\u003E extends ZodType\u003C\n  T[\"_output\"],\n  CompletableDef\u003CT\u003E,\n  T[\"_input\"]\n\u003E {\n  _parse(input: ParseInput): ParseReturnType\u003Cthis[\"_output\"]\u003E {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx,\n    });\n  }\n\n  unwrap() {\n    return this._def.type;\n  }\n\n  static create = \u003CT extends ZodTypeAny\u003E(\n    type: T,\n    params: RawCreateParams & {\n      complete: CompleteCallback\u003CT\u003E;\n    },\n  ): Completable\u003CT\u003E =\u003E {\n    return new Completable({\n      type,\n      typeName: McpZodTypeKind.Completable,\n      complete: params.complete,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n/**\n * Wraps a Zod type to provide autocompletion capabilities. Useful for, e.g., prompt arguments in MCP.\n */\nexport function completable\u003CT extends ZodTypeAny\u003E(\n  schema: T,\n  complete: CompleteCallback\u003CT\u003E,\n): Completable\u003CT\u003E {\n  return Completable.create(schema, { ...schema._def, complete });\n}\n\n// Not sure why this isn't exported from Zod:\n// https://github.com/colinhacks/zod/blob/f7ad26147ba291cb3fb257545972a8e00e767470/src/types.ts#L130\nfunction processCreateParams(params: RawCreateParams): ProcessedCreateParams {\n  if (!params) return {};\n  const { errorMap, invalid_type_error, required_error, description } = params;\n  if (errorMap && (invalid_type_error || required_error)) {\n    throw new Error(\n      `Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`,\n    );\n  }\n  if (errorMap) return { errorMap: errorMap, description };\n  const customMap: ZodErrorMap = (iss, ctx) =\u003E {\n    const { message } = params;\n\n    if (iss.code === \"invalid_enum_value\") {\n      return { message: message ?? ctx.defaultError };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return { message: message ?? required_error ?? ctx.defaultError };\n    }\n    if (iss.code !== \"invalid_type\") return { message: ctx.defaultError };\n    return { message: message ?? invalid_type_error ?? ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\n",
      "hash": "73549e5af074fce9b5653c11deb3c0e83f738790d18eb477e4fa4184c975012d",
      "size": 2724
    },
    "/src/server/index.test.ts": {
      "type": "content",
      "content": "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-constant-binary-expression */\n/* eslint-disable @typescript-eslint/no-unused-expressions */\nimport { Server } from \"./index.js\";\nimport { z } from \"zod\";\nimport {\n  RequestSchema,\n  NotificationSchema,\n  ResultSchema,\n  LATEST_PROTOCOL_VERSION,\n  SUPPORTED_PROTOCOL_VERSIONS,\n  CreateMessageRequestSchema,\n  ElicitRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListToolsRequestSchema,\n  SetLevelRequestSchema,\n  ErrorCode\n} from \"../types.js\";\nimport { Transport } from \"../shared/transport.js\";\nimport { InMemoryTransport } from \"../inMemory.js\";\nimport { Client } from \"../client/index.js\";\n\ntest(\"should accept latest protocol version\", async () =\u003E {\n  let sendPromiseResolve: (value: unknown) =\u003E void;\n  const sendPromise = new Promise((resolve) =\u003E {\n    sendPromiseResolve = resolve;\n  });\n\n  const serverTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) =\u003E {\n      if (message.id === 1 && message.result) {\n        expect(message.result).toEqual({\n          protocolVersion: LATEST_PROTOCOL_VERSION,\n          capabilities: expect.any(Object),\n          serverInfo: {\n            name: \"test server\",\n            version: \"1.0\",\n          },\n          instructions: \"Test instructions\",\n        });\n        sendPromiseResolve(undefined);\n      }\n      return Promise.resolve();\n    }),\n  };\n\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n      instructions: \"Test instructions\",\n    },\n  );\n\n  await server.connect(serverTransport);\n\n  // Simulate initialize request with latest version\n  serverTransport.onmessage?.({\n    jsonrpc: \"2.0\",\n    id: 1,\n    method: \"initialize\",\n    params: {\n      protocolVersion: LATEST_PROTOCOL_VERSION,\n      capabilities: {},\n      clientInfo: {\n        name: \"test client\",\n        version: \"1.0\",\n      },\n    },\n  });\n\n  await expect(sendPromise).resolves.toBeUndefined();\n});\n\ntest(\"should accept supported older protocol version\", async () =\u003E {\n  const OLD_VERSION = SUPPORTED_PROTOCOL_VERSIONS[1];\n  let sendPromiseResolve: (value: unknown) =\u003E void;\n  const sendPromise = new Promise((resolve) =\u003E {\n    sendPromiseResolve = resolve;\n  });\n\n  const serverTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) =\u003E {\n      if (message.id === 1 && message.result) {\n        expect(message.result).toEqual({\n          protocolVersion: OLD_VERSION,\n          capabilities: expect.any(Object),\n          serverInfo: {\n            name: \"test server\",\n            version: \"1.0\",\n          },\n        });\n        sendPromiseResolve(undefined);\n      }\n      return Promise.resolve();\n    }),\n  };\n\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n    },\n  );\n\n  await server.connect(serverTransport);\n\n  // Simulate initialize request with older version\n  serverTransport.onmessage?.({\n    jsonrpc: \"2.0\",\n    id: 1,\n    method: \"initialize\",\n    params: {\n      protocolVersion: OLD_VERSION,\n      capabilities: {},\n      clientInfo: {\n        name: \"test client\",\n        version: \"1.0\",\n      },\n    },\n  });\n\n  await expect(sendPromise).resolves.toBeUndefined();\n});\n\ntest(\"should handle unsupported protocol version\", async () =\u003E {\n  let sendPromiseResolve: (value: unknown) =\u003E void;\n  const sendPromise = new Promise((resolve) =\u003E {\n    sendPromiseResolve = resolve;\n  });\n\n  const serverTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) =\u003E {\n      if (message.id === 1 && message.result) {\n        expect(message.result).toEqual({\n          protocolVersion: LATEST_PROTOCOL_VERSION,\n          capabilities: expect.any(Object),\n          serverInfo: {\n            name: \"test server\",\n            version: \"1.0\",\n          },\n        });\n        sendPromiseResolve(undefined);\n      }\n      return Promise.resolve();\n    }),\n  };\n\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n    },\n  );\n\n  await server.connect(serverTransport);\n\n  // Simulate initialize request with unsupported version\n  serverTransport.onmessage?.({\n    jsonrpc: \"2.0\",\n    id: 1,\n    method: \"initialize\",\n    params: {\n      protocolVersion: \"invalid-version\",\n      capabilities: {},\n      clientInfo: {\n        name: \"test client\",\n        version: \"1.0\",\n      },\n    },\n  });\n\n  await expect(sendPromise).resolves.toBeUndefined();\n});\n\ntest(\"should respect client capabilities\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  // Implement request handler for sampling/createMessage\n  client.setRequestHandler(CreateMessageRequestSchema, async (request) =\u003E {\n    // Mock implementation of createMessage\n    return {\n      model: \"test-model\",\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"This is a test response\",\n      },\n    };\n  });\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  expect(server.getClientCapabilities()).toEqual({ sampling: {} });\n\n  // This should work because sampling is supported by the client\n  await expect(\n    server.createMessage({\n      messages: [],\n      maxTokens: 10,\n    }),\n  ).resolves.not.toThrow();\n\n  // This should still throw because roots are not supported by the client\n  await expect(server.listRoots()).rejects.toThrow(/^Client does not support/);\n});\n\ntest(\"should respect client elicitation capabilities\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        elicitation: {},\n      },\n    },\n  );\n\n  client.setRequestHandler(ElicitRequestSchema, (params) =\u003E ({\n    action: \"accept\",\n    content: {\n      username: params.params.message.includes(\"username\") ? \"test-user\" : undefined,\n      confirmed: true,\n    },\n  }));\n\n  const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  expect(server.getClientCapabilities()).toEqual({ elicitation: {} });\n\n  // This should work because elicitation is supported by the client\n  await expect(\n    server.elicitInput({\n      message: \"Please provide your username\",\n      requestedSchema: {\n        type: \"object\",\n        properties: {\n          username: {\n            type: \"string\",\n            title: \"Username\",\n            description: \"Your username\",\n          },\n          confirmed: {\n            type: \"boolean\",\n            title: \"Confirm\",\n            description: \"Please confirm\",\n            default: false,\n          },\n        },\n        required: [\"username\"],\n      },\n    }),\n  ).resolves.toEqual({\n    action: \"accept\",\n    content: {\n      username: \"test-user\",\n      confirmed: true,\n    },\n  });\n\n  // This should still throw because sampling is not supported by the client\n  await expect(\n    server.createMessage({\n      messages: [],\n      maxTokens: 10,\n    }),\n  ).rejects.toThrow(/^Client does not support/);\n});\n\ntest(\"should validate elicitation response against requested schema\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        elicitation: {},\n      },\n    },\n  );\n\n  // Set up client to return valid response\n  client.setRequestHandler(ElicitRequestSchema, (request) =\u003E ({\n    action: \"accept\",\n    content: {\n      name: \"John Doe\",\n      email: \"john@example.com\",\n      age: 30,\n    },\n  }));\n\n  const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Test with valid response\n  await expect(\n    server.elicitInput({\n      message: \"Please provide your information\",\n      requestedSchema: {\n        type: \"object\",\n        properties: {\n          name: {\n            type: \"string\",\n            minLength: 1,\n          },\n          email: {\n            type: \"string\",\n            minLength: 1,\n          },\n          age: {\n            type: \"integer\",\n            minimum: 0,\n            maximum: 150,\n          },\n        },\n        required: [\"name\", \"email\"],\n      },\n    }),\n  ).resolves.toEqual({\n    action: \"accept\",\n    content: {\n      name: \"John Doe\",\n      email: \"john@example.com\",\n      age: 30,\n    },\n  });\n});\n\ntest(\"should reject elicitation response with invalid data\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        elicitation: {},\n      },\n    },\n  );\n\n  // Set up client to return invalid response (missing required field, invalid age)\n  client.setRequestHandler(ElicitRequestSchema, (request) =\u003E ({\n    action: \"accept\",\n    content: {\n      email: \"\", // Invalid - too short\n      age: -5, // Invalid age\n    },\n  }));\n\n  const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Test with invalid response\n  await expect(\n    server.elicitInput({\n      message: \"Please provide your information\",\n      requestedSchema: {\n        type: \"object\",\n        properties: {\n          name: {\n            type: \"string\",\n            minLength: 1,\n          },\n          email: {\n            type: \"string\",\n            minLength: 1,\n          },\n          age: {\n            type: \"integer\",\n            minimum: 0,\n            maximum: 150,\n          },\n        },\n        required: [\"name\", \"email\"],\n      },\n    }),\n  ).rejects.toThrow(/does not match requested schema/);\n});\n\ntest(\"should allow elicitation reject and cancel without validation\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        elicitation: {},\n      },\n    },\n  );\n\n  let requestCount = 0;\n  client.setRequestHandler(ElicitRequestSchema, (request) =\u003E {\n    requestCount++;\n    if (requestCount === 1) {\n      return { action: \"decline\" };\n    } else {\n      return { action: \"cancel\" };\n    }\n  });\n\n  const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  const schema = {\n    type: \"object\" as const,\n    properties: {\n      name: { type: \"string\" as const },\n    },\n    required: [\"name\"],\n  };\n\n  // Test reject - should not validate\n  await expect(\n    server.elicitInput({\n      message: \"Please provide your name\",\n      requestedSchema: schema,\n    }),\n  ).resolves.toEqual({\n    action: \"decline\",\n  });\n\n  // Test cancel - should not validate  \n  await expect(\n    server.elicitInput({\n      message: \"Please provide your name\",\n      requestedSchema: schema,\n    }),\n  ).resolves.toEqual({\n    action: \"cancel\",\n  });\n});\n\ntest(\"should respect server notification capabilities\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        logging: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await server.connect(serverTransport);\n\n  // This should work because logging is supported by the server\n  await expect(\n    server.sendLoggingMessage({\n      level: \"info\",\n      data: \"Test log message\",\n    }),\n  ).resolves.not.toThrow();\n\n  // This should throw because resource notificaitons are not supported by the server\n  await expect(\n    server.sendResourceUpdated({ uri: \"test://resource\" }),\n  ).rejects.toThrow(/^Server does not support/);\n});\n\ntest(\"should only allow setRequestHandler for declared capabilities\", () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n      },\n    },\n  );\n\n  // These should work because the capabilities are declared\n  expect(() =\u003E {\n    server.setRequestHandler(ListPromptsRequestSchema, () =\u003E ({ prompts: [] }));\n  }).not.toThrow();\n\n  expect(() =\u003E {\n    server.setRequestHandler(ListResourcesRequestSchema, () =\u003E ({\n      resources: [],\n    }));\n  }).not.toThrow();\n\n  // These should throw because the capabilities are not declared\n  expect(() =\u003E {\n    server.setRequestHandler(ListToolsRequestSchema, () =\u003E ({ tools: [] }));\n  }).toThrow(/^Server does not support tools/);\n\n  expect(() =\u003E {\n    server.setRequestHandler(SetLevelRequestSchema, () =\u003E ({}));\n  }).toThrow(/^Server does not support logging/);\n});\n\n/*\n  Test that custom request/notification/result schemas can be used with the Server class.\n  */\ntest(\"should typecheck\", () =\u003E {\n  const GetWeatherRequestSchema = RequestSchema.extend({\n    method: z.literal(\"weather/get\"),\n    params: z.object({\n      city: z.string(),\n    }),\n  });\n\n  const GetForecastRequestSchema = RequestSchema.extend({\n    method: z.literal(\"weather/forecast\"),\n    params: z.object({\n      city: z.string(),\n      days: z.number(),\n    }),\n  });\n\n  const WeatherForecastNotificationSchema = NotificationSchema.extend({\n    method: z.literal(\"weather/alert\"),\n    params: z.object({\n      severity: z.enum([\"warning\", \"watch\"]),\n      message: z.string(),\n    }),\n  });\n\n  const WeatherRequestSchema = GetWeatherRequestSchema.or(\n    GetForecastRequestSchema,\n  );\n  const WeatherNotificationSchema = WeatherForecastNotificationSchema;\n  const WeatherResultSchema = ResultSchema.extend({\n    temperature: z.number(),\n    conditions: z.string(),\n  });\n\n  type WeatherRequest = z.infer\u003Ctypeof WeatherRequestSchema\u003E;\n  type WeatherNotification = z.infer\u003Ctypeof WeatherNotificationSchema\u003E;\n  type WeatherResult = z.infer\u003Ctypeof WeatherResultSchema\u003E;\n\n  // Create a typed Server for weather data\n  const weatherServer = new Server\u003C\n    WeatherRequest,\n    WeatherNotification,\n    WeatherResult\n  \u003E(\n    {\n      name: \"WeatherServer\",\n      version: \"1.0.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n    },\n  );\n\n  // Typecheck that only valid weather requests/notifications/results are allowed\n  weatherServer.setRequestHandler(GetWeatherRequestSchema, (request) =\u003E {\n    return {\n      temperature: 72,\n      conditions: \"sunny\",\n    };\n  });\n\n  weatherServer.setNotificationHandler(\n    WeatherForecastNotificationSchema,\n    (notification) =\u003E {\n      console.log(`Weather alert: ${notification.params.message}`);\n    },\n  );\n});\n\ntest(\"should handle server cancelling a request\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  // Set up client to delay responding to createMessage\n  client.setRequestHandler(\n    CreateMessageRequestSchema,\n    async (_request, extra) =\u003E {\n      await new Promise((resolve) =\u003E setTimeout(resolve, 1000));\n      return {\n        model: \"test\",\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      };\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Set up abort controller\n  const controller = new AbortController();\n\n  // Issue request but cancel it immediately\n  const createMessagePromise = server.createMessage(\n    {\n      messages: [],\n      maxTokens: 10,\n    },\n    {\n      signal: controller.signal,\n    },\n  );\n  controller.abort(\"Cancelled by test\");\n\n  // Request should be rejected\n  await expect(createMessagePromise).rejects.toBe(\"Cancelled by test\");\n});\n\ntest(\"should handle request timeout\", async () =\u003E {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  // Set up client that delays responses\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  client.setRequestHandler(\n    CreateMessageRequestSchema,\n    async (_request, extra) =\u003E {\n      await new Promise((resolve, reject) =\u003E {\n        const timeout = setTimeout(resolve, 100);\n        extra.signal.addEventListener(\"abort\", () =\u003E {\n          clearTimeout(timeout);\n          reject(extra.signal.reason);\n        });\n      });\n\n      return {\n        model: \"test\",\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      };\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Request with 0 msec timeout should fail immediately\n  await expect(\n    server.createMessage(\n      {\n        messages: [],\n        maxTokens: 10,\n      },\n      { timeout: 0 },\n    ),\n  ).rejects.toMatchObject({\n    code: ErrorCode.RequestTimeout,\n  });\n});\n",
      "hash": "ffd635ce20d3b5ced6545ce0ba40dd0920cea3dfda8adfec34f5e83eb60d8216",
      "size": 19656
    },
    "/src/server/index.ts": {
      "type": "content",
      "content": "import {\n  mergeCapabilities,\n  Protocol,\n  ProtocolOptions,\n  RequestOptions,\n} from \"../shared/protocol.js\";\nimport {\n  ClientCapabilities,\n  CreateMessageRequest,\n  CreateMessageResultSchema,\n  ElicitRequest,\n  ElicitResult,\n  ElicitResultSchema,\n  EmptyResultSchema,\n  Implementation,\n  InitializedNotificationSchema,\n  InitializeRequest,\n  InitializeRequestSchema,\n  InitializeResult,\n  LATEST_PROTOCOL_VERSION,\n  ListRootsRequest,\n  ListRootsResultSchema,\n  LoggingMessageNotification,\n  McpError,\n  ErrorCode,\n  Notification,\n  Request,\n  ResourceUpdatedNotification,\n  Result,\n  ServerCapabilities,\n  ServerNotification,\n  ServerRequest,\n  ServerResult,\n  SUPPORTED_PROTOCOL_VERSIONS,\n} from \"../types.js\";\nimport Ajv from \"ajv\";\n\nexport type ServerOptions = ProtocolOptions & {\n  /**\n   * Capabilities to advertise as being supported by this server.\n   */\n  capabilities?: ServerCapabilities;\n\n  /**\n   * Optional instructions describing how to use the server and its features.\n   */\n  instructions?: string;\n};\n\n/**\n * An MCP server on top of a pluggable transport.\n *\n * This server will automatically respond to the initialization flow as initiated from the client.\n *\n * To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:\n *\n * ```typescript\n * // Custom schemas\n * const CustomRequestSchema = RequestSchema.extend({...})\n * const CustomNotificationSchema = NotificationSchema.extend({...})\n * const CustomResultSchema = ResultSchema.extend({...})\n *\n * // Type aliases\n * type CustomRequest = z.infer\u003Ctypeof CustomRequestSchema\u003E\n * type CustomNotification = z.infer\u003Ctypeof CustomNotificationSchema\u003E\n * type CustomResult = z.infer\u003Ctypeof CustomResultSchema\u003E\n *\n * // Create typed server\n * const server = new Server\u003CCustomRequest, CustomNotification, CustomResult\u003E({\n *   name: \"CustomServer\",\n *   version: \"1.0.0\"\n * })\n * ```\n */\nexport class Server\u003C\n  RequestT extends Request = Request,\n  NotificationT extends Notification = Notification,\n  ResultT extends Result = Result,\n\u003E extends Protocol\u003C\n  ServerRequest | RequestT,\n  ServerNotification | NotificationT,\n  ServerResult | ResultT\n\u003E {\n  private _clientCapabilities?: ClientCapabilities;\n  private _clientVersion?: Implementation;\n  private _capabilities: ServerCapabilities;\n  private _instructions?: string;\n\n  /**\n   * Callback for when initialization has fully completed (i.e., the client has sent an `initialized` notification).\n   */\n  oninitialized?: () =\u003E void;\n\n  /**\n   * Initializes this server with the given name and version information.\n   */\n  constructor(\n    private _serverInfo: Implementation,\n    options?: ServerOptions,\n  ) {\n    super(options);\n    this._capabilities = options?.capabilities ?? {};\n    this._instructions = options?.instructions;\n\n    this.setRequestHandler(InitializeRequestSchema, (request) =\u003E\n      this._oninitialize(request),\n    );\n    this.setNotificationHandler(InitializedNotificationSchema, () =\u003E\n      this.oninitialized?.(),\n    );\n  }\n\n  /**\n   * Registers new capabilities. This can only be called before connecting to a transport.\n   *\n   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).\n   */\n  public registerCapabilities(capabilities: ServerCapabilities): void {\n    if (this.transport) {\n      throw new Error(\n        \"Cannot register capabilities after connecting to transport\",\n      );\n    }\n\n    this._capabilities = mergeCapabilities(this._capabilities, capabilities);\n  }\n\n  protected assertCapabilityForMethod(method: RequestT[\"method\"]): void {\n    switch (method as ServerRequest[\"method\"]) {\n      case \"sampling/createMessage\":\n        if (!this._clientCapabilities?.sampling) {\n          throw new Error(\n            `Client does not support sampling (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"elicitation/create\":\n        if (!this._clientCapabilities?.elicitation) {\n          throw new Error(\n            `Client does not support elicitation (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"roots/list\":\n        if (!this._clientCapabilities?.roots) {\n          throw new Error(\n            `Client does not support listing roots (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"ping\":\n        // No specific capability required for ping\n        break;\n    }\n  }\n\n  protected assertNotificationCapability(\n    method: (ServerNotification | NotificationT)[\"method\"],\n  ): void {\n    switch (method as ServerNotification[\"method\"]) {\n      case \"notifications/message\":\n        if (!this._capabilities.logging) {\n          throw new Error(\n            `Server does not support logging (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"notifications/resources/updated\":\n      case \"notifications/resources/list_changed\":\n        if (!this._capabilities.resources) {\n          throw new Error(\n            `Server does not support notifying about resources (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"notifications/tools/list_changed\":\n        if (!this._capabilities.tools) {\n          throw new Error(\n            `Server does not support notifying of tool list changes (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"notifications/prompts/list_changed\":\n        if (!this._capabilities.prompts) {\n          throw new Error(\n            `Server does not support notifying of prompt list changes (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"notifications/cancelled\":\n        // Cancellation notifications are always allowed\n        break;\n\n      case \"notifications/progress\":\n        // Progress notifications are always allowed\n        break;\n    }\n  }\n\n  protected assertRequestHandlerCapability(method: string): void {\n    switch (method) {\n      case \"sampling/createMessage\":\n        if (!this._capabilities.sampling) {\n          throw new Error(\n            `Server does not support sampling (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"logging/setLevel\":\n        if (!this._capabilities.logging) {\n          throw new Error(\n            `Server does not support logging (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"prompts/get\":\n      case \"prompts/list\":\n        if (!this._capabilities.prompts) {\n          throw new Error(\n            `Server does not support prompts (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"resources/list\":\n      case \"resources/templates/list\":\n      case \"resources/read\":\n        if (!this._capabilities.resources) {\n          throw new Error(\n            `Server does not support resources (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"tools/call\":\n      case \"tools/list\":\n        if (!this._capabilities.tools) {\n          throw new Error(\n            `Server does not support tools (required for ${method})`,\n          );\n        }\n        break;\n\n      case \"ping\":\n      case \"initialize\":\n        // No specific capability required for these methods\n        break;\n    }\n  }\n\n  private async _oninitialize(\n    request: InitializeRequest,\n  ): Promise\u003CInitializeResult\u003E {\n    const requestedVersion = request.params.protocolVersion;\n\n    this._clientCapabilities = request.params.capabilities;\n    this._clientVersion = request.params.clientInfo;\n\n    const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion)\n        ? requestedVersion\n        : LATEST_PROTOCOL_VERSION;\n\n    return {\n      protocolVersion,\n      capabilities: this.getCapabilities(),\n      serverInfo: this._serverInfo,\n      ...(this._instructions && { instructions: this._instructions }),\n    };\n  }\n\n  /**\n   * After initialization has completed, this will be populated with the client's reported capabilities.\n   */\n  getClientCapabilities(): ClientCapabilities | undefined {\n    return this._clientCapabilities;\n  }\n\n  /**\n   * After initialization has completed, this will be populated with information about the client's name and version.\n   */\n  getClientVersion(): Implementation | undefined {\n    return this._clientVersion;\n  }\n\n  private getCapabilities(): ServerCapabilities {\n    return this._capabilities;\n  }\n\n  async ping() {\n    return this.request({ method: \"ping\" }, EmptyResultSchema);\n  }\n\n  async createMessage(\n    params: CreateMessageRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"sampling/createMessage\", params },\n      CreateMessageResultSchema,\n      options,\n    );\n  }\n\n  async elicitInput(\n    params: ElicitRequest[\"params\"],\n    options?: RequestOptions,\n  ): Promise\u003CElicitResult\u003E {\n    const result = await this.request(\n      { method: \"elicitation/create\", params },\n      ElicitResultSchema,\n      options,\n    );\n\n    // Validate the response content against the requested schema if action is \"accept\"\n    if (result.action === \"accept\" && result.content) {\n      try {\n        const ajv = new Ajv();\n        \n        const validate = ajv.compile(params.requestedSchema);\n        const isValid = validate(result.content);\n        \n        if (!isValid) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Elicitation response content does not match requested schema: ${ajv.errorsText(validate.errors)}`,\n          );\n        }\n      } catch (error) {\n        if (error instanceof McpError) {\n          throw error;\n        }\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Error validating elicitation response: ${error}`,\n        );\n      }\n    }\n\n    return result;\n  }\n\n  async listRoots(\n    params?: ListRootsRequest[\"params\"],\n    options?: RequestOptions,\n  ) {\n    return this.request(\n      { method: \"roots/list\", params },\n      ListRootsResultSchema,\n      options,\n    );\n  }\n\n  async sendLoggingMessage(params: LoggingMessageNotification[\"params\"]) {\n    return this.notification({ method: \"notifications/message\", params });\n  }\n\n  async sendResourceUpdated(params: ResourceUpdatedNotification[\"params\"]) {\n    return this.notification({\n      method: \"notifications/resources/updated\",\n      params,\n    });\n  }\n\n  async sendResourceListChanged() {\n    return this.notification({\n      method: \"notifications/resources/list_changed\",\n    });\n  }\n\n  async sendToolListChanged() {\n    return this.notification({ method: \"notifications/tools/list_changed\" });\n  }\n\n  async sendPromptListChanged() {\n    return this.notification({ method: \"notifications/prompts/list_changed\" });\n  }\n}\n",
      "hash": "030942f8b8750eb23eb836cba1ec563350449069eb50d52776a6dbe9314f1e71",
      "size": 10695
    },
    "/src/server/mcp.test.ts": {
      "type": "content",
      "content": "import { McpServer } from \"./mcp.js\";\nimport { Client } from \"../client/index.js\";\nimport { InMemoryTransport } from \"../inMemory.js\";\nimport { z } from \"zod\";\nimport {\n  ListToolsResultSchema,\n  CallToolResultSchema,\n  ListResourcesResultSchema,\n  ListResourceTemplatesResultSchema,\n  ReadResourceResultSchema,\n  ListPromptsResultSchema,\n  GetPromptResultSchema,\n  CompleteResultSchema,\n  LoggingMessageNotificationSchema,\n  Notification,\n  TextContent,\n  ElicitRequestSchema\n} from \"../types.js\";\nimport { ResourceTemplate } from \"./mcp.js\";\nimport { completable } from \"./completable.js\";\nimport { UriTemplate } from \"../shared/uriTemplate.js\";\nimport { getDisplayName } from \"../shared/metadataUtils.js\";\n\ndescribe(\"McpServer\", () =\u003E {\n  /***\n   * Test: Basic Server Instance\n   */\n  test(\"should expose underlying Server instance\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    expect(mcpServer.server).toBeDefined();\n  });\n\n  /***\n   * Test: Notification Sending via Server\n   */\n  test(\"should allow sending notifications via Server\", async () =\u003E {\n    const mcpServer = new McpServer(\n      {\n        name: \"test server\",\n        version: \"1.0\",\n      },\n      { capabilities: { logging: {} } },\n    );\n\n    const notifications: Notification[] = []\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification)\n    }\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // This should work because we're using the underlying server\n    await expect(\n      mcpServer.server.sendLoggingMessage({\n        level: \"info\",\n        data: \"Test log message\",\n      }),\n    ).resolves.not.toThrow();\n\n    expect(notifications).toMatchObject([\n      {\n        \"method\": \"notifications/message\",\n        params: {\n          level: \"info\",\n          data: \"Test log message\",\n        }\n      }\n    ])\n  });\n\n  /***\n   * Test: Progress Notification with Message Field\n   */\n  test(\"should send progress notifications with message field\", async () =\u003E {\n    const mcpServer = new McpServer(\n      {\n        name: \"test server\",\n        version: \"1.0\",\n      }\n    );\n\n    // Create a tool that sends progress updates\n    mcpServer.tool(\n      \"long-operation\",\n      \"A long running operation with progress updates\",\n      {\n        steps: z.number().min(1).describe(\"Number of steps to perform\"),\n      },\n      async ({ steps }, { sendNotification, _meta }) =\u003E {\n        const progressToken = _meta?.progressToken;\n\n        if (progressToken) {\n          // Send progress notification for each step\n          for (let i = 1; i \u003C= steps; i++) {\n            await sendNotification({\n              method: \"notifications/progress\",\n              params: {\n                progressToken,\n                progress: i,\n                total: steps,\n                message: `Completed step ${i} of ${steps}`,\n              },\n            });\n          }\n        }\n\n        return { content: [{ type: \"text\" as const, text: `Operation completed with ${steps} steps` }] };\n      }\n    );\n\n    const progressUpdates: Array\u003C{ progress: number, total?: number, message?: string }\u003E = [];\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Call the tool with progress tracking\n    await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"long-operation\",\n          arguments: { steps: 3 },\n          _meta: {\n            progressToken: \"progress-test-1\"\n          }\n        }\n      },\n      CallToolResultSchema,\n      {\n        onprogress: (progress) =\u003E {\n          progressUpdates.push(progress);\n        }\n      }\n    );\n\n    // Verify progress notifications were received with message field\n    expect(progressUpdates).toHaveLength(3);\n    expect(progressUpdates[0]).toMatchObject({\n      progress: 1,\n      total: 3,\n      message: \"Completed step 1 of 3\",\n    });\n    expect(progressUpdates[1]).toMatchObject({\n      progress: 2,\n      total: 3,\n      message: \"Completed step 2 of 3\",\n    });\n    expect(progressUpdates[2]).toMatchObject({\n      progress: 3,\n      total: 3,\n      message: \"Completed step 3 of 3\",\n    });\n  });\n});\n\ndescribe(\"ResourceTemplate\", () =\u003E {\n  /***\n   * Test: ResourceTemplate Creation with String Pattern\n   */\n  test(\"should create ResourceTemplate with string pattern\", () =\u003E {\n    const template = new ResourceTemplate(\"test://{category}/{id}\", {\n      list: undefined,\n    });\n    expect(template.uriTemplate.toString()).toBe(\"test://{category}/{id}\");\n    expect(template.listCallback).toBeUndefined();\n  });\n\n  /***\n   * Test: ResourceTemplate Creation with UriTemplate Instance\n   */\n  test(\"should create ResourceTemplate with UriTemplate\", () =\u003E {\n    const uriTemplate = new UriTemplate(\"test://{category}/{id}\");\n    const template = new ResourceTemplate(uriTemplate, { list: undefined });\n    expect(template.uriTemplate).toBe(uriTemplate);\n    expect(template.listCallback).toBeUndefined();\n  });\n\n  /***\n   * Test: ResourceTemplate with List Callback\n   */\n  test(\"should create ResourceTemplate with list callback\", async () =\u003E {\n    const list = jest.fn().mockResolvedValue({\n      resources: [{ name: \"Test\", uri: \"test://example\" }],\n    });\n\n    const template = new ResourceTemplate(\"test://{id}\", { list });\n    expect(template.listCallback).toBe(list);\n\n    const abortController = new AbortController();\n    const result = await template.listCallback?.({\n      signal: abortController.signal,\n      requestId: 'not-implemented',\n      sendRequest: () =\u003E { throw new Error(\"Not implemented\") },\n      sendNotification: () =\u003E { throw new Error(\"Not implemented\") }\n    });\n    expect(result?.resources).toHaveLength(1);\n    expect(list).toHaveBeenCalled();\n  });\n});\n\ndescribe(\"tool()\", () =\u003E {\n  /***\n   * Test: Zero-Argument Tool Registration\n   */\n  test(\"should register zero-argument tool\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = []\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification)\n    }\n\n    mcpServer.tool(\"test\", async () =\u003E ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(1);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].inputSchema).toEqual({\n      type: \"object\",\n      properties: {},\n    });\n\n    // Adding the tool before the connection was established means no notification was sent\n    expect(notifications).toHaveLength(0)\n\n    // Adding another tool triggers the update notification\n    mcpServer.tool(\"test2\", async () =\u003E ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    // Yield event loop to let the notification fly\n    await new Promise(process.nextTick)\n\n    expect(notifications).toMatchObject([\n      {\n        method: \"notifications/tools/list_changed\",\n      }\n    ])\n  });\n\n  /***\n   * Test: Updating Existing Tool\n   */\n  test(\"should update existing tool\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = []\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification)\n    }\n\n    // Register initial tool\n    const tool = mcpServer.tool(\"test\", async () =\u003E ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Initial response\",\n        },\n      ],\n    }));\n\n    // Update the tool\n    tool.update({\n      callback: async () =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: \"Updated response\",\n          },\n        ],\n      })\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Call the tool and verify we get the updated response\n    const result = await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"test\",\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(result.content).toEqual([\n      {\n        type: \"text\",\n        text: \"Updated response\",\n      },\n    ]);\n\n    // Update happened before transport was connected, so no notifications should be expected\n    expect(notifications).toHaveLength(0)\n  });\n\n  /***\n   * Test: Updating Tool with Schema\n   */\n  test(\"should update tool with schema\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = []\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification)\n    }\n\n    // Register initial tool\n    const tool = mcpServer.tool(\n      \"test\",\n      {\n        name: z.string(),\n      },\n      async ({ name }) =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: `Initial: ${name}`,\n          },\n        ],\n      }),\n    );\n\n    // Update the tool with a different schema\n    tool.update({\n      paramsSchema: {\n        name: z.string(),\n        value: z.number(),\n      },\n      callback: async ({ name, value }) =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: `Updated: ${name}, ${value}`,\n          },\n        ],\n      })\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Verify the schema was updated\n    const listResult = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(listResult.tools[0].inputSchema).toMatchObject({\n      properties: {\n        name: { type: \"string\" },\n        value: { type: \"number\" },\n      },\n    });\n\n    // Call the tool with the new schema\n    const callResult = await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"test\",\n          arguments: {\n            name: \"test\",\n            value: 42,\n          },\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(callResult.content).toEqual([\n      {\n        type: \"text\",\n        text: \"Updated: test, 42\",\n      },\n    ]);\n\n    // Update happened before transport was connected, so no notifications should be expected\n    expect(notifications).toHaveLength(0)\n  });\n\n  /***\n   * Test: Tool List Changed Notifications\n   */\n  test(\"should send tool list changed notifications when connected\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = []\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification)\n    }\n\n    // Register initial tool\n    const tool = mcpServer.tool(\"test\", async () =\u003E ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    expect(notifications).toHaveLength(0)\n\n    // Now update the tool\n    tool.update({\n      callback: async () =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: \"Updated response\",\n          },\n        ],\n      })\n    });\n\n    // Yield event loop to let the notification fly\n    await new Promise(process.nextTick)\n\n    expect(notifications).toMatchObject([\n      { method: \"notifications/tools/list_changed\" }\n    ])\n\n    // Now delete the tool\n    tool.remove();\n\n    // Yield event loop to let the notification fly\n    await new Promise(process.nextTick)\n\n    expect(notifications).toMatchObject([\n      { method: \"notifications/tools/list_changed\" },\n      { method: \"notifications/tools/list_changed\" },\n    ])\n  });\n\n  /***\n   * Test: Tool Registration with Parameters\n   */\n  test(\"should register tool with params\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    // old api\n    mcpServer.tool(\n      \"test\",\n      {\n        name: z.string(),\n        value: z.number(),\n      },\n      async ({ name, value }) =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: `${name}: ${value}`,\n          },\n        ],\n      }),\n    );\n\n    // new api\n    mcpServer.registerTool(\n      \"test (new api)\",\n      {\n        inputSchema: { name: z.string(), value: z.number() },\n      },\n      async ({ name, value }) =\u003E ({\n        content: [{ type: \"text\", text: `${name}: ${value}` }],\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(2);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].inputSchema).toMatchObject({\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        value: { type: \"number\" },\n      },\n    });\n    expect(result.tools[1].name).toBe(\"test (new api)\");\n    expect(result.tools[1].inputSchema).toEqual(result.tools[0].inputSchema);\n  });\n\n  /***\n   * Test: Tool Registration with Description\n   */\n  test(\"should register tool with description\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    // old api\n    mcpServer.tool(\"test\", \"Test description\", async () =\u003E ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    // new api\n    mcpServer.registerTool(\n      \"test (new api)\",\n      {\n        description: \"Test description\",\n      },\n      async () =\u003E ({\n        content: [\n          {\n            type: \"text\" as const,\n            text: \"Test response\",\n          },\n        ],\n      })\n    );\n\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(2);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].description).toBe(\"Test description\");\n    expect(result.tools[1].name).toBe(\"test (new api)\");\n    expect(result.tools[1].description).toBe(\"Test description\");\n  });\n\n  /***\n   * Test: Tool Registration with Annotations\n   */\n  test(\"should register tool with annotations\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\"test\", { title: \"Test Tool\", readOnlyHint: true }, async () =\u003E ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    mcpServer.registerTool(\n      \"test (new api)\",\n      {\n        annotations: { title: \"Test Tool\", readOnlyHint: true },\n      },\n      async () =\u003E ({\n        content: [\n          {\n            type: \"text\" as const,\n            text: \"Test response\",\n          },\n        ],\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(2);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].annotations).toEqual({ title: \"Test Tool\", readOnlyHint: true });\n    expect(result.tools[1].name).toBe(\"test (new api)\");\n    expect(result.tools[1].annotations).toEqual({ title: \"Test Tool\", readOnlyHint: true });\n  });\n\n  /***\n   * Test: Tool Registration with Parameters and Annotations\n   */\n  test(\"should register tool with params and annotations\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\n      \"test\",\n      { name: z.string() },\n      { title: \"Test Tool\", readOnlyHint: true },\n      async ({ name }) =\u003E ({\n        content: [{ type: \"text\", text: `Hello, ${name}!` }]\n      })\n    );\n\n    mcpServer.registerTool(\n      \"test (new api)\",\n      {\n        inputSchema: { name: z.string() },\n        annotations: { title: \"Test Tool\", readOnlyHint: true },\n      },\n      async ({ name }) =\u003E ({\n        content: [{ type: \"text\", text: `Hello, ${name}!` }]\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      { method: \"tools/list\" },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(2);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].inputSchema).toMatchObject({\n      type: \"object\",\n      properties: { name: { type: \"string\" } }\n    });\n    expect(result.tools[0].annotations).toEqual({ title: \"Test Tool\", readOnlyHint: true });\n    expect(result.tools[1].name).toBe(\"test (new api)\");\n    expect(result.tools[1].inputSchema).toEqual(result.tools[0].inputSchema);\n    expect(result.tools[1].annotations).toEqual(result.tools[0].annotations);\n  });\n\n  /***\n   * Test: Tool Registration with Description, Parameters, and Annotations\n   */\n  test(\"should register tool with description, params, and annotations\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\n      \"test\",\n      \"A tool with everything\",\n      { name: z.string() },\n      { title: \"Complete Test Tool\", readOnlyHint: true, openWorldHint: false },\n      async ({ name }) =\u003E ({\n        content: [{ type: \"text\", text: `Hello, ${name}!` }]\n      })\n    );\n\n    mcpServer.registerTool(\n      \"test (new api)\",\n      {\n        description: \"A tool with everything\",\n        inputSchema: { name: z.string() },\n        annotations: { title: \"Complete Test Tool\", readOnlyHint: true, openWorldHint: false },\n      },\n      async ({ name }) =\u003E ({\n        content: [{ type: \"text\", text: `Hello, ${name}!` }]\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      { method: \"tools/list\" },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(2);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].description).toBe(\"A tool with everything\");\n    expect(result.tools[0].inputSchema).toMatchObject({\n      type: \"object\",\n      properties: { name: { type: \"string\" } }\n    });\n    expect(result.tools[0].annotations).toEqual({\n      title: \"Complete Test Tool\",\n      readOnlyHint: true,\n      openWorldHint: false\n    });\n    expect(result.tools[1].name).toBe(\"test (new api)\");\n    expect(result.tools[1].description).toBe(\"A tool with everything\");\n    expect(result.tools[1].inputSchema).toEqual(result.tools[0].inputSchema);\n    expect(result.tools[1].annotations).toEqual(result.tools[0].annotations);\n  });\n\n  /***\n   * Test: Tool Registration with Description, Empty Parameters, and Annotations\n   */\n  test(\"should register tool with description, empty params, and annotations\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\n      \"test\",\n      \"A tool with everything but empty params\",\n      {},\n      { title: \"Complete Test Tool with empty params\", readOnlyHint: true, openWorldHint: false },\n      async () =\u003E ({\n        content: [{ type: \"text\", text: \"Test response\" }]\n      })\n    );\n\n    mcpServer.registerTool(\n      \"test (new api)\",\n      {\n        description: \"A tool with everything but empty params\",\n        inputSchema: {},\n        annotations: { title: \"Complete Test Tool with empty params\", readOnlyHint: true, openWorldHint: false },\n      },\n      async () =\u003E ({\n        content: [{ type: \"text\" as const, text: \"Test response\" }]\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      { method: \"tools/list\" },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(2);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].description).toBe(\"A tool with everything but empty params\");\n    expect(result.tools[0].inputSchema).toMatchObject({\n      type: \"object\",\n      properties: {}\n    });\n    expect(result.tools[0].annotations).toEqual({\n      title: \"Complete Test Tool with empty params\",\n      readOnlyHint: true,\n      openWorldHint: false\n    });\n    expect(result.tools[1].name).toBe(\"test (new api)\");\n    expect(result.tools[1].description).toBe(\"A tool with everything but empty params\");\n    expect(result.tools[1].inputSchema).toEqual(result.tools[0].inputSchema);\n    expect(result.tools[1].annotations).toEqual(result.tools[0].annotations);\n  });\n\n  /***\n   * Test: Tool Argument Validation\n   */\n  test(\"should validate tool args\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\n      \"test\",\n      {\n        name: z.string(),\n        value: z.number(),\n      },\n      async ({ name, value }) =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: `${name}: ${value}`,\n          },\n        ],\n      }),\n    );\n\n    mcpServer.registerTool(\n      \"test (new api)\",\n      {\n        inputSchema: {\n          name: z.string(),\n          value: z.number(),\n        },\n      },\n      async ({ name, value }) =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: `${name}: ${value}`,\n          },\n        ],\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.request(\n        {\n          method: \"tools/call\",\n          params: {\n            name: \"test\",\n            arguments: {\n              name: \"test\",\n              value: \"not a number\",\n            },\n          },\n        },\n        CallToolResultSchema,\n      ),\n    ).rejects.toThrow(/Invalid arguments/);\n\n    await expect(\n      client.request(\n        {\n          method: \"tools/call\",\n          params: {\n            name: \"test (new api)\",\n            arguments: {\n              name: \"test\",\n              value: \"not a number\",\n            },\n          },\n        },\n        CallToolResultSchema,\n      ),\n    ).rejects.toThrow(/Invalid arguments/);\n  });\n\n  /***\n   * Test: Preventing Duplicate Tool Registration\n   */\n  test(\"should prevent duplicate tool registration\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\"test\", async () =\u003E ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    expect(() =\u003E {\n      mcpServer.tool(\"test\", async () =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: \"Test response 2\",\n          },\n        ],\n      }));\n    }).toThrow(/already registered/);\n  });\n\n  /***\n   * Test: Multiple Tool Registration\n   */\n  test(\"should allow registering multiple tools\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    // This should succeed\n    mcpServer.tool(\"tool1\", () =\u003E ({ content: [] }));\n\n    // This should also succeed and not throw about request handlers\n    mcpServer.tool(\"tool2\", () =\u003E ({ content: [] }));\n  });\n\n  /***\n   * Test: Tool with Output Schema and Structured Content\n   */\n  test(\"should support tool with outputSchema and structuredContent\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    // Register a tool with outputSchema\n    mcpServer.registerTool(\n      \"test\",\n      {\n        description: \"Test tool with structured output\",\n        inputSchema: {\n          input: z.string(),\n        },\n        outputSchema: {\n          processedInput: z.string(),\n          resultType: z.string(),\n          timestamp: z.string()\n        },\n      },\n      async ({ input }) =\u003E ({\n        structuredContent: {\n          processedInput: input,\n          resultType: \"structured\",\n          timestamp: \"2023-01-01T00:00:00Z\"\n        },\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              processedInput: input,\n              resultType: \"structured\",\n              timestamp: \"2023-01-01T00:00:00Z\"\n            }),\n          },\n        ]\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Verify the tool registration includes outputSchema\n    const listResult = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(listResult.tools).toHaveLength(1);\n    expect(listResult.tools[0].outputSchema).toMatchObject({\n      type: \"object\",\n      properties: {\n        processedInput: { type: \"string\" },\n        resultType: { type: \"string\" },\n        timestamp: { type: \"string\" }\n      },\n      required: [\"processedInput\", \"resultType\", \"timestamp\"]\n    });\n\n    // Call the tool and verify it returns valid structuredContent\n    const result = await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"test\",\n          arguments: {\n            input: \"hello\",\n          },\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(result.structuredContent).toBeDefined();\n    const structuredContent = result.structuredContent as {\n      processedInput: string;\n      resultType: string;\n      timestamp: string;\n    };\n    expect(structuredContent.processedInput).toBe(\"hello\");\n    expect(structuredContent.resultType).toBe(\"structured\");\n    expect(structuredContent.timestamp).toBe(\"2023-01-01T00:00:00Z\");\n\n    // For backward compatibility, content is auto-generated from structuredContent\n    expect(result.content).toBeDefined();\n    expect(result.content!).toHaveLength(1);\n    expect(result.content![0]).toMatchObject({ type: \"text\" });\n    const textContent = result.content![0] as TextContent;\n    expect(JSON.parse(textContent.text)).toEqual(result.structuredContent);\n  });\n\n  /***\n   * Test: Tool with Output Schema Must Provide Structured Content\n   */\n  test(\"should throw error when tool with outputSchema returns no structuredContent\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    // Register a tool with outputSchema that returns only content without structuredContent\n    mcpServer.registerTool(\n      \"test\",\n      {\n        description: \"Test tool with output schema but missing structured content\",\n        inputSchema: {\n          input: z.string(),\n        },\n        outputSchema: {\n          processedInput: z.string(),\n          resultType: z.string(),\n        },\n      },\n      async ({ input }) =\u003E ({\n        // Only return content without structuredContent\n        content: [\n          {\n            type: \"text\",\n            text: `Processed: ${input}`,\n          },\n        ],\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Call the tool and expect it to throw an error\n    await expect(\n      client.callTool({\n        name: \"test\",\n        arguments: {\n          input: \"hello\",\n        },\n      }),\n    ).rejects.toThrow(/Tool test has an output schema but no structured content was provided/);\n  });\n  /***\n   * Test: Tool with Output Schema Must Provide Structured Content\n   */\n  test(\"should skip outputSchema validation when isError is true\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.registerTool(\n      \"test\",\n      {\n        description: \"Test tool with output schema but missing structured content\",\n        inputSchema: {\n          input: z.string(),\n        },\n        outputSchema: {\n          processedInput: z.string(),\n          resultType: z.string(),\n        },\n      },\n      async ({ input }) =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: `Processed: ${input}`,\n          },\n        ],\n        isError: true,\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.callTool({\n        name: \"test\",\n        arguments: {\n          input: \"hello\",\n        },\n      }),\n    ).resolves.toStrictEqual({\n      content: [\n        {\n          type: \"text\",\n          text: `Processed: hello`,\n        },\n      ],\n      isError: true,\n    });\n  });\n\n  /***\n   * Test: Schema Validation Failure for Invalid Structured Content\n   */\n  test(\"should fail schema validation when tool returns invalid structuredContent\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    // Register a tool with outputSchema that returns invalid data\n    mcpServer.registerTool(\n      \"test\",\n      {\n        description: \"Test tool with invalid structured output\",\n        inputSchema: {\n          input: z.string(),\n        },\n        outputSchema: {\n          processedInput: z.string(),\n          resultType: z.string(),\n          timestamp: z.string()\n        },\n      },\n      async ({ input }) =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              processedInput: input,\n              resultType: \"structured\",\n              // Missing required 'timestamp' field\n              someExtraField: \"unexpected\" // Extra field not in schema\n            }),\n          },\n        ],\n        structuredContent: {\n          processedInput: input,\n          resultType: \"structured\",\n          // Missing required 'timestamp' field\n          someExtraField: \"unexpected\" // Extra field not in schema\n        },\n      })\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Call the tool and expect it to throw a server-side validation error\n    await expect(\n      client.callTool({\n        name: \"test\",\n        arguments: {\n          input: \"hello\",\n        },\n      }),\n    ).rejects.toThrow(/Invalid structured content for tool test/);\n  });\n\n  /***\n   * Test: Pass Session ID to Tool Callback\n   */\n  test(\"should pass sessionId to tool callback via RequestHandlerExtra\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    let receivedSessionId: string | undefined;\n    mcpServer.tool(\"test-tool\", async (extra) =\u003E {\n      receivedSessionId = extra.sessionId;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        ],\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n    // Set a test sessionId on the server transport\n    serverTransport.sessionId = \"test-session-123\";\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"test-tool\",\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(receivedSessionId).toBe(\"test-session-123\");\n  });\n\n  /***\n   * Test: Pass Request ID to Tool Callback\n   */\n  test(\"should pass requestId to tool callback via RequestHandlerExtra\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    let receivedRequestId: string | number | undefined;\n    mcpServer.tool(\"request-id-test\", async (extra) =\u003E {\n      receivedRequestId = extra.requestId;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Received request ID: ${extra.requestId}`,\n          },\n        ],\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"request-id-test\",\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(receivedRequestId).toBeDefined();\n    expect(typeof receivedRequestId === 'string' || typeof receivedRequestId === 'number').toBe(true);\n    expect(result.content && result.content[0].text).toContain(\"Received request ID:\");\n  });\n\n  /***\n   * Test: Send Notification within Tool Call\n   */\n  test(\"should provide sendNotification within tool call\", async () =\u003E {\n    const mcpServer = new McpServer(\n      {\n        name: \"test server\",\n        version: \"1.0\",\n      },\n      { capabilities: { logging: {} } },\n    );\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    let receivedLogMessage: string | undefined;\n    const loggingMessage = \"hello here is log message 1\";\n\n    client.setNotificationHandler(LoggingMessageNotificationSchema, (notification) =\u003E {\n      receivedLogMessage = notification.params.data as string;\n    });\n\n    mcpServer.tool(\"test-tool\", async ({ sendNotification }) =\u003E {\n      await sendNotification({ method: \"notifications/message\", params: { level: \"debug\", data: loggingMessage } });\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        ],\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n    await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"test-tool\",\n        },\n      },\n      CallToolResultSchema,\n    );\n    expect(receivedLogMessage).toBe(loggingMessage);\n  });\n\n  /***\n   * Test: Client to Server Tool Call\n   */\n  test(\"should allow client to call server tools\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\n      \"test\",\n      \"Test tool\",\n      {\n        input: z.string(),\n      },\n      async ({ input }) =\u003E ({\n        content: [\n          {\n            type: \"text\",\n            text: `Processed: ${input}`,\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"test\",\n          arguments: {\n            input: \"hello\",\n          },\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(result.content).toEqual([\n      {\n        type: \"text\",\n        text: \"Processed: hello\",\n      },\n    ]);\n  });\n\n  /***\n   * Test: Graceful Tool Error Handling\n   */\n  test(\"should handle server tool errors gracefully\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\"error-test\", async () =\u003E {\n      throw new Error(\"Tool execution failed\");\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"error-test\",\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(result.isError).toBe(true);\n    expect(result.content).toEqual([\n      {\n        type: \"text\",\n        text: \"Tool execution failed\",\n      },\n    ]);\n  });\n\n  /***\n   * Test: McpError for Invalid Tool Name\n   */\n  test(\"should throw McpError for invalid tool name\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\"test-tool\", async () =\u003E ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.request(\n        {\n          method: \"tools/call\",\n          params: {\n            name: \"nonexistent-tool\",\n          },\n        },\n        CallToolResultSchema,\n      ),\n    ).rejects.toThrow(/Tool nonexistent-tool not found/);\n  });\n});\n\ndescribe(\"resource()\", () =\u003E {\n  /***\n   * Test: Resource Registration with URI and Read Callback\n   */\n  test(\"should register resource with uri and readCallback\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\"test\", \"test://resource\", async () =\u003E ({\n      contents: [\n        {\n          uri: \"test://resource\",\n          text: \"Test content\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/list\",\n      },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(1);\n    expect(result.resources[0].name).toBe(\"test\");\n    expect(result.resources[0].uri).toBe(\"test://resource\");\n  });\n\n  /***\n   * Test: Update Resource with URI\n   */\n  test(\"should update resource with uri\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register initial resource\n    const resource = mcpServer.resource(\"test\", \"test://resource\", async () =\u003E ({\n      contents: [\n        {\n          uri: \"test://resource\",\n          text: \"Initial content\",\n        },\n      ],\n    }));\n\n    // Update the resource\n    resource.update({\n      callback: async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource\",\n            text: \"Updated content\",\n          },\n        ],\n      })\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Read the resource and verify we get the updated content\n    const result = await client.request(\n      {\n        method: \"resources/read\",\n        params: {\n          uri: \"test://resource\",\n        },\n      },\n      ReadResourceResultSchema,\n    );\n\n    expect(result.contents).toHaveLength(1);\n    expect(result.contents[0].text).toBe(\"Updated content\");\n\n    // Update happened before transport was connected, so no notifications should be expected\n    expect(notifications).toHaveLength(0);\n  });\n\n  /***\n   * Test: Update Resource Template\n   */\n  test(\"should update resource template\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register initial resource template\n    const resourceTemplate = mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{id}\", { list: undefined }),\n      async (uri) =\u003E ({\n        contents: [\n          {\n            uri: uri.href,\n            text: \"Initial content\",\n          },\n        ],\n      }),\n    );\n\n    // Update the resource template\n    resourceTemplate.update({\n      callback: async (uri) =\u003E ({\n        contents: [\n          {\n            uri: uri.href,\n            text: \"Updated content\",\n          },\n        ],\n      })\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Read the resource and verify we get the updated content\n    const result = await client.request(\n      {\n        method: \"resources/read\",\n        params: {\n          uri: \"test://resource/123\",\n        },\n      },\n      ReadResourceResultSchema,\n    );\n\n    expect(result.contents).toHaveLength(1);\n    expect(result.contents[0].text).toBe(\"Updated content\");\n\n    // Update happened before transport was connected, so no notifications should be expected\n    expect(notifications).toHaveLength(0);\n  });\n\n  /***\n   * Test: Resource List Changed Notification\n   */\n  test(\"should send resource list changed notification when connected\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register initial resource\n    const resource = mcpServer.resource(\"test\", \"test://resource\", async () =\u003E ({\n      contents: [\n        {\n          uri: \"test://resource\",\n          text: \"Test content\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    expect(notifications).toHaveLength(0);\n\n    // Now update the resource while connected\n    resource.update({\n      callback: async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource\",\n            text: \"Updated content\",\n          },\n        ],\n      })\n    });\n\n    // Yield event loop to let the notification fly\n    await new Promise(process.nextTick);\n\n    expect(notifications).toMatchObject([\n      { method: \"notifications/resources/list_changed\" }\n    ]);\n  });\n\n  /***\n   * Test: Remove Resource and Send Notification\n   */\n  test(\"should remove resource and send notification when connected\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register initial resources\n    const resource1 = mcpServer.resource(\"resource1\", \"test://resource1\", async () =\u003E ({\n      contents: [{ uri: \"test://resource1\", text: \"Resource 1 content\" }],\n    }));\n\n    mcpServer.resource(\"resource2\", \"test://resource2\", async () =\u003E ({\n      contents: [{ uri: \"test://resource2\", text: \"Resource 2 content\" }],\n    }));\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Verify both resources are registered\n    let result = await client.request(\n      { method: \"resources/list\" },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(2);\n\n    expect(notifications).toHaveLength(0);\n\n    // Remove a resource\n    resource1.remove()\n\n    // Yield event loop to let the notification fly\n    await new Promise(process.nextTick);\n\n    // Should have sent notification\n    expect(notifications).toMatchObject([\n      { method: \"notifications/resources/list_changed\" }\n    ]);\n\n    // Verify the resource was removed\n    result = await client.request(\n      { method: \"resources/list\" },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(1);\n    expect(result.resources[0].uri).toBe(\"test://resource2\");\n  });\n\n  /***\n   * Test: Remove Resource Template and Send Notification\n   */\n  test(\"should remove resource template and send notification when connected\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register resource template\n    const resourceTemplate = mcpServer.resource(\n      \"template\",\n      new ResourceTemplate(\"test://resource/{id}\", { list: undefined }),\n      async (uri) =\u003E ({\n        contents: [\n          {\n            uri: uri.href,\n            text: \"Template content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Verify template is registered\n    const result = await client.request(\n      { method: \"resources/templates/list\" },\n      ListResourceTemplatesResultSchema,\n    );\n\n    expect(result.resourceTemplates).toHaveLength(1);\n    expect(notifications).toHaveLength(0);\n\n    // Remove the template\n    resourceTemplate.remove()\n\n    // Yield event loop to let the notification fly\n    await new Promise(process.nextTick);\n\n    // Should have sent notification\n    expect(notifications).toMatchObject([\n      { method: \"notifications/resources/list_changed\" }\n    ]);\n\n    // Verify the template was removed\n    const result2 = await client.request(\n      { method: \"resources/templates/list\" },\n      ListResourceTemplatesResultSchema,\n    );\n\n    expect(result2.resourceTemplates).toHaveLength(0);\n  });\n\n  /***\n   * Test: Resource Registration with Metadata\n   */\n  test(\"should register resource with metadata\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      \"test://resource\",\n      {\n        description: \"Test resource\",\n        mimeType: \"text/plain\",\n      },\n      async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/list\",\n      },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(1);\n    expect(result.resources[0].description).toBe(\"Test resource\");\n    expect(result.resources[0].mimeType).toBe(\"text/plain\");\n  });\n\n  /***\n   * Test: Resource Template Registration\n   */\n  test(\"should register resource template\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{id}\", { list: undefined }),\n      async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource/123\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/templates/list\",\n      },\n      ListResourceTemplatesResultSchema,\n    );\n\n    expect(result.resourceTemplates).toHaveLength(1);\n    expect(result.resourceTemplates[0].name).toBe(\"test\");\n    expect(result.resourceTemplates[0].uriTemplate).toBe(\n      \"test://resource/{id}\",\n    );\n  });\n\n  /***\n   * Test: Resource Template with List Callback\n   */\n  test(\"should register resource template with listCallback\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{id}\", {\n        list: async () =\u003E ({\n          resources: [\n            {\n              name: \"Resource 1\",\n              uri: \"test://resource/1\",\n            },\n            {\n              name: \"Resource 2\",\n              uri: \"test://resource/2\",\n            },\n          ],\n        }),\n      }),\n      async (uri) =\u003E ({\n        contents: [\n          {\n            uri: uri.href,\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/list\",\n      },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(2);\n    expect(result.resources[0].name).toBe(\"Resource 1\");\n    expect(result.resources[0].uri).toBe(\"test://resource/1\");\n    expect(result.resources[1].name).toBe(\"Resource 2\");\n    expect(result.resources[1].uri).toBe(\"test://resource/2\");\n  });\n\n  /***\n   * Test: Template Variables to Read Callback\n   */\n  test(\"should pass template variables to readCallback\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{category}/{id}\", {\n        list: undefined,\n      }),\n      async (uri, { category, id }) =\u003E ({\n        contents: [\n          {\n            uri: uri.href,\n            text: `Category: ${category}, ID: ${id}`,\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/read\",\n        params: {\n          uri: \"test://resource/books/123\",\n        },\n      },\n      ReadResourceResultSchema,\n    );\n\n    expect(result.contents[0].text).toBe(\"Category: books, ID: 123\");\n  });\n\n  /***\n   * Test: Preventing Duplicate Resource Registration\n   */\n  test(\"should prevent duplicate resource registration\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\"test\", \"test://resource\", async () =\u003E ({\n      contents: [\n        {\n          uri: \"test://resource\",\n          text: \"Test content\",\n        },\n      ],\n    }));\n\n    expect(() =\u003E {\n      mcpServer.resource(\"test2\", \"test://resource\", async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource\",\n            text: \"Test content 2\",\n          },\n        ],\n      }));\n    }).toThrow(/already registered/);\n  });\n\n  /***\n   * Test: Multiple Resource Registration\n   */\n  test(\"should allow registering multiple resources\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    // This should succeed\n    mcpServer.resource(\"resource1\", \"test://resource1\", async () =\u003E ({\n      contents: [\n        {\n          uri: \"test://resource1\",\n          text: \"Test content 1\",\n        },\n      ],\n    }));\n\n    // This should also succeed and not throw about request handlers\n    mcpServer.resource(\"resource2\", \"test://resource2\", async () =\u003E ({\n      contents: [\n        {\n          uri: \"test://resource2\",\n          text: \"Test content 2\",\n        },\n      ],\n    }));\n  });\n\n  /***\n   * Test: Preventing Duplicate Resource Template Registration\n   */\n  test(\"should prevent duplicate resource template registration\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{id}\", { list: undefined }),\n      async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource/123\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    expect(() =\u003E {\n      mcpServer.resource(\n        \"test\",\n        new ResourceTemplate(\"test://resource/{id}\", { list: undefined }),\n        async () =\u003E ({\n          contents: [\n            {\n              uri: \"test://resource/123\",\n              text: \"Test content 2\",\n            },\n          ],\n        }),\n      );\n    }).toThrow(/already registered/);\n  });\n\n  /***\n   * Test: Graceful Resource Read Error Handling\n   */\n  test(\"should handle resource read errors gracefully\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\"error-test\", \"test://error\", async () =\u003E {\n      throw new Error(\"Resource read failed\");\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.request(\n        {\n          method: \"resources/read\",\n          params: {\n            uri: \"test://error\",\n          },\n        },\n        ReadResourceResultSchema,\n      ),\n    ).rejects.toThrow(/Resource read failed/);\n  });\n\n  /***\n   * Test: McpError for Invalid Resource URI\n   */\n  test(\"should throw McpError for invalid resource URI\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\"test\", \"test://resource\", async () =\u003E ({\n      contents: [\n        {\n          uri: \"test://resource\",\n          text: \"Test content\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.request(\n        {\n          method: \"resources/read\",\n          params: {\n            uri: \"test://nonexistent\",\n          },\n        },\n        ReadResourceResultSchema,\n      ),\n    ).rejects.toThrow(/Resource test:\\/\\/nonexistent not found/);\n  });\n\n  /***\n   * Test: Registering a resource template with a complete callback should update server capabilities to advertise support for completion\n   */\n  test(\"should advertise support for completion when a resource template with a complete callback is defined\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{category}\", {\n        list: undefined,\n        complete: {\n          category: () =\u003E [\"books\", \"movies\", \"music\"],\n        },\n      }),\n      async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource/test\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    expect(client.getServerCapabilities()).toMatchObject({ completions: {} })\n  })\n\n  /***\n   * Test: Resource Template Parameter Completion\n   */\n  test(\"should support completion of resource template parameters\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{category}\", {\n        list: undefined,\n        complete: {\n          category: () =\u003E [\"books\", \"movies\", \"music\"],\n        },\n      }),\n      async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource/test\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/resource\",\n            uri: \"test://resource/{category}\",\n          },\n          argument: {\n            name: \"category\",\n            value: \"\",\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result.completion.values).toEqual([\"books\", \"movies\", \"music\"]);\n    expect(result.completion.total).toBe(3);\n  });\n\n  /***\n   * Test: Filtered Resource Template Parameter Completion\n   */\n  test(\"should support filtered completion of resource template parameters\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{category}\", {\n        list: undefined,\n        complete: {\n          category: (test: string) =\u003E\n            [\"books\", \"movies\", \"music\"].filter((value) =\u003E\n              value.startsWith(test),\n            ),\n        },\n      }),\n      async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource/test\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/resource\",\n            uri: \"test://resource/{category}\",\n          },\n          argument: {\n            name: \"category\",\n            value: \"m\",\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result.completion.values).toEqual([\"movies\", \"music\"]);\n    expect(result.completion.total).toBe(2);\n  });\n\n  /***\n   * Test: Pass Request ID to Resource Callback\n   */\n  test(\"should pass requestId to resource callback via RequestHandlerExtra\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    let receivedRequestId: string | number | undefined;\n    mcpServer.resource(\"request-id-test\", \"test://resource\", async (_uri, extra) =\u003E {\n      receivedRequestId = extra.requestId;\n      return {\n        contents: [\n          {\n            uri: \"test://resource\",\n            text: `Received request ID: ${extra.requestId}`,\n          },\n        ],\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/read\",\n        params: {\n          uri: \"test://resource\",\n        },\n      },\n      ReadResourceResultSchema,\n    );\n\n    expect(receivedRequestId).toBeDefined();\n    expect(typeof receivedRequestId === 'string' || typeof receivedRequestId === 'number').toBe(true);\n    expect(result.contents[0].text).toContain(\"Received request ID:\");\n  });\n});\n\ndescribe(\"prompt()\", () =\u003E {\n  /***\n   * Test: Zero-Argument Prompt Registration\n   */\n  test(\"should register zero-argument prompt\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\"test\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"prompts/list\",\n      },\n      ListPromptsResultSchema,\n    );\n\n    expect(result.prompts).toHaveLength(1);\n    expect(result.prompts[0].name).toBe(\"test\");\n    expect(result.prompts[0].arguments).toBeUndefined();\n  });\n  /***\n   * Test: Updating Existing Prompt\n   */\n  test(\"should update existing prompt\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register initial prompt\n    const prompt = mcpServer.prompt(\"test\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Initial response\",\n          },\n        },\n      ],\n    }));\n\n    // Update the prompt\n    prompt.update({\n      callback: async () =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: \"Updated response\",\n            },\n          },\n        ],\n      })\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Call the prompt and verify we get the updated response\n    const result = await client.request(\n      {\n        method: \"prompts/get\",\n        params: {\n          name: \"test\",\n        },\n      },\n      GetPromptResultSchema,\n    );\n\n    expect(result.messages).toHaveLength(1);\n    expect(result.messages[0].content.text).toBe(\"Updated response\");\n\n    // Update happened before transport was connected, so no notifications should be expected\n    expect(notifications).toHaveLength(0);\n  });\n\n  /***\n   * Test: Updating Prompt with Schema\n   */\n  test(\"should update prompt with schema\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register initial prompt\n    const prompt = mcpServer.prompt(\n      \"test\",\n      {\n        name: z.string(),\n      },\n      async ({ name }) =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Initial: ${name}`,\n            },\n          },\n        ],\n      }),\n    );\n\n    // Update the prompt with a different schema\n    prompt.update({\n      argsSchema: {\n        name: z.string(),\n        value: z.string(),\n      },\n      callback: async ({ name, value }) =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Updated: ${name}, ${value}`,\n            },\n          },\n        ],\n      })\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Verify the schema was updated\n    const listResult = await client.request(\n      {\n        method: \"prompts/list\",\n      },\n      ListPromptsResultSchema,\n    );\n\n    expect(listResult.prompts[0].arguments).toHaveLength(2);\n    expect(listResult.prompts[0].arguments?.map(a =\u003E a.name).sort()).toEqual([\"name\", \"value\"]);\n\n    // Call the prompt with the new schema\n    const getResult = await client.request(\n      {\n        method: \"prompts/get\",\n        params: {\n          name: \"test\",\n          arguments: {\n            name: \"test\",\n            value: \"value\",\n          },\n        },\n      },\n      GetPromptResultSchema,\n    );\n\n    expect(getResult.messages).toHaveLength(1);\n    expect(getResult.messages[0].content.text).toBe(\"Updated: test, value\");\n\n    // Update happened before transport was connected, so no notifications should be expected\n    expect(notifications).toHaveLength(0);\n  });\n\n  /***\n   * Test: Prompt List Changed Notification\n   */\n  test(\"should send prompt list changed notification when connected\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register initial prompt\n    const prompt = mcpServer.prompt(\"test\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    expect(notifications).toHaveLength(0);\n\n    // Now update the prompt while connected\n    prompt.update({\n      callback: async () =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: \"Updated response\",\n            },\n          },\n        ],\n      })\n    });\n\n    // Yield event loop to let the notification fly\n    await new Promise(process.nextTick);\n\n    expect(notifications).toMatchObject([\n      { method: \"notifications/prompts/list_changed\" }\n    ]);\n  });\n\n  /***\n   * Test: Remove Prompt and Send Notification\n   */\n  test(\"should remove prompt and send notification when connected\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const notifications: Notification[] = [];\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n    client.fallbackNotificationHandler = async (notification) =\u003E {\n      notifications.push(notification);\n    };\n\n    // Register initial prompts\n    const prompt1 = mcpServer.prompt(\"prompt1\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Prompt 1 response\",\n          },\n        },\n      ],\n    }));\n\n    mcpServer.prompt(\"prompt2\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Prompt 2 response\",\n          },\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    // Verify both prompts are registered\n    let result = await client.request(\n      { method: \"prompts/list\" },\n      ListPromptsResultSchema,\n    );\n\n    expect(result.prompts).toHaveLength(2);\n    expect(result.prompts.map(p =\u003E p.name).sort()).toEqual([\"prompt1\", \"prompt2\"]);\n\n    expect(notifications).toHaveLength(0);\n\n    // Remove a prompt\n    prompt1.remove()\n\n    // Yield event loop to let the notification fly\n    await new Promise(process.nextTick);\n\n    // Should have sent notification\n    expect(notifications).toMatchObject([\n      { method: \"notifications/prompts/list_changed\" }\n    ]);\n\n    // Verify the prompt was removed\n    result = await client.request(\n      { method: \"prompts/list\" },\n      ListPromptsResultSchema,\n    );\n\n    expect(result.prompts).toHaveLength(1);\n    expect(result.prompts[0].name).toBe(\"prompt2\");\n  });\n\n  /***\n   * Test: Prompt Registration with Arguments Schema\n   */\n  test(\"should register prompt with args schema\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\n      \"test\",\n      {\n        name: z.string(),\n        value: z.string(),\n      },\n      async ({ name, value }) =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `${name}: ${value}`,\n            },\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"prompts/list\",\n      },\n      ListPromptsResultSchema,\n    );\n\n    expect(result.prompts).toHaveLength(1);\n    expect(result.prompts[0].name).toBe(\"test\");\n    expect(result.prompts[0].arguments).toEqual([\n      { name: \"name\", required: true },\n      { name: \"value\", required: true },\n    ]);\n  });\n\n  /***\n   * Test: Prompt Registration with Description\n   */\n  test(\"should register prompt with description\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\"test\", \"Test description\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"prompts/list\",\n      },\n      ListPromptsResultSchema,\n    );\n\n    expect(result.prompts).toHaveLength(1);\n    expect(result.prompts[0].name).toBe(\"test\");\n    expect(result.prompts[0].description).toBe(\"Test description\");\n  });\n\n  /***\n   * Test: Prompt Argument Validation\n   */\n  test(\"should validate prompt args\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\n      \"test\",\n      {\n        name: z.string(),\n        value: z.string().min(3),\n      },\n      async ({ name, value }) =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `${name}: ${value}`,\n            },\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.request(\n        {\n          method: \"prompts/get\",\n          params: {\n            name: \"test\",\n            arguments: {\n              name: \"test\",\n              value: \"ab\", // Too short\n            },\n          },\n        },\n        GetPromptResultSchema,\n      ),\n    ).rejects.toThrow(/Invalid arguments/);\n  });\n\n  /***\n   * Test: Preventing Duplicate Prompt Registration\n   */\n  test(\"should prevent duplicate prompt registration\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\"test\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        },\n      ],\n    }));\n\n    expect(() =\u003E {\n      mcpServer.prompt(\"test\", async () =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: \"Test response 2\",\n            },\n          },\n        ],\n      }));\n    }).toThrow(/already registered/);\n  });\n\n  /***\n   * Test: Multiple Prompt Registration\n   */\n  test(\"should allow registering multiple prompts\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    // This should succeed\n    mcpServer.prompt(\"prompt1\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Test response 1\",\n          },\n        },\n      ],\n    }));\n\n    // This should also succeed and not throw about request handlers\n    mcpServer.prompt(\"prompt2\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Test response 2\",\n          },\n        },\n      ],\n    }));\n  });\n\n  /***\n   * Test: Prompt Registration with Arguments\n   */\n  test(\"should allow registering prompts with arguments\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    // This should succeed\n    mcpServer.prompt(\n      \"echo\",\n      { message: z.string() },\n      ({ message }) =\u003E ({\n        messages: [{\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Please process this message: ${message}`\n          }\n        }]\n      })\n    );\n  });\n\n  /***\n   * Test: Resources and Prompts with Completion Handlers\n   */\n  test(\"should allow registering both resources and prompts with completion handlers\", () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    // Register a resource with completion\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{category}\", {\n        list: undefined,\n        complete: {\n          category: () =\u003E [\"books\", \"movies\", \"music\"],\n        },\n      }),\n      async () =\u003E ({\n        contents: [\n          {\n            uri: \"test://resource/test\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    // Register a prompt with completion\n    mcpServer.prompt(\n      \"echo\",\n      { message: completable(z.string(), () =\u003E [\"hello\", \"world\"]) },\n      ({ message }) =\u003E ({\n        messages: [{\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Please process this message: ${message}`\n          }\n        }]\n      })\n    );\n  });\n\n  /***\n   * Test: McpError for Invalid Prompt Name\n   */\n  test(\"should throw McpError for invalid prompt name\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\"test-prompt\", async () =\u003E ({\n      messages: [\n        {\n          role: \"assistant\",\n          content: {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.request(\n        {\n          method: \"prompts/get\",\n          params: {\n            name: \"nonexistent-prompt\",\n          },\n        },\n        GetPromptResultSchema,\n      ),\n    ).rejects.toThrow(/Prompt nonexistent-prompt not found/);\n  });\n\n\n  /***\n   * Test: Registering a prompt with a completable argument should update server capabilities to advertise support for completion\n   */\n  test(\"should advertise support for completion when a prompt with a completable argument is defined\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\n      \"test-prompt\",\n      {\n        name: completable(z.string(), () =\u003E [\"Alice\", \"Bob\", \"Charlie\"]),\n      },\n      async ({ name }) =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Hello ${name}`,\n            },\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    expect(client.getServerCapabilities()).toMatchObject({ completions: {} })\n  })\n\n  /***\n   * Test: Prompt Argument Completion\n   */\n  test(\"should support completion of prompt arguments\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\n      \"test-prompt\",\n      {\n        name: completable(z.string(), () =\u003E [\"Alice\", \"Bob\", \"Charlie\"]),\n      },\n      async ({ name }) =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Hello ${name}`,\n            },\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/prompt\",\n            name: \"test-prompt\",\n          },\n          argument: {\n            name: \"name\",\n            value: \"\",\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result.completion.values).toEqual([\"Alice\", \"Bob\", \"Charlie\"]);\n    expect(result.completion.total).toBe(3);\n  });\n\n  /***\n   * Test: Filtered Prompt Argument Completion\n   */\n  test(\"should support filtered completion of prompt arguments\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.prompt(\n      \"test-prompt\",\n      {\n        name: completable(z.string(), (test) =\u003E\n          [\"Alice\", \"Bob\", \"Charlie\"].filter((value) =\u003E value.startsWith(test)),\n        ),\n      },\n      async ({ name }) =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Hello ${name}`,\n            },\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/prompt\",\n            name: \"test-prompt\",\n          },\n          argument: {\n            name: \"name\",\n            value: \"A\",\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result.completion.values).toEqual([\"Alice\"]);\n    expect(result.completion.total).toBe(1);\n  });\n\n  /***\n   * Test: Pass Request ID to Prompt Callback\n   */\n  test(\"should pass requestId to prompt callback via RequestHandlerExtra\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    let receivedRequestId: string | number | undefined;\n    mcpServer.prompt(\"request-id-test\", async (extra) =\u003E {\n      receivedRequestId = extra.requestId;\n      return {\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Received request ID: ${extra.requestId}`,\n            },\n          },\n        ],\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"prompts/get\",\n        params: {\n          name: \"request-id-test\",\n        },\n      },\n      GetPromptResultSchema,\n    );\n\n    expect(receivedRequestId).toBeDefined();\n    expect(typeof receivedRequestId === 'string' || typeof receivedRequestId === 'number').toBe(true);\n    expect(result.messages[0].content.text).toContain(\"Received request ID:\");\n  });\n\n  /***\n   * Test: Resource Template Metadata Priority\n   */\n  test(\"should prioritize individual resource metadata over template metadata\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{id}\", {\n        list: async () =\u003E ({\n          resources: [\n            {\n              name: \"Resource 1\",\n              uri: \"test://resource/1\",\n              description: \"Individual resource description\",\n              mimeType: \"text/plain\",\n            },\n            {\n              name: \"Resource 2\",\n              uri: \"test://resource/2\",\n              // This resource has no description or mimeType\n            },\n          ],\n        }),\n      }),\n      {\n        description: \"Template description\",\n        mimeType: \"application/json\",\n      },\n      async (uri) =\u003E ({\n        contents: [\n          {\n            uri: uri.href,\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/list\",\n      },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(2);\n\n    // Resource 1 should have its own metadata\n    expect(result.resources[0].name).toBe(\"Resource 1\");\n    expect(result.resources[0].description).toBe(\"Individual resource description\");\n    expect(result.resources[0].mimeType).toBe(\"text/plain\");\n\n    // Resource 2 should inherit template metadata\n    expect(result.resources[1].name).toBe(\"Resource 2\");\n    expect(result.resources[1].description).toBe(\"Template description\");\n    expect(result.resources[1].mimeType).toBe(\"application/json\");\n  });\n\n  /***\n   * Test: Resource Template Metadata Overrides All Fields\n   */\n  test(\"should allow resource to override all template metadata fields\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{id}\", {\n        list: async () =\u003E ({\n          resources: [\n            {\n              name: \"Overridden Name\",\n              uri: \"test://resource/1\",\n              description: \"Overridden description\",\n              mimeType: \"text/markdown\",\n              // Add any other metadata fields if they exist\n            },\n          ],\n        }),\n      }),\n      {\n        name: \"Template Name\",\n        description: \"Template description\",\n        mimeType: \"application/json\",\n      },\n      async (uri) =\u003E ({\n        contents: [\n          {\n            uri: uri.href,\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/list\",\n      },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(1);\n\n    // All fields should be from the individual resource, not the template\n    expect(result.resources[0].name).toBe(\"Overridden Name\");\n    expect(result.resources[0].description).toBe(\"Overridden description\");\n    expect(result.resources[0].mimeType).toBe(\"text/markdown\");\n  });\n});\n\ndescribe(\"Tool title precedence\", () =\u003E {\n  test(\"should follow correct title precedence: title → annotations.title → name\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    // Tool 1: Only name\n    mcpServer.tool(\n      \"tool_name_only\",\n      async () =\u003E ({\n        content: [{ type: \"text\", text: \"Response\" }],\n      })\n    );\n\n    // Tool 2: Name and annotations.title\n    mcpServer.tool(\n      \"tool_with_annotations_title\",\n      \"Tool with annotations title\",\n      {\n        title: \"Annotations Title\"\n      },\n      async () =\u003E ({\n        content: [{ type: \"text\", text: \"Response\" }],\n      })\n    );\n\n    // Tool 3: Name and title (using registerTool)\n    mcpServer.registerTool(\n      \"tool_with_title\",\n      {\n        title: \"Regular Title\",\n        description: \"Tool with regular title\"\n      },\n      async () =\u003E ({\n        content: [{ type: \"text\", text: \"Response\" }],\n      })\n    );\n\n    // Tool 4: All three - title should win\n    mcpServer.registerTool(\n      \"tool_with_all_titles\",\n      {\n        title: \"Regular Title Wins\",\n        description: \"Tool with all titles\",\n        annotations: {\n          title: \"Annotations Title Should Not Show\"\n        }\n      },\n      async () =\u003E ({\n        content: [{ type: \"text\", text: \"Response\" }],\n      })\n    );\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      { method: \"tools/list\" },\n      ListToolsResultSchema,\n    );\n\n\n    expect(result.tools).toHaveLength(4);\n\n    // Tool 1: Only name - should display name\n    const tool1 = result.tools.find(t =\u003E t.name === \"tool_name_only\");\n    expect(tool1).toBeDefined();\n    expect(getDisplayName(tool1!)).toBe(\"tool_name_only\");\n\n    // Tool 2: Name and annotations.title - should display annotations.title\n    const tool2 = result.tools.find(t =\u003E t.name === \"tool_with_annotations_title\");\n    expect(tool2).toBeDefined();\n    expect(tool2!.annotations?.title).toBe(\"Annotations Title\");\n    expect(getDisplayName(tool2!)).toBe(\"Annotations Title\");\n\n    // Tool 3: Name and title - should display title\n    const tool3 = result.tools.find(t =\u003E t.name === \"tool_with_title\");\n    expect(tool3).toBeDefined();\n    expect(tool3!.title).toBe(\"Regular Title\");\n    expect(getDisplayName(tool3!)).toBe(\"Regular Title\");\n\n    // Tool 4: All three - title should take precedence\n    const tool4 = result.tools.find(t =\u003E t.name === \"tool_with_all_titles\");\n    expect(tool4).toBeDefined();\n    expect(tool4!.title).toBe(\"Regular Title Wins\");\n    expect(tool4!.annotations?.title).toBe(\"Annotations Title Should Not Show\");\n    expect(getDisplayName(tool4!)).toBe(\"Regular Title Wins\");\n  });\n\n  test(\"getDisplayName unit tests for title precedence\", () =\u003E {\n\n    // Test 1: Only name\n    expect(getDisplayName({ name: \"tool_name\" })).toBe(\"tool_name\");\n\n    // Test 2: Name and title - title wins\n    expect(getDisplayName({\n      name: \"tool_name\",\n      title: \"Tool Title\"\n    })).toBe(\"Tool Title\");\n\n    // Test 3: Name and annotations.title - annotations.title wins\n    expect(getDisplayName({\n      name: \"tool_name\",\n      annotations: { title: \"Annotations Title\" }\n    })).toBe(\"Annotations Title\");\n\n    // Test 4: All three - title wins (correct precedence)\n    expect(getDisplayName({\n      name: \"tool_name\",\n      title: \"Regular Title\",\n      annotations: { title: \"Annotations Title\" }\n    })).toBe(\"Regular Title\");\n\n    // Test 5: Empty title should not be used\n    expect(getDisplayName({\n      name: \"tool_name\",\n      title: \"\",\n      annotations: { title: \"Annotations Title\" }\n    })).toBe(\"Annotations Title\");\n\n    // Test 6: Undefined vs null handling\n    expect(getDisplayName({\n      name: \"tool_name\",\n      title: undefined,\n      annotations: { title: \"Annotations Title\" }\n    })).toBe(\"Annotations Title\");\n  });\n\n  test(\"should support resource template completion with resolved context\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.registerResource(\n      \"test\",\n      new ResourceTemplate(\"github://repos/{owner}/{repo}\", {\n        list: undefined,\n        complete: {\n          repo: (value, context) =\u003E {\n            if (context?.arguments?.[\"owner\"] === \"org1\") {\n              return [\"project1\", \"project2\", \"project3\"].filter(r =\u003E r.startsWith(value));\n            } else if (context?.arguments?.[\"owner\"] === \"org2\") {\n              return [\"repo1\", \"repo2\", \"repo3\"].filter(r =\u003E r.startsWith(value));\n            }\n            return [];\n          },\n        },\n      }),\n      {\n        title: \"GitHub Repository\",\n        description: \"Repository information\"\n      },\n      async () =\u003E ({\n        contents: [\n          {\n            uri: \"github://repos/test/test\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Test with microsoft owner\n    const result1 = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/resource\",\n            uri: \"github://repos/{owner}/{repo}\",\n          },\n          argument: {\n            name: \"repo\",\n            value: \"p\",\n          },\n          context: {\n            arguments: {\n              owner: \"org1\",\n            },\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result1.completion.values).toEqual([\"project1\", \"project2\", \"project3\"]);\n    expect(result1.completion.total).toBe(3);\n\n    // Test with facebook owner\n    const result2 = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/resource\",\n            uri: \"github://repos/{owner}/{repo}\",\n          },\n          argument: {\n            name: \"repo\",\n            value: \"r\",\n          },\n          context: {\n            arguments: {\n              owner: \"org2\",\n            },\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result2.completion.values).toEqual([\"repo1\", \"repo2\", \"repo3\"]);\n    expect(result2.completion.total).toBe(3);\n\n    // Test with no resolved context\n    const result3 = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/resource\",\n            uri: \"github://repos/{owner}/{repo}\",\n          },\n          argument: {\n            name: \"repo\",\n            value: \"t\",\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result3.completion.values).toEqual([]);\n    expect(result3.completion.total).toBe(0);\n  });\n\n  test(\"should support prompt argument completion with resolved context\", async () =\u003E {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.registerPrompt(\n      \"test-prompt\",\n      {\n        title: \"Team Greeting\",\n        description: \"Generate a greeting for team members\",\n        argsSchema: {\n          department: completable(z.string(), (value) =\u003E {\n            return [\"engineering\", \"sales\", \"marketing\", \"support\"].filter(d =\u003E d.startsWith(value));\n          }),\n          name: completable(z.string(), (value, context) =\u003E {\n            const department = context?.arguments?.[\"department\"];\n            if (department === \"engineering\") {\n              return [\"Alice\", \"Bob\", \"Charlie\"].filter(n =\u003E n.startsWith(value));\n            } else if (department === \"sales\") {\n              return [\"David\", \"Eve\", \"Frank\"].filter(n =\u003E n.startsWith(value));\n            } else if (department === \"marketing\") {\n              return [\"Grace\", \"Henry\", \"Iris\"].filter(n =\u003E n.startsWith(value));\n            }\n            return [\"Guest\"].filter(n =\u003E n.startsWith(value));\n          }),\n        }\n      },\n      async ({ department, name }) =\u003E ({\n        messages: [\n          {\n            role: \"assistant\",\n            content: {\n              type: \"text\",\n              text: `Hello ${name}, welcome to the ${department} team!`,\n            },\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Test with engineering department\n    const result1 = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/prompt\",\n            name: \"test-prompt\",\n          },\n          argument: {\n            name: \"name\",\n            value: \"A\",\n          },\n          context: {\n            arguments: {\n              department: \"engineering\",\n            },\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result1.completion.values).toEqual([\"Alice\"]);\n\n    // Test with sales department\n    const result2 = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/prompt\",\n            name: \"test-prompt\",\n          },\n          argument: {\n            name: \"name\",\n            value: \"D\",\n          },\n          context: {\n            arguments: {\n              department: \"sales\",\n            },\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result2.completion.values).toEqual([\"David\"]);\n\n    // Test with marketing department\n    const result3 = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/prompt\",\n            name: \"test-prompt\",\n          },\n          argument: {\n            name: \"name\",\n            value: \"G\",\n          },\n          context: {\n            arguments: {\n              department: \"marketing\",\n            },\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result3.completion.values).toEqual([\"Grace\"]);\n\n    // Test with no resolved context\n    const result4 = await client.request(\n      {\n        method: \"completion/complete\",\n        params: {\n          ref: {\n            type: \"ref/prompt\",\n            name: \"test-prompt\",\n          },\n          argument: {\n            name: \"name\",\n            value: \"G\",\n          },\n        },\n      },\n      CompleteResultSchema,\n    );\n\n    expect(result4.completion.values).toEqual([\"Guest\"]);\n  });\n});\n\ndescribe(\"elicitInput()\", () =\u003E {\n\n  const checkAvailability = jest.fn().mockResolvedValue(false);\n  const findAlternatives = jest.fn().mockResolvedValue([]);\n  const makeBooking = jest.fn().mockResolvedValue(\"BOOKING-123\");\n\n  let mcpServer: McpServer;\n  let client: Client;\n\n  beforeEach(() =\u003E {\n    jest.clearAllMocks();\n\n    // Create server with restaurant booking tool\n    mcpServer = new McpServer({\n      name: \"restaurant-booking-server\",\n      version: \"1.0.0\",\n    });\n\n    // Register the restaurant booking tool from README example\n    mcpServer.tool(\n      \"book-restaurant\",\n      {\n        restaurant: z.string(),\n        date: z.string(),\n        partySize: z.number()\n      },\n      async ({ restaurant, date, partySize }) =\u003E {\n        // Check availability\n        const available = await checkAvailability(restaurant, date, partySize);\n\n        if (!available) {\n          // Ask user if they want to try alternative dates\n          const result = await mcpServer.server.elicitInput({\n            message: `No tables available at ${restaurant} on ${date}. Would you like to check alternative dates?`,\n            requestedSchema: {\n              type: \"object\",\n              properties: {\n                checkAlternatives: {\n                  type: \"boolean\",\n                  title: \"Check alternative dates\",\n                  description: \"Would you like me to check other dates?\"\n                },\n                flexibleDates: {\n                  type: \"string\",\n                  title: \"Date flexibility\",\n                  description: \"How flexible are your dates?\",\n                  enum: [\"next_day\", \"same_week\", \"next_week\"],\n                  enumNames: [\"Next day\", \"Same week\", \"Next week\"]\n                }\n              },\n              required: [\"checkAlternatives\"]\n            }\n          });\n\n          if (result.action === \"accept\" && result.content?.checkAlternatives) {\n            const alternatives = await findAlternatives(\n              restaurant,\n              date,\n              partySize,\n              result.content.flexibleDates as string\n            );\n            return {\n              content: [{\n                type: \"text\",\n                text: `Found these alternatives: ${alternatives.join(\", \")}`\n              }]\n            };\n          }\n\n          return {\n            content: [{\n              type: \"text\",\n              text: \"No booking made. Original date not available.\"\n            }]\n          };\n        }\n\n        await makeBooking(restaurant, date, partySize);\n        return {\n          content: [{\n            type: \"text\",\n            text: `Booked table for ${partySize} at ${restaurant} on ${date}`\n          }]\n        };\n      }\n    );\n\n    // Create client with elicitation capability\n    client = new Client(\n      {\n        name: \"test-client\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {\n          elicitation: {},\n        },\n      }\n    );\n  });\n\n  test(\"should successfully elicit additional information\", async () =\u003E {\n    // Mock availability check to return false\n    checkAvailability.mockResolvedValue(false);\n    findAlternatives.mockResolvedValue([\"2024-12-26\", \"2024-12-27\", \"2024-12-28\"]);\n\n    // Set up client to accept alternative date checking\n    client.setRequestHandler(ElicitRequestSchema, async (request) =\u003E {\n      expect(request.params.message).toContain(\"No tables available at ABC Restaurant on 2024-12-25\");\n      return {\n        action: \"accept\",\n        content: {\n          checkAlternatives: true,\n          flexibleDates: \"same_week\"\n        }\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Call the tool\n    const result = await client.callTool({\n      name: \"book-restaurant\",\n      arguments: {\n        restaurant: \"ABC Restaurant\",\n        date: \"2024-12-25\",\n        partySize: 2\n      }\n    });\n\n    expect(checkAvailability).toHaveBeenCalledWith(\"ABC Restaurant\", \"2024-12-25\", 2);\n    expect(findAlternatives).toHaveBeenCalledWith(\"ABC Restaurant\", \"2024-12-25\", 2, \"same_week\");\n    expect(result.content).toEqual([{\n      type: \"text\",\n      text: \"Found these alternatives: 2024-12-26, 2024-12-27, 2024-12-28\"\n    }]);\n  });\n\n  test(\"should handle user declining to elicitation request\", async () =\u003E {\n    // Mock availability check to return false\n    checkAvailability.mockResolvedValue(false);\n\n    // Set up client to reject alternative date checking\n    client.setRequestHandler(ElicitRequestSchema, async () =\u003E {\n      return {\n        action: \"accept\",\n        content: {\n          checkAlternatives: false\n        }\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Call the tool\n    const result = await client.callTool({\n      name: \"book-restaurant\",\n      arguments: {\n        restaurant: \"ABC Restaurant\",\n        date: \"2024-12-25\",\n        partySize: 2\n      }\n    });\n\n    expect(checkAvailability).toHaveBeenCalledWith(\"ABC Restaurant\", \"2024-12-25\", 2);\n    expect(findAlternatives).not.toHaveBeenCalled();\n    expect(result.content).toEqual([{\n      type: \"text\",\n      text: \"No booking made. Original date not available.\"\n    }]);\n  });\n\n  test(\"should handle user cancelling the elicitation\", async () =\u003E {\n    // Mock availability check to return false\n    checkAvailability.mockResolvedValue(false);\n\n    // Set up client to cancel the elicitation\n    client.setRequestHandler(ElicitRequestSchema, async () =\u003E {\n      return {\n        action: \"cancel\"\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // Call the tool\n    const result = await client.callTool({\n      name: \"book-restaurant\",\n      arguments: {\n        restaurant: \"ABC Restaurant\",\n        date: \"2024-12-25\",\n        partySize: 2\n      }\n    });\n\n    expect(checkAvailability).toHaveBeenCalledWith(\"ABC Restaurant\", \"2024-12-25\", 2);\n    expect(findAlternatives).not.toHaveBeenCalled();\n    expect(result.content).toEqual([{\n      type: \"text\",\n      text: \"No booking made. Original date not available.\"\n    }]);\n  });\n});\n",
      "hash": "9815fabff77b66636eaf0854f81b2275116026bee94d8ef22337e337bb139e17",
      "size": 108495
    },
    "/src/server/mcp.ts": {
      "type": "content",
      "content": "import { Server, ServerOptions } from \"./index.js\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport {\n  z,\n  ZodRawShape,\n  ZodObject,\n  ZodString,\n  AnyZodObject,\n  ZodTypeAny,\n  ZodType,\n  ZodTypeDef,\n  ZodOptional,\n} from \"zod\";\nimport {\n  Implementation,\n  Tool,\n  ListToolsResult,\n  CallToolResult,\n  McpError,\n  ErrorCode,\n  CompleteRequest,\n  CompleteResult,\n  PromptReference,\n  ResourceTemplateReference,\n  BaseMetadata,\n  Resource,\n  ListResourcesResult,\n  ListResourceTemplatesRequestSchema,\n  ReadResourceRequestSchema,\n  ListToolsRequestSchema,\n  CallToolRequestSchema,\n  ListResourcesRequestSchema,\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema,\n  CompleteRequestSchema,\n  ListPromptsResult,\n  Prompt,\n  PromptArgument,\n  GetPromptResult,\n  ReadResourceResult,\n  ServerRequest,\n  ServerNotification,\n  ToolAnnotations,\n} from \"../types.js\";\nimport { Completable, CompletableDef } from \"./completable.js\";\nimport { UriTemplate, Variables } from \"../shared/uriTemplate.js\";\nimport { RequestHandlerExtra } from \"../shared/protocol.js\";\nimport { Transport } from \"../shared/transport.js\";\n\n/**\n * High-level MCP server that provides a simpler API for working with resources, tools, and prompts.\n * For advanced usage (like sending notifications or setting custom request handlers), use the underlying\n * Server instance available via the `server` property.\n */\nexport class McpServer {\n  /**\n   * The underlying Server instance, useful for advanced operations like sending notifications.\n   */\n  public readonly server: Server;\n\n  private _registeredResources: { [uri: string]: RegisteredResource } = {};\n  private _registeredResourceTemplates: {\n    [name: string]: RegisteredResourceTemplate;\n  } = {};\n  private _registeredTools: { [name: string]: RegisteredTool } = {};\n  private _registeredPrompts: { [name: string]: RegisteredPrompt } = {};\n\n  constructor(serverInfo: Implementation, options?: ServerOptions) {\n    this.server = new Server(serverInfo, options);\n  }\n\n  /**\n   * Attaches to the given transport, starts it, and starts listening for messages.\n   *\n   * The `server` object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.\n   */\n  async connect(transport: Transport): Promise\u003Cvoid\u003E {\n    return await this.server.connect(transport);\n  }\n\n  /**\n   * Closes the connection.\n   */\n  async close(): Promise\u003Cvoid\u003E {\n    await this.server.close();\n  }\n\n  private _toolHandlersInitialized = false;\n\n  private setToolRequestHandlers() {\n    if (this._toolHandlersInitialized) {\n      return;\n    }\n\n    this.server.assertCanSetRequestHandler(\n      ListToolsRequestSchema.shape.method.value,\n    );\n    this.server.assertCanSetRequestHandler(\n      CallToolRequestSchema.shape.method.value,\n    );\n\n    this.server.registerCapabilities({\n      tools: {\n        listChanged: true\n      }\n    })\n\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      (): ListToolsResult =\u003E ({\n        tools: Object.entries(this._registeredTools).filter(\n          ([, tool]) =\u003E tool.enabled,\n        ).map(\n          ([name, tool]): Tool =\u003E {\n            const toolDefinition: Tool = {\n              name,\n              title: tool.title,\n              description: tool.description,\n              inputSchema: tool.inputSchema\n                ? (zodToJsonSchema(tool.inputSchema, {\n                  strictUnions: true,\n                }) as Tool[\"inputSchema\"])\n                : EMPTY_OBJECT_JSON_SCHEMA,\n              annotations: tool.annotations,\n            };\n\n            if (tool.outputSchema) {\n              toolDefinition.outputSchema = zodToJsonSchema(\n                tool.outputSchema,\n                { strictUnions: true }\n              ) as Tool[\"outputSchema\"];\n            }\n\n            return toolDefinition;\n          },\n        ),\n      }),\n    );\n\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request, extra): Promise\u003CCallToolResult\u003E =\u003E {\n        const tool = this._registeredTools[request.params.name];\n        if (!tool) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Tool ${request.params.name} not found`,\n          );\n        }\n\n        if (!tool.enabled) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Tool ${request.params.name} disabled`,\n          );\n        }\n\n        let result: CallToolResult;\n\n        if (tool.inputSchema) {\n          const parseResult = await tool.inputSchema.safeParseAsync(\n            request.params.arguments,\n          );\n          if (!parseResult.success) {\n            throw new McpError(\n              ErrorCode.InvalidParams,\n              `Invalid arguments for tool ${request.params.name}: ${parseResult.error.message}`,\n            );\n          }\n\n          const args = parseResult.data;\n          const cb = tool.callback as ToolCallback\u003CZodRawShape\u003E;\n          try {\n            result = await Promise.resolve(cb(args, extra));\n          } catch (error) {\n            result = {\n              content: [\n                {\n                  type: \"text\",\n                  text: error instanceof Error ? error.message : String(error),\n                },\n              ],\n              isError: true,\n            };\n          }\n        } else {\n          const cb = tool.callback as ToolCallback\u003Cundefined\u003E;\n          try {\n            result = await Promise.resolve(cb(extra));\n          } catch (error) {\n            result = {\n              content: [\n                {\n                  type: \"text\",\n                  text: error instanceof Error ? error.message : String(error),\n                },\n              ],\n              isError: true,\n            };\n          }\n        }\n\n        if (tool.outputSchema && !result.isError) {\n          if (!result.structuredContent) {\n            throw new McpError(\n              ErrorCode.InvalidParams,\n              `Tool ${request.params.name} has an output schema but no structured content was provided`,\n            );\n          }\n\n          // if the tool has an output schema, validate structured content\n          const parseResult = await tool.outputSchema.safeParseAsync(\n            result.structuredContent,\n          );\n          if (!parseResult.success) {\n            throw new McpError(\n              ErrorCode.InvalidParams,\n              `Invalid structured content for tool ${request.params.name}: ${parseResult.error.message}`,\n            );\n          }\n        }\n\n        return result;\n      },\n    );\n\n    this._toolHandlersInitialized = true;\n  }\n\n  private _completionHandlerInitialized = false;\n\n  private setCompletionRequestHandler() {\n    if (this._completionHandlerInitialized) {\n      return;\n    }\n\n    this.server.assertCanSetRequestHandler(\n      CompleteRequestSchema.shape.method.value,\n    );\n\n    this.server.registerCapabilities({\n      completions: {},\n    });\n\n    this.server.setRequestHandler(\n      CompleteRequestSchema,\n      async (request): Promise\u003CCompleteResult\u003E =\u003E {\n        switch (request.params.ref.type) {\n          case \"ref/prompt\":\n            return this.handlePromptCompletion(request, request.params.ref);\n\n          case \"ref/resource\":\n            return this.handleResourceCompletion(request, request.params.ref);\n\n          default:\n            throw new McpError(\n              ErrorCode.InvalidParams,\n              `Invalid completion reference: ${request.params.ref}`,\n            );\n        }\n      },\n    );\n\n    this._completionHandlerInitialized = true;\n  }\n\n  private async handlePromptCompletion(\n    request: CompleteRequest,\n    ref: PromptReference,\n  ): Promise\u003CCompleteResult\u003E {\n    const prompt = this._registeredPrompts[ref.name];\n    if (!prompt) {\n      throw new McpError(\n        ErrorCode.InvalidParams,\n        `Prompt ${ref.name} not found`,\n      );\n    }\n\n    if (!prompt.enabled) {\n      throw new McpError(\n        ErrorCode.InvalidParams,\n        `Prompt ${ref.name} disabled`,\n      );\n    }\n\n    if (!prompt.argsSchema) {\n      return EMPTY_COMPLETION_RESULT;\n    }\n\n    const field = prompt.argsSchema.shape[request.params.argument.name];\n    if (!(field instanceof Completable)) {\n      return EMPTY_COMPLETION_RESULT;\n    }\n\n    const def: CompletableDef\u003CZodString\u003E = field._def;\n    const suggestions = await def.complete(request.params.argument.value, request.params.context);\n    return createCompletionResult(suggestions);\n  }\n\n  private async handleResourceCompletion(\n    request: CompleteRequest,\n    ref: ResourceTemplateReference,\n  ): Promise\u003CCompleteResult\u003E {\n    const template = Object.values(this._registeredResourceTemplates).find(\n      (t) =\u003E t.resourceTemplate.uriTemplate.toString() === ref.uri,\n    );\n\n    if (!template) {\n      if (this._registeredResources[ref.uri]) {\n        // Attempting to autocomplete a fixed resource URI is not an error in the spec (but probably should be).\n        return EMPTY_COMPLETION_RESULT;\n      }\n\n      throw new McpError(\n        ErrorCode.InvalidParams,\n        `Resource template ${request.params.ref.uri} not found`,\n      );\n    }\n\n    const completer = template.resourceTemplate.completeCallback(\n      request.params.argument.name,\n    );\n    if (!completer) {\n      return EMPTY_COMPLETION_RESULT;\n    }\n\n    const suggestions = await completer(request.params.argument.value, request.params.context);\n    return createCompletionResult(suggestions);\n  }\n\n  private _resourceHandlersInitialized = false;\n\n  private setResourceRequestHandlers() {\n    if (this._resourceHandlersInitialized) {\n      return;\n    }\n\n    this.server.assertCanSetRequestHandler(\n      ListResourcesRequestSchema.shape.method.value,\n    );\n    this.server.assertCanSetRequestHandler(\n      ListResourceTemplatesRequestSchema.shape.method.value,\n    );\n    this.server.assertCanSetRequestHandler(\n      ReadResourceRequestSchema.shape.method.value,\n    );\n\n    this.server.registerCapabilities({\n      resources: {\n        listChanged: true\n      }\n    })\n\n    this.server.setRequestHandler(\n      ListResourcesRequestSchema,\n      async (request, extra) =\u003E {\n        const resources = Object.entries(this._registeredResources).filter(\n          ([_, resource]) =\u003E resource.enabled,\n        ).map(\n          ([uri, resource]) =\u003E ({\n            uri,\n            name: resource.name,\n            ...resource.metadata,\n          }),\n        );\n\n        const templateResources: Resource[] = [];\n        for (const template of Object.values(\n          this._registeredResourceTemplates,\n        )) {\n          if (!template.resourceTemplate.listCallback) {\n            continue;\n          }\n\n          const result = await template.resourceTemplate.listCallback(extra);\n          for (const resource of result.resources) {\n            templateResources.push({\n              ...template.metadata,\n              // the defined resource metadata should override the template metadata if present\n              ...resource,\n            });\n          }\n        }\n\n        return { resources: [...resources, ...templateResources] };\n      },\n    );\n\n    this.server.setRequestHandler(\n      ListResourceTemplatesRequestSchema,\n      async () =\u003E {\n        const resourceTemplates = Object.entries(\n          this._registeredResourceTemplates,\n        ).map(([name, template]) =\u003E ({\n          name,\n          uriTemplate: template.resourceTemplate.uriTemplate.toString(),\n          ...template.metadata,\n        }));\n\n        return { resourceTemplates };\n      },\n    );\n\n    this.server.setRequestHandler(\n      ReadResourceRequestSchema,\n      async (request, extra) =\u003E {\n        const uri = new URL(request.params.uri);\n\n        // First check for exact resource match\n        const resource = this._registeredResources[uri.toString()];\n        if (resource) {\n          if (!resource.enabled) {\n            throw new McpError(\n              ErrorCode.InvalidParams,\n              `Resource ${uri} disabled`,\n            );\n          }\n          return resource.readCallback(uri, extra);\n        }\n\n        // Then check templates\n        for (const template of Object.values(\n          this._registeredResourceTemplates,\n        )) {\n          const variables = template.resourceTemplate.uriTemplate.match(\n            uri.toString(),\n          );\n          if (variables) {\n            return template.readCallback(uri, variables, extra);\n          }\n        }\n\n        throw new McpError(\n          ErrorCode.InvalidParams,\n          `Resource ${uri} not found`,\n        );\n      },\n    );\n\n    this.setCompletionRequestHandler();\n\n    this._resourceHandlersInitialized = true;\n  }\n\n  private _promptHandlersInitialized = false;\n\n  private setPromptRequestHandlers() {\n    if (this._promptHandlersInitialized) {\n      return;\n    }\n\n    this.server.assertCanSetRequestHandler(\n      ListPromptsRequestSchema.shape.method.value,\n    );\n    this.server.assertCanSetRequestHandler(\n      GetPromptRequestSchema.shape.method.value,\n    );\n\n    this.server.registerCapabilities({\n      prompts: {\n        listChanged: true\n      }\n    })\n\n    this.server.setRequestHandler(\n      ListPromptsRequestSchema,\n      (): ListPromptsResult =\u003E ({\n        prompts: Object.entries(this._registeredPrompts).filter(\n          ([, prompt]) =\u003E prompt.enabled,\n        ).map(\n          ([name, prompt]): Prompt =\u003E {\n            return {\n              name,\n              title: prompt.title,\n              description: prompt.description,\n              arguments: prompt.argsSchema\n                ? promptArgumentsFromSchema(prompt.argsSchema)\n                : undefined,\n            };\n          },\n        ),\n      }),\n    );\n\n    this.server.setRequestHandler(\n      GetPromptRequestSchema,\n      async (request, extra): Promise\u003CGetPromptResult\u003E =\u003E {\n        const prompt = this._registeredPrompts[request.params.name];\n        if (!prompt) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Prompt ${request.params.name} not found`,\n          );\n        }\n\n        if (!prompt.enabled) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Prompt ${request.params.name} disabled`,\n          );\n        }\n\n        if (prompt.argsSchema) {\n          const parseResult = await prompt.argsSchema.safeParseAsync(\n            request.params.arguments,\n          );\n          if (!parseResult.success) {\n            throw new McpError(\n              ErrorCode.InvalidParams,\n              `Invalid arguments for prompt ${request.params.name}: ${parseResult.error.message}`,\n            );\n          }\n\n          const args = parseResult.data;\n          const cb = prompt.callback as PromptCallback\u003CPromptArgsRawShape\u003E;\n          return await Promise.resolve(cb(args, extra));\n        } else {\n          const cb = prompt.callback as PromptCallback\u003Cundefined\u003E;\n          return await Promise.resolve(cb(extra));\n        }\n      },\n    );\n\n    this.setCompletionRequestHandler();\n\n    this._promptHandlersInitialized = true;\n  }\n\n  /**\n   * Registers a resource `name` at a fixed URI, which will use the given callback to respond to read requests.\n   */\n  resource(name: string, uri: string, readCallback: ReadResourceCallback): RegisteredResource;\n\n  /**\n   * Registers a resource `name` at a fixed URI with metadata, which will use the given callback to respond to read requests.\n   */\n  resource(\n    name: string,\n    uri: string,\n    metadata: ResourceMetadata,\n    readCallback: ReadResourceCallback,\n  ): RegisteredResource;\n\n  /**\n   * Registers a resource `name` with a template pattern, which will use the given callback to respond to read requests.\n   */\n  resource(\n    name: string,\n    template: ResourceTemplate,\n    readCallback: ReadResourceTemplateCallback,\n  ): RegisteredResourceTemplate;\n\n  /**\n   * Registers a resource `name` with a template pattern and metadata, which will use the given callback to respond to read requests.\n   */\n  resource(\n    name: string,\n    template: ResourceTemplate,\n    metadata: ResourceMetadata,\n    readCallback: ReadResourceTemplateCallback,\n  ): RegisteredResourceTemplate;\n\n  resource(\n    name: string,\n    uriOrTemplate: string | ResourceTemplate,\n    ...rest: unknown[]\n  ): RegisteredResource | RegisteredResourceTemplate {\n    let metadata: ResourceMetadata | undefined;\n    if (typeof rest[0] === \"object\") {\n      metadata = rest.shift() as ResourceMetadata;\n    }\n\n    const readCallback = rest[0] as\n      | ReadResourceCallback\n      | ReadResourceTemplateCallback;\n\n    if (typeof uriOrTemplate === \"string\") {\n      if (this._registeredResources[uriOrTemplate]) {\n        throw new Error(`Resource ${uriOrTemplate} is already registered`);\n      }\n\n      const registeredResource = this._createRegisteredResource(\n        name,\n        undefined,\n        uriOrTemplate,\n        metadata,\n        readCallback as ReadResourceCallback\n      );\n\n      this.setResourceRequestHandlers();\n      this.sendResourceListChanged();\n      return registeredResource;\n    } else {\n      if (this._registeredResourceTemplates[name]) {\n        throw new Error(`Resource template ${name} is already registered`);\n      }\n\n      const registeredResourceTemplate = this._createRegisteredResourceTemplate(\n        name,\n        undefined,\n        uriOrTemplate,\n        metadata,\n        readCallback as ReadResourceTemplateCallback\n      );\n\n      this.setResourceRequestHandlers();\n      this.sendResourceListChanged();\n      return registeredResourceTemplate;\n    }\n  }\n\n  /**\n   * Registers a resource with a config object and callback.\n   * For static resources, use a URI string. For dynamic resources, use a ResourceTemplate.\n   */\n  registerResource(\n    name: string,\n    uriOrTemplate: string,\n    config: ResourceMetadata,\n    readCallback: ReadResourceCallback\n  ): RegisteredResource;\n  registerResource(\n    name: string,\n    uriOrTemplate: ResourceTemplate,\n    config: ResourceMetadata,\n    readCallback: ReadResourceTemplateCallback\n  ): RegisteredResourceTemplate;\n  registerResource(\n    name: string,\n    uriOrTemplate: string | ResourceTemplate,\n    config: ResourceMetadata,\n    readCallback: ReadResourceCallback | ReadResourceTemplateCallback\n  ): RegisteredResource | RegisteredResourceTemplate {\n    if (typeof uriOrTemplate === \"string\") {\n      if (this._registeredResources[uriOrTemplate]) {\n        throw new Error(`Resource ${uriOrTemplate} is already registered`);\n      }\n\n      const registeredResource = this._createRegisteredResource(\n        name,\n        (config as BaseMetadata).title,\n        uriOrTemplate,\n        config,\n        readCallback as ReadResourceCallback\n      );\n\n      this.setResourceRequestHandlers();\n      this.sendResourceListChanged();\n      return registeredResource;\n    } else {\n      if (this._registeredResourceTemplates[name]) {\n        throw new Error(`Resource template ${name} is already registered`);\n      }\n\n      const registeredResourceTemplate = this._createRegisteredResourceTemplate(\n        name,\n        (config as BaseMetadata).title,\n        uriOrTemplate,\n        config,\n        readCallback as ReadResourceTemplateCallback\n      );\n\n      this.setResourceRequestHandlers();\n      this.sendResourceListChanged();\n      return registeredResourceTemplate;\n    }\n  }\n\n  private _createRegisteredResource(\n    name: string,\n    title: string | undefined,\n    uri: string,\n    metadata: ResourceMetadata | undefined,\n    readCallback: ReadResourceCallback\n  ): RegisteredResource {\n    const registeredResource: RegisteredResource = {\n      name,\n      title,\n      metadata,\n      readCallback,\n      enabled: true,\n      disable: () =\u003E registeredResource.update({ enabled: false }),\n      enable: () =\u003E registeredResource.update({ enabled: true }),\n      remove: () =\u003E registeredResource.update({ uri: null }),\n      update: (updates) =\u003E {\n        if (typeof updates.uri !== \"undefined\" && updates.uri !== uri) {\n          delete this._registeredResources[uri]\n          if (updates.uri) this._registeredResources[updates.uri] = registeredResource\n        }\n        if (typeof updates.name !== \"undefined\") registeredResource.name = updates.name\n        if (typeof updates.title !== \"undefined\") registeredResource.title = updates.title\n        if (typeof updates.metadata !== \"undefined\") registeredResource.metadata = updates.metadata\n        if (typeof updates.callback !== \"undefined\") registeredResource.readCallback = updates.callback\n        if (typeof updates.enabled !== \"undefined\") registeredResource.enabled = updates.enabled\n        this.sendResourceListChanged()\n      },\n    };\n    this._registeredResources[uri] = registeredResource;\n    return registeredResource;\n  }\n\n  private _createRegisteredResourceTemplate(\n    name: string,\n    title: string | undefined,\n    template: ResourceTemplate,\n    metadata: ResourceMetadata | undefined,\n    readCallback: ReadResourceTemplateCallback\n  ): RegisteredResourceTemplate {\n    const registeredResourceTemplate: RegisteredResourceTemplate = {\n      resourceTemplate: template,\n      title,\n      metadata,\n      readCallback,\n      enabled: true,\n      disable: () =\u003E registeredResourceTemplate.update({ enabled: false }),\n      enable: () =\u003E registeredResourceTemplate.update({ enabled: true }),\n      remove: () =\u003E registeredResourceTemplate.update({ name: null }),\n      update: (updates) =\u003E {\n        if (typeof updates.name !== \"undefined\" && updates.name !== name) {\n          delete this._registeredResourceTemplates[name]\n          if (updates.name) this._registeredResourceTemplates[updates.name] = registeredResourceTemplate\n        }\n        if (typeof updates.title !== \"undefined\") registeredResourceTemplate.title = updates.title\n        if (typeof updates.template !== \"undefined\") registeredResourceTemplate.resourceTemplate = updates.template\n        if (typeof updates.metadata !== \"undefined\") registeredResourceTemplate.metadata = updates.metadata\n        if (typeof updates.callback !== \"undefined\") registeredResourceTemplate.readCallback = updates.callback\n        if (typeof updates.enabled !== \"undefined\") registeredResourceTemplate.enabled = updates.enabled\n        this.sendResourceListChanged()\n      },\n    };\n    this._registeredResourceTemplates[name] = registeredResourceTemplate;\n    return registeredResourceTemplate;\n  }\n\n  private _createRegisteredPrompt(\n    name: string,\n    title: string | undefined,\n    description: string | undefined,\n    argsSchema: PromptArgsRawShape | undefined,\n    callback: PromptCallback\u003CPromptArgsRawShape | undefined\u003E\n  ): RegisteredPrompt {\n    const registeredPrompt: RegisteredPrompt = {\n      title,\n      description,\n      argsSchema: argsSchema === undefined ? undefined : z.object(argsSchema),\n      callback,\n      enabled: true,\n      disable: () =\u003E registeredPrompt.update({ enabled: false }),\n      enable: () =\u003E registeredPrompt.update({ enabled: true }),\n      remove: () =\u003E registeredPrompt.update({ name: null }),\n      update: (updates) =\u003E {\n        if (typeof updates.name !== \"undefined\" && updates.name !== name) {\n          delete this._registeredPrompts[name]\n          if (updates.name) this._registeredPrompts[updates.name] = registeredPrompt\n        }\n        if (typeof updates.title !== \"undefined\") registeredPrompt.title = updates.title\n        if (typeof updates.description !== \"undefined\") registeredPrompt.description = updates.description\n        if (typeof updates.argsSchema !== \"undefined\") registeredPrompt.argsSchema = z.object(updates.argsSchema)\n        if (typeof updates.callback !== \"undefined\") registeredPrompt.callback = updates.callback\n        if (typeof updates.enabled !== \"undefined\") registeredPrompt.enabled = updates.enabled\n        this.sendPromptListChanged()\n      },\n    };\n    this._registeredPrompts[name] = registeredPrompt;\n    return registeredPrompt;\n  }\n\n  private _createRegisteredTool(\n    name: string,\n    title: string | undefined,\n    description: string | undefined,\n    inputSchema: ZodRawShape | undefined,\n    outputSchema: ZodRawShape | undefined,\n    annotations: ToolAnnotations | undefined,\n    callback: ToolCallback\u003CZodRawShape | undefined\u003E\n  ): RegisteredTool {\n    const registeredTool: RegisteredTool = {\n      title,\n      description,\n      inputSchema:\n        inputSchema === undefined ? undefined : z.object(inputSchema),\n      outputSchema:\n        outputSchema === undefined ? undefined : z.object(outputSchema),\n      annotations,\n      callback,\n      enabled: true,\n      disable: () =\u003E registeredTool.update({ enabled: false }),\n      enable: () =\u003E registeredTool.update({ enabled: true }),\n      remove: () =\u003E registeredTool.update({ name: null }),\n      update: (updates) =\u003E {\n        if (typeof updates.name !== \"undefined\" && updates.name !== name) {\n          delete this._registeredTools[name]\n          if (updates.name) this._registeredTools[updates.name] = registeredTool\n        }\n        if (typeof updates.title !== \"undefined\") registeredTool.title = updates.title\n        if (typeof updates.description !== \"undefined\") registeredTool.description = updates.description\n        if (typeof updates.paramsSchema !== \"undefined\") registeredTool.inputSchema = z.object(updates.paramsSchema)\n        if (typeof updates.callback !== \"undefined\") registeredTool.callback = updates.callback\n        if (typeof updates.annotations !== \"undefined\") registeredTool.annotations = updates.annotations\n        if (typeof updates.enabled !== \"undefined\") registeredTool.enabled = updates.enabled\n        this.sendToolListChanged()\n      },\n    };\n    this._registeredTools[name] = registeredTool;\n\n    this.setToolRequestHandlers();\n    this.sendToolListChanged()\n\n    return registeredTool\n  }\n\n  /**\n   * Registers a zero-argument tool `name`, which will run the given function when the client calls it.\n   */\n  tool(name: string, cb: ToolCallback): RegisteredTool;\n\n  /**\n   * Registers a zero-argument tool `name` (with a description) which will run the given function when the client calls it.\n   */\n  tool(name: string, description: string, cb: ToolCallback): RegisteredTool;\n\n  /**\n   * Registers a tool taking either a parameter schema for validation or annotations for additional metadata.\n   * This unified overload handles both `tool(name, paramsSchema, cb)` and `tool(name, annotations, cb)` cases.\n   * \n   * Note: We use a union type for the second parameter because TypeScript cannot reliably disambiguate\n   * between ToolAnnotations and ZodRawShape during overload resolution, as both are plain object types.\n   */\n  tool\u003CArgs extends ZodRawShape\u003E(\n    name: string,\n    paramsSchemaOrAnnotations: Args | ToolAnnotations,\n    cb: ToolCallback\u003CArgs\u003E,\n  ): RegisteredTool;\n\n  /**\n   * Registers a tool `name` (with a description) taking either parameter schema or annotations.\n   * This unified overload handles both `tool(name, description, paramsSchema, cb)` and \n   * `tool(name, description, annotations, cb)` cases.\n   * \n   * Note: We use a union type for the third parameter because TypeScript cannot reliably disambiguate\n   * between ToolAnnotations and ZodRawShape during overload resolution, as both are plain object types.\n   */\n  tool\u003CArgs extends ZodRawShape\u003E(\n    name: string,\n    description: string,\n    paramsSchemaOrAnnotations: Args | ToolAnnotations,\n    cb: ToolCallback\u003CArgs\u003E,\n  ): RegisteredTool;\n\n  /**\n   * Registers a tool with both parameter schema and annotations.\n   */\n  tool\u003CArgs extends ZodRawShape\u003E(\n    name: string,\n    paramsSchema: Args,\n    annotations: ToolAnnotations,\n    cb: ToolCallback\u003CArgs\u003E,\n  ): RegisteredTool;\n\n  /**\n   * Registers a tool with description, parameter schema, and annotations.\n   */\n  tool\u003CArgs extends ZodRawShape\u003E(\n    name: string,\n    description: string,\n    paramsSchema: Args,\n    annotations: ToolAnnotations,\n    cb: ToolCallback\u003CArgs\u003E,\n  ): RegisteredTool;\n\n\n  /**\n   * tool() implementation. Parses arguments passed to overrides defined above.\n   */\n  tool(name: string, ...rest: unknown[]): RegisteredTool {\n    if (this._registeredTools[name]) {\n      throw new Error(`Tool ${name} is already registered`);\n    }\n\n    let description: string | undefined;\n    let inputSchema: ZodRawShape | undefined;\n    let outputSchema: ZodRawShape | undefined;\n    let annotations: ToolAnnotations | undefined;\n\n    // Tool properties are passed as separate arguments, with omissions allowed.\n    // Support for this style is frozen as of protocol version 2025-03-26. Future additions\n    // to tool definition should *NOT* be added.\n\n    if (typeof rest[0] === \"string\") {\n      description = rest.shift() as string;\n    }\n\n    // Handle the different overload combinations\n    if (rest.length \u003E 1) {\n      // We have at least one more arg before the callback\n      const firstArg = rest[0];\n\n      if (isZodRawShape(firstArg)) {\n        // We have a params schema as the first arg\n        inputSchema = rest.shift() as ZodRawShape;\n\n        // Check if the next arg is potentially annotations\n        if (rest.length \u003E 1 && typeof rest[0] === \"object\" && rest[0] !== null && !(isZodRawShape(rest[0]))) {\n          // Case: tool(name, paramsSchema, annotations, cb)\n          // Or: tool(name, description, paramsSchema, annotations, cb)\n          annotations = rest.shift() as ToolAnnotations;\n        }\n      } else if (typeof firstArg === \"object\" && firstArg !== null) {\n        // Not a ZodRawShape, so must be annotations in this position\n        // Case: tool(name, annotations, cb)\n        // Or: tool(name, description, annotations, cb)\n        annotations = rest.shift() as ToolAnnotations;\n      }\n    }\n    const callback = rest[0] as ToolCallback\u003CZodRawShape | undefined\u003E;\n\n    return this._createRegisteredTool(name, undefined, description, inputSchema, outputSchema, annotations, callback)\n  }\n\n  /**\n   * Registers a tool with a config object and callback.\n   */\n  registerTool\u003CInputArgs extends ZodRawShape, OutputArgs extends ZodRawShape\u003E(\n    name: string,\n    config: {\n      title?: string;\n      description?: string;\n      inputSchema?: InputArgs;\n      outputSchema?: OutputArgs;\n      annotations?: ToolAnnotations;\n    },\n    cb: ToolCallback\u003CInputArgs\u003E\n  ): RegisteredTool {\n    if (this._registeredTools[name]) {\n      throw new Error(`Tool ${name} is already registered`);\n    }\n\n    const { title, description, inputSchema, outputSchema, annotations } = config;\n\n    return this._createRegisteredTool(\n      name,\n      title,\n      description,\n      inputSchema,\n      outputSchema,\n      annotations,\n      cb as ToolCallback\u003CZodRawShape | undefined\u003E\n    );\n  }\n\n  /**\n   * Registers a zero-argument prompt `name`, which will run the given function when the client calls it.\n   */\n  prompt(name: string, cb: PromptCallback): RegisteredPrompt;\n\n  /**\n   * Registers a zero-argument prompt `name` (with a description) which will run the given function when the client calls it.\n   */\n  prompt(name: string, description: string, cb: PromptCallback): RegisteredPrompt;\n\n  /**\n   * Registers a prompt `name` accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.\n   */\n  prompt\u003CArgs extends PromptArgsRawShape\u003E(\n    name: string,\n    argsSchema: Args,\n    cb: PromptCallback\u003CArgs\u003E,\n  ): RegisteredPrompt;\n\n  /**\n   * Registers a prompt `name` (with a description) accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.\n   */\n  prompt\u003CArgs extends PromptArgsRawShape\u003E(\n    name: string,\n    description: string,\n    argsSchema: Args,\n    cb: PromptCallback\u003CArgs\u003E,\n  ): RegisteredPrompt;\n\n  prompt(name: string, ...rest: unknown[]): RegisteredPrompt {\n    if (this._registeredPrompts[name]) {\n      throw new Error(`Prompt ${name} is already registered`);\n    }\n\n    let description: string | undefined;\n    if (typeof rest[0] === \"string\") {\n      description = rest.shift() as string;\n    }\n\n    let argsSchema: PromptArgsRawShape | undefined;\n    if (rest.length \u003E 1) {\n      argsSchema = rest.shift() as PromptArgsRawShape;\n    }\n\n    const cb = rest[0] as PromptCallback\u003CPromptArgsRawShape | undefined\u003E;\n    const registeredPrompt = this._createRegisteredPrompt(\n      name,\n      undefined,\n      description,\n      argsSchema,\n      cb\n    );\n\n    this.setPromptRequestHandlers();\n    this.sendPromptListChanged()\n\n    return registeredPrompt\n  }\n\n  /**\n   * Registers a prompt with a config object and callback.\n   */\n  registerPrompt\u003CArgs extends PromptArgsRawShape\u003E(\n    name: string,\n    config: {\n      title?: string;\n      description?: string;\n      argsSchema?: Args;\n    },\n    cb: PromptCallback\u003CArgs\u003E\n  ): RegisteredPrompt {\n    if (this._registeredPrompts[name]) {\n      throw new Error(`Prompt ${name} is already registered`);\n    }\n\n    const { title, description, argsSchema } = config;\n\n    const registeredPrompt = this._createRegisteredPrompt(\n      name,\n      title,\n      description,\n      argsSchema,\n      cb as PromptCallback\u003CPromptArgsRawShape | undefined\u003E\n    );\n\n    this.setPromptRequestHandlers();\n    this.sendPromptListChanged()\n\n    return registeredPrompt;\n  }\n\n  /**\n   * Checks if the server is connected to a transport.\n   * @returns True if the server is connected\n   */\n  isConnected() {\n    return this.server.transport !== undefined\n  }\n\n  /**\n   * Sends a resource list changed event to the client, if connected.\n   */\n  sendResourceListChanged() {\n    if (this.isConnected()) {\n      this.server.sendResourceListChanged();\n    }\n  }\n\n  /**\n   * Sends a tool list changed event to the client, if connected.\n   */\n  sendToolListChanged() {\n    if (this.isConnected()) {\n      this.server.sendToolListChanged();\n    }\n  }\n\n  /**\n   * Sends a prompt list changed event to the client, if connected.\n   */\n  sendPromptListChanged() {\n    if (this.isConnected()) {\n      this.server.sendPromptListChanged();\n    }\n  }\n}\n\n/**\n * A callback to complete one variable within a resource template's URI template.\n */\nexport type CompleteResourceTemplateCallback = (\n  value: string,\n  context?: {\n    arguments?: Record\u003Cstring, string\u003E;\n  },\n) =\u003E string[] | Promise\u003Cstring[]\u003E;\n\n/**\n * A resource template combines a URI pattern with optional functionality to enumerate\n * all resources matching that pattern.\n */\nexport class ResourceTemplate {\n  private _uriTemplate: UriTemplate;\n\n  constructor(\n    uriTemplate: string | UriTemplate,\n    private _callbacks: {\n      /**\n       * A callback to list all resources matching this template. This is required to specified, even if `undefined`, to avoid accidentally forgetting resource listing.\n       */\n      list: ListResourcesCallback | undefined;\n\n      /**\n       * An optional callback to autocomplete variables within the URI template. Useful for clients and users to discover possible values.\n       */\n      complete?: {\n        [variable: string]: CompleteResourceTemplateCallback;\n      };\n    },\n  ) {\n    this._uriTemplate =\n      typeof uriTemplate === \"string\"\n        ? new UriTemplate(uriTemplate)\n        : uriTemplate;\n  }\n\n  /**\n   * Gets the URI template pattern.\n   */\n  get uriTemplate(): UriTemplate {\n    return this._uriTemplate;\n  }\n\n  /**\n   * Gets the list callback, if one was provided.\n   */\n  get listCallback(): ListResourcesCallback | undefined {\n    return this._callbacks.list;\n  }\n\n  /**\n   * Gets the callback for completing a specific URI template variable, if one was provided.\n   */\n  completeCallback(\n    variable: string,\n  ): CompleteResourceTemplateCallback | undefined {\n    return this._callbacks.complete?.[variable];\n  }\n}\n\n/**\n * Callback for a tool handler registered with Server.tool().\n *\n * Parameters will include tool arguments, if applicable, as well as other request handler context.\n *\n * The callback should return:\n * - `structuredContent` if the tool has an outputSchema defined\n * - `content` if the tool does not have an outputSchema\n * - Both fields are optional but typically one should be provided\n */\nexport type ToolCallback\u003CArgs extends undefined | ZodRawShape = undefined\u003E =\n  Args extends ZodRawShape\n  ? (\n    args: z.objectOutputType\u003CArgs, ZodTypeAny\u003E,\n    extra: RequestHandlerExtra\u003CServerRequest, ServerNotification\u003E,\n  ) =\u003E CallToolResult | Promise\u003CCallToolResult\u003E\n  : (extra: RequestHandlerExtra\u003CServerRequest, ServerNotification\u003E) =\u003E CallToolResult | Promise\u003CCallToolResult\u003E;\n\nexport type RegisteredTool = {\n  title?: string;\n  description?: string;\n  inputSchema?: AnyZodObject;\n  outputSchema?: AnyZodObject;\n  annotations?: ToolAnnotations;\n  callback: ToolCallback\u003Cundefined | ZodRawShape\u003E;\n  enabled: boolean;\n  enable(): void;\n  disable(): void;\n  update\u003CInputArgs extends ZodRawShape, OutputArgs extends ZodRawShape\u003E(\n    updates: {\n      name?: string | null,\n      title?: string,\n      description?: string,\n      paramsSchema?: InputArgs,\n      outputSchema?: OutputArgs,\n      annotations?: ToolAnnotations,\n      callback?: ToolCallback\u003CInputArgs\u003E,\n      enabled?: boolean\n    }): void\n  remove(): void\n};\n\nconst EMPTY_OBJECT_JSON_SCHEMA = {\n  type: \"object\" as const,\n  properties: {},\n};\n\n// Helper to check if an object is a Zod schema (ZodRawShape)\nfunction isZodRawShape(obj: unknown): obj is ZodRawShape {\n  if (typeof obj !== \"object\" || obj === null) return false;\n\n  const isEmptyObject = Object.keys(obj).length === 0;\n\n  // Check if object is empty or at least one property is a ZodType instance\n  // Note: use heuristic check to avoid instanceof failure across different Zod versions\n  return isEmptyObject || Object.values(obj as object).some(isZodTypeLike);\n}\n\nfunction isZodTypeLike(value: unknown): value is ZodType {\n  return value !== null &&\n    typeof value === 'object' &&\n    'parse' in value && typeof value.parse === 'function' &&\n    'safeParse' in value && typeof value.safeParse === 'function';\n}\n\n/**\n * Additional, optional information for annotating a resource.\n */\nexport type ResourceMetadata = Omit\u003CResource, \"uri\" | \"name\"\u003E;\n\n/**\n * Callback to list all resources matching a given template.\n */\nexport type ListResourcesCallback = (\n  extra: RequestHandlerExtra\u003CServerRequest, ServerNotification\u003E,\n) =\u003E ListResourcesResult | Promise\u003CListResourcesResult\u003E;\n\n/**\n * Callback to read a resource at a given URI.\n */\nexport type ReadResourceCallback = (\n  uri: URL,\n  extra: RequestHandlerExtra\u003CServerRequest, ServerNotification\u003E,\n) =\u003E ReadResourceResult | Promise\u003CReadResourceResult\u003E;\n\nexport type RegisteredResource = {\n  name: string;\n  title?: string;\n  metadata?: ResourceMetadata;\n  readCallback: ReadResourceCallback;\n  enabled: boolean;\n  enable(): void;\n  disable(): void;\n  update(updates: { name?: string, title?: string, uri?: string | null, metadata?: ResourceMetadata, callback?: ReadResourceCallback, enabled?: boolean }): void\n  remove(): void\n};\n\n/**\n * Callback to read a resource at a given URI, following a filled-in URI template.\n */\nexport type ReadResourceTemplateCallback = (\n  uri: URL,\n  variables: Variables,\n  extra: RequestHandlerExtra\u003CServerRequest, ServerNotification\u003E,\n) =\u003E ReadResourceResult | Promise\u003CReadResourceResult\u003E;\n\nexport type RegisteredResourceTemplate = {\n  resourceTemplate: ResourceTemplate;\n  title?: string;\n  metadata?: ResourceMetadata;\n  readCallback: ReadResourceTemplateCallback;\n  enabled: boolean;\n  enable(): void;\n  disable(): void;\n  update(updates: { name?: string | null, title?: string, template?: ResourceTemplate, metadata?: ResourceMetadata, callback?: ReadResourceTemplateCallback, enabled?: boolean }): void\n  remove(): void\n};\n\ntype PromptArgsRawShape = {\n  [k: string]:\n  | ZodType\u003Cstring, ZodTypeDef, string\u003E\n  | ZodOptional\u003CZodType\u003Cstring, ZodTypeDef, string\u003E\u003E;\n};\n\nexport type PromptCallback\u003C\n  Args extends undefined | PromptArgsRawShape = undefined,\n\u003E = Args extends PromptArgsRawShape\n  ? (\n    args: z.objectOutputType\u003CArgs, ZodTypeAny\u003E,\n    extra: RequestHandlerExtra\u003CServerRequest, ServerNotification\u003E,\n  ) =\u003E GetPromptResult | Promise\u003CGetPromptResult\u003E\n  : (extra: RequestHandlerExtra\u003CServerRequest, ServerNotification\u003E) =\u003E GetPromptResult | Promise\u003CGetPromptResult\u003E;\n\nexport type RegisteredPrompt = {\n  title?: string;\n  description?: string;\n  argsSchema?: ZodObject\u003CPromptArgsRawShape\u003E;\n  callback: PromptCallback\u003Cundefined | PromptArgsRawShape\u003E;\n  enabled: boolean;\n  enable(): void;\n  disable(): void;\n  update\u003CArgs extends PromptArgsRawShape\u003E(updates: { name?: string | null, title?: string, description?: string, argsSchema?: Args, callback?: PromptCallback\u003CArgs\u003E, enabled?: boolean }): void\n  remove(): void\n};\n\nfunction promptArgumentsFromSchema(\n  schema: ZodObject\u003CPromptArgsRawShape\u003E,\n): PromptArgument[] {\n  return Object.entries(schema.shape).map(\n    ([name, field]): PromptArgument =\u003E ({\n      name,\n      description: field.description,\n      required: !field.isOptional(),\n    }),\n  );\n}\n\nfunction createCompletionResult(suggestions: string[]): CompleteResult {\n  return {\n    completion: {\n      values: suggestions.slice(0, 100),\n      total: suggestions.length,\n      hasMore: suggestions.length \u003E 100,\n    },\n  };\n}\n\nconst EMPTY_COMPLETION_RESULT: CompleteResult = {\n  completion: {\n    values: [],\n    hasMore: false,\n  },\n};\n",
      "hash": "7758153db0f39f538728215d52ed742f988bdf1c0ede96e6c9ecc9e3d001c4d7",
      "size": 41449
    },
    "/src/server/sse.test.ts": {
      "type": "content",
      "content": "import http from 'http'; \nimport { jest } from '@jest/globals';\nimport { SSEServerTransport } from './sse.js'; \nimport { McpServer } from './mcp.js';\nimport { createServer, type Server } from \"node:http\";\nimport { AddressInfo } from \"node:net\";\nimport { z } from 'zod';\nimport { CallToolResult, JSONRPCMessage } from 'src/types.js';\n\nconst createMockResponse = () =\u003E {\n  const res = {\n    writeHead: jest.fn\u003Chttp.ServerResponse['writeHead']\u003E().mockReturnThis(),\n    write: jest.fn\u003Chttp.ServerResponse['write']\u003E().mockReturnThis(),\n    on: jest.fn\u003Chttp.ServerResponse['on']\u003E().mockReturnThis(),\n    end: jest.fn\u003Chttp.ServerResponse['end']\u003E().mockReturnThis(),\n  };\n  \n  return res as unknown as jest.Mocked\u003Chttp.ServerResponse\u003E;\n};\n\nconst createMockRequest = ({ headers = {}, body }: { headers?: Record\u003Cstring, string\u003E, body?: string } = {}) =\u003E {\n  const mockReq = {\n    headers,\n    body: body ? body : undefined,\n    auth: {\n      token: 'test-token',\n    },\n    on: jest.fn\u003Chttp.IncomingMessage['on']\u003E().mockImplementation((event, listener) =\u003E {\n      const mockListener = listener as unknown as (...args: unknown[]) =\u003E void;\n      if (event === 'data') {\n        mockListener(Buffer.from(body || '') as unknown as Error);\n      }\n      if (event === 'error') {\n        mockListener(new Error('test'));\n      }\n      if (event === 'end') {\n        mockListener();\n      }\n      if (event === 'close') {\n        setTimeout(listener, 100);\n      }\n      return mockReq;\n    }),\n    listeners: jest.fn\u003Chttp.IncomingMessage['listeners']\u003E(),\n    removeListener: jest.fn\u003Chttp.IncomingMessage['removeListener']\u003E(),\n  } as unknown as http.IncomingMessage;\n\n  return mockReq;\n};\n\n/**\n * Helper to create and start test HTTP server with MCP setup\n */\nasync function createTestServerWithSse(args: {\n  mockRes: http.ServerResponse;\n}): Promise\u003C{\n  server: Server;\n  transport: SSEServerTransport;\n  mcpServer: McpServer;\n  baseUrl: URL;\n  sessionId: string\n  serverPort: number;\n}\u003E {\n  const mcpServer = new McpServer(\n    { name: \"test-server\", version: \"1.0.0\" },\n    { capabilities: { logging: {} } }\n  );\n\n  mcpServer.tool(\n    \"greet\",\n    \"A simple greeting tool\",\n    { name: z.string().describe(\"Name to greet\") },\n    async ({ name }): Promise\u003CCallToolResult\u003E =\u003E {\n      return { content: [{ type: \"text\", text: `Hello, ${name}!` }] };\n    }\n  );\n\n  const endpoint = '/messages';\n\n  const transport = new SSEServerTransport(endpoint, args.mockRes);\n  const sessionId = transport.sessionId;\n\n  await mcpServer.connect(transport);\n\n  const server = createServer(async (req, res) =\u003E {\n    try {\n        await transport.handlePostMessage(req, res);\n    } catch (error) {\n      console.error(\"Error handling request:\", error);\n      if (!res.headersSent) res.writeHead(500).end();\n    }\n  });\n\n  const baseUrl = await new Promise\u003CURL\u003E((resolve) =\u003E {\n    server.listen(0, \"127.0.0.1\", () =\u003E {\n      const addr = server.address() as AddressInfo;\n      resolve(new URL(`http://127.0.0.1:${addr.port}`));\n    });\n  });\n\n  const port = (server.address() as AddressInfo).port;\n\n  return { server, transport, mcpServer, baseUrl, sessionId, serverPort: port };\n}\n\nasync function readAllSSEEvents(response: Response): Promise\u003Cstring[]\u003E {\n  const reader = response.body?.getReader();\n  if (!reader) throw new Error('No readable stream');\n  \n  const events: string[] = [];\n  const decoder = new TextDecoder();\n  \n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      \n      if (value) {\n        events.push(decoder.decode(value));\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n  \n  return events;\n}\n\n/**\n * Helper to send JSON-RPC request\n */\nasync function sendSsePostRequest(baseUrl: URL, message: JSONRPCMessage | JSONRPCMessage[], sessionId?: string, extraHeaders?: Record\u003Cstring, string\u003E): Promise\u003CResponse\u003E {\n  const headers: Record\u003Cstring, string\u003E = {\n    \"Content-Type\": \"application/json\",\n    Accept: \"application/json, text/event-stream\",\n    ...extraHeaders\n  };\n\n  if (sessionId) {\n    baseUrl.searchParams.set('sessionId', sessionId);\n  }\n\n  return fetch(baseUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(message),\n  });\n}\n\ndescribe('SSEServerTransport', () =\u003E {\n\n  async function initializeServer(baseUrl: URL): Promise\u003Cvoid\u003E {\n    const response = await sendSsePostRequest(baseUrl, {\n      jsonrpc: \"2.0\",\n      method: \"initialize\",\n      params: {\n        clientInfo: { name: \"test-client\", version: \"1.0\" },\n        protocolVersion: \"2025-03-26\",\n        capabilities: {\n        },\n      },\n  \n      id: \"init-1\",\n    } as JSONRPCMessage);\n\n    expect(response.status).toBe(202);\n\n    const text = await readAllSSEEvents(response);\n\n    expect(text).toHaveLength(1);\n    expect(text[0]).toBe('Accepted');\n  }\n\n  describe('start method', () =\u003E { \n    it('should correctly append sessionId to a simple relative endpoint', async () =\u003E { \n      const mockRes = createMockResponse();\n      const endpoint = '/messages';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      const expectedSessionId = transport.sessionId;\n\n      await transport.start();\n\n      expect(mockRes.writeHead).toHaveBeenCalledWith(200, expect.any(Object));\n      expect(mockRes.write).toHaveBeenCalledTimes(1);\n      expect(mockRes.write).toHaveBeenCalledWith(\n        `event: endpoint\\ndata: /messages?sessionId=${expectedSessionId}\\n\\n`\n      );\n    });\n\n    it('should correctly append sessionId to an endpoint with existing query parameters', async () =\u003E { \n      const mockRes = createMockResponse();\n      const endpoint = '/messages?foo=bar&baz=qux';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      const expectedSessionId = transport.sessionId;\n\n      await transport.start();\n\n      expect(mockRes.writeHead).toHaveBeenCalledWith(200, expect.any(Object));\n      expect(mockRes.write).toHaveBeenCalledTimes(1);\n      expect(mockRes.write).toHaveBeenCalledWith(\n        `event: endpoint\\ndata: /messages?foo=bar&baz=qux&sessionId=${expectedSessionId}\\n\\n`\n      );\n    });\n\n    it('should correctly append sessionId to an endpoint with a hash fragment', async () =\u003E { \n      const mockRes = createMockResponse();\n      const endpoint = '/messages#section1';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      const expectedSessionId = transport.sessionId;\n\n      await transport.start();\n\n      expect(mockRes.writeHead).toHaveBeenCalledWith(200, expect.any(Object));\n      expect(mockRes.write).toHaveBeenCalledTimes(1);\n      expect(mockRes.write).toHaveBeenCalledWith(\n        `event: endpoint\\ndata: /messages?sessionId=${expectedSessionId}#section1\\n\\n`\n      );\n    });\n\n    it('should correctly append sessionId to an endpoint with query parameters and a hash fragment', async () =\u003E { \n      const mockRes = createMockResponse();\n      const endpoint = '/messages?key=value#section2';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      const expectedSessionId = transport.sessionId;\n\n      await transport.start();\n\n      expect(mockRes.writeHead).toHaveBeenCalledWith(200, expect.any(Object));\n      expect(mockRes.write).toHaveBeenCalledTimes(1);\n      expect(mockRes.write).toHaveBeenCalledWith(\n        `event: endpoint\\ndata: /messages?key=value&sessionId=${expectedSessionId}#section2\\n\\n`\n      );\n    });\n\n    it('should correctly handle the root path endpoint \"/\"', async () =\u003E { \n      const mockRes = createMockResponse();\n      const endpoint = '/';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      const expectedSessionId = transport.sessionId;\n\n      await transport.start();\n\n      expect(mockRes.writeHead).toHaveBeenCalledWith(200, expect.any(Object));\n      expect(mockRes.write).toHaveBeenCalledTimes(1);\n      expect(mockRes.write).toHaveBeenCalledWith(\n        `event: endpoint\\ndata: /?sessionId=${expectedSessionId}\\n\\n`\n      );\n    });\n\n    it('should correctly handle an empty string endpoint \"\"', async () =\u003E { \n      const mockRes = createMockResponse();\n      const endpoint = ''; \n      const transport = new SSEServerTransport(endpoint, mockRes);\n      const expectedSessionId = transport.sessionId;\n\n      await transport.start();\n\n      expect(mockRes.writeHead).toHaveBeenCalledWith(200, expect.any(Object));\n      expect(mockRes.write).toHaveBeenCalledTimes(1);\n      expect(mockRes.write).toHaveBeenCalledWith(\n        `event: endpoint\\ndata: /?sessionId=${expectedSessionId}\\n\\n`\n      );\n    });\n\n  /**\n   * Test: Tool With Request Info\n   */\n  it(\"should pass request info to tool callback\", async () =\u003E {\n    const mockRes = createMockResponse();\n    const { mcpServer, baseUrl, sessionId, serverPort } = await createTestServerWithSse({ mockRes });\n    await initializeServer(baseUrl);\n\n    mcpServer.tool(\n      \"test-request-info\",\n      \"A simple test tool with request info\",\n      { name: z.string().describe(\"Name to greet\") },\n      async ({ name }, { requestInfo }): Promise\u003CCallToolResult\u003E =\u003E {\n        return { content: [{ type: \"text\", text: `Hello, ${name}!` }, { type: \"text\", text: `${JSON.stringify(requestInfo)}` }] };\n      }\n    );\n   \n    const toolCallMessage: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/call\",\n      params: {\n        name: \"test-request-info\",\n        arguments: {\n          name: \"Test User\",\n        },\n      },\n      id: \"call-1\",\n    };\n\n    const response = await sendSsePostRequest(baseUrl, toolCallMessage, sessionId);\n\n    expect(response.status).toBe(202);\n\n    expect(mockRes.write).toHaveBeenCalledWith(`event: endpoint\\ndata: /messages?sessionId=${sessionId}\\n\\n`);\n\n    const expectedMessage = {\n      result: {\n        content: [\n          {\n            type: \"text\",\n            text: \"Hello, Test User!\",\n          },\n          {\n            type: \"text\",\n            text: JSON.stringify({\n              headers: {\n                host: `127.0.0.1:${serverPort}`,\n                connection: 'keep-alive',\n                'content-type': 'application/json',\n                accept: 'application/json, text/event-stream',\n                'accept-language': '*',\n                'sec-fetch-mode': 'cors',\n                'user-agent': 'node',\n                'accept-encoding': 'gzip, deflate',\n                'content-length': '124'\n              },\n            })\n          },\n        ],\n      },\n      jsonrpc: \"2.0\",\n      id: \"call-1\",\n    };\n    expect(mockRes.write).toHaveBeenCalledWith(`event: message\\ndata: ${JSON.stringify(expectedMessage)}\\n\\n`);\n  });\n  });\n\n  describe('handlePostMessage method', () =\u003E {\n    it('should return 500 if server has not started', async () =\u003E {\n      const mockReq = createMockRequest();\n      const mockRes = createMockResponse();\n      const endpoint = '/messages';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n\n      const error = 'SSE connection not established';\n      await expect(transport.handlePostMessage(mockReq, mockRes))\n        .rejects.toThrow(error);\n      expect(mockRes.writeHead).toHaveBeenCalledWith(500);\n      expect(mockRes.end).toHaveBeenCalledWith(error);\n    });\n\n    it('should return 400 if content-type is not application/json', async () =\u003E {\n      const mockReq = createMockRequest({ headers: { 'content-type': 'text/plain' } });\n      const mockRes = createMockResponse();\n      const endpoint = '/messages';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      await transport.start();\n\n      transport.onerror = jest.fn();\n      const error = 'Unsupported content-type: text/plain';\n      await expect(transport.handlePostMessage(mockReq, mockRes))\n        .resolves.toBe(undefined);\n      expect(mockRes.writeHead).toHaveBeenCalledWith(400);\n      expect(mockRes.end).toHaveBeenCalledWith(expect.stringContaining(error));\n      expect(transport.onerror).toHaveBeenCalledWith(new Error(error));\n    });\n\n    it('should return 400 if message has not a valid schema', async () =\u003E {\n      const invalidMessage = JSON.stringify({\n        // missing jsonrpc field\n        method: 'call',\n        params: [1, 2, 3],\n        id: 1,\n      })\n      const mockReq = createMockRequest({\n        headers: { 'content-type': 'application/json' },\n        body: invalidMessage,\n      });\n      const mockRes = createMockResponse();\n      const endpoint = '/messages';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      await transport.start();\n\n      transport.onmessage = jest.fn();\n      await transport.handlePostMessage(mockReq, mockRes);\n      expect(mockRes.writeHead).toHaveBeenCalledWith(400);\n      expect(transport.onmessage).not.toHaveBeenCalled();\n      expect(mockRes.end).toHaveBeenCalledWith(`Invalid message: ${invalidMessage}`);\n    });\n\n    it('should return 202 if message has a valid schema', async () =\u003E {\n      const validMessage = JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: 'call',\n        params: {\n          a: 1,\n          b: 2,\n          c: 3,\n        },\n        id: 1\n      })\n      const mockReq = createMockRequest({\n        headers: { 'content-type': 'application/json' },\n        body: validMessage,\n      });\n      const mockRes = createMockResponse();\n      const endpoint = '/messages';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      await transport.start();\n\n      transport.onmessage = jest.fn();\n      await transport.handlePostMessage(mockReq, mockRes);\n      expect(mockRes.writeHead).toHaveBeenCalledWith(202);\n      expect(mockRes.end).toHaveBeenCalledWith('Accepted');\n      expect(transport.onmessage).toHaveBeenCalledWith({\n        jsonrpc: \"2.0\",\n        method: 'call',\n        params: {\n          a: 1,\n          b: 2,\n          c: 3,\n        },\n        id: 1\n      }, {\n        authInfo: {\n          token: 'test-token',\n        },\n        requestInfo: {\n          headers: {\n            'content-type': 'application/json',\n          },\n        },\n      });\n    });\n  });\n\n  describe('close method', () =\u003E {\n    it('should call onclose', async () =\u003E {\n      const mockRes = createMockResponse();\n      const endpoint = '/messages';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      await transport.start();\n      transport.onclose = jest.fn();\n      await transport.close();\n      expect(transport.onclose).toHaveBeenCalled();\n    });\n  });\n\n  describe('send method', () =\u003E {\n    it('should call onsend', async () =\u003E {\n      const mockRes = createMockResponse();\n      const endpoint = '/messages';\n      const transport = new SSEServerTransport(endpoint, mockRes);\n      await transport.start();\n      expect(mockRes.write).toHaveBeenCalledTimes(1);\n      expect(mockRes.write).toHaveBeenCalledWith(\n        expect.stringContaining('event: endpoint'));\n      expect(mockRes.write).toHaveBeenCalledWith(\n        expect.stringContaining(`data: /messages?sessionId=${transport.sessionId}`));\n    });\n  });\n\n  describe('DNS rebinding protection', () =\u003E {\n    beforeEach(() =\u003E {\n      jest.clearAllMocks();\n    });\n\n    describe('Host header validation', () =\u003E {\n      it('should accept requests with allowed host headers', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes, {\n          allowedHosts: ['localhost:3000', 'example.com'],\n          enableDnsRebindingProtection: true,\n        });\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            host: 'localhost:3000',\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');\n      });\n\n      it('should reject requests with disallowed host headers', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes, {\n          allowedHosts: ['localhost:3000'],\n          enableDnsRebindingProtection: true,\n        });\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            host: 'evil.com',\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(403);\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Invalid Host header: evil.com');\n      });\n\n      it('should reject requests without host header when allowedHosts is configured', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes, {\n          allowedHosts: ['localhost:3000'],\n          enableDnsRebindingProtection: true,\n        });\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(403);\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Invalid Host header: undefined');\n      });\n    });\n\n    describe('Origin header validation', () =\u003E {\n      it('should accept requests with allowed origin headers', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes, {\n          allowedOrigins: ['http://localhost:3000', 'https://example.com'],\n          enableDnsRebindingProtection: true,\n        });\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            origin: 'http://localhost:3000',\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');\n      });\n\n      it('should reject requests with disallowed origin headers', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes, {\n          allowedOrigins: ['http://localhost:3000'],\n          enableDnsRebindingProtection: true,\n        });\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            origin: 'http://evil.com',\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(403);\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Invalid Origin header: http://evil.com');\n      });\n    });\n\n    describe('Content-Type validation', () =\u003E {\n      it('should accept requests with application/json content-type', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes);\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');\n      });\n\n      it('should accept requests with application/json with charset', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes);\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            'content-type': 'application/json; charset=utf-8',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');\n      });\n\n      it('should reject requests with non-application/json content-type when protection is enabled', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes);\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            'content-type': 'text/plain',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(400);\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Error: Unsupported content-type: text/plain');\n      });\n    });\n\n    describe('enableDnsRebindingProtection option', () =\u003E {\n      it('should skip all validations when enableDnsRebindingProtection is false', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes, {\n          allowedHosts: ['localhost:3000'],\n          allowedOrigins: ['http://localhost:3000'],\n          enableDnsRebindingProtection: false,\n        });\n        await transport.start();\n\n        const mockReq = createMockRequest({\n          headers: {\n            host: 'evil.com',\n            origin: 'http://evil.com',\n            'content-type': 'text/plain',\n          }\n        });\n        const mockHandleRes = createMockResponse();\n\n        await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });\n\n        // Should pass even with invalid headers because protection is disabled\n        expect(mockHandleRes.writeHead).toHaveBeenCalledWith(400);\n        // The error should be from content-type parsing, not DNS rebinding protection\n        expect(mockHandleRes.end).toHaveBeenCalledWith('Error: Unsupported content-type: text/plain');\n      });\n    });\n\n    describe('Combined validations', () =\u003E {\n      it('should validate both host and origin when both are configured', async () =\u003E {\n        const mockRes = createMockResponse();\n        const transport = new SSEServerTransport('/messages', mockRes, {\n          allowedHosts: ['localhost:3000'],\n          allowedOrigins: ['http://localhost:3000'],\n          enableDnsRebindingProtection: true,\n        });\n        await transport.start();\n\n        // Valid host, invalid origin\n        const mockReq1 = createMockRequest({\n          headers: {\n            host: 'localhost:3000',\n            origin: 'http://evil.com',\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes1 = createMockResponse();\n\n        await transport.handlePostMessage(mockReq1, mockHandleRes1, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes1.writeHead).toHaveBeenCalledWith(403);\n        expect(mockHandleRes1.end).toHaveBeenCalledWith('Invalid Origin header: http://evil.com');\n\n        // Invalid host, valid origin\n        const mockReq2 = createMockRequest({\n          headers: {\n            host: 'evil.com',\n            origin: 'http://localhost:3000',\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes2 = createMockResponse();\n\n        await transport.handlePostMessage(mockReq2, mockHandleRes2, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes2.writeHead).toHaveBeenCalledWith(403);\n        expect(mockHandleRes2.end).toHaveBeenCalledWith('Invalid Host header: evil.com');\n\n        // Both valid\n        const mockReq3 = createMockRequest({\n          headers: {\n            host: 'localhost:3000',\n            origin: 'http://localhost:3000',\n            'content-type': 'application/json',\n          }\n        });\n        const mockHandleRes3 = createMockResponse();\n\n        await transport.handlePostMessage(mockReq3, mockHandleRes3, { jsonrpc: '2.0', method: 'test' });\n\n        expect(mockHandleRes3.writeHead).toHaveBeenCalledWith(202);\n        expect(mockHandleRes3.end).toHaveBeenCalledWith('Accepted');\n      });\n    });\n  });\n});\n",
      "hash": "e55b54e3ac27e6c3d88e299d5a12d1b7fb9bbbab26982b4531f785385eed09b1",
      "size": 24816
    },
    "/src/server/sse.ts": {
      "type": "content",
      "content": "import { randomUUID } from \"node:crypto\";\nimport { IncomingMessage, ServerResponse } from \"node:http\";\nimport { Transport } from \"../shared/transport.js\";\nimport { JSONRPCMessage, JSONRPCMessageSchema, MessageExtraInfo, RequestInfo } from \"../types.js\";\nimport getRawBody from \"raw-body\";\nimport contentType from \"content-type\";\nimport { AuthInfo } from \"./auth/types.js\";\nimport { URL } from 'url';\n\nconst MAXIMUM_MESSAGE_SIZE = \"4mb\";\n\n/**\n * Configuration options for SSEServerTransport.\n */\nexport interface SSEServerTransportOptions {\n  /**\n   * List of allowed host header values for DNS rebinding protection.\n   * If not specified, host validation is disabled.\n   */\n  allowedHosts?: string[];\n  \n  /**\n   * List of allowed origin header values for DNS rebinding protection.\n   * If not specified, origin validation is disabled.\n   */\n  allowedOrigins?: string[];\n  \n  /**\n   * Enable DNS rebinding protection (requires allowedHosts and/or allowedOrigins to be configured).\n   * Default is false for backwards compatibility.\n   */\n  enableDnsRebindingProtection?: boolean;\n}\n\n/**\n * Server transport for SSE: this will send messages over an SSE connection and receive messages from HTTP POST requests.\n *\n * This transport is only available in Node.js environments.\n */\nexport class SSEServerTransport implements Transport {\n  private _sseResponse?: ServerResponse;\n  private _sessionId: string;\n  private _options: SSEServerTransportOptions;\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) =\u003E void;\n\n  /**\n   * Creates a new SSE server transport, which will direct the client to POST messages to the relative or absolute URL identified by `_endpoint`.\n   */\n  constructor(\n    private _endpoint: string,\n    private res: ServerResponse,\n    options?: SSEServerTransportOptions,\n  ) {\n    this._sessionId = randomUUID();\n    this._options = options || {enableDnsRebindingProtection: false};\n  }\n\n  /**\n   * Validates request headers for DNS rebinding protection.\n   * @returns Error message if validation fails, undefined if validation passes.\n   */\n  private validateRequestHeaders(req: IncomingMessage): string | undefined {\n    // Skip validation if protection is not enabled\n    if (!this._options.enableDnsRebindingProtection) {\n      return undefined;\n    }\n\n    // Validate Host header if allowedHosts is configured\n    if (this._options.allowedHosts && this._options.allowedHosts.length \u003E 0) {\n      const hostHeader = req.headers.host;\n      if (!hostHeader || !this._options.allowedHosts.includes(hostHeader)) {\n        return `Invalid Host header: ${hostHeader}`;\n      }\n    }\n\n    // Validate Origin header if allowedOrigins is configured\n    if (this._options.allowedOrigins && this._options.allowedOrigins.length \u003E 0) {\n      const originHeader = req.headers.origin;\n      if (!originHeader || !this._options.allowedOrigins.includes(originHeader)) {\n        return `Invalid Origin header: ${originHeader}`;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Handles the initial SSE connection request.\n   *\n   * This should be called when a GET request is made to establish the SSE stream.\n   */\n  async start(): Promise\u003Cvoid\u003E {\n    if (this._sseResponse) {\n      throw new Error(\n        \"SSEServerTransport already started! If using Server class, note that connect() calls start() automatically.\",\n      );\n    }\n\n    this.res.writeHead(200, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache, no-transform\",\n      Connection: \"keep-alive\",\n    });\n\n    // Send the endpoint event\n    // Use a dummy base URL because this._endpoint is relative.\n    // This allows using URL/URLSearchParams for robust parameter handling.\n    const dummyBase = 'http://localhost'; // Any valid base works\n    const endpointUrl = new URL(this._endpoint, dummyBase);\n    endpointUrl.searchParams.set('sessionId', this._sessionId);\n\n    // Reconstruct the relative URL string (pathname + search + hash)\n    const relativeUrlWithSession = endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;\n\n    this.res.write(\n      `event: endpoint\\ndata: ${relativeUrlWithSession}\\n\\n`,\n    );\n\n    this._sseResponse = this.res;\n    this.res.on(\"close\", () =\u003E {\n      this._sseResponse = undefined;\n      this.onclose?.();\n    });\n  }\n\n  /**\n   * Handles incoming POST messages.\n   *\n   * This should be called when a POST request is made to send a message to the server.\n   */\n  async handlePostMessage(\n    req: IncomingMessage & { auth?: AuthInfo },\n    res: ServerResponse,\n    parsedBody?: unknown,\n  ): Promise\u003Cvoid\u003E {\n    if (!this._sseResponse) {\n      const message = \"SSE connection not established\";\n      res.writeHead(500).end(message);\n      throw new Error(message);\n    }\n\n    // Validate request headers for DNS rebinding protection\n    const validationError = this.validateRequestHeaders(req);\n    if (validationError) {\n      res.writeHead(403).end(validationError);\n      this.onerror?.(new Error(validationError));\n      return;\n    }\n\n    const authInfo: AuthInfo | undefined = req.auth;\n    const requestInfo: RequestInfo = { headers: req.headers };\n\n    let body: string | unknown;\n    try {\n      const ct = contentType.parse(req.headers[\"content-type\"] ?? \"\");\n      if (ct.type !== \"application/json\") {\n        throw new Error(`Unsupported content-type: ${ct.type}`);\n      }\n\n      body = parsedBody ?? await getRawBody(req, {\n        limit: MAXIMUM_MESSAGE_SIZE,\n        encoding: ct.parameters.charset ?? \"utf-8\",\n      });\n    } catch (error) {\n      res.writeHead(400).end(String(error));\n      this.onerror?.(error as Error);\n      return;\n    }\n\n    try {\n      await this.handleMessage(typeof body === 'string' ? JSON.parse(body) : body, { requestInfo, authInfo });\n    } catch {\n      res.writeHead(400).end(`Invalid message: ${body}`);\n      return;\n    }\n\n    res.writeHead(202).end(\"Accepted\");\n  }\n\n  /**\n   * Handle a client message, regardless of how it arrived. This can be used to inform the server of messages that arrive via a means different than HTTP POST.\n   */\n  async handleMessage(message: unknown, extra?: MessageExtraInfo): Promise\u003Cvoid\u003E {\n    let parsedMessage: JSONRPCMessage;\n    try {\n      parsedMessage = JSONRPCMessageSchema.parse(message);\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n\n    this.onmessage?.(parsedMessage, extra);\n  }\n\n  async close(): Promise\u003Cvoid\u003E {\n    this._sseResponse?.end();\n    this._sseResponse = undefined;\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise\u003Cvoid\u003E {\n    if (!this._sseResponse) {\n      throw new Error(\"Not connected\");\n    }\n\n    this._sseResponse.write(\n      `event: message\\ndata: ${JSON.stringify(message)}\\n\\n`,\n    );\n  }\n\n  /**\n   * Returns the session ID for this transport.\n   *\n   * This can be used to route incoming POST requests.\n   */\n  get sessionId(): string {\n    return this._sessionId;\n  }\n}\n",
      "hash": "8296e8d21a5612c20a01a4acb37eb708e4344515f75ed71453c5951bc3f09e5c",
      "size": 6986
    },
    "/src/server/stdio.test.ts": {
      "type": "content",
      "content": "import { Readable, Writable } from \"node:stream\";\nimport { ReadBuffer, serializeMessage } from \"../shared/stdio.js\";\nimport { JSONRPCMessage } from \"../types.js\";\nimport { StdioServerTransport } from \"./stdio.js\";\n\nlet input: Readable;\nlet outputBuffer: ReadBuffer;\nlet output: Writable;\n\nbeforeEach(() =\u003E {\n  input = new Readable({\n    // We'll use input.push() instead.\n    read: () =\u003E {},\n  });\n\n  outputBuffer = new ReadBuffer();\n  output = new Writable({\n    write(chunk, encoding, callback) {\n      outputBuffer.append(chunk);\n      callback();\n    },\n  });\n});\n\ntest(\"should start then close cleanly\", async () =\u003E {\n  const server = new StdioServerTransport(input, output);\n  server.onerror = (error) =\u003E {\n    throw error;\n  };\n\n  let didClose = false;\n  server.onclose = () =\u003E {\n    didClose = true;\n  };\n\n  await server.start();\n  expect(didClose).toBeFalsy();\n  await server.close();\n  expect(didClose).toBeTruthy();\n});\n\ntest(\"should not read until started\", async () =\u003E {\n  const server = new StdioServerTransport(input, output);\n  server.onerror = (error) =\u003E {\n    throw error;\n  };\n\n  let didRead = false;\n  const readMessage = new Promise((resolve) =\u003E {\n    server.onmessage = (message) =\u003E {\n      didRead = true;\n      resolve(message);\n    };\n  });\n\n  const message: JSONRPCMessage = {\n    jsonrpc: \"2.0\",\n    id: 1,\n    method: \"ping\",\n  };\n  input.push(serializeMessage(message));\n\n  expect(didRead).toBeFalsy();\n  await server.start();\n  expect(await readMessage).toEqual(message);\n});\n\ntest(\"should read multiple messages\", async () =\u003E {\n  const server = new StdioServerTransport(input, output);\n  server.onerror = (error) =\u003E {\n    throw error;\n  };\n\n  const messages: JSONRPCMessage[] = [\n    {\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"ping\",\n    },\n    {\n      jsonrpc: \"2.0\",\n      method: \"notifications/initialized\",\n    },\n  ];\n\n  const readMessages: JSONRPCMessage[] = [];\n  const finished = new Promise\u003Cvoid\u003E((resolve) =\u003E {\n    server.onmessage = (message) =\u003E {\n      readMessages.push(message);\n      if (JSON.stringify(message) === JSON.stringify(messages[1])) {\n        resolve();\n      }\n    };\n  });\n\n  input.push(serializeMessage(messages[0]));\n  input.push(serializeMessage(messages[1]));\n\n  await server.start();\n  await finished;\n  expect(readMessages).toEqual(messages);\n});\n",
      "hash": "c951c9ae2fc26882bd6da8f6e1c3ef449f3792ceababc6d819e8543542c6ef36",
      "size": 2323
    },
    "/src/server/stdio.ts": {
      "type": "content",
      "content": "import process from \"node:process\";\nimport { Readable, Writable } from \"node:stream\";\nimport { ReadBuffer, serializeMessage } from \"../shared/stdio.js\";\nimport { JSONRPCMessage } from \"../types.js\";\nimport { Transport } from \"../shared/transport.js\";\n\n/**\n * Server transport for stdio: this communicates with a MCP client by reading from the current process' stdin and writing to stdout.\n *\n * This transport is only available in Node.js environments.\n */\nexport class StdioServerTransport implements Transport {\n  private _readBuffer: ReadBuffer = new ReadBuffer();\n  private _started = false;\n\n  constructor(\n    private _stdin: Readable = process.stdin,\n    private _stdout: Writable = process.stdout,\n  ) {}\n\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: JSONRPCMessage) =\u003E void;\n\n  // Arrow functions to bind `this` properly, while maintaining function identity.\n  _ondata = (chunk: Buffer) =\u003E {\n    this._readBuffer.append(chunk);\n    this.processReadBuffer();\n  };\n  _onerror = (error: Error) =\u003E {\n    this.onerror?.(error);\n  };\n\n  /**\n   * Starts listening for messages on stdin.\n   */\n  async start(): Promise\u003Cvoid\u003E {\n    if (this._started) {\n      throw new Error(\n        \"StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.\",\n      );\n    }\n\n    this._started = true;\n    this._stdin.on(\"data\", this._ondata);\n    this._stdin.on(\"error\", this._onerror);\n  }\n\n  private processReadBuffer() {\n    while (true) {\n      try {\n        const message = this._readBuffer.readMessage();\n        if (message === null) {\n          break;\n        }\n\n        this.onmessage?.(message);\n      } catch (error) {\n        this.onerror?.(error as Error);\n      }\n    }\n  }\n\n  async close(): Promise\u003Cvoid\u003E {\n    // Remove our event listeners first\n    this._stdin.off(\"data\", this._ondata);\n    this._stdin.off(\"error\", this._onerror);\n\n    // Check if we were the only data listener\n    const remainingDataListeners = this._stdin.listenerCount('data');\n    if (remainingDataListeners === 0) {\n      // Only pause stdin if we were the only listener\n      // This prevents interfering with other parts of the application that might be using stdin\n      this._stdin.pause();\n    }\n    \n    // Clear the buffer and notify closure\n    this._readBuffer.clear();\n    this.onclose?.();\n  }\n\n  send(message: JSONRPCMessage): Promise\u003Cvoid\u003E {\n    return new Promise((resolve) =\u003E {\n      const json = serializeMessage(message);\n      if (this._stdout.write(json)) {\n        resolve();\n      } else {\n        this._stdout.once(\"drain\", resolve);\n      }\n    });\n  }\n}\n",
      "hash": "096ceb5d54cc9fdcee1633f0a470902c88b38b5e8470bf8c4c1f4770f269fa1e",
      "size": 2647
    },
    "/src/server/streamableHttp.test.ts": {
      "type": "content",
      "content": "import { createServer, type Server, IncomingMessage, ServerResponse } from \"node:http\";\nimport { createServer as netCreateServer, AddressInfo } from \"node:net\";\nimport { randomUUID } from \"node:crypto\";\nimport { EventStore, StreamableHTTPServerTransport, EventId, StreamId } from \"./streamableHttp.js\";\nimport { McpServer } from \"./mcp.js\";\nimport { CallToolResult, JSONRPCMessage } from \"../types.js\";\nimport { z } from \"zod\";\nimport { AuthInfo } from \"./auth/types.js\";\n\nasync function getFreePort() {\n  return new Promise(res =\u003E {\n    const srv = netCreateServer();\n    srv.listen(0, () =\u003E {\n      const address = srv.address()!\n      if (typeof address === \"string\") {\n        throw new Error(\"Unexpected address type: \" + typeof address);\n      }\n      const port = (address as AddressInfo).port;\n      srv.close((_err) =\u003E res(port))\n    });\n  })\n}\n\n/**\n * Test server configuration for StreamableHTTPServerTransport tests\n */\ninterface TestServerConfig {\n  sessionIdGenerator: (() =\u003E string) | undefined;\n  enableJsonResponse?: boolean;\n  customRequestHandler?: (req: IncomingMessage, res: ServerResponse, parsedBody?: unknown) =\u003E Promise\u003Cvoid\u003E;\n  eventStore?: EventStore;\n  onsessioninitialized?: (sessionId: string) =\u003E void | Promise\u003Cvoid\u003E;\n  onsessionclosed?: (sessionId: string) =\u003E void | Promise\u003Cvoid\u003E;\n}\n\n/**\n * Helper to create and start test HTTP server with MCP setup\n */\nasync function createTestServer(config: TestServerConfig = { sessionIdGenerator: (() =\u003E randomUUID()) }): Promise\u003C{\n  server: Server;\n  transport: StreamableHTTPServerTransport;\n  mcpServer: McpServer;\n  baseUrl: URL;\n}\u003E {\n  const mcpServer = new McpServer(\n    { name: \"test-server\", version: \"1.0.0\" },\n    { capabilities: { logging: {} } }\n  );\n\n  mcpServer.tool(\n    \"greet\",\n    \"A simple greeting tool\",\n    { name: z.string().describe(\"Name to greet\") },\n    async ({ name }): Promise\u003CCallToolResult\u003E =\u003E {\n      return { content: [{ type: \"text\", text: `Hello, ${name}!` }] };\n    }\n  );\n\n  const transport = new StreamableHTTPServerTransport({\n    sessionIdGenerator: config.sessionIdGenerator,\n    enableJsonResponse: config.enableJsonResponse ?? false,\n    eventStore: config.eventStore,\n    onsessioninitialized: config.onsessioninitialized,\n    onsessionclosed: config.onsessionclosed\n  });\n\n  await mcpServer.connect(transport);\n\n  const server = createServer(async (req, res) =\u003E {\n    try {\n      if (config.customRequestHandler) {\n        await config.customRequestHandler(req, res);\n      } else {\n        await transport.handleRequest(req, res);\n      }\n    } catch (error) {\n      console.error(\"Error handling request:\", error);\n      if (!res.headersSent) res.writeHead(500).end();\n    }\n  });\n\n  const baseUrl = await new Promise\u003CURL\u003E((resolve) =\u003E {\n    server.listen(0, \"127.0.0.1\", () =\u003E {\n      const addr = server.address() as AddressInfo;\n      resolve(new URL(`http://127.0.0.1:${addr.port}`));\n    });\n  });\n\n  return { server, transport, mcpServer, baseUrl };\n}\n\n/**\n * Helper to create and start authenticated test HTTP server with MCP setup\n */\nasync function createTestAuthServer(config: TestServerConfig = { sessionIdGenerator: (() =\u003E randomUUID()) }): Promise\u003C{\n  server: Server;\n  transport: StreamableHTTPServerTransport;\n  mcpServer: McpServer;\n  baseUrl: URL;\n}\u003E {\n  const mcpServer = new McpServer(\n    { name: \"test-server\", version: \"1.0.0\" },\n    { capabilities: { logging: {} } }\n  );\n\n  mcpServer.tool(\n    \"profile\",\n    \"A user profile data tool\",\n    { active: z.boolean().describe(\"Profile status\") },\n    async ({ active }, { authInfo }): Promise\u003CCallToolResult\u003E =\u003E {\n      return { content: [{ type: \"text\", text: `${active ? 'Active' : 'Inactive'} profile from token: ${authInfo?.token}!` }] };\n    }\n  );\n\n  const transport = new StreamableHTTPServerTransport({\n    sessionIdGenerator: config.sessionIdGenerator,\n    enableJsonResponse: config.enableJsonResponse ?? false,\n    eventStore: config.eventStore,\n    onsessioninitialized: config.onsessioninitialized,\n    onsessionclosed: config.onsessionclosed\n  });\n\n  await mcpServer.connect(transport);\n\n  const server = createServer(async (req: IncomingMessage & { auth?: AuthInfo }, res) =\u003E {\n    try {\n      if (config.customRequestHandler) {\n        await config.customRequestHandler(req, res);\n      } else {\n        req.auth = { token: req.headers[\"authorization\"]?.split(\" \")[1] } as AuthInfo;\n        await transport.handleRequest(req, res);\n      }\n    } catch (error) {\n      console.error(\"Error handling request:\", error);\n      if (!res.headersSent) res.writeHead(500).end();\n    }\n  });\n\n  const baseUrl = await new Promise\u003CURL\u003E((resolve) =\u003E {\n    server.listen(0, \"127.0.0.1\", () =\u003E {\n      const addr = server.address() as AddressInfo;\n      resolve(new URL(`http://127.0.0.1:${addr.port}`));\n    });\n  });\n\n  return { server, transport, mcpServer, baseUrl };\n}\n\n/**\n * Helper to stop test server\n */\nasync function stopTestServer({ server, transport }: { server: Server; transport: StreamableHTTPServerTransport }): Promise\u003Cvoid\u003E {\n  // First close the transport to ensure all SSE streams are closed\n  await transport.close();\n\n  // Close the server without waiting indefinitely\n  server.close();\n}\n\n/**\n * Common test messages\n */\nconst TEST_MESSAGES = {\n  initialize: {\n    jsonrpc: \"2.0\",\n    method: \"initialize\",\n    params: {\n      clientInfo: { name: \"test-client\", version: \"1.0\" },\n      protocolVersion: \"2025-03-26\",\n      capabilities: {\n      },\n    },\n\n    id: \"init-1\",\n  } as JSONRPCMessage,\n\n  toolsList: {\n    jsonrpc: \"2.0\",\n    method: \"tools/list\",\n    params: {},\n    id: \"tools-1\",\n  } as JSONRPCMessage\n};\n\n/**\n * Helper to extract text from SSE response\n * Note: Can only be called once per response stream. For multiple reads,\n * get the reader manually and read multiple times.\n */\nasync function readSSEEvent(response: Response): Promise\u003Cstring\u003E {\n  const reader = response.body?.getReader();\n  const { value } = await reader!.read();\n  return new TextDecoder().decode(value);\n}\n\n/**\n * Helper to send JSON-RPC request\n */\nasync function sendPostRequest(baseUrl: URL, message: JSONRPCMessage | JSONRPCMessage[], sessionId?: string, extraHeaders?: Record\u003Cstring, string\u003E): Promise\u003CResponse\u003E {\n  const headers: Record\u003Cstring, string\u003E = {\n    \"Content-Type\": \"application/json\",\n    Accept: \"application/json, text/event-stream\",\n    ...extraHeaders\n  };\n\n  if (sessionId) {\n    headers[\"mcp-session-id\"] = sessionId;\n    // After initialization, include the protocol version header\n    headers[\"mcp-protocol-version\"] = \"2025-03-26\";\n  }\n\n  return fetch(baseUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(message),\n  });\n}\n\nfunction expectErrorResponse(data: unknown, expectedCode: number, expectedMessagePattern: RegExp): void {\n  expect(data).toMatchObject({\n    jsonrpc: \"2.0\",\n    error: expect.objectContaining({\n      code: expectedCode,\n      message: expect.stringMatching(expectedMessagePattern),\n    }),\n  });\n}\n\ndescribe(\"StreamableHTTPServerTransport\", () =\u003E {\n  let server: Server;\n  let mcpServer: McpServer;\n  let transport: StreamableHTTPServerTransport;\n  let baseUrl: URL;\n  let sessionId: string;\n\n  beforeEach(async () =\u003E {\n    const result = await createTestServer();\n    server = result.server;\n    transport = result.transport;\n    mcpServer = result.mcpServer;\n    baseUrl = result.baseUrl;\n  });\n\n  afterEach(async () =\u003E {\n    await stopTestServer({ server, transport });\n  });\n\n  async function initializeServer(): Promise\u003Cstring\u003E {\n    const response = await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n\n    expect(response.status).toBe(200);\n    const newSessionId = response.headers.get(\"mcp-session-id\");\n    expect(newSessionId).toBeDefined();\n    return newSessionId as string;\n  }\n\n  it(\"should initialize server and generate session ID\", async () =\u003E {\n    const response = await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n\n    expect(response.status).toBe(200);\n    expect(response.headers.get(\"content-type\")).toBe(\"text/event-stream\");\n    expect(response.headers.get(\"mcp-session-id\")).toBeDefined();\n  });\n\n  it(\"should reject second initialization request\", async () =\u003E {\n    // First initialize\n    const sessionId = await initializeServer();\n    expect(sessionId).toBeDefined();\n\n    // Try second initialize\n    const secondInitMessage = {\n      ...TEST_MESSAGES.initialize,\n      id: \"second-init\"\n    };\n\n    const response = await sendPostRequest(baseUrl, secondInitMessage);\n\n    expect(response.status).toBe(400);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32600, /Server already initialized/);\n  });\n\n  it(\"should reject batch initialize request\", async () =\u003E {\n    const batchInitMessages: JSONRPCMessage[] = [\n      TEST_MESSAGES.initialize,\n      {\n        jsonrpc: \"2.0\",\n        method: \"initialize\",\n        params: {\n          clientInfo: { name: \"test-client-2\", version: \"1.0\" },\n          protocolVersion: \"2025-03-26\",\n        },\n        id: \"init-2\",\n      }\n    ];\n\n    const response = await sendPostRequest(baseUrl, batchInitMessages);\n\n    expect(response.status).toBe(400);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32600, /Only one initialization request is allowed/);\n  });\n\n  it(\"should handle post requests via sse response correctly\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    const response = await sendPostRequest(baseUrl, TEST_MESSAGES.toolsList, sessionId);\n\n    expect(response.status).toBe(200);\n\n    // Read the SSE stream for the response\n    const text = await readSSEEvent(response);\n\n    // Parse the SSE event\n    const eventLines = text.split(\"\\n\");\n    const dataLine = eventLines.find(line =\u003E line.startsWith(\"data:\"));\n    expect(dataLine).toBeDefined();\n\n    const eventData = JSON.parse(dataLine!.substring(5));\n    expect(eventData).toMatchObject({\n      jsonrpc: \"2.0\",\n      result: expect.objectContaining({\n        tools: expect.arrayContaining([\n          expect.objectContaining({\n            name: \"greet\",\n            description: \"A simple greeting tool\",\n          }),\n        ]),\n      }),\n      id: \"tools-1\",\n    });\n  });\n\n  it(\"should call a tool and return the result\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    const toolCallMessage: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/call\",\n      params: {\n        name: \"greet\",\n        arguments: {\n          name: \"Test User\",\n        },\n      },\n      id: \"call-1\",\n    };\n\n    const response = await sendPostRequest(baseUrl, toolCallMessage, sessionId);\n    expect(response.status).toBe(200);\n\n    const text = await readSSEEvent(response);\n    const eventLines = text.split(\"\\n\");\n    const dataLine = eventLines.find(line =\u003E line.startsWith(\"data:\"));\n    expect(dataLine).toBeDefined();\n\n    const eventData = JSON.parse(dataLine!.substring(5));\n    expect(eventData).toMatchObject({\n      jsonrpc: \"2.0\",\n      result: {\n        content: [\n          {\n            type: \"text\",\n            text: \"Hello, Test User!\",\n          },\n        ],\n      },\n      id: \"call-1\",\n    });\n  });\n\n  /***\n   * Test: Tool With Request Info\n   */\n  it(\"should pass request info to tool callback\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    mcpServer.tool(\n      \"test-request-info\",\n      \"A simple test tool with request info\",\n      { name: z.string().describe(\"Name to greet\") },\n      async ({ name }, { requestInfo }): Promise\u003CCallToolResult\u003E =\u003E {\n        return { content: [{ type: \"text\", text: `Hello, ${name}!` }, { type: \"text\", text: `${JSON.stringify(requestInfo)}` }] };\n      }\n    );\n\n    const toolCallMessage: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/call\",\n      params: {\n        name: \"test-request-info\",\n        arguments: {\n          name: \"Test User\",\n        },\n      },\n      id: \"call-1\",\n    };\n\n    const response = await sendPostRequest(baseUrl, toolCallMessage, sessionId);\n    expect(response.status).toBe(200);\n\n    const text = await readSSEEvent(response);\n    const eventLines = text.split(\"\\n\");\n    const dataLine = eventLines.find(line =\u003E line.startsWith(\"data:\"));\n    expect(dataLine).toBeDefined();\n\n    const eventData = JSON.parse(dataLine!.substring(5));\n\n    expect(eventData).toMatchObject({\n      jsonrpc: \"2.0\",\n      result: {\n        content: [\n          { type: \"text\", text: \"Hello, Test User!\" },\n          { type: \"text\", text: expect.any(String) }\n        ],\n      },\n      id: \"call-1\",\n    });\n\n    const requestInfo = JSON.parse(eventData.result.content[1].text);\n    expect(requestInfo).toMatchObject({\n      headers: {\n        'content-type': 'application/json',\n        accept: 'application/json, text/event-stream',\n        connection: 'keep-alive',\n        'mcp-session-id': sessionId,\n        'accept-language': '*',\n        'user-agent': expect.any(String),\n        'accept-encoding': expect.any(String),\n        'content-length': expect.any(String),\n      },\n    });\n  });\n\n  it(\"should reject requests without a valid session ID\", async () =\u003E {\n    const response = await sendPostRequest(baseUrl, TEST_MESSAGES.toolsList);\n\n    expect(response.status).toBe(400);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32000, /Bad Request/);\n    expect(errorData.id).toBeNull();\n  });\n\n  it(\"should reject invalid session ID\", async () =\u003E {\n    // First initialize to be in valid state\n    await initializeServer();\n\n    // Now try with invalid session ID\n    const response = await sendPostRequest(baseUrl, TEST_MESSAGES.toolsList, \"invalid-session-id\");\n\n    expect(response.status).toBe(404);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32001, /Session not found/);\n  });\n\n  it(\"should establish standalone SSE stream and receive server-initiated messages\", async () =\u003E {\n    // First initialize to get a session ID\n    sessionId = await initializeServer();\n\n    // Open a standalone SSE stream  \n    const sseResponse = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-session-id\": sessionId,\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(sseResponse.status).toBe(200);\n    expect(sseResponse.headers.get(\"content-type\")).toBe(\"text/event-stream\");\n\n\n    // Send a notification (server-initiated message) that should appear on SSE stream\n    const notification: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"notifications/message\",\n      params: { level: \"info\", data: \"Test notification\" },\n    };\n\n    // Send the notification via transport\n    await transport.send(notification);\n\n    // Read from the stream and verify we got the notification\n    const text = await readSSEEvent(sseResponse);\n\n    const eventLines = text.split(\"\\n\");\n    const dataLine = eventLines.find(line =\u003E line.startsWith(\"data:\"));\n    expect(dataLine).toBeDefined();\n\n    const eventData = JSON.parse(dataLine!.substring(5));\n    expect(eventData).toMatchObject({\n      jsonrpc: \"2.0\",\n      method: \"notifications/message\",\n      params: { level: \"info\", data: \"Test notification\" },\n    });\n  });\n\n  it(\"should not close GET SSE stream after sending multiple server notifications\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Open a standalone SSE stream\n    const sseResponse = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-session-id\": sessionId,\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(sseResponse.status).toBe(200);\n    const reader = sseResponse.body?.getReader();\n\n    // Send multiple notifications\n    const notification1: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"notifications/message\",\n      params: { level: \"info\", data: \"First notification\" }\n    };\n\n    // Just send one and verify it comes through - then the stream should stay open\n    await transport.send(notification1);\n\n    const { value, done } = await reader!.read();\n    const text = new TextDecoder().decode(value);\n    expect(text).toContain(\"First notification\");\n    expect(done).toBe(false);  // Stream should still be open\n  });\n\n  it(\"should reject second SSE stream for the same session\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Open first SSE stream\n    const firstStream = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-session-id\": sessionId,\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(firstStream.status).toBe(200);\n\n    // Try to open a second SSE stream with the same session ID\n    const secondStream = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-session-id\": sessionId,\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    // Should be rejected\n    expect(secondStream.status).toBe(409); // Conflict\n    const errorData = await secondStream.json();\n    expectErrorResponse(errorData, -32000, /Only one SSE stream is allowed per session/);\n  });\n\n  it(\"should reject GET requests without Accept: text/event-stream header\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Try GET without proper Accept header\n    const response = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\",\n        \"mcp-session-id\": sessionId,\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(response.status).toBe(406);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32000, /Client must accept text\\/event-stream/);\n  });\n\n  it(\"should reject POST requests without proper Accept header\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Try POST without Accept: text/event-stream\n    const response = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",  // Missing text/event-stream\n        \"mcp-session-id\": sessionId,\n      },\n      body: JSON.stringify(TEST_MESSAGES.toolsList),\n    });\n\n    expect(response.status).toBe(406);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32000, /Client must accept both application\\/json and text\\/event-stream/);\n  });\n\n  it(\"should reject unsupported Content-Type\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Try POST with text/plain Content-Type\n    const response = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"text/plain\",\n        Accept: \"application/json, text/event-stream\",\n        \"mcp-session-id\": sessionId,\n      },\n      body: \"This is plain text\",\n    });\n\n    expect(response.status).toBe(415);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32000, /Content-Type must be application\\/json/);\n  });\n\n  it(\"should handle JSON-RPC batch notification messages with 202 response\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Send batch of notifications (no IDs)\n    const batchNotifications: JSONRPCMessage[] = [\n      { jsonrpc: \"2.0\", method: \"someNotification1\", params: {} },\n      { jsonrpc: \"2.0\", method: \"someNotification2\", params: {} },\n    ];\n    const response = await sendPostRequest(baseUrl, batchNotifications, sessionId);\n\n    expect(response.status).toBe(202);\n  });\n\n  it(\"should handle batch request messages with SSE stream for responses\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Send batch of requests\n    const batchRequests: JSONRPCMessage[] = [\n      { jsonrpc: \"2.0\", method: \"tools/list\", params: {}, id: \"req-1\" },\n      { jsonrpc: \"2.0\", method: \"tools/call\", params: { name: \"greet\", arguments: { name: \"BatchUser\" } }, id: \"req-2\" },\n    ];\n    const response = await sendPostRequest(baseUrl, batchRequests, sessionId);\n\n    expect(response.status).toBe(200);\n    expect(response.headers.get(\"content-type\")).toBe(\"text/event-stream\");\n\n    const reader = response.body?.getReader();\n\n    // The responses may come in any order or together in one chunk\n    const { value } = await reader!.read();\n    const text = new TextDecoder().decode(value);\n\n    // Check that both responses were sent on the same stream\n    expect(text).toContain('\"id\":\"req-1\"');\n    expect(text).toContain('\"tools\"'); // tools/list result\n    expect(text).toContain('\"id\":\"req-2\"');\n    expect(text).toContain('Hello, BatchUser'); // tools/call result\n  });\n\n  it(\"should properly handle invalid JSON data\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Send invalid JSON\n    const response = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json, text/event-stream\",\n        \"mcp-session-id\": sessionId,\n      },\n      body: \"This is not valid JSON\",\n    });\n\n    expect(response.status).toBe(400);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32700, /Parse error/);\n  });\n\n  it(\"should return 400 error for invalid JSON-RPC messages\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Invalid JSON-RPC (missing required jsonrpc version)\n    const invalidMessage = { method: \"tools/list\", params: {}, id: 1 }; // missing jsonrpc version\n    const response = await sendPostRequest(baseUrl, invalidMessage as JSONRPCMessage, sessionId);\n\n    expect(response.status).toBe(400);\n    const errorData = await response.json();\n    expect(errorData).toMatchObject({\n      jsonrpc: \"2.0\",\n      error: expect.anything(),\n    });\n  });\n\n  it(\"should reject requests to uninitialized server\", async () =\u003E {\n    // Create a new HTTP server and transport without initializing\n    const { server: uninitializedServer, transport: uninitializedTransport, baseUrl: uninitializedUrl } = await createTestServer();\n    // Transport not used in test but needed for cleanup\n\n    // No initialization, just send a request directly\n    const uninitializedMessage: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/list\",\n      params: {},\n      id: \"uninitialized-test\",\n    };\n\n    // Send a request to uninitialized server\n    const response = await sendPostRequest(uninitializedUrl, uninitializedMessage, \"any-session-id\");\n\n    expect(response.status).toBe(400);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32000, /Server not initialized/);\n\n    // Cleanup\n    await stopTestServer({ server: uninitializedServer, transport: uninitializedTransport });\n  });\n\n  it(\"should send response messages to the connection that sent the request\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    const message1: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/list\",\n      params: {},\n      id: \"req-1\"\n    };\n\n    const message2: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/call\",\n      params: {\n        name: \"greet\",\n        arguments: { name: \"Connection2\" }\n      },\n      id: \"req-2\"\n    };\n\n    // Make two concurrent fetch connections for different requests\n    const req1 = sendPostRequest(baseUrl, message1, sessionId);\n    const req2 = sendPostRequest(baseUrl, message2, sessionId);\n\n    // Get both responses\n    const [response1, response2] = await Promise.all([req1, req2]);\n    const reader1 = response1.body?.getReader();\n    const reader2 = response2.body?.getReader();\n\n    // Read responses from each stream (requires each receives its specific response)\n    const { value: value1 } = await reader1!.read();\n    const text1 = new TextDecoder().decode(value1);\n    expect(text1).toContain('\"id\":\"req-1\"');\n    expect(text1).toContain('\"tools\"');  // tools/list result\n\n    const { value: value2 } = await reader2!.read();\n    const text2 = new TextDecoder().decode(value2);\n    expect(text2).toContain('\"id\":\"req-2\"');\n    expect(text2).toContain('Hello, Connection2');  // tools/call result\n  });\n\n  it(\"should keep stream open after sending server notifications\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    // Open a standalone SSE stream\n    const sseResponse = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-session-id\": sessionId,\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    // Send several server-initiated notifications\n    await transport.send({\n      jsonrpc: \"2.0\",\n      method: \"notifications/message\",\n      params: { level: \"info\", data: \"First notification\" },\n    });\n\n    await transport.send({\n      jsonrpc: \"2.0\",\n      method: \"notifications/message\",\n      params: { level: \"info\", data: \"Second notification\" },\n    });\n\n    // Stream should still be open - it should not close after sending notifications\n    expect(sseResponse.bodyUsed).toBe(false);\n  });\n\n  // The current implementation will close the entire transport for DELETE\n  // Creating a temporary transport/server where we don't care if it gets closed\n  it(\"should properly handle DELETE requests and close session\", async () =\u003E {\n    // Setup a temporary server for this test\n    const tempResult = await createTestServer();\n    const tempServer = tempResult.server;\n    const tempUrl = tempResult.baseUrl;\n\n    // Initialize to get a session ID\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    const tempSessionId = initResponse.headers.get(\"mcp-session-id\");\n\n    // Now DELETE the session\n    const deleteResponse = await fetch(tempUrl, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": tempSessionId || \"\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse.status).toBe(200);\n\n    // Clean up - don't wait indefinitely for server close\n    tempServer.close();\n  });\n\n  it(\"should reject DELETE requests with invalid session ID\", async () =\u003E {\n    // Initialize the server first to activate it\n    sessionId = await initializeServer();\n\n    // Try to delete with invalid session ID\n    const response = await fetch(baseUrl, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": \"invalid-session-id\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(response.status).toBe(404);\n    const errorData = await response.json();\n    expectErrorResponse(errorData, -32001, /Session not found/);\n  });\n\n  describe(\"protocol version header validation\", () =\u003E {\n    it(\"should accept requests with matching protocol version\", async () =\u003E {\n      sessionId = await initializeServer();\n\n      // Send request with matching protocol version\n      const response = await sendPostRequest(baseUrl, TEST_MESSAGES.toolsList, sessionId);\n\n      expect(response.status).toBe(200);\n    });\n\n    it(\"should accept requests without protocol version header\", async () =\u003E {\n      sessionId = await initializeServer();\n\n      // Send request without protocol version header\n      const response = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n          \"mcp-session-id\": sessionId,\n          // No mcp-protocol-version header\n        },\n        body: JSON.stringify(TEST_MESSAGES.toolsList),\n      });\n\n      expect(response.status).toBe(200);\n    });\n\n    it(\"should reject requests with unsupported protocol version\", async () =\u003E {\n      sessionId = await initializeServer();\n\n      // Send request with unsupported protocol version\n      const response = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n          \"mcp-session-id\": sessionId,\n          \"mcp-protocol-version\": \"1999-01-01\", // Unsupported version\n        },\n        body: JSON.stringify(TEST_MESSAGES.toolsList),\n      });\n\n      expect(response.status).toBe(400);\n      const errorData = await response.json();\n      expectErrorResponse(errorData, -32000, /Bad Request: Unsupported protocol version \\(supported versions: .+\\)/);\n    });\n\n    it(\"should accept when protocol version differs from negotiated version\", async () =\u003E {\n      sessionId = await initializeServer();\n\n      // Spy on console.warn to verify warning is logged\n      const warnSpy = jest.spyOn(console, 'warn').mockImplementation();\n\n      // Send request with different but supported protocol version\n      const response = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n          \"mcp-session-id\": sessionId,\n          \"mcp-protocol-version\": \"2024-11-05\", // Different but supported version\n        },\n        body: JSON.stringify(TEST_MESSAGES.toolsList),\n      });\n\n      // Request should still succeed\n      expect(response.status).toBe(200);\n\n      warnSpy.mockRestore();\n    });\n\n    it(\"should handle protocol version validation for GET requests\", async () =\u003E {\n      sessionId = await initializeServer();\n\n      // GET request with unsupported protocol version\n      const response = await fetch(baseUrl, {\n        method: \"GET\",\n        headers: {\n          Accept: \"text/event-stream\",\n          \"mcp-session-id\": sessionId,\n          \"mcp-protocol-version\": \"invalid-version\",\n        },\n      });\n\n      expect(response.status).toBe(400);\n      const errorData = await response.json();\n      expectErrorResponse(errorData, -32000, /Bad Request: Unsupported protocol version \\(supported versions: .+\\)/);\n    });\n\n    it(\"should handle protocol version validation for DELETE requests\", async () =\u003E {\n      sessionId = await initializeServer();\n\n      // DELETE request with unsupported protocol version\n      const response = await fetch(baseUrl, {\n        method: \"DELETE\",\n        headers: {\n          \"mcp-session-id\": sessionId,\n          \"mcp-protocol-version\": \"invalid-version\",\n        },\n      });\n\n      expect(response.status).toBe(400);\n      const errorData = await response.json();\n      expectErrorResponse(errorData, -32000, /Bad Request: Unsupported protocol version \\(supported versions: .+\\)/);\n    });\n  });\n});\n\ndescribe(\"StreamableHTTPServerTransport with AuthInfo\", () =\u003E {\n  let server: Server;\n  let transport: StreamableHTTPServerTransport;\n  let baseUrl: URL;\n  let sessionId: string;\n\n  beforeEach(async () =\u003E {\n    const result = await createTestAuthServer();\n    server = result.server;\n    transport = result.transport;\n    baseUrl = result.baseUrl;\n  });\n\n  afterEach(async () =\u003E {\n    await stopTestServer({ server, transport });\n  });\n\n  async function initializeServer(): Promise\u003Cstring\u003E {\n    const response = await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n\n    expect(response.status).toBe(200);\n    const newSessionId = response.headers.get(\"mcp-session-id\");\n    expect(newSessionId).toBeDefined();\n    return newSessionId as string;\n  }\n\n  it(\"should call a tool with authInfo\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    const toolCallMessage: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/call\",\n      params: {\n        name: \"profile\",\n        arguments: { active: true },\n      },\n      id: \"call-1\",\n    };\n\n    const response = await sendPostRequest(baseUrl, toolCallMessage, sessionId, { 'authorization': 'Bearer test-token' });\n    expect(response.status).toBe(200);\n\n    const text = await readSSEEvent(response);\n    const eventLines = text.split(\"\\n\");\n    const dataLine = eventLines.find(line =\u003E line.startsWith(\"data:\"));\n    expect(dataLine).toBeDefined();\n\n    const eventData = JSON.parse(dataLine!.substring(5));\n    expect(eventData).toMatchObject({\n      jsonrpc: \"2.0\",\n      result: {\n        content: [\n          {\n            type: \"text\",\n            text: \"Active profile from token: test-token!\",\n          },\n        ],\n      },\n      id: \"call-1\",\n    });\n  });\n\n  it(\"should calls tool without authInfo when it is optional\", async () =\u003E {\n    sessionId = await initializeServer();\n\n    const toolCallMessage: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/call\",\n      params: {\n        name: \"profile\",\n        arguments: { active: false },\n      },\n      id: \"call-1\",\n    };\n\n    const response = await sendPostRequest(baseUrl, toolCallMessage, sessionId);\n    expect(response.status).toBe(200);\n\n    const text = await readSSEEvent(response);\n    const eventLines = text.split(\"\\n\");\n    const dataLine = eventLines.find(line =\u003E line.startsWith(\"data:\"));\n    expect(dataLine).toBeDefined();\n\n    const eventData = JSON.parse(dataLine!.substring(5));\n    expect(eventData).toMatchObject({\n      jsonrpc: \"2.0\",\n      result: {\n        content: [\n          {\n            type: \"text\",\n            text: \"Inactive profile from token: undefined!\",\n          },\n        ],\n      },\n      id: \"call-1\",\n    });\n  });\n});\n\n// Test JSON Response Mode\ndescribe(\"StreamableHTTPServerTransport with JSON Response Mode\", () =\u003E {\n  let server: Server;\n  let transport: StreamableHTTPServerTransport;\n  let baseUrl: URL;\n  let sessionId: string;\n\n  beforeEach(async () =\u003E {\n    const result = await createTestServer({ sessionIdGenerator: (() =\u003E randomUUID()), enableJsonResponse: true });\n    server = result.server;\n    transport = result.transport;\n    baseUrl = result.baseUrl;\n\n    // Initialize and get session ID\n    const initResponse = await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n\n    sessionId = initResponse.headers.get(\"mcp-session-id\") as string;\n  });\n\n  afterEach(async () =\u003E {\n    await stopTestServer({ server, transport });\n  });\n\n  it(\"should return JSON response for a single request\", async () =\u003E {\n    const toolsListMessage: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"tools/list\",\n      params: {},\n      id: \"json-req-1\",\n    };\n\n    const response = await sendPostRequest(baseUrl, toolsListMessage, sessionId);\n\n    expect(response.status).toBe(200);\n    expect(response.headers.get(\"content-type\")).toBe(\"application/json\");\n\n    const result = await response.json();\n    expect(result).toMatchObject({\n      jsonrpc: \"2.0\",\n      result: expect.objectContaining({\n        tools: expect.arrayContaining([\n          expect.objectContaining({ name: \"greet\" })\n        ])\n      }),\n      id: \"json-req-1\"\n    });\n  });\n\n  it(\"should return JSON response for batch requests\", async () =\u003E {\n    const batchMessages: JSONRPCMessage[] = [\n      { jsonrpc: \"2.0\", method: \"tools/list\", params: {}, id: \"batch-1\" },\n      { jsonrpc: \"2.0\", method: \"tools/call\", params: { name: \"greet\", arguments: { name: \"JSON\" } }, id: \"batch-2\" }\n    ];\n\n    const response = await sendPostRequest(baseUrl, batchMessages, sessionId);\n\n    expect(response.status).toBe(200);\n    expect(response.headers.get(\"content-type\")).toBe(\"application/json\");\n\n    const results = await response.json();\n    expect(Array.isArray(results)).toBe(true);\n    expect(results).toHaveLength(2);\n\n    // Batch responses can come in any order\n    const listResponse = results.find((r: { id?: string }) =\u003E r.id === \"batch-1\");\n    const callResponse = results.find((r: { id?: string }) =\u003E r.id === \"batch-2\");\n\n    expect(listResponse).toEqual(expect.objectContaining({\n      jsonrpc: \"2.0\",\n      id: \"batch-1\",\n      result: expect.objectContaining({\n        tools: expect.arrayContaining([\n          expect.objectContaining({ name: \"greet\" })\n        ])\n      })\n    }));\n\n    expect(callResponse).toEqual(expect.objectContaining({\n      jsonrpc: \"2.0\",\n      id: \"batch-2\",\n      result: expect.objectContaining({\n        content: expect.arrayContaining([\n          expect.objectContaining({ type: \"text\", text: \"Hello, JSON!\" })\n        ])\n      })\n    }));\n  });\n});\n\n// Test pre-parsed body handling\ndescribe(\"StreamableHTTPServerTransport with pre-parsed body\", () =\u003E {\n  let server: Server;\n  let transport: StreamableHTTPServerTransport;\n  let baseUrl: URL;\n  let sessionId: string;\n  let parsedBody: unknown = null;\n\n  beforeEach(async () =\u003E {\n    const result = await createTestServer({\n      customRequestHandler: async (req, res) =\u003E {\n        try {\n          if (parsedBody !== null) {\n            await transport.handleRequest(req, res, parsedBody);\n            parsedBody = null; // Reset after use\n          } else {\n            await transport.handleRequest(req, res);\n          }\n        } catch (error) {\n          console.error(\"Error handling request:\", error);\n          if (!res.headersSent) res.writeHead(500).end();\n        }\n      },\n      sessionIdGenerator: (() =\u003E randomUUID())\n    });\n\n    server = result.server;\n    transport = result.transport;\n    baseUrl = result.baseUrl;\n\n    // Initialize and get session ID\n    const initResponse = await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n    sessionId = initResponse.headers.get(\"mcp-session-id\") as string;\n  });\n\n  afterEach(async () =\u003E {\n    await stopTestServer({ server, transport });\n  });\n\n  it(\"should accept pre-parsed request body\", async () =\u003E {\n    // Set up the pre-parsed body\n    parsedBody = {\n      jsonrpc: \"2.0\",\n      method: \"tools/list\",\n      params: {},\n      id: \"preparsed-1\",\n    };\n\n    // Send an empty body since we'll use pre-parsed body  \n    const response = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json, text/event-stream\",\n        \"mcp-session-id\": sessionId,\n      },\n      // Empty body - we're testing pre-parsed body\n      body: \"\"\n    });\n\n    expect(response.status).toBe(200);\n    expect(response.headers.get(\"content-type\")).toBe(\"text/event-stream\");\n\n    const reader = response.body?.getReader();\n    const { value } = await reader!.read();\n    const text = new TextDecoder().decode(value);\n\n    // Verify the response used the pre-parsed body\n    expect(text).toContain('\"id\":\"preparsed-1\"');\n    expect(text).toContain('\"tools\"');\n  });\n\n  it(\"should handle pre-parsed batch messages\", async () =\u003E {\n    parsedBody = [\n      { jsonrpc: \"2.0\", method: \"tools/list\", params: {}, id: \"batch-1\" },\n      { jsonrpc: \"2.0\", method: \"tools/call\", params: { name: \"greet\", arguments: { name: \"PreParsed\" } }, id: \"batch-2\" }\n    ];\n\n    const response = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json, text/event-stream\",\n        \"mcp-session-id\": sessionId,\n      },\n      body: \"\" // Empty as we're using pre-parsed\n    });\n\n    expect(response.status).toBe(200);\n\n    const reader = response.body?.getReader();\n    const { value } = await reader!.read();\n    const text = new TextDecoder().decode(value);\n\n    expect(text).toContain('\"id\":\"batch-1\"');\n    expect(text).toContain('\"tools\"');\n  });\n\n  it(\"should prefer pre-parsed body over request body\", async () =\u003E {\n    // Set pre-parsed to tools/list\n    parsedBody = {\n      jsonrpc: \"2.0\",\n      method: \"tools/list\",\n      params: {},\n      id: \"preparsed-wins\",\n    };\n\n    // Send actual body with tools/call - should be ignored\n    const response = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json, text/event-stream\",\n        \"mcp-session-id\": sessionId,\n      },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: \"tools/call\",\n        params: { name: \"greet\", arguments: { name: \"Ignored\" } },\n        id: \"ignored-id\"\n      })\n    });\n\n    expect(response.status).toBe(200);\n\n    const reader = response.body?.getReader();\n    const { value } = await reader!.read();\n    const text = new TextDecoder().decode(value);\n\n    // Should have processed the pre-parsed body\n    expect(text).toContain('\"id\":\"preparsed-wins\"');\n    expect(text).toContain('\"tools\"');\n    expect(text).not.toContain('\"ignored-id\"');\n  });\n});\n\n// Test resumability support\ndescribe(\"StreamableHTTPServerTransport with resumability\", () =\u003E {\n  let server: Server;\n  let transport: StreamableHTTPServerTransport;\n  let baseUrl: URL;\n  let sessionId: string;\n  let mcpServer: McpServer;\n  const storedEvents: Map\u003Cstring, { eventId: string, message: JSONRPCMessage }\u003E = new Map();\n\n  // Simple implementation of EventStore\n  const eventStore: EventStore = {\n\n    async storeEvent(streamId: string, message: JSONRPCMessage): Promise\u003Cstring\u003E {\n      const eventId = `${streamId}_${randomUUID()}`;\n      storedEvents.set(eventId, { eventId, message });\n      return eventId;\n    },\n\n    async replayEventsAfter(lastEventId: EventId, { send }: {\n      send: (eventId: EventId, message: JSONRPCMessage) =\u003E Promise\u003Cvoid\u003E\n    }): Promise\u003CStreamId\u003E {\n      const streamId = lastEventId.split('_')[0];\n      // Extract stream ID from the event ID\n      // For test simplicity, just return all events with matching streamId that aren't the lastEventId\n      for (const [eventId, { message }] of storedEvents.entries()) {\n        if (eventId.startsWith(streamId) && eventId !== lastEventId) {\n          await send(eventId, message);\n        }\n      }\n      return streamId;\n    },\n  };\n\n  beforeEach(async () =\u003E {\n    storedEvents.clear();\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      eventStore\n    });\n\n    server = result.server;\n    transport = result.transport;\n    baseUrl = result.baseUrl;\n    mcpServer = result.mcpServer;\n\n    // Verify resumability is enabled on the transport\n    expect((transport)['_eventStore']).toBeDefined();\n\n    // Initialize the server\n    const initResponse = await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n    sessionId = initResponse.headers.get(\"mcp-session-id\") as string;\n    expect(sessionId).toBeDefined();\n  });\n\n  afterEach(async () =\u003E {\n    await stopTestServer({ server, transport });\n    storedEvents.clear();\n  });\n\n  it(\"should store and include event IDs in server SSE messages\", async () =\u003E {\n    // Open a standalone SSE stream\n    const sseResponse = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-session-id\": sessionId,\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(sseResponse.status).toBe(200);\n    expect(sseResponse.headers.get(\"content-type\")).toBe(\"text/event-stream\");\n\n    // Send a notification that should be stored with an event ID\n    const notification: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"notifications/message\",\n      params: { level: \"info\", data: \"Test notification with event ID\" },\n    };\n\n    // Send the notification via transport\n    await transport.send(notification);\n\n    // Read from the stream and verify we got the notification with an event ID\n    const reader = sseResponse.body?.getReader();\n    const { value } = await reader!.read();\n    const text = new TextDecoder().decode(value);\n\n    // The response should contain an event ID\n    expect(text).toContain('id: ');\n    expect(text).toContain('\"method\":\"notifications/message\"');\n\n    // Extract the event ID\n    const idMatch = text.match(/id: ([^\\n]+)/);\n    expect(idMatch).toBeTruthy();\n\n    // Verify the event was stored\n    const eventId = idMatch![1];\n    expect(storedEvents.has(eventId)).toBe(true);\n    const storedEvent = storedEvents.get(eventId);\n    expect(eventId.startsWith('_GET_stream')).toBe(true);\n    expect(storedEvent?.message).toMatchObject(notification);\n  });\n\n\n  it(\"should store and replay MCP server tool notifications\", async () =\u003E {\n    // Establish a standalone SSE stream\n    const sseResponse = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-session-id\": sessionId,\n      },\n    });\n    expect(sseResponse.status).toBe(200);   // Send a server notification through the MCP server\n    await mcpServer.server.sendLoggingMessage({ level: \"info\", data: \"First notification from MCP server\" });\n\n    // Read the notification from the SSE stream\n    const reader = sseResponse.body?.getReader();\n    const { value } = await reader!.read();\n    const text = new TextDecoder().decode(value);\n\n    // Verify the notification was sent with an event ID\n    expect(text).toContain('id: ');\n    expect(text).toContain('First notification from MCP server');\n\n    // Extract the event ID\n    const idMatch = text.match(/id: ([^\\n]+)/);\n    expect(idMatch).toBeTruthy();\n    const firstEventId = idMatch![1];\n\n    // Send a second notification \n    await mcpServer.server.sendLoggingMessage({ level: \"info\", data: \"Second notification from MCP server\" });\n\n    // Close the first SSE stream to simulate a disconnect\n    await reader!.cancel();\n\n    // Reconnect with the Last-Event-ID to get missed messages\n    const reconnectResponse = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-session-id\": sessionId,\n        \"mcp-protocol-version\": \"2025-03-26\",\n        \"last-event-id\": firstEventId\n      },\n    });\n\n    expect(reconnectResponse.status).toBe(200);\n\n    // Read the replayed notification\n    const reconnectReader = reconnectResponse.body?.getReader();\n    const reconnectData = await reconnectReader!.read();\n    const reconnectText = new TextDecoder().decode(reconnectData.value);\n\n    // Verify we received the second notification that was sent after our stored eventId\n    expect(reconnectText).toContain('Second notification from MCP server');\n    expect(reconnectText).toContain('id: ');\n  });\n});\n\n// Test stateless mode\ndescribe(\"StreamableHTTPServerTransport in stateless mode\", () =\u003E {\n  let server: Server;\n  let transport: StreamableHTTPServerTransport;\n  let baseUrl: URL;\n\n  beforeEach(async () =\u003E {\n    const result = await createTestServer({ sessionIdGenerator: undefined });\n    server = result.server;\n    transport = result.transport;\n    baseUrl = result.baseUrl;\n  });\n\n  afterEach(async () =\u003E {\n    await stopTestServer({ server, transport });\n  });\n\n  it(\"should operate without session ID validation\", async () =\u003E {\n    // Initialize the server first\n    const initResponse = await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n\n    expect(initResponse.status).toBe(200);\n    // Should NOT have session ID header in stateless mode\n    expect(initResponse.headers.get(\"mcp-session-id\")).toBeNull();\n\n    // Try request without session ID - should work in stateless mode\n    const toolsResponse = await sendPostRequest(baseUrl, TEST_MESSAGES.toolsList);\n\n    expect(toolsResponse.status).toBe(200);\n  });\n\n  it(\"should handle POST requests with various session IDs in stateless mode\", async () =\u003E {\n    await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n\n    // Try with a random session ID - should be accepted\n    const response1 = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json, text/event-stream\",\n        \"mcp-session-id\": \"random-id-1\",\n      },\n      body: JSON.stringify({ jsonrpc: \"2.0\", method: \"tools/list\", params: {}, id: \"t1\" }),\n    });\n    expect(response1.status).toBe(200);\n\n    // Try with another random session ID - should also be accepted\n    const response2 = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json, text/event-stream\",\n        \"mcp-session-id\": \"different-id-2\",\n      },\n      body: JSON.stringify({ jsonrpc: \"2.0\", method: \"tools/list\", params: {}, id: \"t2\" }),\n    });\n    expect(response2.status).toBe(200);\n  });\n\n  it(\"should reject second SSE stream even in stateless mode\", async () =\u003E {\n    // Despite no session ID requirement, the transport still only allows \n    // one standalone SSE stream at a time\n\n    // Initialize the server first\n    await sendPostRequest(baseUrl, TEST_MESSAGES.initialize);\n\n    // Open first SSE stream\n    const stream1 = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-protocol-version\": \"2025-03-26\"\n      },\n    });\n    expect(stream1.status).toBe(200);\n\n    // Open second SSE stream - should still be rejected, stateless mode still only allows one\n    const stream2 = await fetch(baseUrl, {\n      method: \"GET\",\n      headers: {\n        Accept: \"text/event-stream\",\n        \"mcp-protocol-version\": \"2025-03-26\"\n      },\n    });\n    expect(stream2.status).toBe(409); // Conflict - only one stream allowed\n  });\n});\n\n// Test onsessionclosed callback\ndescribe(\"StreamableHTTPServerTransport onsessionclosed callback\", () =\u003E {\n  it(\"should call onsessionclosed callback when session is closed via DELETE\", async () =\u003E {\n    const mockCallback = jest.fn();\n    \n    // Create server with onsessionclosed callback\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessionclosed: mockCallback,\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize to get a session ID\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    const tempSessionId = initResponse.headers.get(\"mcp-session-id\");\n    expect(tempSessionId).toBeDefined();\n\n    // DELETE the session\n    const deleteResponse = await fetch(tempUrl, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": tempSessionId || \"\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse.status).toBe(200);\n    expect(mockCallback).toHaveBeenCalledWith(tempSessionId);\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n\n    // Clean up\n    tempServer.close();\n  });\n\n  it(\"should not call onsessionclosed callback when not provided\", async () =\u003E {\n    // Create server without onsessionclosed callback\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize to get a session ID\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    const tempSessionId = initResponse.headers.get(\"mcp-session-id\");\n\n    // DELETE the session - should not throw error\n    const deleteResponse = await fetch(tempUrl, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": tempSessionId || \"\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse.status).toBe(200);\n\n    // Clean up\n    tempServer.close();\n  });\n\n  it(\"should not call onsessionclosed callback for invalid session DELETE\", async () =\u003E {\n    const mockCallback = jest.fn();\n    \n    // Create server with onsessionclosed callback\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessionclosed: mockCallback,\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize to get a valid session\n    await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n\n    // Try to DELETE with invalid session ID\n    const deleteResponse = await fetch(tempUrl, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": \"invalid-session-id\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse.status).toBe(404);\n    expect(mockCallback).not.toHaveBeenCalled();\n\n    // Clean up\n    tempServer.close();\n  });\n\n  it(\"should call onsessionclosed callback with correct session ID when multiple sessions exist\", async () =\u003E {\n    const mockCallback = jest.fn();\n    \n    // Create first server\n    const result1 = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessionclosed: mockCallback,\n    });\n    \n    const server1 = result1.server;\n    const url1 = result1.baseUrl;\n\n    // Create second server\n    const result2 = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessionclosed: mockCallback,\n    });\n    \n    const server2 = result2.server;\n    const url2 = result2.baseUrl;\n\n    // Initialize both servers\n    const initResponse1 = await sendPostRequest(url1, TEST_MESSAGES.initialize);\n    const sessionId1 = initResponse1.headers.get(\"mcp-session-id\");\n    \n    const initResponse2 = await sendPostRequest(url2, TEST_MESSAGES.initialize);\n    const sessionId2 = initResponse2.headers.get(\"mcp-session-id\");\n\n    expect(sessionId1).toBeDefined();\n    expect(sessionId2).toBeDefined();\n    expect(sessionId1).not.toBe(sessionId2);\n\n    // DELETE first session\n    const deleteResponse1 = await fetch(url1, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": sessionId1 || \"\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse1.status).toBe(200);\n    expect(mockCallback).toHaveBeenCalledWith(sessionId1);\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n\n    // DELETE second session\n    const deleteResponse2 = await fetch(url2, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": sessionId2 || \"\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse2.status).toBe(200);\n    expect(mockCallback).toHaveBeenCalledWith(sessionId2);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n\n    // Clean up\n    server1.close();\n    server2.close();\n  });\n});\n\n// Test async callbacks for onsessioninitialized and onsessionclosed\ndescribe(\"StreamableHTTPServerTransport async callbacks\", () =\u003E {\n  it(\"should support async onsessioninitialized callback\", async () =\u003E {\n    const initializationOrder: string[] = [];\n    \n    // Create server with async onsessioninitialized callback\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessioninitialized: async (sessionId: string) =\u003E {\n        initializationOrder.push('async-start');\n        // Simulate async operation\n        await new Promise(resolve =\u003E setTimeout(resolve, 10));\n        initializationOrder.push('async-end');\n        initializationOrder.push(sessionId);\n      },\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize to trigger the callback\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    const tempSessionId = initResponse.headers.get(\"mcp-session-id\");\n    \n    // Give time for async callback to complete\n    await new Promise(resolve =\u003E setTimeout(resolve, 50));\n    \n    expect(initializationOrder).toEqual(['async-start', 'async-end', tempSessionId]);\n    \n    // Clean up\n    tempServer.close();\n  });\n\n  it(\"should support sync onsessioninitialized callback (backwards compatibility)\", async () =\u003E {\n    const capturedSessionId: string[] = [];\n    \n    // Create server with sync onsessioninitialized callback\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessioninitialized: (sessionId: string) =\u003E {\n        capturedSessionId.push(sessionId);\n      },\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize to trigger the callback\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    const tempSessionId = initResponse.headers.get(\"mcp-session-id\");\n    \n    expect(capturedSessionId).toEqual([tempSessionId]);\n    \n    // Clean up\n    tempServer.close();\n  });\n\n  it(\"should support async onsessionclosed callback\", async () =\u003E {\n    const closureOrder: string[] = [];\n    \n    // Create server with async onsessionclosed callback\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessionclosed: async (sessionId: string) =\u003E {\n        closureOrder.push('async-close-start');\n        // Simulate async operation\n        await new Promise(resolve =\u003E setTimeout(resolve, 10));\n        closureOrder.push('async-close-end');\n        closureOrder.push(sessionId);\n      },\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize to get a session ID\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    const tempSessionId = initResponse.headers.get(\"mcp-session-id\");\n    expect(tempSessionId).toBeDefined();\n\n    // DELETE the session\n    const deleteResponse = await fetch(tempUrl, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": tempSessionId || \"\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse.status).toBe(200);\n    \n    // Give time for async callback to complete\n    await new Promise(resolve =\u003E setTimeout(resolve, 50));\n    \n    expect(closureOrder).toEqual(['async-close-start', 'async-close-end', tempSessionId]);\n\n    // Clean up\n    tempServer.close();\n  });\n\n  it(\"should propagate errors from async onsessioninitialized callback\", async () =\u003E {\n    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n    \n    // Create server with async onsessioninitialized callback that throws\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessioninitialized: async (_sessionId: string) =\u003E {\n        throw new Error('Async initialization error');\n      },\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize should fail when callback throws\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    expect(initResponse.status).toBe(400);\n    \n    // Clean up\n    consoleErrorSpy.mockRestore();\n    tempServer.close();\n  });\n\n  it(\"should propagate errors from async onsessionclosed callback\", async () =\u003E {\n    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n    \n    // Create server with async onsessionclosed callback that throws\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessionclosed: async (_sessionId: string) =\u003E {\n        throw new Error('Async closure error');\n      },\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize to get a session ID\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    const tempSessionId = initResponse.headers.get(\"mcp-session-id\");\n\n    // DELETE should fail when callback throws\n    const deleteResponse = await fetch(tempUrl, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": tempSessionId || \"\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse.status).toBe(500);\n    \n    // Clean up\n    consoleErrorSpy.mockRestore();\n    tempServer.close();\n  });\n\n  it(\"should handle both async callbacks together\", async () =\u003E {\n    const events: string[] = [];\n    \n    // Create server with both async callbacks\n    const result = await createTestServer({\n      sessionIdGenerator: () =\u003E randomUUID(),\n      onsessioninitialized: async (sessionId: string) =\u003E {\n        await new Promise(resolve =\u003E setTimeout(resolve, 5));\n        events.push(`initialized:${sessionId}`);\n      },\n      onsessionclosed: async (sessionId: string) =\u003E {\n        await new Promise(resolve =\u003E setTimeout(resolve, 5));\n        events.push(`closed:${sessionId}`);\n      },\n    });\n    \n    const tempServer = result.server;\n    const tempUrl = result.baseUrl;\n\n    // Initialize to trigger first callback\n    const initResponse = await sendPostRequest(tempUrl, TEST_MESSAGES.initialize);\n    const tempSessionId = initResponse.headers.get(\"mcp-session-id\");\n    \n    // Wait for async callback\n    await new Promise(resolve =\u003E setTimeout(resolve, 20));\n    \n    expect(events).toContain(`initialized:${tempSessionId}`);\n\n    // DELETE to trigger second callback\n    const deleteResponse = await fetch(tempUrl, {\n      method: \"DELETE\",\n      headers: {\n        \"mcp-session-id\": tempSessionId || \"\",\n        \"mcp-protocol-version\": \"2025-03-26\",\n      },\n    });\n\n    expect(deleteResponse.status).toBe(200);\n    \n    // Wait for async callback\n    await new Promise(resolve =\u003E setTimeout(resolve, 20));\n    \n    expect(events).toContain(`closed:${tempSessionId}`);\n    expect(events).toHaveLength(2);\n\n    // Clean up\n    tempServer.close();\n  });\n});\n\n// Test DNS rebinding protection\ndescribe(\"StreamableHTTPServerTransport DNS rebinding protection\", () =\u003E {\n  let server: Server;\n  let transport: StreamableHTTPServerTransport;\n  let baseUrl: URL;\n\n  afterEach(async () =\u003E {\n    if (server && transport) {\n      await stopTestServer({ server, transport });\n    }\n  });\n\n  describe(\"Host header validation\", () =\u003E {\n    it(\"should accept requests with allowed host headers\", async () =\u003E {\n      const result = await createTestServerWithDnsProtection({\n        sessionIdGenerator: undefined,\n        allowedHosts: ['localhost'],\n        enableDnsRebindingProtection: true,\n      });\n      server = result.server;\n      transport = result.transport;\n      baseUrl = result.baseUrl;\n\n      // Note: fetch() automatically sets Host header to match the URL\n      // Since we're connecting to localhost:3001 and that's in allowedHosts, this should work\n      const response = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n        },\n        body: JSON.stringify(TEST_MESSAGES.initialize),\n      });\n\n      expect(response.status).toBe(200);\n    });\n\n    it(\"should reject requests with disallowed host headers\", async () =\u003E {\n      // Test DNS rebinding protection by creating a server that only allows example.com\n      // but we're connecting via localhost, so it should be rejected\n      const result = await createTestServerWithDnsProtection({\n        sessionIdGenerator: undefined,\n        allowedHosts: ['example.com:3001'],\n        enableDnsRebindingProtection: true,\n      });\n      server = result.server;\n      transport = result.transport;\n      baseUrl = result.baseUrl;\n\n      const response = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n        },\n        body: JSON.stringify(TEST_MESSAGES.initialize),\n      });\n\n      expect(response.status).toBe(403);\n      const body = await response.json();\n      expect(body.error.message).toContain(\"Invalid Host header:\");\n    });\n\n    it(\"should reject GET requests with disallowed host headers\", async () =\u003E {\n      const result = await createTestServerWithDnsProtection({\n        sessionIdGenerator: undefined,\n        allowedHosts: ['example.com:3001'],\n        enableDnsRebindingProtection: true,\n      });\n      server = result.server;\n      transport = result.transport;\n      baseUrl = result.baseUrl;\n\n      const response = await fetch(baseUrl, {\n        method: \"GET\",\n        headers: {\n          Accept: \"text/event-stream\",\n        },\n      });\n\n      expect(response.status).toBe(403);\n    });\n  });\n\n  describe(\"Origin header validation\", () =\u003E {\n    it(\"should accept requests with allowed origin headers\", async () =\u003E {\n      const result = await createTestServerWithDnsProtection({\n        sessionIdGenerator: undefined,\n        allowedOrigins: ['http://localhost:3000', 'https://example.com'],\n        enableDnsRebindingProtection: true,\n      });\n      server = result.server;\n      transport = result.transport;\n      baseUrl = result.baseUrl;\n\n      const response = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n          Origin: \"http://localhost:3000\",\n        },\n        body: JSON.stringify(TEST_MESSAGES.initialize),\n      });\n\n      expect(response.status).toBe(200);\n    });\n\n    it(\"should reject requests with disallowed origin headers\", async () =\u003E {\n      const result = await createTestServerWithDnsProtection({\n        sessionIdGenerator: undefined,\n        allowedOrigins: ['http://localhost:3000'],\n        enableDnsRebindingProtection: true,\n      });\n      server = result.server;\n      transport = result.transport;\n      baseUrl = result.baseUrl;\n\n      const response = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n          Origin: \"http://evil.com\",\n        },\n        body: JSON.stringify(TEST_MESSAGES.initialize),\n      });\n\n      expect(response.status).toBe(403);\n      const body = await response.json();\n      expect(body.error.message).toBe(\"Invalid Origin header: http://evil.com\");\n    });\n  });\n\n  describe(\"enableDnsRebindingProtection option\", () =\u003E {\n    it(\"should skip all validations when enableDnsRebindingProtection is false\", async () =\u003E {\n      const result = await createTestServerWithDnsProtection({\n        sessionIdGenerator: undefined,\n        allowedHosts: ['localhost'],\n        allowedOrigins: ['http://localhost:3000'],\n        enableDnsRebindingProtection: false,\n      });\n      server = result.server;\n      transport = result.transport;\n      baseUrl = result.baseUrl;\n\n      const response = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n          Host: \"evil.com\",\n          Origin: \"http://evil.com\",\n        },\n        body: JSON.stringify(TEST_MESSAGES.initialize),\n      });\n\n      // Should pass even with invalid headers because protection is disabled\n      expect(response.status).toBe(200);\n    });\n  });\n\n  describe(\"Combined validations\", () =\u003E {\n    it(\"should validate both host and origin when both are configured\", async () =\u003E {\n      const result = await createTestServerWithDnsProtection({\n        sessionIdGenerator: undefined,\n        allowedHosts: ['localhost'],\n        allowedOrigins: ['http://localhost:3001'],\n        enableDnsRebindingProtection: true,\n      });\n      server = result.server;\n      transport = result.transport;\n      baseUrl = result.baseUrl;\n\n      // Test with invalid origin (host will be automatically correct via fetch)\n      const response1 = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n          Origin: \"http://evil.com\",\n        },\n        body: JSON.stringify(TEST_MESSAGES.initialize),\n      });\n\n      expect(response1.status).toBe(403);\n      const body1 = await response1.json();\n      expect(body1.error.message).toBe(\"Invalid Origin header: http://evil.com\");\n\n      // Test with valid origin\n      const response2 = await fetch(baseUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json, text/event-stream\",\n          Origin: \"http://localhost:3001\",\n        },\n        body: JSON.stringify(TEST_MESSAGES.initialize),\n      });\n\n      expect(response2.status).toBe(200);\n    });\n  });\n});\n\n/**\n * Helper to create test server with DNS rebinding protection options\n */\nasync function createTestServerWithDnsProtection(config: {\n  sessionIdGenerator: (() =\u003E string) | undefined;\n  allowedHosts?: string[];\n  allowedOrigins?: string[];\n  enableDnsRebindingProtection?: boolean;\n}): Promise\u003C{\n  server: Server;\n  transport: StreamableHTTPServerTransport;\n  mcpServer: McpServer;\n  baseUrl: URL;\n}\u003E {\n  const mcpServer = new McpServer(\n    { name: \"test-server\", version: \"1.0.0\" },\n    { capabilities: { logging: {} } }\n  );\n\n  const port = await getFreePort();\n\n  if (config.allowedHosts) {\n    config.allowedHosts = config.allowedHosts.map(host =\u003E {\n      if (host.includes(':')) {\n        return host;\n      }\n      return `localhost:${port}`;\n    });\n  }\n\n  const transport = new StreamableHTTPServerTransport({\n    sessionIdGenerator: config.sessionIdGenerator,\n    allowedHosts: config.allowedHosts,\n    allowedOrigins: config.allowedOrigins,\n    enableDnsRebindingProtection: config.enableDnsRebindingProtection,\n  });\n\n  await mcpServer.connect(transport);\n\n  const httpServer = createServer(async (req, res) =\u003E {\n    if (req.method === \"POST\") {\n      let body = \"\";\n      req.on(\"data\", (chunk) =\u003E (body += chunk));\n      req.on(\"end\", async () =\u003E {\n        const parsedBody = JSON.parse(body);\n        await transport.handleRequest(req as IncomingMessage & { auth?: AuthInfo }, res, parsedBody);\n      });\n    } else {\n      await transport.handleRequest(req as IncomingMessage & { auth?: AuthInfo }, res);\n    }\n  });\n\n  await new Promise\u003Cvoid\u003E((resolve) =\u003E {\n    httpServer.listen(port, () =\u003E resolve());\n  });\n\n  const serverUrl = new URL(`http://localhost:${port}/`);\n\n  return {\n    server: httpServer,\n    transport,\n    mcpServer,\n    baseUrl: serverUrl,\n  };\n}",
      "hash": "52ea4a6ba9b2cca761960f4933d3e9a2ea8cf65031cb83d55a7d01e174a91851",
      "size": 69066
    },
    "/src/server/streamableHttp.ts": {
      "type": "content",
      "content": "import { IncomingMessage, ServerResponse } from \"node:http\";\nimport { Transport } from \"../shared/transport.js\";\nimport { MessageExtraInfo, RequestInfo, isInitializeRequest, isJSONRPCError, isJSONRPCRequest, isJSONRPCResponse, JSONRPCMessage, JSONRPCMessageSchema, RequestId, SUPPORTED_PROTOCOL_VERSIONS, DEFAULT_NEGOTIATED_PROTOCOL_VERSION } from \"../types.js\";\nimport getRawBody from \"raw-body\";\nimport contentType from \"content-type\";\nimport { randomUUID } from \"node:crypto\";\nimport { AuthInfo } from \"./auth/types.js\";\n\nconst MAXIMUM_MESSAGE_SIZE = \"4mb\";\n\nexport type StreamId = string;\nexport type EventId = string;\n\n/**\n * Interface for resumability support via event storage\n */\nexport interface EventStore {\n  /**\n   * Stores an event for later retrieval\n   * @param streamId ID of the stream the event belongs to\n   * @param message The JSON-RPC message to store\n   * @returns The generated event ID for the stored event\n   */\n  storeEvent(streamId: StreamId, message: JSONRPCMessage): Promise\u003CEventId\u003E;\n\n  replayEventsAfter(lastEventId: EventId, { send }: {\n    send: (eventId: EventId, message: JSONRPCMessage) =\u003E Promise\u003Cvoid\u003E\n  }): Promise\u003CStreamId\u003E;\n}\n\n/**\n * Configuration options for StreamableHTTPServerTransport\n */\nexport interface StreamableHTTPServerTransportOptions {\n  /**\n   * Function that generates a session ID for the transport.\n   * The session ID SHOULD be globally unique and cryptographically secure (e.g., a securely generated UUID, a JWT, or a cryptographic hash)\n   * \n   * Return undefined to disable session management.\n   */\n  sessionIdGenerator: (() =\u003E string) | undefined;\n\n  /**\n   * A callback for session initialization events\n   * This is called when the server initializes a new session.\n   * Useful in cases when you need to register multiple mcp sessions\n   * and need to keep track of them.\n   * @param sessionId The generated session ID\n   */\n  onsessioninitialized?: (sessionId: string) =\u003E void | Promise\u003Cvoid\u003E;\n\n  /**\n   * A callback for session close events\n   * This is called when the server closes a session due to a DELETE request.\n   * Useful in cases when you need to clean up resources associated with the session.\n   * Note that this is different from the transport closing, if you are handling \n   * HTTP requests from multiple nodes you might want to close each \n   * StreamableHTTPServerTransport after a request is completed while still keeping the \n   * session open/running.\n   * @param sessionId The session ID that was closed\n  */\n  onsessionclosed?: (sessionId: string) =\u003E void | Promise\u003Cvoid\u003E;\n\n  /**\n   * If true, the server will return JSON responses instead of starting an SSE stream.\n   * This can be useful for simple request/response scenarios without streaming.\n   * Default is false (SSE streams are preferred).\n   */\n  enableJsonResponse?: boolean;\n\n  /**\n   * Event store for resumability support\n   * If provided, resumability will be enabled, allowing clients to reconnect and resume messages\n   */\n  eventStore?: EventStore;\n\n  /**\n   * List of allowed host header values for DNS rebinding protection.\n   * If not specified, host validation is disabled.\n   */\n  allowedHosts?: string[];\n  \n  /**\n   * List of allowed origin header values for DNS rebinding protection.\n   * If not specified, origin validation is disabled.\n   */\n  allowedOrigins?: string[];\n  \n  /**\n   * Enable DNS rebinding protection (requires allowedHosts and/or allowedOrigins to be configured).\n   * Default is false for backwards compatibility.\n   */\n  enableDnsRebindingProtection?: boolean;\n}\n\n/**\n * Server transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.\n * It supports both SSE streaming and direct HTTP responses.\n * \n * Usage example:\n * \n * ```typescript\n * // Stateful mode - server sets the session ID\n * const statefulTransport = new StreamableHTTPServerTransport({\n *   sessionIdGenerator: () =\u003E randomUUID(),\n * });\n * \n * // Stateless mode - explicitly set session ID to undefined\n * const statelessTransport = new StreamableHTTPServerTransport({\n *   sessionIdGenerator: undefined,\n * });\n * \n * // Using with pre-parsed request body\n * app.post('/mcp', (req, res) =\u003E {\n *   transport.handleRequest(req, res, req.body);\n * });\n * ```\n * \n * In stateful mode:\n * - Session ID is generated and included in response headers\n * - Session ID is always included in initialization responses\n * - Requests with invalid session IDs are rejected with 404 Not Found\n * - Non-initialization requests without a session ID are rejected with 400 Bad Request\n * - State is maintained in-memory (connections, message history)\n * \n * In stateless mode:\n * - No Session ID is included in any responses\n * - No session validation is performed\n */\nexport class StreamableHTTPServerTransport implements Transport {\n  // when sessionId is not set (undefined), it means the transport is in stateless mode\n  private sessionIdGenerator: (() =\u003E string) | undefined;\n  private _started: boolean = false;\n  private _streamMapping: Map\u003Cstring, ServerResponse\u003E = new Map();\n  private _requestToStreamMapping: Map\u003CRequestId, string\u003E = new Map();\n  private _requestResponseMap: Map\u003CRequestId, JSONRPCMessage\u003E = new Map();\n  private _initialized: boolean = false;\n  private _enableJsonResponse: boolean = false;\n  private _standaloneSseStreamId: string = '_GET_stream';\n  private _eventStore?: EventStore;\n  private _onsessioninitialized?: (sessionId: string) =\u003E void | Promise\u003Cvoid\u003E;\n  private _onsessionclosed?: (sessionId: string) =\u003E void | Promise\u003Cvoid\u003E;\n  private _allowedHosts?: string[];\n  private _allowedOrigins?: string[];\n  private _enableDnsRebindingProtection: boolean;\n\n  sessionId?: string;\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) =\u003E void;\n\n  constructor(options: StreamableHTTPServerTransportOptions) {\n    this.sessionIdGenerator = options.sessionIdGenerator;\n    this._enableJsonResponse = options.enableJsonResponse ?? false;\n    this._eventStore = options.eventStore;\n    this._onsessioninitialized = options.onsessioninitialized;\n    this._onsessionclosed = options.onsessionclosed;\n    this._allowedHosts = options.allowedHosts;\n    this._allowedOrigins = options.allowedOrigins;\n    this._enableDnsRebindingProtection = options.enableDnsRebindingProtection ?? false;\n  }\n\n  /**\n   * Starts the transport. This is required by the Transport interface but is a no-op\n   * for the Streamable HTTP transport as connections are managed per-request.\n   */\n  async start(): Promise\u003Cvoid\u003E {\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  /**\n   * Validates request headers for DNS rebinding protection.\n   * @returns Error message if validation fails, undefined if validation passes.\n   */\n  private validateRequestHeaders(req: IncomingMessage): string | undefined {\n    // Skip validation if protection is not enabled\n    if (!this._enableDnsRebindingProtection) {\n      return undefined;\n    }\n\n    // Validate Host header if allowedHosts is configured\n    if (this._allowedHosts && this._allowedHosts.length \u003E 0) {\n      const hostHeader = req.headers.host;\n      if (!hostHeader || !this._allowedHosts.includes(hostHeader)) {\n        return `Invalid Host header: ${hostHeader}`;\n      }\n    }\n\n    // Validate Origin header if allowedOrigins is configured\n    if (this._allowedOrigins && this._allowedOrigins.length \u003E 0) {\n      const originHeader = req.headers.origin;\n      if (!originHeader || !this._allowedOrigins.includes(originHeader)) {\n        return `Invalid Origin header: ${originHeader}`;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Handles an incoming HTTP request, whether GET or POST\n   */\n  async handleRequest(req: IncomingMessage & { auth?: AuthInfo }, res: ServerResponse, parsedBody?: unknown): Promise\u003Cvoid\u003E {\n    // Validate request headers for DNS rebinding protection\n    const validationError = this.validateRequestHeaders(req);\n    if (validationError) {\n      res.writeHead(403).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32000,\n          message: validationError\n        },\n        id: null\n      }));\n      this.onerror?.(new Error(validationError));\n      return;\n    }\n\n    if (req.method === \"POST\") {\n      await this.handlePostRequest(req, res, parsedBody);\n    } else if (req.method === \"GET\") {\n      await this.handleGetRequest(req, res);\n    } else if (req.method === \"DELETE\") {\n      await this.handleDeleteRequest(req, res);\n    } else {\n      await this.handleUnsupportedRequest(res);\n    }\n  }\n\n  /**\n   * Handles GET requests for SSE stream\n   */\n  private async handleGetRequest(req: IncomingMessage, res: ServerResponse): Promise\u003Cvoid\u003E {\n    // The client MUST include an Accept header, listing text/event-stream as a supported content type.\n    const acceptHeader = req.headers.accept;\n    if (!acceptHeader?.includes(\"text/event-stream\")) {\n      res.writeHead(406).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32000,\n          message: \"Not Acceptable: Client must accept text/event-stream\"\n        },\n        id: null\n      }));\n      return;\n    }\n\n    // If an Mcp-Session-Id is returned by the server during initialization,\n    // clients using the Streamable HTTP transport MUST include it\n    // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n    if (!this.validateSession(req, res)) {\n      return;\n    }\n    if (!this.validateProtocolVersion(req, res)) {\n      return;\n    }\n    // Handle resumability: check for Last-Event-ID header\n    if (this._eventStore) {\n      const lastEventId = req.headers['last-event-id'] as string | undefined;\n      if (lastEventId) {\n        await this.replayEvents(lastEventId, res);\n        return;\n      }\n    }\n\n    // The server MUST either return Content-Type: text/event-stream in response to this HTTP GET,\n    // or else return HTTP 405 Method Not Allowed\n    const headers: Record\u003Cstring, string\u003E = {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache, no-transform\",\n      Connection: \"keep-alive\",\n    };\n\n    // After initialization, always include the session ID if we have one\n    if (this.sessionId !== undefined) {\n      headers[\"mcp-session-id\"] = this.sessionId;\n    }\n\n    // Check if there's already an active standalone SSE stream for this session\n    if (this._streamMapping.get(this._standaloneSseStreamId) !== undefined) {\n      // Only one GET SSE stream is allowed per session\n      res.writeHead(409).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32000,\n          message: \"Conflict: Only one SSE stream is allowed per session\"\n        },\n        id: null\n      }));\n      return;\n    }\n\n    // We need to send headers immediately as messages will arrive much later,\n    // otherwise the client will just wait for the first message\n    res.writeHead(200, headers).flushHeaders();\n\n    // Assign the response to the standalone SSE stream\n    this._streamMapping.set(this._standaloneSseStreamId, res);\n    // Set up close handler for client disconnects\n    res.on(\"close\", () =\u003E {\n      this._streamMapping.delete(this._standaloneSseStreamId);\n    });\n  }\n\n  /**\n   * Replays events that would have been sent after the specified event ID\n   * Only used when resumability is enabled\n   */\n  private async replayEvents(lastEventId: string, res: ServerResponse): Promise\u003Cvoid\u003E {\n    if (!this._eventStore) {\n      return;\n    }\n    try {\n      const headers: Record\u003Cstring, string\u003E = {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache, no-transform\",\n        Connection: \"keep-alive\",\n      };\n\n      if (this.sessionId !== undefined) {\n        headers[\"mcp-session-id\"] = this.sessionId;\n      }\n      res.writeHead(200, headers).flushHeaders();\n\n      const streamId = await this._eventStore?.replayEventsAfter(lastEventId, {\n        send: async (eventId: string, message: JSONRPCMessage) =\u003E {\n          if (!this.writeSSEEvent(res, message, eventId)) {\n            this.onerror?.(new Error(\"Failed replay events\"));\n            res.end();\n          }\n        }\n      });\n      this._streamMapping.set(streamId, res);\n    } catch (error) {\n      this.onerror?.(error as Error);\n    }\n  }\n\n  /**\n   * Writes an event to the SSE stream with proper formatting\n   */\n  private writeSSEEvent(res: ServerResponse, message: JSONRPCMessage, eventId?: string): boolean {\n    let eventData = `event: message\\n`;\n    // Include event ID if provided - this is important for resumability\n    if (eventId) {\n      eventData += `id: ${eventId}\\n`;\n    }\n    eventData += `data: ${JSON.stringify(message)}\\n\\n`;\n\n    return res.write(eventData);\n  }\n\n  /**\n   * Handles unsupported requests (PUT, PATCH, etc.)\n   */\n  private async handleUnsupportedRequest(res: ServerResponse): Promise\u003Cvoid\u003E {\n    res.writeHead(405, {\n      \"Allow\": \"GET, POST, DELETE\"\n    }).end(JSON.stringify({\n      jsonrpc: \"2.0\",\n      error: {\n        code: -32000,\n        message: \"Method not allowed.\"\n      },\n      id: null\n    }));\n  }\n\n  /**\n   * Handles POST requests containing JSON-RPC messages\n   */\n  private async handlePostRequest(req: IncomingMessage & { auth?: AuthInfo }, res: ServerResponse, parsedBody?: unknown): Promise\u003Cvoid\u003E {\n    try {\n      // Validate the Accept header\n      const acceptHeader = req.headers.accept;\n      // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n      if (!acceptHeader?.includes(\"application/json\") || !acceptHeader.includes(\"text/event-stream\")) {\n        res.writeHead(406).end(JSON.stringify({\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32000,\n            message: \"Not Acceptable: Client must accept both application/json and text/event-stream\"\n          },\n          id: null\n        }));\n        return;\n      }\n\n      const ct = req.headers[\"content-type\"];\n      if (!ct || !ct.includes(\"application/json\")) {\n        res.writeHead(415).end(JSON.stringify({\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32000,\n            message: \"Unsupported Media Type: Content-Type must be application/json\"\n          },\n          id: null\n        }));\n        return;\n      }\n\n      const authInfo: AuthInfo | undefined = req.auth;\n      const requestInfo: RequestInfo = { headers: req.headers };\n\n      let rawMessage;\n      if (parsedBody !== undefined) {\n        rawMessage = parsedBody;\n      } else {\n        const parsedCt = contentType.parse(ct);\n        const body = await getRawBody(req, {\n          limit: MAXIMUM_MESSAGE_SIZE,\n          encoding: parsedCt.parameters.charset ?? \"utf-8\",\n        });\n        rawMessage = JSON.parse(body.toString());\n      }\n\n      let messages: JSONRPCMessage[];\n\n      // handle batch and single messages\n      if (Array.isArray(rawMessage)) {\n        messages = rawMessage.map(msg =\u003E JSONRPCMessageSchema.parse(msg));\n      } else {\n        messages = [JSONRPCMessageSchema.parse(rawMessage)];\n      }\n\n      // Check if this is an initialization request\n      // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/\n      const isInitializationRequest = messages.some(isInitializeRequest);\n      if (isInitializationRequest) {\n        // If it's a server with session management and the session ID is already set we should reject the request\n        // to avoid re-initialization.\n        if (this._initialized && this.sessionId !== undefined) {\n          res.writeHead(400).end(JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: {\n              code: -32600,\n              message: \"Invalid Request: Server already initialized\"\n            },\n            id: null\n          }));\n          return;\n        }\n        if (messages.length \u003E 1) {\n          res.writeHead(400).end(JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: {\n              code: -32600,\n              message: \"Invalid Request: Only one initialization request is allowed\"\n            },\n            id: null\n          }));\n          return;\n        }\n        this.sessionId = this.sessionIdGenerator?.();\n        this._initialized = true;\n\n        // If we have a session ID and an onsessioninitialized handler, call it immediately\n        // This is needed in cases where the server needs to keep track of multiple sessions\n        if (this.sessionId && this._onsessioninitialized) {\n          await Promise.resolve(this._onsessioninitialized(this.sessionId));\n        }\n\n      }\n      if (!isInitializationRequest) {\n        // If an Mcp-Session-Id is returned by the server during initialization,\n        // clients using the Streamable HTTP transport MUST include it \n        // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n        if (!this.validateSession(req, res)) {\n          return;\n        }\n        // Mcp-Protocol-Version header is required for all requests after initialization.\n        if (!this.validateProtocolVersion(req, res)) {\n          return;\n        }\n      }\n\n\n      // check if it contains requests\n      const hasRequests = messages.some(isJSONRPCRequest);\n\n      if (!hasRequests) {\n        // if it only contains notifications or responses, return 202\n        res.writeHead(202).end();\n\n        // handle each message\n        for (const message of messages) {\n          this.onmessage?.(message, { authInfo, requestInfo });\n        }\n      } else if (hasRequests) {\n        // The default behavior is to use SSE streaming\n        // but in some cases server will return JSON responses\n        const streamId = randomUUID();\n        if (!this._enableJsonResponse) {\n          const headers: Record\u003Cstring, string\u003E = {\n            \"Content-Type\": \"text/event-stream\",\n            \"Cache-Control\": \"no-cache\",\n            Connection: \"keep-alive\",\n          };\n\n          // After initialization, always include the session ID if we have one\n          if (this.sessionId !== undefined) {\n            headers[\"mcp-session-id\"] = this.sessionId;\n          }\n\n          res.writeHead(200, headers);\n        }\n        // Store the response for this request to send messages back through this connection\n        // We need to track by request ID to maintain the connection\n        for (const message of messages) {\n          if (isJSONRPCRequest(message)) {\n            this._streamMapping.set(streamId, res);\n            this._requestToStreamMapping.set(message.id, streamId);\n          }\n        }\n        // Set up close handler for client disconnects\n        res.on(\"close\", () =\u003E {\n          this._streamMapping.delete(streamId);\n        });\n\n        // handle each message\n        for (const message of messages) {\n          this.onmessage?.(message, { authInfo, requestInfo });\n        }\n        // The server SHOULD NOT close the SSE stream before sending all JSON-RPC responses\n        // This will be handled by the send() method when responses are ready\n      }\n    } catch (error) {\n      // return JSON-RPC formatted error\n      res.writeHead(400).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32700,\n          message: \"Parse error\",\n          data: String(error)\n        },\n        id: null\n      }));\n      this.onerror?.(error as Error);\n    }\n  }\n\n  /**\n   * Handles DELETE requests to terminate sessions\n   */\n  private async handleDeleteRequest(req: IncomingMessage, res: ServerResponse): Promise\u003Cvoid\u003E {\n    if (!this.validateSession(req, res)) {\n      return;\n    }\n    if (!this.validateProtocolVersion(req, res)) {\n      return;\n    }\n    await Promise.resolve(this._onsessionclosed?.(this.sessionId!));\n    await this.close();\n    res.writeHead(200).end();\n  }\n\n  /**\n   * Validates session ID for non-initialization requests\n   * Returns true if the session is valid, false otherwise\n   */\n  private validateSession(req: IncomingMessage, res: ServerResponse): boolean {\n    if (this.sessionIdGenerator === undefined) {\n      // If the sessionIdGenerator ID is not set, the session management is disabled\n      // and we don't need to validate the session ID\n      return true;\n    }\n    if (!this._initialized) {\n      // If the server has not been initialized yet, reject all requests\n      res.writeHead(400).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32000,\n          message: \"Bad Request: Server not initialized\"\n        },\n        id: null\n      }));\n      return false;\n    }\n\n    const sessionId = req.headers[\"mcp-session-id\"];\n\n    if (!sessionId) {\n      // Non-initialization requests without a session ID should return 400 Bad Request\n      res.writeHead(400).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32000,\n          message: \"Bad Request: Mcp-Session-Id header is required\"\n        },\n        id: null\n      }));\n      return false;\n    } else if (Array.isArray(sessionId)) {\n      res.writeHead(400).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32000,\n          message: \"Bad Request: Mcp-Session-Id header must be a single value\"\n        },\n        id: null\n      }));\n      return false;\n    }\n    else if (sessionId !== this.sessionId) {\n      // Reject requests with invalid session ID with 404 Not Found\n      res.writeHead(404).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32001,\n          message: \"Session not found\"\n        },\n        id: null\n      }));\n      return false;\n    }\n\n    return true;\n  }\n\n  private validateProtocolVersion(req: IncomingMessage, res: ServerResponse): boolean {\n    let protocolVersion = req.headers[\"mcp-protocol-version\"] ?? DEFAULT_NEGOTIATED_PROTOCOL_VERSION;\n    if (Array.isArray(protocolVersion)) {\n      protocolVersion = protocolVersion[protocolVersion.length - 1];\n    }\n\n    if (!SUPPORTED_PROTOCOL_VERSIONS.includes(protocolVersion)) {\n      res.writeHead(400).end(JSON.stringify({\n        jsonrpc: \"2.0\",\n        error: {\n          code: -32000,\n          message: `Bad Request: Unsupported protocol version (supported versions: ${SUPPORTED_PROTOCOL_VERSIONS.join(\", \")})`\n        },\n        id: null\n      }));\n      return false;\n    }\n    return true;\n  }\n\n  async close(): Promise\u003Cvoid\u003E {\n    // Close all SSE connections\n    this._streamMapping.forEach((response) =\u003E {\n      response.end();\n    });\n    this._streamMapping.clear();\n\n    // Clear any pending responses\n    this._requestResponseMap.clear();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage, options?: { relatedRequestId?: RequestId }): Promise\u003Cvoid\u003E {\n    let requestId = options?.relatedRequestId;\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      // If the message is a response, use the request ID from the message\n      requestId = message.id;\n    }\n\n    // Check if this message should be sent on the standalone SSE stream (no request ID)\n    // Ignore notifications from tools (which have relatedRequestId set)\n    // Those will be sent via dedicated response SSE streams\n    if (requestId === undefined) {\n      // For standalone SSE streams, we can only send requests and notifications\n      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n        throw new Error(\"Cannot send a response on a standalone SSE stream unless resuming a previous client request\");\n      }\n      const standaloneSse = this._streamMapping.get(this._standaloneSseStreamId)\n      if (standaloneSse === undefined) {\n        // The spec says the server MAY send messages on the stream, so it's ok to discard if no stream\n        return;\n      }\n\n      // Generate and store event ID if event store is provided\n      let eventId: string | undefined;\n      if (this._eventStore) {\n        // Stores the event and gets the generated event ID\n        eventId = await this._eventStore.storeEvent(this._standaloneSseStreamId, message);\n      }\n\n      // Send the message to the standalone SSE stream\n      this.writeSSEEvent(standaloneSse, message, eventId);\n      return;\n    }\n\n    // Get the response for this request\n    const streamId = this._requestToStreamMapping.get(requestId);\n    const response = this._streamMapping.get(streamId!);\n    if (!streamId) {\n      throw new Error(`No connection established for request ID: ${String(requestId)}`);\n    }\n\n    if (!this._enableJsonResponse) {\n      // For SSE responses, generate event ID if event store is provided\n      let eventId: string | undefined;\n\n      if (this._eventStore) {\n        eventId = await this._eventStore.storeEvent(streamId, message);\n      }\n      if (response) {\n        // Write the event to the response stream\n        this.writeSSEEvent(response, message, eventId);\n      }\n    }\n\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      this._requestResponseMap.set(requestId, message);\n      const relatedIds = Array.from(this._requestToStreamMapping.entries())\n        .filter(([_, streamId]) =\u003E this._streamMapping.get(streamId) === response)\n        .map(([id]) =\u003E id);\n\n      // Check if we have responses for all requests using this connection\n      const allResponsesReady = relatedIds.every(id =\u003E this._requestResponseMap.has(id));\n\n      if (allResponsesReady) {\n        if (!response) {\n          throw new Error(`No connection established for request ID: ${String(requestId)}`);\n        }\n        if (this._enableJsonResponse) {\n          // All responses ready, send as JSON\n          const headers: Record\u003Cstring, string\u003E = {\n            'Content-Type': 'application/json',\n          };\n          if (this.sessionId !== undefined) {\n            headers['mcp-session-id'] = this.sessionId;\n          }\n\n          const responses = relatedIds\n            .map(id =\u003E this._requestResponseMap.get(id)!);\n\n          response.writeHead(200, headers);\n          if (responses.length === 1) {\n            response.end(JSON.stringify(responses[0]));\n          } else {\n            response.end(JSON.stringify(responses));\n          }\n        } else {\n          // End the SSE stream\n          response.end();\n        }\n        // Clean up\n        for (const id of relatedIds) {\n          this._requestResponseMap.delete(id);\n          this._requestToStreamMapping.delete(id);\n        }\n      }\n    }\n  }\n}\n\n",
      "hash": "bdd9ac69d6cad782e9f6a2abfcfbe95dd4ea6c24de3001197ee35d673f0b32b7",
      "size": 26377
    },
    "/src/server/title.test.ts": {
      "type": "content",
      "content": "import { Server } from \"./index.js\";\nimport { Client } from \"../client/index.js\";\nimport { InMemoryTransport } from \"../inMemory.js\";\nimport { z } from \"zod\";\nimport { McpServer, ResourceTemplate } from \"./mcp.js\";\n\ndescribe(\"Title field backwards compatibility\", () =\u003E {\n  it(\"should work with tools that have title\", async () =\u003E {\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    const server = new McpServer(\n      { name: \"test-server\", version: \"1.0.0\" },\n      { capabilities: {} }\n    );\n\n    // Register tool with title\n    server.registerTool(\n      \"test-tool\",\n      {\n        title: \"Test Tool Display Name\",\n        description: \"A test tool\",\n        inputSchema: {\n          value: z.string()\n        }\n      },\n      async () =\u003E ({ content: [{ type: \"text\", text: \"result\" }] })\n    );\n\n    const client = new Client({ name: \"test-client\", version: \"1.0.0\" });\n\n    await server.server.connect(serverTransport);\n    await client.connect(clientTransport);\n\n    const tools = await client.listTools();\n    expect(tools.tools).toHaveLength(1);\n    expect(tools.tools[0].name).toBe(\"test-tool\");\n    expect(tools.tools[0].title).toBe(\"Test Tool Display Name\");\n    expect(tools.tools[0].description).toBe(\"A test tool\");\n  });\n\n  it(\"should work with tools without title\", async () =\u003E {\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    const server = new McpServer(\n      { name: \"test-server\", version: \"1.0.0\" },\n      { capabilities: {} }\n    );\n\n    // Register tool without title\n    server.tool(\n      \"test-tool\",\n      \"A test tool\",\n      { value: z.string() },\n      async () =\u003E ({ content: [{ type: \"text\", text: \"result\" }] })\n    );\n\n    const client = new Client({ name: \"test-client\", version: \"1.0.0\" });\n\n    await server.server.connect(serverTransport);\n    await client.connect(clientTransport);\n\n    const tools = await client.listTools();\n    expect(tools.tools).toHaveLength(1);\n    expect(tools.tools[0].name).toBe(\"test-tool\");\n    expect(tools.tools[0].title).toBeUndefined();\n    expect(tools.tools[0].description).toBe(\"A test tool\");\n  });\n\n  it(\"should work with prompts that have title using update\", async () =\u003E {\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    const server = new McpServer(\n      { name: \"test-server\", version: \"1.0.0\" },\n      { capabilities: {} }\n    );\n\n    // Register prompt with title by updating after creation\n    const prompt = server.prompt(\n      \"test-prompt\",\n      \"A test prompt\",\n      async () =\u003E ({ messages: [{ role: \"user\", content: { type: \"text\", text: \"test\" } }] })\n    );\n    prompt.update({ title: \"Test Prompt Display Name\" });\n\n    const client = new Client({ name: \"test-client\", version: \"1.0.0\" });\n\n    await server.server.connect(serverTransport);\n    await client.connect(clientTransport);\n\n    const prompts = await client.listPrompts();\n    expect(prompts.prompts).toHaveLength(1);\n    expect(prompts.prompts[0].name).toBe(\"test-prompt\");\n    expect(prompts.prompts[0].title).toBe(\"Test Prompt Display Name\");\n    expect(prompts.prompts[0].description).toBe(\"A test prompt\");\n  });\n\n  it(\"should work with prompts using registerPrompt\", async () =\u003E {\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    const server = new McpServer(\n      { name: \"test-server\", version: \"1.0.0\" },\n      { capabilities: {} }\n    );\n\n    // Register prompt with title using registerPrompt\n    server.registerPrompt(\n      \"test-prompt\",\n      {\n        title: \"Test Prompt Display Name\",\n        description: \"A test prompt\",\n        argsSchema: { input: z.string() }\n      },\n      async ({ input }) =\u003E ({\n        messages: [{\n          role: \"user\",\n          content: { type: \"text\", text: `test: ${input}` }\n        }]\n      })\n    );\n\n    const client = new Client({ name: \"test-client\", version: \"1.0.0\" });\n\n    await server.server.connect(serverTransport);\n    await client.connect(clientTransport);\n\n    const prompts = await client.listPrompts();\n    expect(prompts.prompts).toHaveLength(1);\n    expect(prompts.prompts[0].name).toBe(\"test-prompt\");\n    expect(prompts.prompts[0].title).toBe(\"Test Prompt Display Name\");\n    expect(prompts.prompts[0].description).toBe(\"A test prompt\");\n    expect(prompts.prompts[0].arguments).toHaveLength(1);\n  });\n\n  it(\"should work with resources using registerResource\", async () =\u003E {\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    const server = new McpServer(\n      { name: \"test-server\", version: \"1.0.0\" },\n      { capabilities: {} }\n    );\n\n    // Register resource with title using registerResource\n    server.registerResource(\n      \"test-resource\",\n      \"https://example.com/test\",\n      {\n        title: \"Test Resource Display Name\",\n        description: \"A test resource\",\n        mimeType: \"text/plain\"\n      },\n      async () =\u003E ({\n        contents: [{\n          uri: \"https://example.com/test\",\n          text: \"test content\"\n        }]\n      })\n    );\n\n    const client = new Client({ name: \"test-client\", version: \"1.0.0\" });\n\n    await server.server.connect(serverTransport);\n    await client.connect(clientTransport);\n\n    const resources = await client.listResources();\n    expect(resources.resources).toHaveLength(1);\n    expect(resources.resources[0].name).toBe(\"test-resource\");\n    expect(resources.resources[0].title).toBe(\"Test Resource Display Name\");\n    expect(resources.resources[0].description).toBe(\"A test resource\");\n    expect(resources.resources[0].mimeType).toBe(\"text/plain\");\n  });\n\n  it(\"should work with dynamic resources using registerResource\", async () =\u003E {\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    const server = new McpServer(\n      { name: \"test-server\", version: \"1.0.0\" },\n      { capabilities: {} }\n    );\n\n    // Register dynamic resource with title using registerResource\n    server.registerResource(\n      \"user-profile\",\n      new ResourceTemplate(\"users://{userId}/profile\", { list: undefined }),\n      {\n        title: \"User Profile\",\n        description: \"User profile information\"\n      },\n      async (uri, { userId }, _extra) =\u003E ({\n        contents: [{\n          uri: uri.href,\n          text: `Profile data for user ${userId}`\n        }]\n      })\n    );\n\n    const client = new Client({ name: \"test-client\", version: \"1.0.0\" });\n\n    await server.server.connect(serverTransport);\n    await client.connect(clientTransport);\n\n    const resourceTemplates = await client.listResourceTemplates();\n    expect(resourceTemplates.resourceTemplates).toHaveLength(1);\n    expect(resourceTemplates.resourceTemplates[0].name).toBe(\"user-profile\");\n    expect(resourceTemplates.resourceTemplates[0].title).toBe(\"User Profile\");\n    expect(resourceTemplates.resourceTemplates[0].description).toBe(\"User profile information\");\n    expect(resourceTemplates.resourceTemplates[0].uriTemplate).toBe(\"users://{userId}/profile\");\n\n    // Test reading the resource\n    const readResult = await client.readResource({ uri: \"users://123/profile\" });\n    expect(readResult.contents).toHaveLength(1);\n    expect(readResult.contents[0].text).toBe(\"Profile data for user 123\");\n  });\n\n  it(\"should support serverInfo with title\", async () =\u003E {\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n\n    const server = new Server(\n      {\n        name: \"test-server\",\n        version: \"1.0.0\",\n        title: \"Test Server Display Name\"\n      },\n      { capabilities: {} }\n    );\n\n    const client = new Client({ name: \"test-client\", version: \"1.0.0\" });\n\n    await server.connect(serverTransport);\n    await client.connect(clientTransport);\n\n    const serverInfo = client.getServerVersion();\n    expect(serverInfo?.name).toBe(\"test-server\");\n    expect(serverInfo?.version).toBe(\"1.0.0\");\n    expect(serverInfo?.title).toBe(\"Test Server Display Name\");\n  });\n});",
      "hash": "e92e3e5539b49e7a0ecbbce6f0630b36ec0573d0dd3ad8df5d563b924082a306",
      "size": 8005
    },
    "/src/shared/auth-utils.test.ts": {
      "type": "content",
      "content": "import { resourceUrlFromServerUrl, checkResourceAllowed } from './auth-utils.js';\n\ndescribe('auth-utils', () =\u003E {\n  describe('resourceUrlFromServerUrl', () =\u003E {\n    it('should remove fragments', () =\u003E {\n      expect(resourceUrlFromServerUrl(new URL('https://example.com/path#fragment')).href).toBe('https://example.com/path');\n      expect(resourceUrlFromServerUrl(new URL('https://example.com#fragment')).href).toBe('https://example.com/');\n      expect(resourceUrlFromServerUrl(new URL('https://example.com/path?query=1#fragment')).href).toBe('https://example.com/path?query=1');\n    });\n\n    it('should return URL unchanged if no fragment', () =\u003E {\n      expect(resourceUrlFromServerUrl(new URL('https://example.com')).href).toBe('https://example.com/');\n      expect(resourceUrlFromServerUrl(new URL('https://example.com/path')).href).toBe('https://example.com/path');\n      expect(resourceUrlFromServerUrl(new URL('https://example.com/path?query=1')).href).toBe('https://example.com/path?query=1');\n    });\n\n    it('should keep everything else unchanged', () =\u003E {\n      // Case sensitivity preserved\n      expect(resourceUrlFromServerUrl(new URL('https://EXAMPLE.COM/PATH')).href).toBe('https://example.com/PATH');\n      // Ports preserved\n      expect(resourceUrlFromServerUrl(new URL('https://example.com:443/path')).href).toBe('https://example.com/path');\n      expect(resourceUrlFromServerUrl(new URL('https://example.com:8080/path')).href).toBe('https://example.com:8080/path');\n      // Query parameters preserved\n      expect(resourceUrlFromServerUrl(new URL('https://example.com?foo=bar&baz=qux')).href).toBe('https://example.com/?foo=bar&baz=qux');\n      // Trailing slashes preserved\n      expect(resourceUrlFromServerUrl(new URL('https://example.com/')).href).toBe('https://example.com/');\n      expect(resourceUrlFromServerUrl(new URL('https://example.com/path/')).href).toBe('https://example.com/path/');\n    });\n  });\n\n  describe('resourceMatches', () =\u003E {\n    it('should match identical URLs', () =\u003E {\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/path', configuredResource: 'https://example.com/path' })).toBe(true);\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/', configuredResource: 'https://example.com/' })).toBe(true);\n    });\n\n    it('should not match URLs with different paths', () =\u003E {\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/path1', configuredResource: 'https://example.com/path2' })).toBe(false);\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/', configuredResource: 'https://example.com/path' })).toBe(false);\n    });\n\n    it('should not match URLs with different domains', () =\u003E {\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/path', configuredResource: 'https://example.org/path' })).toBe(false);\n    });\n\n    it('should not match URLs with different ports', () =\u003E {\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com:8080/path', configuredResource: 'https://example.com/path' })).toBe(false);\n    });\n\n    it('should not match URLs where one path is a sub-path of another', () =\u003E {\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/mcpxxxx', configuredResource: 'https://example.com/mcp' })).toBe(false);\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/folder', configuredResource: 'https://example.com/folder/subfolder' })).toBe(false);\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/api/v1', configuredResource: 'https://example.com/api' })).toBe(true);\n    });\n\n    it('should handle trailing slashes vs no trailing slashes', () =\u003E {\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/mcp/', configuredResource: 'https://example.com/mcp' })).toBe(true);\n      expect(checkResourceAllowed({ requestedResource: 'https://example.com/folder', configuredResource: 'https://example.com/folder/' })).toBe(false);\n    });\n  });\n});\n",
      "hash": "86d7c8043a38ce95fe68f16584321778044fefd449adc45f6a9937677f67fb0f",
      "size": 4051
    },
    "/src/shared/auth-utils.ts": {
      "type": "content",
      "content": "/**\n * Utilities for handling OAuth resource URIs.\n */\n\n/**\n * Converts a server URL to a resource URL by removing the fragment.\n * RFC 8707 section 2 states that resource URIs \"MUST NOT include a fragment component\".\n * Keeps everything else unchanged (scheme, domain, port, path, query).\n */\nexport function resourceUrlFromServerUrl(url: URL | string ): URL {\n  const resourceURL = typeof url === \"string\" ? new URL(url) : new URL(url.href);\n  resourceURL.hash = ''; // Remove fragment\n  return resourceURL;\n}\n\n/**\n * Checks if a requested resource URL matches a configured resource URL.\n * A requested resource matches if it has the same scheme, domain, port,\n * and its path starts with the configured resource's path.\n *\n * @param requestedResource The resource URL being requested\n * @param configuredResource The resource URL that has been configured\n * @returns true if the requested resource matches the configured resource, false otherwise\n */\n export function checkResourceAllowed(\n   { requestedResource, configuredResource }: {\n     requestedResource: URL | string;\n     configuredResource: URL | string\n   }\n ): boolean {\n   const requested = typeof requestedResource === \"string\" ? new URL(requestedResource) : new URL(requestedResource.href);\n   const configured = typeof configuredResource === \"string\" ? new URL(configuredResource) : new URL(configuredResource.href);\n\n   // Compare the origin (scheme, domain, and port)\n   if (requested.origin !== configured.origin) {\n     return false;\n   }\n\n   // Handle cases like requested=/foo and configured=/foo/\n   if (requested.pathname.length \u003C configured.pathname.length) {\n     return false\n   }\n\n   // Check if the requested path starts with the configured path\n   // Ensure both paths end with / for proper comparison\n   // This ensures that if we have paths like \"/api\" and \"/api/users\",\n   // we properly detect that \"/api/users\" is a subpath of \"/api\"\n   // By adding a trailing slash if missing, we avoid false positives\n   // where paths like \"/api123\" would incorrectly match \"/api\"\n   const requestedPath = requested.pathname.endsWith('/') ? requested.pathname : requested.pathname + '/';\n   const configuredPath = configured.pathname.endsWith('/') ? configured.pathname : configured.pathname + '/';\n\n   return requestedPath.startsWith(configuredPath);\n }\n",
      "hash": "bccf20caf5bf398e218d02f73ec7e5703e75f6999ad3c38bd1fdcea3139a571b",
      "size": 2330
    },
    "/src/shared/auth.test.ts": {
      "type": "content",
      "content": "import { describe, it, expect } from '@jest/globals';\nimport {\n  SafeUrlSchema,\n  OAuthMetadataSchema,\n  OpenIdProviderMetadataSchema,\n  OAuthClientMetadataSchema,\n} from './auth.js';\n\ndescribe('SafeUrlSchema', () =\u003E {\n  it('accepts valid HTTPS URLs', () =\u003E {\n    expect(SafeUrlSchema.parse('https://example.com')).toBe('https://example.com');\n    expect(SafeUrlSchema.parse('https://auth.example.com/oauth/authorize')).toBe('https://auth.example.com/oauth/authorize');\n  });\n\n  it('accepts valid HTTP URLs', () =\u003E {\n    expect(SafeUrlSchema.parse('http://localhost:3000')).toBe('http://localhost:3000');\n  });\n\n  it('rejects javascript: scheme URLs', () =\u003E {\n    expect(() =\u003E SafeUrlSchema.parse('javascript:alert(1)')).toThrow('URL cannot use javascript:, data:, or vbscript: scheme');\n    expect(() =\u003E SafeUrlSchema.parse('JAVASCRIPT:alert(1)')).toThrow('URL cannot use javascript:, data:, or vbscript: scheme');\n  });\n\n  it('rejects invalid URLs', () =\u003E {\n    expect(() =\u003E SafeUrlSchema.parse('not-a-url')).toThrow();\n    expect(() =\u003E SafeUrlSchema.parse('')).toThrow();\n  });\n\n  it('works with safeParse', () =\u003E {\n    expect(() =\u003E SafeUrlSchema.safeParse('not-a-url')).not.toThrow();\n  });\n});\n\ndescribe('OAuthMetadataSchema', () =\u003E {\n  it('validates complete OAuth metadata', () =\u003E {\n    const metadata = {\n      issuer: 'https://auth.example.com',\n      authorization_endpoint: 'https://auth.example.com/oauth/authorize',\n      token_endpoint: 'https://auth.example.com/oauth/token',\n      response_types_supported: ['code'],\n      scopes_supported: ['read', 'write'],\n    };\n\n    expect(() =\u003E OAuthMetadataSchema.parse(metadata)).not.toThrow();\n  });\n\n  it('rejects metadata with javascript: URLs', () =\u003E {\n    const metadata = {\n      issuer: 'https://auth.example.com',\n      authorization_endpoint: 'javascript:alert(1)',\n      token_endpoint: 'https://auth.example.com/oauth/token',\n      response_types_supported: ['code'],\n    };\n\n    expect(() =\u003E OAuthMetadataSchema.parse(metadata)).toThrow('URL cannot use javascript:, data:, or vbscript: scheme');\n  });\n\n  it('requires mandatory fields', () =\u003E {\n    const incompleteMetadata = {\n      issuer: 'https://auth.example.com',\n    };\n\n    expect(() =\u003E OAuthMetadataSchema.parse(incompleteMetadata)).toThrow();\n  });\n});\n\ndescribe('OpenIdProviderMetadataSchema', () =\u003E {\n  it('validates complete OpenID Provider metadata', () =\u003E {\n    const metadata = {\n      issuer: 'https://auth.example.com',\n      authorization_endpoint: 'https://auth.example.com/oauth/authorize',\n      token_endpoint: 'https://auth.example.com/oauth/token',\n      jwks_uri: 'https://auth.example.com/.well-known/jwks.json',\n      response_types_supported: ['code'],\n      subject_types_supported: ['public'],\n      id_token_signing_alg_values_supported: ['RS256'],\n    };\n\n    expect(() =\u003E OpenIdProviderMetadataSchema.parse(metadata)).not.toThrow();\n  });\n\n  it('rejects metadata with javascript: in jwks_uri', () =\u003E {\n    const metadata = {\n      issuer: 'https://auth.example.com',\n      authorization_endpoint: 'https://auth.example.com/oauth/authorize',\n      token_endpoint: 'https://auth.example.com/oauth/token',\n      jwks_uri: 'javascript:alert(1)',\n      response_types_supported: ['code'],\n      subject_types_supported: ['public'],\n      id_token_signing_alg_values_supported: ['RS256'],\n    };\n\n    expect(() =\u003E OpenIdProviderMetadataSchema.parse(metadata)).toThrow('URL cannot use javascript:, data:, or vbscript: scheme');\n  });\n});\n\ndescribe('OAuthClientMetadataSchema', () =\u003E {\n  it('validates client metadata with safe URLs', () =\u003E {\n    const metadata = {\n      redirect_uris: ['https://app.example.com/callback'],\n      client_name: 'Test App',\n      client_uri: 'https://app.example.com',\n    };\n\n    expect(() =\u003E OAuthClientMetadataSchema.parse(metadata)).not.toThrow();\n  });\n\n  it('rejects client metadata with javascript: redirect URIs', () =\u003E {\n    const metadata = {\n      redirect_uris: ['javascript:alert(1)'],\n      client_name: 'Test App',\n    };\n\n    expect(() =\u003E OAuthClientMetadataSchema.parse(metadata)).toThrow('URL cannot use javascript:, data:, or vbscript: scheme');\n  });\n});\n",
      "hash": "ed528fe05f3357394745db0d5b8ab1eefd19975247624914cb74cede707bb880",
      "size": 4153
    },
    "/src/shared/auth.ts": {
      "type": "content",
      "content": "import { z } from \"zod\";\n\n/**\n * Reusable URL validation that disallows javascript: scheme\n */\nexport const SafeUrlSchema = z.string().url()\n  .superRefine((val, ctx) =\u003E {\n    if (!URL.canParse(val)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: \"URL must be parseable\",\n        fatal: true,\n      });\n\n      return z.NEVER;\n    }\n  }).refine(\n    (url) =\u003E {\n      const u = new URL(url);\n      return u.protocol !== 'javascript:' && u.protocol !== 'data:' && u.protocol !== 'vbscript:';\n    },\n    { message: \"URL cannot use javascript:, data:, or vbscript: scheme\" }\n);\n\n\n/**\n * RFC 9728 OAuth Protected Resource Metadata\n */\nexport const OAuthProtectedResourceMetadataSchema = z\n  .object({\n    resource: z.string().url(),\n    authorization_servers: z.array(SafeUrlSchema).optional(),\n    jwks_uri: z.string().url().optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    bearer_methods_supported: z.array(z.string()).optional(),\n    resource_signing_alg_values_supported: z.array(z.string()).optional(),\n    resource_name: z.string().optional(),\n    resource_documentation: z.string().optional(),\n    resource_policy_uri: z.string().url().optional(),\n    resource_tos_uri: z.string().url().optional(),\n    tls_client_certificate_bound_access_tokens: z.boolean().optional(),\n    authorization_details_types_supported: z.array(z.string()).optional(),\n    dpop_signing_alg_values_supported: z.array(z.string()).optional(),\n    dpop_bound_access_tokens_required: z.boolean().optional(),\n  })\n  .passthrough();\n\n/**\n * RFC 8414 OAuth 2.0 Authorization Server Metadata\n */\nexport const OAuthMetadataSchema = z\n  .object({\n    issuer: z.string(),\n    authorization_endpoint: SafeUrlSchema,\n    token_endpoint: SafeUrlSchema,\n    registration_endpoint: SafeUrlSchema.optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    response_types_supported: z.array(z.string()),\n    response_modes_supported: z.array(z.string()).optional(),\n    grant_types_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_signing_alg_values_supported: z\n      .array(z.string())\n      .optional(),\n    service_documentation: SafeUrlSchema.optional(),\n    revocation_endpoint: SafeUrlSchema.optional(),\n    revocation_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n    revocation_endpoint_auth_signing_alg_values_supported: z\n      .array(z.string())\n      .optional(),\n    introspection_endpoint: z.string().optional(),\n    introspection_endpoint_auth_methods_supported: z\n      .array(z.string())\n      .optional(),\n    introspection_endpoint_auth_signing_alg_values_supported: z\n      .array(z.string())\n      .optional(),\n    code_challenge_methods_supported: z.array(z.string()).optional(),\n  })\n  .passthrough();\n\n/**\n * OpenID Connect Discovery 1.0 Provider Metadata\n * see: https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n */\nexport const OpenIdProviderMetadataSchema = z\n  .object({\n    issuer: z.string(),\n    authorization_endpoint: SafeUrlSchema,\n    token_endpoint: SafeUrlSchema,\n    userinfo_endpoint: SafeUrlSchema.optional(),\n    jwks_uri: SafeUrlSchema,\n    registration_endpoint: SafeUrlSchema.optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    response_types_supported: z.array(z.string()),\n    response_modes_supported: z.array(z.string()).optional(),\n    grant_types_supported: z.array(z.string()).optional(),\n    acr_values_supported: z.array(z.string()).optional(),\n    subject_types_supported: z.array(z.string()),\n    id_token_signing_alg_values_supported: z.array(z.string()),\n    id_token_encryption_alg_values_supported: z.array(z.string()).optional(),\n    id_token_encryption_enc_values_supported: z.array(z.string()).optional(),\n    userinfo_signing_alg_values_supported: z.array(z.string()).optional(),\n    userinfo_encryption_alg_values_supported: z.array(z.string()).optional(),\n    userinfo_encryption_enc_values_supported: z.array(z.string()).optional(),\n    request_object_signing_alg_values_supported: z.array(z.string()).optional(),\n    request_object_encryption_alg_values_supported: z\n      .array(z.string())\n      .optional(),\n    request_object_encryption_enc_values_supported: z\n      .array(z.string())\n      .optional(),\n    token_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_signing_alg_values_supported: z\n      .array(z.string())\n      .optional(),\n    display_values_supported: z.array(z.string()).optional(),\n    claim_types_supported: z.array(z.string()).optional(),\n    claims_supported: z.array(z.string()).optional(),\n    service_documentation: z.string().optional(),\n    claims_locales_supported: z.array(z.string()).optional(),\n    ui_locales_supported: z.array(z.string()).optional(),\n    claims_parameter_supported: z.boolean().optional(),\n    request_parameter_supported: z.boolean().optional(),\n    request_uri_parameter_supported: z.boolean().optional(),\n    require_request_uri_registration: z.boolean().optional(),\n    op_policy_uri: SafeUrlSchema.optional(),\n    op_tos_uri: SafeUrlSchema.optional(),\n  })\n  .passthrough();\n\n/**\n * OpenID Connect Discovery metadata that may include OAuth 2.0 fields\n * This schema represents the real-world scenario where OIDC providers\n * return a mix of OpenID Connect and OAuth 2.0 metadata fields\n */\nexport const OpenIdProviderDiscoveryMetadataSchema =\n  OpenIdProviderMetadataSchema.merge(\n    OAuthMetadataSchema.pick({\n      code_challenge_methods_supported: true,\n    })\n  );\n\n/**\n * OAuth 2.1 token response\n */\nexport const OAuthTokensSchema = z\n  .object({\n    access_token: z.string(),\n    id_token: z.string().optional(), // Optional for OAuth 2.1, but necessary in OpenID Connect\n    token_type: z.string(),\n    expires_in: z.number().optional(),\n    scope: z.string().optional(),\n    refresh_token: z.string().optional(),\n  })\n  .strip();\n\n/**\n * OAuth 2.1 error response\n */\nexport const OAuthErrorResponseSchema = z\n  .object({\n    error: z.string(),\n    error_description: z.string().optional(),\n    error_uri: z.string().optional(),\n  });\n\n/**\n * RFC 7591 OAuth 2.0 Dynamic Client Registration metadata\n */\nexport const OAuthClientMetadataSchema = z.object({\n  redirect_uris: z.array(SafeUrlSchema),\n  token_endpoint_auth_method: z.string().optional(),\n  grant_types: z.array(z.string()).optional(),\n  response_types: z.array(z.string()).optional(),\n  client_name: z.string().optional(),\n  client_uri: SafeUrlSchema.optional(),\n  logo_uri: SafeUrlSchema.optional(),\n  scope: z.string().optional(),\n  contacts: z.array(z.string()).optional(),\n  tos_uri: SafeUrlSchema.optional(),\n  policy_uri: z.string().optional(),\n  jwks_uri: SafeUrlSchema.optional(),\n  jwks: z.any().optional(),\n  software_id: z.string().optional(),\n  software_version: z.string().optional(),\n  software_statement: z.string().optional(),\n}).strip();\n\n/**\n * RFC 7591 OAuth 2.0 Dynamic Client Registration client information\n */\nexport const OAuthClientInformationSchema = z.object({\n  client_id: z.string(),\n  client_secret: z.string().optional(),\n  client_id_issued_at: z.number().optional(),\n  client_secret_expires_at: z.number().optional(),\n}).strip();\n\n/**\n * RFC 7591 OAuth 2.0 Dynamic Client Registration full response (client information plus metadata)\n */\nexport const OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);\n\n/**\n * RFC 7591 OAuth 2.0 Dynamic Client Registration error response\n */\nexport const OAuthClientRegistrationErrorSchema = z.object({\n  error: z.string(),\n  error_description: z.string().optional(),\n}).strip();\n\n/**\n * RFC 7009 OAuth 2.0 Token Revocation request\n */\nexport const OAuthTokenRevocationRequestSchema = z.object({\n  token: z.string(),\n  token_type_hint: z.string().optional(),\n}).strip();\n\nexport type OAuthMetadata = z.infer\u003Ctypeof OAuthMetadataSchema\u003E;\nexport type OpenIdProviderMetadata = z.infer\u003Ctypeof OpenIdProviderMetadataSchema\u003E;\nexport type OpenIdProviderDiscoveryMetadata = z.infer\u003Ctypeof OpenIdProviderDiscoveryMetadataSchema\u003E;\n\nexport type OAuthTokens = z.infer\u003Ctypeof OAuthTokensSchema\u003E;\nexport type OAuthErrorResponse = z.infer\u003Ctypeof OAuthErrorResponseSchema\u003E;\nexport type OAuthClientMetadata = z.infer\u003Ctypeof OAuthClientMetadataSchema\u003E;\nexport type OAuthClientInformation = z.infer\u003Ctypeof OAuthClientInformationSchema\u003E;\nexport type OAuthClientInformationFull = z.infer\u003Ctypeof OAuthClientInformationFullSchema\u003E;\nexport type OAuthClientRegistrationError = z.infer\u003Ctypeof OAuthClientRegistrationErrorSchema\u003E;\nexport type OAuthTokenRevocationRequest = z.infer\u003Ctypeof OAuthTokenRevocationRequestSchema\u003E;\nexport type OAuthProtectedResourceMetadata = z.infer\u003Ctypeof OAuthProtectedResourceMetadataSchema\u003E;\n\n// Unified type for authorization server metadata\nexport type AuthorizationServerMetadata = OAuthMetadata | OpenIdProviderDiscoveryMetadata;\n",
      "hash": "fa4889ee0861d276f1183b3149802dcae6b97108ec1db0eef3074e4e3727d3d5",
      "size": 8967
    },
    "/src/shared/metadataUtils.ts": {
      "type": "content",
      "content": "import { BaseMetadata } from \"../types.js\";\n\n/**\n * Utilities for working with BaseMetadata objects.\n */\n\n/**\n * Gets the display name for an object with BaseMetadata.\n * For tools, the precedence is: title → annotations.title → name\n * For other objects: title → name\n * This implements the spec requirement: \"if no title is provided, name should be used for display purposes\"\n */\nexport function getDisplayName(metadata: BaseMetadata): string {\n  // First check for title (not undefined and not empty string)\n  if (metadata.title !== undefined && metadata.title !== '') {\n    return metadata.title;\n  }\n\n  // Then check for annotations.title (only present in Tool objects)\n  if ('annotations' in metadata) {\n    const metadataWithAnnotations = metadata as BaseMetadata & { annotations?: { title?: string } };\n    if (metadataWithAnnotations.annotations?.title) {\n      return metadataWithAnnotations.annotations.title;\n    }\n  }\n\n  // Finally fall back to name\n  return metadata.name;\n}\n",
      "hash": "b1ccc105c32cdecc952c3c4319cfbf7ad9fa1ba425e22071d86bfe5611ab2599",
      "size": 995
    },
    "/src/shared/protocol-transport-handling.test.ts": {
      "type": "content",
      "content": "import { describe, expect, test, beforeEach } from \"@jest/globals\";\nimport { Protocol } from \"./protocol.js\";\nimport { Transport } from \"./transport.js\";\nimport { Request, Notification, Result, JSONRPCMessage } from \"../types.js\";\nimport { z } from \"zod\";\n\n// Mock Transport class\nclass MockTransport implements Transport {\n  id: string;\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: unknown) =\u003E void;\n  sentMessages: JSONRPCMessage[] = [];\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  async start(): Promise\u003Cvoid\u003E {}\n  \n  async close(): Promise\u003Cvoid\u003E {\n    this.onclose?.();\n  }\n  \n  async send(message: JSONRPCMessage): Promise\u003Cvoid\u003E {\n    this.sentMessages.push(message);\n  }\n}\n\ndescribe(\"Protocol transport handling bug\", () =\u003E {\n  let protocol: Protocol\u003CRequest, Notification, Result\u003E;\n  let transportA: MockTransport;\n  let transportB: MockTransport;\n\n  beforeEach(() =\u003E {\n    protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n      protected assertCapabilityForMethod(): void {}\n      protected assertNotificationCapability(): void {}\n      protected assertRequestHandlerCapability(): void {}\n    })();\n    \n    transportA = new MockTransport(\"A\");\n    transportB = new MockTransport(\"B\");\n  });\n\n  test(\"should send response to the correct transport when multiple clients are connected\", async () =\u003E {\n    // Set up a request handler that simulates processing time\n    let resolveHandler: (value: Result) =\u003E void;\n    const handlerPromise = new Promise\u003CResult\u003E((resolve) =\u003E {\n      resolveHandler = resolve;\n    });\n\n    const TestRequestSchema = z.object({\n      method: z.literal(\"test/method\"),\n      params: z.object({\n        from: z.string()\n      }).optional()\n    });\n\n    protocol.setRequestHandler(\n      TestRequestSchema,\n      async (request) =\u003E {\n        console.log(`Processing request from ${request.params?.from}`);\n        return handlerPromise;\n      }\n    );\n\n    // Client A connects and sends a request\n    await protocol.connect(transportA);\n    \n    const requestFromA = {\n      jsonrpc: \"2.0\" as const,\n      method: \"test/method\",\n      params: { from: \"clientA\" },\n      id: 1\n    };\n    \n    // Simulate client A sending a request\n    transportA.onmessage?.(requestFromA);\n    \n    // While A's request is being processed, client B connects\n    // This overwrites the transport reference in the protocol\n    await protocol.connect(transportB);\n    \n    const requestFromB = {\n      jsonrpc: \"2.0\" as const,\n      method: \"test/method\", \n      params: { from: \"clientB\" },\n      id: 2\n    };\n    \n    // Client B sends its own request\n    transportB.onmessage?.(requestFromB);\n    \n    // Now complete A's request\n    resolveHandler!({ data: \"responseForA\" } as Result);\n    \n    // Wait for async operations to complete\n    await new Promise(resolve =\u003E setTimeout(resolve, 10));\n    \n    // Check where the responses went\n    console.log(\"Transport A received:\", transportA.sentMessages);\n    console.log(\"Transport B received:\", transportB.sentMessages);\n    \n    // FIXED: Each transport now receives its own response\n    \n    // Transport A should receive response for request ID 1\n    expect(transportA.sentMessages.length).toBe(1);\n    expect(transportA.sentMessages[0]).toMatchObject({\n      jsonrpc: \"2.0\",\n      id: 1,\n      result: { data: \"responseForA\" }\n    });\n    \n    // Transport B should only receive its own response (when implemented)\n    expect(transportB.sentMessages.length).toBe(1);\n    expect(transportB.sentMessages[0]).toMatchObject({\n      jsonrpc: \"2.0\",\n      id: 2,\n      result: { data: \"responseForA\" } // Same handler result in this test\n    });\n  });\n\n  test(\"demonstrates the timing issue with multiple rapid connections\", async () =\u003E {\n    const delays: number[] = [];\n    const results: { transport: string; response: JSONRPCMessage[] }[] = [];\n    \n    const DelayedRequestSchema = z.object({\n      method: z.literal(\"test/delayed\"),\n      params: z.object({\n        delay: z.number(),\n        client: z.string()\n      }).optional()\n    });\n\n    // Set up handler with variable delay\n    protocol.setRequestHandler(\n      DelayedRequestSchema,\n      async (request, extra) =\u003E {\n        const delay = request.params?.delay || 0;\n        delays.push(delay);\n        \n        await new Promise(resolve =\u003E setTimeout(resolve, delay));\n        \n        return { \n          processedBy: `handler-${extra.requestId}`,\n          delay: delay\n        } as Result;\n      }\n    );\n\n    // Rapid succession of connections and requests\n    await protocol.connect(transportA);\n    transportA.onmessage?.({\n      jsonrpc: \"2.0\" as const,\n      method: \"test/delayed\",\n      params: { delay: 50, client: \"A\" },\n      id: 1\n    });\n\n    // Connect B while A is processing\n    setTimeout(async () =\u003E {\n      await protocol.connect(transportB);\n      transportB.onmessage?.({\n        jsonrpc: \"2.0\" as const,\n        method: \"test/delayed\", \n        params: { delay: 10, client: \"B\" },\n        id: 2\n      });\n    }, 10);\n\n    // Wait for all processing\n    await new Promise(resolve =\u003E setTimeout(resolve, 100));\n\n    // Collect results\n    if (transportA.sentMessages.length \u003E 0) {\n      results.push({ transport: \"A\", response: transportA.sentMessages });\n    }\n    if (transportB.sentMessages.length \u003E 0) {\n      results.push({ transport: \"B\", response: transportB.sentMessages });\n    }\n\n    console.log(\"Timing test results:\", results);\n    \n    // FIXED: Each transport receives its own responses\n    expect(transportA.sentMessages.length).toBe(1);\n    expect(transportB.sentMessages.length).toBe(1);\n  });\n});",
      "hash": "dfbf418ceea3b7176ca99b6a4a2c6e5e10a5abde4f9235cc056f3da8730a9b6a",
      "size": 5641
    },
    "/src/shared/protocol.test.ts": {
      "type": "content",
      "content": "import { ZodType, z } from \"zod\";\nimport {\n  ClientCapabilities,\n  ErrorCode,\n  McpError,\n  Notification,\n  Request,\n  Result,\n  ServerCapabilities,\n} from \"../types.js\";\nimport { Protocol, mergeCapabilities } from \"./protocol.js\";\nimport { Transport } from \"./transport.js\";\n\n// Mock Transport class\nclass MockTransport implements Transport {\n  onclose?: () =\u003E void;\n  onerror?: (error: Error) =\u003E void;\n  onmessage?: (message: unknown) =\u003E void;\n\n  async start(): Promise\u003Cvoid\u003E {}\n  async close(): Promise\u003Cvoid\u003E {\n    this.onclose?.();\n  }\n  async send(_message: unknown): Promise\u003Cvoid\u003E {}\n}\n\ndescribe(\"protocol tests\", () =\u003E {\n  let protocol: Protocol\u003CRequest, Notification, Result\u003E;\n  let transport: MockTransport;\n  let sendSpy: jest.SpyInstance;\n\n  beforeEach(() =\u003E {\n    transport = new MockTransport();\n    sendSpy = jest.spyOn(transport, 'send');\n    protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n      protected assertCapabilityForMethod(): void {}\n      protected assertNotificationCapability(): void {}\n      protected assertRequestHandlerCapability(): void {}\n    })();\n  });\n\n  test(\"should throw a timeout error if the request exceeds the timeout\", async () =\u003E {\n    await protocol.connect(transport);\n    const request = { method: \"example\", params: {} };\n    try {\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      await protocol.request(request, mockSchema, {\n        timeout: 0,\n      });\n    } catch (error) {\n      expect(error).toBeInstanceOf(McpError);\n      if (error instanceof McpError) {\n        expect(error.code).toBe(ErrorCode.RequestTimeout);\n      }\n    }\n  });\n\n  test(\"should invoke onclose when the connection is closed\", async () =\u003E {\n    const oncloseMock = jest.fn();\n    protocol.onclose = oncloseMock;\n    await protocol.connect(transport);\n    await transport.close();\n    expect(oncloseMock).toHaveBeenCalled();\n  });\n\n  test(\"should not overwrite existing hooks when connecting transports\", async () =\u003E {\n    const oncloseMock = jest.fn();\n    const onerrorMock = jest.fn();\n    const onmessageMock = jest.fn();\n    transport.onclose = oncloseMock;\n    transport.onerror = onerrorMock;\n    transport.onmessage = onmessageMock;\n    await protocol.connect(transport);\n    transport.onclose();\n    transport.onerror(new Error());\n    transport.onmessage(\"\");\n    expect(oncloseMock).toHaveBeenCalled();\n    expect(onerrorMock).toHaveBeenCalled();\n    expect(onmessageMock).toHaveBeenCalled();\n  });\n\n  describe(\"_meta preservation with onprogress\", () =\u003E {\n    test(\"should preserve existing _meta when adding progressToken\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { \n        method: \"example\", \n        params: {\n          data: \"test\",\n          _meta: {\n            customField: \"customValue\",\n            anotherField: 123\n          }\n        }\n      };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const onProgressMock = jest.fn();\n      \n      protocol.request(request, mockSchema, {\n        onprogress: onProgressMock,\n      });\n      \n      expect(sendSpy).toHaveBeenCalledWith(expect.objectContaining({\n        method: \"example\",\n        params: {\n          data: \"test\",\n          _meta: {\n            customField: \"customValue\",\n            anotherField: 123,\n            progressToken: expect.any(Number)\n          }\n        },\n        jsonrpc: \"2.0\",\n        id: expect.any(Number)\n      }), expect.any(Object));\n    });\n\n    test(\"should create _meta with progressToken when no _meta exists\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { \n        method: \"example\", \n        params: {\n          data: \"test\"\n        }\n      };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const onProgressMock = jest.fn();\n      \n      protocol.request(request, mockSchema, {\n        onprogress: onProgressMock,\n      });\n      \n      expect(sendSpy).toHaveBeenCalledWith(expect.objectContaining({\n        method: \"example\",\n        params: {\n          data: \"test\",\n          _meta: {\n            progressToken: expect.any(Number)\n          }\n        },\n        jsonrpc: \"2.0\",\n        id: expect.any(Number)\n      }), expect.any(Object));\n    });\n\n    test(\"should not modify _meta when onprogress is not provided\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { \n        method: \"example\", \n        params: {\n          data: \"test\",\n          _meta: {\n            customField: \"customValue\"\n          }\n        }\n      };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      \n      protocol.request(request, mockSchema);\n      \n      expect(sendSpy).toHaveBeenCalledWith(expect.objectContaining({\n        method: \"example\",\n        params: {\n          data: \"test\",\n          _meta: {\n            customField: \"customValue\"\n          }\n        },\n        jsonrpc: \"2.0\",\n        id: expect.any(Number)\n      }), expect.any(Object));\n    });\n\n    test(\"should handle params being undefined with onprogress\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { \n        method: \"example\"\n      };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const onProgressMock = jest.fn();\n      \n      protocol.request(request, mockSchema, {\n        onprogress: onProgressMock,\n      });\n      \n      expect(sendSpy).toHaveBeenCalledWith(expect.objectContaining({\n        method: \"example\",\n        params: {\n          _meta: {\n            progressToken: expect.any(Number)\n          }\n        },\n        jsonrpc: \"2.0\",\n        id: expect.any(Number)\n      }), expect.any(Object));\n    });\n  });\n\n  describe(\"progress notification timeout behavior\", () =\u003E {\n    beforeEach(() =\u003E {\n      jest.useFakeTimers();\n    });\n    afterEach(() =\u003E {\n      jest.useRealTimers();\n    });\n\n    test(\"should not reset timeout when resetTimeoutOnProgress is false\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { method: \"example\", params: {} };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const onProgressMock = jest.fn();\n      const requestPromise = protocol.request(request, mockSchema, {\n        timeout: 1000,\n        resetTimeoutOnProgress: false,\n        onprogress: onProgressMock,\n      });\n      \n      jest.advanceTimersByTime(800);\n      \n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          method: \"notifications/progress\",\n          params: {\n            progressToken: 0,\n            progress: 50,\n            total: 100,\n          },\n        });\n      }\n      await Promise.resolve();\n      \n      expect(onProgressMock).toHaveBeenCalledWith({\n        progress: 50,\n        total: 100,\n      });\n      \n      jest.advanceTimersByTime(201);\n      \n      await expect(requestPromise).rejects.toThrow(\"Request timed out\");\n    });\n\n    test(\"should reset timeout when progress notification is received\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { method: \"example\", params: {} };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const onProgressMock = jest.fn();\n      const requestPromise = protocol.request(request, mockSchema, {\n        timeout: 1000,\n        resetTimeoutOnProgress: true,\n        onprogress: onProgressMock,\n      });\n      jest.advanceTimersByTime(800);\n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          method: \"notifications/progress\",\n          params: {\n            progressToken: 0,\n            progress: 50,\n            total: 100,\n          },\n        });\n      }\n      await Promise.resolve();\n      expect(onProgressMock).toHaveBeenCalledWith({\n        progress: 50,\n        total: 100,\n      });\n      jest.advanceTimersByTime(800);\n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          id: 0,\n          result: { result: \"success\" },\n        });\n      }\n      await Promise.resolve();\n      await expect(requestPromise).resolves.toEqual({ result: \"success\" });\n    });\n\n    test(\"should respect maxTotalTimeout\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { method: \"example\", params: {} };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const onProgressMock = jest.fn();\n      const requestPromise = protocol.request(request, mockSchema, {\n        timeout: 1000,\n        maxTotalTimeout: 150,\n        resetTimeoutOnProgress: true,\n        onprogress: onProgressMock,\n      });\n\n      // First progress notification should work\n      jest.advanceTimersByTime(80);\n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          method: \"notifications/progress\",\n          params: {\n            progressToken: 0,\n            progress: 50,\n            total: 100,\n          },\n        });\n      }\n      await Promise.resolve();\n      expect(onProgressMock).toHaveBeenCalledWith({\n        progress: 50,\n        total: 100,\n      });\n      jest.advanceTimersByTime(80);\n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          method: \"notifications/progress\",\n          params: {\n            progressToken: 0,\n            progress: 75,\n            total: 100,\n          },\n        });\n      }\n      await expect(requestPromise).rejects.toThrow(\"Maximum total timeout exceeded\");\n      expect(onProgressMock).toHaveBeenCalledTimes(1);\n    });\n\n    test(\"should timeout if no progress received within timeout period\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { method: \"example\", params: {} };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const requestPromise = protocol.request(request, mockSchema, {\n        timeout: 100,\n        resetTimeoutOnProgress: true,\n      });\n      jest.advanceTimersByTime(101);\n      await expect(requestPromise).rejects.toThrow(\"Request timed out\");\n    });\n\n    test(\"should handle multiple progress notifications correctly\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { method: \"example\", params: {} };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const onProgressMock = jest.fn();\n      const requestPromise = protocol.request(request, mockSchema, {\n        timeout: 1000,\n        resetTimeoutOnProgress: true,\n        onprogress: onProgressMock,\n      });\n\n      // Simulate multiple progress updates\n      for (let i = 1; i \u003C= 3; i++) {\n        jest.advanceTimersByTime(800);\n        if (transport.onmessage) {\n          transport.onmessage({\n            jsonrpc: \"2.0\",\n            method: \"notifications/progress\",\n            params: {\n              progressToken: 0,\n              progress: i * 25,\n              total: 100,\n            },\n          });\n        }\n        await Promise.resolve();\n        expect(onProgressMock).toHaveBeenNthCalledWith(i, {\n          progress: i * 25,\n          total: 100,\n        });\n      }\n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          id: 0,\n          result: { result: \"success\" },\n        });\n      }\n      await Promise.resolve();\n      await expect(requestPromise).resolves.toEqual({ result: \"success\" });\n    });\n\n    test(\"should handle progress notifications with message field\", async () =\u003E {\n      await protocol.connect(transport);\n      const request = { method: \"example\", params: {} };\n      const mockSchema: ZodType\u003C{ result: string }\u003E = z.object({\n        result: z.string(),\n      });\n      const onProgressMock = jest.fn();\n\n      const requestPromise = protocol.request(request, mockSchema, {\n        timeout: 1000,\n        onprogress: onProgressMock,\n      });\n\n      jest.advanceTimersByTime(200);\n\n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          method: \"notifications/progress\",\n          params: {\n            progressToken: 0,\n            progress: 25,\n            total: 100,\n            message: \"Initializing process...\",\n          },\n        });\n      }\n      await Promise.resolve();\n\n      expect(onProgressMock).toHaveBeenCalledWith({\n        progress: 25,\n        total: 100,\n        message: \"Initializing process...\",\n      });\n\n      jest.advanceTimersByTime(200);\n\n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          method: \"notifications/progress\",\n          params: {\n            progressToken: 0,\n            progress: 75,\n            total: 100,\n            message: \"Processing data...\",\n          },\n        });\n      }\n      await Promise.resolve();\n\n      expect(onProgressMock).toHaveBeenCalledWith({\n        progress: 75,\n        total: 100,\n        message: \"Processing data...\",\n      });\n\n      if (transport.onmessage) {\n        transport.onmessage({\n          jsonrpc: \"2.0\",\n          id: 0,\n          result: { result: \"success\" },\n        });\n      }\n      await Promise.resolve();\n      await expect(requestPromise).resolves.toEqual({ result: \"success\" });\n    });\n  });\n\n  describe(\"Debounced Notifications\", () =\u003E {\n    // We need to flush the microtask queue to test the debouncing logic.\n    // This helper function does that.\n    const flushMicrotasks = () =\u003E new Promise(resolve =\u003E setImmediate(resolve));\n\n      it(\"should NOT debounce a notification that has parameters\", async () =\u003E {\n      // ARRANGE\n      protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n        protected assertCapabilityForMethod(): void {}\n        protected assertNotificationCapability(): void {}\n        protected assertRequestHandlerCapability(): void {}\n      })({ debouncedNotificationMethods: ['test/debounced_with_params'] });\n      await protocol.connect(transport);\n\n      // ACT\n      // These notifications are configured for debouncing but contain params, so they should be sent immediately.\n      await protocol.notification({ method: 'test/debounced_with_params', params: { data: 1 } });\n      await protocol.notification({ method: 'test/debounced_with_params', params: { data: 2 } });\n\n      // ASSERT\n      // Both should have been sent immediately to avoid data loss.\n      expect(sendSpy).toHaveBeenCalledTimes(2);\n      expect(sendSpy).toHaveBeenCalledWith(expect.objectContaining({ params: { data: 1 } }), undefined);\n      expect(sendSpy).toHaveBeenCalledWith(expect.objectContaining({ params: { data: 2 } }), undefined);\n    });\n\n    it(\"should NOT debounce a notification that has a relatedRequestId\", async () =\u003E {\n      // ARRANGE\n      protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n        protected assertCapabilityForMethod(): void {}\n        protected assertNotificationCapability(): void {}\n        protected assertRequestHandlerCapability(): void {}\n      })({ debouncedNotificationMethods: ['test/debounced_with_options'] });\n      await protocol.connect(transport);\n\n      // ACT\n      await protocol.notification({ method: 'test/debounced_with_options' }, { relatedRequestId: 'req-1' });\n      await protocol.notification({ method: 'test/debounced_with_options' }, { relatedRequestId: 'req-2' });\n\n      // ASSERT\n      expect(sendSpy).toHaveBeenCalledTimes(2);\n      expect(sendSpy).toHaveBeenCalledWith(expect.any(Object), { relatedRequestId: 'req-1' });\n      expect(sendSpy).toHaveBeenCalledWith(expect.any(Object), { relatedRequestId: 'req-2' });\n    });\n\n    it(\"should clear pending debounced notifications on connection close\", async () =\u003E {\n      // ARRANGE\n      protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n        protected assertCapabilityForMethod(): void {}\n        protected assertNotificationCapability(): void {}\n        protected assertRequestHandlerCapability(): void {}\n      })({ debouncedNotificationMethods: ['test/debounced'] });\n      await protocol.connect(transport);\n\n      // ACT\n      // Schedule a notification but don't flush the microtask queue.\n      protocol.notification({ method: 'test/debounced' });\n\n      // Close the connection. This should clear the pending set.\n      await protocol.close();\n\n      // Now, flush the microtask queue.\n      await flushMicrotasks();\n\n      // ASSERT\n      // The send should never have happened because the transport was cleared.\n      expect(sendSpy).not.toHaveBeenCalled();\n    });\n\n    it(\"should debounce multiple synchronous calls when params property is omitted\", async () =\u003E {\n      // ARRANGE\n      protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n        protected assertCapabilityForMethod(): void {}\n        protected assertNotificationCapability(): void {}\n        protected assertRequestHandlerCapability(): void {}\n      })({ debouncedNotificationMethods: ['test/debounced'] });\n      await protocol.connect(transport);\n\n      // ACT\n      // This is the more idiomatic way to write a notification with no params.\n      protocol.notification({ method: 'test/debounced' });\n      protocol.notification({ method: 'test/debounced' });\n      protocol.notification({ method: 'test/debounced' });\n\n      expect(sendSpy).not.toHaveBeenCalled();\n      await flushMicrotasks();\n\n      // ASSERT\n      expect(sendSpy).toHaveBeenCalledTimes(1);\n      // The final sent object might not even have the `params` key, which is fine.\n      // We can check that it was called and that the params are \"falsy\".\n      const sentNotification = sendSpy.mock.calls[0][0];\n      expect(sentNotification.method).toBe('test/debounced');\n      expect(sentNotification.params).toBeUndefined();\n    });\n\n    it(\"should debounce calls when params is explicitly undefined\", async () =\u003E {\n      // ARRANGE\n      protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n        protected assertCapabilityForMethod(): void {}\n        protected assertNotificationCapability(): void {}\n        protected assertRequestHandlerCapability(): void {}\n      })({ debouncedNotificationMethods: ['test/debounced'] });\n      await protocol.connect(transport);\n\n      // ACT\n      protocol.notification({ method: 'test/debounced', params: undefined });\n      protocol.notification({ method: 'test/debounced', params: undefined });\n      await flushMicrotasks();\n\n      // ASSERT\n      expect(sendSpy).toHaveBeenCalledTimes(1);\n      expect(sendSpy).toHaveBeenCalledWith(\n        expect.objectContaining({\n          method: 'test/debounced',\n          params: undefined\n        }),\n        undefined\n      );\n    });\n\n    it(\"should send non-debounced notifications immediately and multiple times\", async () =\u003E {\n      // ARRANGE\n      protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n        protected assertCapabilityForMethod(): void {}\n        protected assertNotificationCapability(): void {}\n        protected assertRequestHandlerCapability(): void {}\n      })({ debouncedNotificationMethods: ['test/debounced'] }); // Configure for a different method\n      await protocol.connect(transport);\n\n      // ACT\n      // Call a non-debounced notification method multiple times.\n      await protocol.notification({ method: 'test/immediate' });\n      await protocol.notification({ method: 'test/immediate' });\n\n      // ASSERT\n      // Since this method is not in the debounce list, it should be sent every time.\n      expect(sendSpy).toHaveBeenCalledTimes(2);\n    });\n\n    it(\"should not debounce any notifications if the option is not provided\", async () =\u003E {\n      // ARRANGE\n      // Use the default protocol from beforeEach, which has no debounce options.\n      await protocol.connect(transport);\n\n      // ACT\n      await protocol.notification({ method: 'any/method' });\n      await protocol.notification({ method: 'any/method' });\n\n      // ASSERT\n      // Without the config, behavior should be immediate sending.\n      expect(sendSpy).toHaveBeenCalledTimes(2);\n    });\n\n    it(\"should handle sequential batches of debounced notifications correctly\", async () =\u003E {\n      // ARRANGE\n      protocol = new (class extends Protocol\u003CRequest, Notification, Result\u003E {\n        protected assertCapabilityForMethod(): void {}\n        protected assertNotificationCapability(): void {}\n        protected assertRequestHandlerCapability(): void {}\n      })({ debouncedNotificationMethods: ['test/debounced'] });\n      await protocol.connect(transport);\n\n      // ACT (Batch 1)\n      protocol.notification({ method: 'test/debounced' });\n      protocol.notification({ method: 'test/debounced' });\n      await flushMicrotasks();\n\n      // ASSERT (Batch 1)\n      expect(sendSpy).toHaveBeenCalledTimes(1);\n\n      // ACT (Batch 2)\n      // After the first batch has been sent, a new batch should be possible.\n      protocol.notification({ method: 'test/debounced' });\n      protocol.notification({ method: 'test/debounced' });\n      await flushMicrotasks();\n\n      // ASSERT (Batch 2)\n      // The total number of sends should now be 2.\n      expect(sendSpy).toHaveBeenCalledTimes(2);\n    });\n  });\n});\n\ndescribe(\"mergeCapabilities\", () =\u003E {\n  it(\"should merge client capabilities\", () =\u003E {\n    const base: ClientCapabilities = {\n      sampling: {},\n      roots: {\n        listChanged: true,\n      },\n    };\n\n    const additional: ClientCapabilities = {\n      experimental: {\n        feature: true,\n      },\n      elicitation: {},\n      roots: {\n        newProp: true,\n      },\n    };\n\n    const merged = mergeCapabilities(base, additional);\n    expect(merged).toEqual({\n      sampling: {},\n      elicitation: {},\n      roots: {\n        listChanged: true,\n        newProp: true,\n      },\n      experimental: {\n        feature: true,\n      },\n    });\n  });\n\n  it(\"should merge server capabilities\", () =\u003E {\n    const base: ServerCapabilities = {\n      logging: {},\n      prompts: {\n        listChanged: true,\n      },\n    };\n\n    const additional: ServerCapabilities = {\n      resources: {\n        subscribe: true,\n      },\n      prompts: {\n        newProp: true,\n      },\n    };\n\n    const merged = mergeCapabilities(base, additional);\n    expect(merged).toEqual({\n      logging: {},\n      prompts: {\n        listChanged: true,\n        newProp: true,\n      },\n      resources: {\n        subscribe: true,\n      },\n    });\n  });\n\n  it(\"should override existing values with additional values\", () =\u003E {\n    const base: ServerCapabilities = {\n      prompts: {\n        listChanged: false,\n      },\n    };\n\n    const additional: ServerCapabilities = {\n      prompts: {\n        listChanged: true,\n      },\n    };\n\n    const merged = mergeCapabilities(base, additional);\n    expect(merged.prompts!.listChanged).toBe(true);\n  });\n\n  it(\"should handle empty objects\", () =\u003E {\n    const base = {};\n    const additional = {};\n    const merged = mergeCapabilities(base, additional);\n    expect(merged).toEqual({});\n  });\n});\n",
      "hash": "81b12f42d9e1a63eaa80aa1c0eebde6807f105171978df40eeaddfee05566c6d",
      "size": 23298
    },
    "/src/shared/protocol.ts": {
      "type": "content",
      "content": "import { ZodLiteral, ZodObject, ZodType, z } from \"zod\";\nimport {\n  CancelledNotificationSchema,\n  ClientCapabilities,\n  ErrorCode,\n  isJSONRPCError,\n  isJSONRPCRequest,\n  isJSONRPCResponse,\n  isJSONRPCNotification,\n  JSONRPCError,\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n  McpError,\n  Notification,\n  PingRequestSchema,\n  Progress,\n  ProgressNotification,\n  ProgressNotificationSchema,\n  Request,\n  RequestId,\n  Result,\n  ServerCapabilities,\n  RequestMeta,\n  MessageExtraInfo,\n  RequestInfo,\n} from \"../types.js\";\nimport { Transport, TransportSendOptions } from \"./transport.js\";\nimport { AuthInfo } from \"../server/auth/types.js\";\n\n/**\n * Callback for progress notifications.\n */\nexport type ProgressCallback = (progress: Progress) =\u003E void;\n\n/**\n * Additional initialization options.\n */\nexport type ProtocolOptions = {\n  /**\n   * Whether to restrict emitted requests to only those that the remote side has indicated that they can handle, through their advertised capabilities.\n   *\n   * Note that this DOES NOT affect checking of _local_ side capabilities, as it is considered a logic error to mis-specify those.\n   *\n   * Currently this defaults to false, for backwards compatibility with SDK versions that did not advertise capabilities correctly. In future, this will default to true.\n   */\n  enforceStrictCapabilities?: boolean;\n  /**\n   * An array of notification method names that should be automatically debounced.\n   * Any notifications with a method in this list will be coalesced if they\n   * occur in the same tick of the event loop.\n   * e.g., ['notifications/tools/list_changed']\n   */\n  debouncedNotificationMethods?: string[];\n};\n\n/**\n * The default request timeout, in miliseconds.\n */\nexport const DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;\n\n/**\n * Options that can be given per request.\n */\nexport type RequestOptions = {\n  /**\n   * If set, requests progress notifications from the remote end (if supported). When progress notifications are received, this callback will be invoked.\n   */\n  onprogress?: ProgressCallback;\n\n  /**\n   * Can be used to cancel an in-flight request. This will cause an AbortError to be raised from request().\n   */\n  signal?: AbortSignal;\n\n  /**\n   * A timeout (in milliseconds) for this request. If exceeded, an McpError with code `RequestTimeout` will be raised from request().\n   *\n   * If not specified, `DEFAULT_REQUEST_TIMEOUT_MSEC` will be used as the timeout.\n   */\n  timeout?: number;\n\n  /**\n   * If true, receiving a progress notification will reset the request timeout.\n   * This is useful for long-running operations that send periodic progress updates.\n   * Default: false\n   */\n  resetTimeoutOnProgress?: boolean;\n\n  /**\n   * Maximum total time (in milliseconds) to wait for a response.\n   * If exceeded, an McpError with code `RequestTimeout` will be raised, regardless of progress notifications.\n   * If not specified, there is no maximum total timeout.\n   */\n  maxTotalTimeout?: number;\n} & TransportSendOptions;\n\n/**\n * Options that can be given per notification.\n */\nexport type NotificationOptions = {\n  /**\n   * May be used to indicate to the transport which incoming request to associate this outgoing notification with.\n   */\n  relatedRequestId?: RequestId;\n}\n\n/**\n * Extra data given to request handlers.\n */\nexport type RequestHandlerExtra\u003CSendRequestT extends Request,\n  SendNotificationT extends Notification\u003E = {\n    /**\n     * An abort signal used to communicate if the request was cancelled from the sender's side.\n     */\n    signal: AbortSignal;\n\n    /**\n     * Information about a validated access token, provided to request handlers.\n     */\n    authInfo?: AuthInfo;\n\n    /**\n     * The session ID from the transport, if available.\n     */\n    sessionId?: string;\n\n    /**\n     * Metadata from the original request.\n     */\n    _meta?: RequestMeta;\n\n    /**\n     * The JSON-RPC ID of the request being handled.\n     * This can be useful for tracking or logging purposes.\n     */\n    requestId: RequestId;\n\n    /**\n     * The original HTTP request.\n     */\n    requestInfo?: RequestInfo;\n\n    /**\n     * Sends a notification that relates to the current request being handled.\n     * \n     * This is used by certain transports to correctly associate related messages.\n     */\n    sendNotification: (notification: SendNotificationT) =\u003E Promise\u003Cvoid\u003E;\n\n    /**\n     * Sends a request that relates to the current request being handled.\n     * \n     * This is used by certain transports to correctly associate related messages.\n     */\n    sendRequest: \u003CU extends ZodType\u003Cobject\u003E\u003E(request: SendRequestT, resultSchema: U, options?: RequestOptions) =\u003E Promise\u003Cz.infer\u003CU\u003E\u003E;\n  };\n\n/**\n * Information about a request's timeout state\n */\ntype TimeoutInfo = {\n  timeoutId: ReturnType\u003Ctypeof setTimeout\u003E;\n  startTime: number;\n  timeout: number;\n  maxTotalTimeout?: number;\n  resetTimeoutOnProgress: boolean;\n  onTimeout: () =\u003E void;\n};\n\n/**\n * Implements MCP protocol framing on top of a pluggable transport, including\n * features like request/response linking, notifications, and progress.\n */\nexport abstract class Protocol\u003C\n  SendRequestT extends Request,\n  SendNotificationT extends Notification,\n  SendResultT extends Result,\n\u003E {\n  private _transport?: Transport;\n  private _requestMessageId = 0;\n  private _requestHandlers: Map\u003C\n    string,\n    (\n      request: JSONRPCRequest,\n      extra: RequestHandlerExtra\u003CSendRequestT, SendNotificationT\u003E,\n    ) =\u003E Promise\u003CSendResultT\u003E\n  \u003E = new Map();\n  private _requestHandlerAbortControllers: Map\u003CRequestId, AbortController\u003E =\n    new Map();\n  private _notificationHandlers: Map\u003C\n    string,\n    (notification: JSONRPCNotification) =\u003E Promise\u003Cvoid\u003E\n  \u003E = new Map();\n  private _responseHandlers: Map\u003C\n    number,\n    (response: JSONRPCResponse | Error) =\u003E void\n  \u003E = new Map();\n  private _progressHandlers: Map\u003Cnumber, ProgressCallback\u003E = new Map();\n  private _timeoutInfo: Map\u003Cnumber, TimeoutInfo\u003E = new Map();\n  private _pendingDebouncedNotifications = new Set\u003Cstring\u003E();\n\n  /**\n   * Callback for when the connection is closed for any reason.\n   *\n   * This is invoked when close() is called as well.\n   */\n  onclose?: () =\u003E void;\n\n  /**\n   * Callback for when an error occurs.\n   *\n   * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.\n   */\n  onerror?: (error: Error) =\u003E void;\n\n  /**\n   * A handler to invoke for any request types that do not have their own handler installed.\n   */\n  fallbackRequestHandler?: (\n    request: JSONRPCRequest,\n    extra: RequestHandlerExtra\u003CSendRequestT, SendNotificationT\u003E\n  ) =\u003E Promise\u003CSendResultT\u003E;\n\n  /**\n   * A handler to invoke for any notification types that do not have their own handler installed.\n   */\n  fallbackNotificationHandler?: (notification: Notification) =\u003E Promise\u003Cvoid\u003E;\n\n  constructor(private _options?: ProtocolOptions) {\n    this.setNotificationHandler(CancelledNotificationSchema, (notification) =\u003E {\n      const controller = this._requestHandlerAbortControllers.get(\n        notification.params.requestId,\n      );\n      controller?.abort(notification.params.reason);\n    });\n\n    this.setNotificationHandler(ProgressNotificationSchema, (notification) =\u003E {\n      this._onprogress(notification as unknown as ProgressNotification);\n    });\n\n    this.setRequestHandler(\n      PingRequestSchema,\n      // Automatic pong by default.\n      (_request) =\u003E ({}) as SendResultT,\n    );\n  }\n\n  private _setupTimeout(\n    messageId: number,\n    timeout: number,\n    maxTotalTimeout: number | undefined,\n    onTimeout: () =\u003E void,\n    resetTimeoutOnProgress: boolean = false\n  ) {\n    this._timeoutInfo.set(messageId, {\n      timeoutId: setTimeout(onTimeout, timeout),\n      startTime: Date.now(),\n      timeout,\n      maxTotalTimeout,\n      resetTimeoutOnProgress,\n      onTimeout\n    });\n  }\n\n  private _resetTimeout(messageId: number): boolean {\n    const info = this._timeoutInfo.get(messageId);\n    if (!info) return false;\n\n    const totalElapsed = Date.now() - info.startTime;\n    if (info.maxTotalTimeout && totalElapsed \u003E= info.maxTotalTimeout) {\n      this._timeoutInfo.delete(messageId);\n      throw new McpError(\n        ErrorCode.RequestTimeout,\n        \"Maximum total timeout exceeded\",\n        { maxTotalTimeout: info.maxTotalTimeout, totalElapsed }\n      );\n    }\n\n    clearTimeout(info.timeoutId);\n    info.timeoutId = setTimeout(info.onTimeout, info.timeout);\n    return true;\n  }\n\n  private _cleanupTimeout(messageId: number) {\n    const info = this._timeoutInfo.get(messageId);\n    if (info) {\n      clearTimeout(info.timeoutId);\n      this._timeoutInfo.delete(messageId);\n    }\n  }\n\n  /**\n   * Attaches to the given transport, starts it, and starts listening for messages.\n   *\n   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.\n   */\n  async connect(transport: Transport): Promise\u003Cvoid\u003E {\n    this._transport = transport;\n    const _onclose = this.transport?.onclose;\n    this._transport.onclose = () =\u003E {\n      _onclose?.();\n      this._onclose();\n    };\n\n    const _onerror = this.transport?.onerror;\n    this._transport.onerror = (error: Error) =\u003E {\n      _onerror?.(error);\n      this._onerror(error);\n    };\n\n    const _onmessage = this._transport?.onmessage;\n    this._transport.onmessage = (message, extra) =\u003E {\n      _onmessage?.(message, extra);\n      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n        this._onresponse(message);\n      } else if (isJSONRPCRequest(message)) {\n        this._onrequest(message, extra);\n      } else if (isJSONRPCNotification(message)) {\n        this._onnotification(message);\n      } else {\n        this._onerror(\n          new Error(`Unknown message type: ${JSON.stringify(message)}`),\n        );\n      }\n    };\n\n    await this._transport.start();\n  }\n\n  private _onclose(): void {\n    const responseHandlers = this._responseHandlers;\n    this._responseHandlers = new Map();\n    this._progressHandlers.clear();\n    this._pendingDebouncedNotifications.clear();\n    this._transport = undefined;\n    this.onclose?.();\n\n    const error = new McpError(ErrorCode.ConnectionClosed, \"Connection closed\");\n    for (const handler of responseHandlers.values()) {\n      handler(error);\n    }\n  }\n\n  private _onerror(error: Error): void {\n    this.onerror?.(error);\n  }\n\n  private _onnotification(notification: JSONRPCNotification): void {\n    const handler =\n      this._notificationHandlers.get(notification.method) ??\n      this.fallbackNotificationHandler;\n\n    // Ignore notifications not being subscribed to.\n    if (handler === undefined) {\n      return;\n    }\n\n    // Starting with Promise.resolve() puts any synchronous errors into the monad as well.\n    Promise.resolve()\n      .then(() =\u003E handler(notification))\n      .catch((error) =\u003E\n        this._onerror(\n          new Error(`Uncaught error in notification handler: ${error}`),\n        ),\n      );\n  }\n\n  private _onrequest(request: JSONRPCRequest, extra?: MessageExtraInfo): void {\n    const handler =\n      this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;\n\n    // Capture the current transport at request time to ensure responses go to the correct client\n    const capturedTransport = this._transport;\n\n    if (handler === undefined) {\n      capturedTransport\n        ?.send({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          error: {\n            code: ErrorCode.MethodNotFound,\n            message: \"Method not found\",\n          },\n        })\n        .catch((error) =\u003E\n          this._onerror(\n            new Error(`Failed to send an error response: ${error}`),\n          ),\n        );\n      return;\n    }\n\n    const abortController = new AbortController();\n    this._requestHandlerAbortControllers.set(request.id, abortController);\n\n    const fullExtra: RequestHandlerExtra\u003CSendRequestT, SendNotificationT\u003E = {\n      signal: abortController.signal,\n      sessionId: capturedTransport?.sessionId,\n      _meta: request.params?._meta,\n      sendNotification:\n        (notification) =\u003E\n          this.notification(notification, { relatedRequestId: request.id }),\n      sendRequest: (r, resultSchema, options?) =\u003E\n        this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),\n      authInfo: extra?.authInfo,\n      requestId: request.id,\n      requestInfo: extra?.requestInfo\n    };\n\n    // Starting with Promise.resolve() puts any synchronous errors into the monad as well.\n    Promise.resolve()\n      .then(() =\u003E handler(request, fullExtra))\n      .then(\n        (result) =\u003E {\n          if (abortController.signal.aborted) {\n            return;\n          }\n\n          return capturedTransport?.send({\n            result,\n            jsonrpc: \"2.0\",\n            id: request.id,\n          });\n        },\n        (error) =\u003E {\n          if (abortController.signal.aborted) {\n            return;\n          }\n\n          return capturedTransport?.send({\n            jsonrpc: \"2.0\",\n            id: request.id,\n            error: {\n              code: Number.isSafeInteger(error[\"code\"])\n                ? error[\"code\"]\n                : ErrorCode.InternalError,\n              message: error.message ?? \"Internal error\",\n            },\n          });\n        },\n      )\n      .catch((error) =\u003E\n        this._onerror(new Error(`Failed to send response: ${error}`)),\n      )\n      .finally(() =\u003E {\n        this._requestHandlerAbortControllers.delete(request.id);\n      });\n  }\n\n  private _onprogress(notification: ProgressNotification): void {\n    const { progressToken, ...params } = notification.params;\n    const messageId = Number(progressToken);\n\n    const handler = this._progressHandlers.get(messageId);\n    if (!handler) {\n      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));\n      return;\n    }\n\n    const responseHandler = this._responseHandlers.get(messageId);\n    const timeoutInfo = this._timeoutInfo.get(messageId);\n\n    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {\n      try {\n        this._resetTimeout(messageId);\n      } catch (error) {\n        responseHandler(error as Error);\n        return;\n      }\n    }\n\n    handler(params);\n  }\n\n  private _onresponse(response: JSONRPCResponse | JSONRPCError): void {\n    const messageId = Number(response.id);\n    const handler = this._responseHandlers.get(messageId);\n    if (handler === undefined) {\n      this._onerror(\n        new Error(\n          `Received a response for an unknown message ID: ${JSON.stringify(response)}`,\n        ),\n      );\n      return;\n    }\n\n    this._responseHandlers.delete(messageId);\n    this._progressHandlers.delete(messageId);\n    this._cleanupTimeout(messageId);\n\n    if (isJSONRPCResponse(response)) {\n      handler(response);\n    } else {\n      const error = new McpError(\n        response.error.code,\n        response.error.message,\n        response.error.data,\n      );\n      handler(error);\n    }\n  }\n\n  get transport(): Transport | undefined {\n    return this._transport;\n  }\n\n  /**\n   * Closes the connection.\n   */\n  async close(): Promise\u003Cvoid\u003E {\n    await this._transport?.close();\n  }\n\n  /**\n   * A method to check if a capability is supported by the remote side, for the given method to be called.\n   *\n   * This should be implemented by subclasses.\n   */\n  protected abstract assertCapabilityForMethod(\n    method: SendRequestT[\"method\"],\n  ): void;\n\n  /**\n   * A method to check if a notification is supported by the local side, for the given method to be sent.\n   *\n   * This should be implemented by subclasses.\n   */\n  protected abstract assertNotificationCapability(\n    method: SendNotificationT[\"method\"],\n  ): void;\n\n  /**\n   * A method to check if a request handler is supported by the local side, for the given method to be handled.\n   *\n   * This should be implemented by subclasses.\n   */\n  protected abstract assertRequestHandlerCapability(method: string): void;\n\n  /**\n   * Sends a request and wait for a response.\n   *\n   * Do not use this method to emit notifications! Use notification() instead.\n   */\n  request\u003CT extends ZodType\u003Cobject\u003E\u003E(\n    request: SendRequestT,\n    resultSchema: T,\n    options?: RequestOptions,\n  ): Promise\u003Cz.infer\u003CT\u003E\u003E {\n    const { relatedRequestId, resumptionToken, onresumptiontoken } = options ?? {};\n\n    return new Promise((resolve, reject) =\u003E {\n      if (!this._transport) {\n        reject(new Error(\"Not connected\"));\n        return;\n      }\n\n      if (this._options?.enforceStrictCapabilities === true) {\n        this.assertCapabilityForMethod(request.method);\n      }\n\n      options?.signal?.throwIfAborted();\n\n      const messageId = this._requestMessageId++;\n      const jsonrpcRequest: JSONRPCRequest = {\n        ...request,\n        jsonrpc: \"2.0\",\n        id: messageId,\n      };\n\n      if (options?.onprogress) {\n        this._progressHandlers.set(messageId, options.onprogress);\n        jsonrpcRequest.params = {\n          ...request.params,\n          _meta: {\n            ...(request.params?._meta || {}),\n            progressToken: messageId\n          },\n        };\n      }\n\n      const cancel = (reason: unknown) =\u003E {\n        this._responseHandlers.delete(messageId);\n        this._progressHandlers.delete(messageId);\n        this._cleanupTimeout(messageId);\n\n        this._transport\n          ?.send({\n            jsonrpc: \"2.0\",\n            method: \"notifications/cancelled\",\n            params: {\n              requestId: messageId,\n              reason: String(reason),\n            },\n          }, { relatedRequestId, resumptionToken, onresumptiontoken })\n          .catch((error) =\u003E\n            this._onerror(new Error(`Failed to send cancellation: ${error}`)),\n          );\n\n        reject(reason);\n      };\n\n      this._responseHandlers.set(messageId, (response) =\u003E {\n        if (options?.signal?.aborted) {\n          return;\n        }\n\n        if (response instanceof Error) {\n          return reject(response);\n        }\n\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      options?.signal?.addEventListener(\"abort\", () =\u003E {\n        cancel(options?.signal?.reason);\n      });\n\n      const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;\n      const timeoutHandler = () =\u003E cancel(new McpError(\n        ErrorCode.RequestTimeout,\n        \"Request timed out\",\n        { timeout }\n      ));\n\n      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);\n\n      this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) =\u003E {\n        this._cleanupTimeout(messageId);\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Emits a notification, which is a one-way message that does not expect a response.\n   */\n  async notification(notification: SendNotificationT, options?: NotificationOptions): Promise\u003Cvoid\u003E {\n    if (!this._transport) {\n      throw new Error(\"Not connected\");\n    }\n\n    this.assertNotificationCapability(notification.method);\n\n    const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];\n    // A notification can only be debounced if it's in the list AND it's \"simple\"\n    // (i.e., has no parameters and no related request ID that could be lost).\n    const canDebounce = debouncedMethods.includes(notification.method)\n      && !notification.params\n      && !(options?.relatedRequestId);\n\n    if (canDebounce) {\n      // If a notification of this type is already scheduled, do nothing.\n      if (this._pendingDebouncedNotifications.has(notification.method)) {\n        return;\n      }\n\n      // Mark this notification type as pending.\n      this._pendingDebouncedNotifications.add(notification.method);\n\n      // Schedule the actual send to happen in the next microtask.\n      // This allows all synchronous calls in the current event loop tick to be coalesced.\n      Promise.resolve().then(() =\u003E {\n        // Un-mark the notification so the next one can be scheduled.\n        this._pendingDebouncedNotifications.delete(notification.method);\n\n        // SAFETY CHECK: If the connection was closed while this was pending, abort.\n        if (!this._transport) {\n          return;\n        }\n\n        const jsonrpcNotification: JSONRPCNotification = {\n          ...notification,\n          jsonrpc: \"2.0\",\n        };\n        // Send the notification, but don't await it here to avoid blocking.\n        // Handle potential errors with a .catch().\n        this._transport?.send(jsonrpcNotification, options).catch(error =\u003E this._onerror(error));\n      });\n\n      // Return immediately.\n      return;\n    }\n\n    const jsonrpcNotification: JSONRPCNotification = {\n      ...notification,\n      jsonrpc: \"2.0\",\n    };\n\n    await this._transport.send(jsonrpcNotification, options);\n  }\n\n  /**\n   * Registers a handler to invoke when this protocol object receives a request with the given method.\n   *\n   * Note that this will replace any previous request handler for the same method.\n   */\n  setRequestHandler\u003C\n    T extends ZodObject\u003C{\n      method: ZodLiteral\u003Cstring\u003E;\n    }\u003E,\n  \u003E(\n    requestSchema: T,\n    handler: (\n      request: z.infer\u003CT\u003E,\n      extra: RequestHandlerExtra\u003CSendRequestT, SendNotificationT\u003E,\n    ) =\u003E SendResultT | Promise\u003CSendResultT\u003E,\n  ): void {\n    const method = requestSchema.shape.method.value;\n    this.assertRequestHandlerCapability(method);\n\n    this._requestHandlers.set(method, (request, extra) =\u003E {\n      return Promise.resolve(handler(requestSchema.parse(request), extra));\n    });\n  }\n\n  /**\n   * Removes the request handler for the given method.\n   */\n  removeRequestHandler(method: string): void {\n    this._requestHandlers.delete(method);\n  }\n\n  /**\n   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.\n   */\n  assertCanSetRequestHandler(method: string): void {\n    if (this._requestHandlers.has(method)) {\n      throw new Error(\n        `A request handler for ${method} already exists, which would be overridden`,\n      );\n    }\n  }\n\n  /**\n   * Registers a handler to invoke when this protocol object receives a notification with the given method.\n   *\n   * Note that this will replace any previous notification handler for the same method.\n   */\n  setNotificationHandler\u003C\n    T extends ZodObject\u003C{\n      method: ZodLiteral\u003Cstring\u003E;\n    }\u003E,\n  \u003E(\n    notificationSchema: T,\n    handler: (notification: z.infer\u003CT\u003E) =\u003E void | Promise\u003Cvoid\u003E,\n  ): void {\n    this._notificationHandlers.set(\n      notificationSchema.shape.method.value,\n      (notification) =\u003E\n        Promise.resolve(handler(notificationSchema.parse(notification))),\n    );\n  }\n\n  /**\n   * Removes the notification handler for the given method.\n   */\n  removeNotificationHandler(method: string): void {\n    this._notificationHandlers.delete(method);\n  }\n}\n\nexport function mergeCapabilities\u003C\n  T extends ServerCapabilities | ClientCapabilities,\n\u003E(base: T, additional: T): T {\n  return Object.entries(additional).reduce(\n    (acc, [key, value]) =\u003E {\n      if (value && typeof value === \"object\") {\n        acc[key] = acc[key] ? { ...acc[key], ...value } : value;\n      } else {\n        acc[key] = value;\n      }\n      return acc;\n    },\n    { ...base },\n  );\n}\n",
      "hash": "deaf1e2003a98af63befe1326d5ced2ebe4409a716c5fb2f9091b84afd51a571",
      "size": 23488
    },
    "/src/shared/stdio.test.ts": {
      "type": "content",
      "content": "import { JSONRPCMessage } from \"../types.js\";\nimport { ReadBuffer } from \"./stdio.js\";\n\nconst testMessage: JSONRPCMessage = {\n  jsonrpc: \"2.0\",\n  method: \"foobar\",\n};\n\ntest(\"should have no messages after initialization\", () =\u003E {\n  const readBuffer = new ReadBuffer();\n  expect(readBuffer.readMessage()).toBeNull();\n});\n\ntest(\"should only yield a message after a newline\", () =\u003E {\n  const readBuffer = new ReadBuffer();\n\n  readBuffer.append(Buffer.from(JSON.stringify(testMessage)));\n  expect(readBuffer.readMessage()).toBeNull();\n\n  readBuffer.append(Buffer.from(\"\\n\"));\n  expect(readBuffer.readMessage()).toEqual(testMessage);\n  expect(readBuffer.readMessage()).toBeNull();\n});\n\ntest(\"should be reusable after clearing\", () =\u003E {\n  const readBuffer = new ReadBuffer();\n\n  readBuffer.append(Buffer.from(\"foobar\"));\n  readBuffer.clear();\n  expect(readBuffer.readMessage()).toBeNull();\n\n  readBuffer.append(Buffer.from(JSON.stringify(testMessage)));\n  readBuffer.append(Buffer.from(\"\\n\"));\n  expect(readBuffer.readMessage()).toEqual(testMessage);\n});\n",
      "hash": "afa352bd49378bad0ee0513ae759e265a9bf7426c1344b782b3f9497850ad606",
      "size": 1048
    },
    "/src/shared/stdio.ts": {
      "type": "content",
      "content": "import { JSONRPCMessage, JSONRPCMessageSchema } from \"../types.js\";\n\n/**\n * Buffers a continuous stdio stream into discrete JSON-RPC messages.\n */\nexport class ReadBuffer {\n  private _buffer?: Buffer;\n\n  append(chunk: Buffer): void {\n    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;\n  }\n\n  readMessage(): JSONRPCMessage | null {\n    if (!this._buffer) {\n      return null;\n    }\n\n    const index = this._buffer.indexOf(\"\\n\");\n    if (index === -1) {\n      return null;\n    }\n\n    const line = this._buffer.toString(\"utf8\", 0, index).replace(/\\r$/, '');\n    this._buffer = this._buffer.subarray(index + 1);\n    return deserializeMessage(line);\n  }\n\n  clear(): void {\n    this._buffer = undefined;\n  }\n}\n\nexport function deserializeMessage(line: string): JSONRPCMessage {\n  return JSONRPCMessageSchema.parse(JSON.parse(line));\n}\n\nexport function serializeMessage(message: JSONRPCMessage): string {\n  return JSON.stringify(message) + \"\\n\";\n}\n",
      "hash": "c12d74d69f8c6d6f0b9c9c90c13f1b8b43dc3de599a69f12875000c275c23451",
      "size": 970
    },
    "/src/shared/transport.ts": {
      "type": "content",
      "content": "import { JSONRPCMessage, MessageExtraInfo, RequestId } from \"../types.js\";\n\nexport type FetchLike = (url: string | URL, init?: RequestInit) =\u003E Promise\u003CResponse\u003E;\n\n/**\n * Options for sending a JSON-RPC message.\n */\nexport type TransportSendOptions = {\n  /**\n   * If present, `relatedRequestId` is used to indicate to the transport which incoming request to associate this outgoing message with.\n   */\n  relatedRequestId?: RequestId;\n\n  /**\n   * The resumption token used to continue long-running requests that were interrupted.\n   *\n   * This allows clients to reconnect and continue from where they left off, if supported by the transport.\n   */\n  resumptionToken?: string;\n\n  /**\n   * A callback that is invoked when the resumption token changes, if supported by the transport.\n   *\n   * This allows clients to persist the latest token for potential reconnection.\n   */\n  onresumptiontoken?: (token: string) =\u003E void;\n}\n/**\n * Describes the minimal contract for a MCP transport that a client or server can communicate over.\n */\nexport interface Transport {\n  /**\n   * Starts processing messages on the transport, including any connection steps that might need to be taken.\n   *\n   * This method should only be called after callbacks are installed, or else messages may be lost.\n   *\n   * NOTE: This method should not be called explicitly when using Client, Server, or Protocol classes, as they will implicitly call start().\n   */\n  start(): Promise\u003Cvoid\u003E;\n\n  /**\n   * Sends a JSON-RPC message (request or response).\n   *\n   * If present, `relatedRequestId` is used to indicate to the transport which incoming request to associate this outgoing message with.\n   */\n  send(message: JSONRPCMessage, options?: TransportSendOptions): Promise\u003Cvoid\u003E;\n\n  /**\n   * Closes the connection.\n   */\n  close(): Promise\u003Cvoid\u003E;\n\n  /**\n   * Callback for when the connection is closed for any reason.\n   *\n   * This should be invoked when close() is called as well.\n   */\n  onclose?: () =\u003E void;\n\n  /**\n   * Callback for when an error occurs.\n   *\n   * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.\n   */\n  onerror?: (error: Error) =\u003E void;\n\n  /**\n   * Callback for when a message (request or response) is received over the connection.\n   *\n   * Includes the requestInfo and authInfo if the transport is authenticated.\n   *\n   * The requestInfo can be used to get the original request information (headers, etc.)\n   */\n  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) =\u003E void;\n\n  /**\n   * The session ID generated for this connection.\n   */\n  sessionId?: string;\n\n  /**\n   * Sets the protocol version used for the connection (called when the initialize response is received).\n   */\n  setProtocolVersion?: (version: string) =\u003E void;\n}\n",
      "hash": "299def0ff8614236d06680cb1ad57e5eaf5b411e2d1200ad30f756360803afed",
      "size": 2805
    },
    "/src/shared/uriTemplate.test.ts": {
      "type": "content",
      "content": "import { UriTemplate } from \"./uriTemplate.js\";\n\ndescribe(\"UriTemplate\", () =\u003E {\n  describe(\"isTemplate\", () =\u003E {\n    it(\"should return true for strings containing template expressions\", () =\u003E {\n      expect(UriTemplate.isTemplate(\"{foo}\")).toBe(true);\n      expect(UriTemplate.isTemplate(\"/users/{id}\")).toBe(true);\n      expect(UriTemplate.isTemplate(\"http://example.com/{path}/{file}\")).toBe(true);\n      expect(UriTemplate.isTemplate(\"/search{?q,limit}\")).toBe(true);\n    });\n\n    it(\"should return false for strings without template expressions\", () =\u003E {\n      expect(UriTemplate.isTemplate(\"\")).toBe(false);\n      expect(UriTemplate.isTemplate(\"plain string\")).toBe(false);\n      expect(UriTemplate.isTemplate(\"http://example.com/foo/bar\")).toBe(false);\n      expect(UriTemplate.isTemplate(\"{}\")).toBe(false); // Empty braces don't count\n      expect(UriTemplate.isTemplate(\"{ }\")).toBe(false); // Just whitespace doesn't count\n    });\n  });\n\n  describe(\"simple string expansion\", () =\u003E {\n    it(\"should expand simple string variables\", () =\u003E {\n      const template = new UriTemplate(\"http://example.com/users/{username}\");\n      expect(template.expand({ username: \"fred\" })).toBe(\n        \"http://example.com/users/fred\",\n      );\n      expect(template.variableNames).toEqual(['username'])\n    });\n\n    it(\"should handle multiple variables\", () =\u003E {\n      const template = new UriTemplate(\"{x,y}\");\n      expect(template.expand({ x: \"1024\", y: \"768\" })).toBe(\"1024,768\");\n      expect(template.variableNames).toEqual(['x', 'y'])\n    });\n\n    it(\"should encode reserved characters\", () =\u003E {\n      const template = new UriTemplate(\"{var}\");\n      expect(template.expand({ var: \"value with spaces\" })).toBe(\n        \"value%20with%20spaces\",\n      );\n    });\n  });\n\n  describe(\"reserved expansion\", () =\u003E {\n    it(\"should not encode reserved characters with + operator\", () =\u003E {\n      const template = new UriTemplate(\"{+path}/here\");\n      expect(template.expand({ path: \"/foo/bar\" })).toBe(\"/foo/bar/here\");\n      expect(template.variableNames).toEqual(['path'])\n    });\n  });\n\n  describe(\"fragment expansion\", () =\u003E {\n    it(\"should add # prefix and not encode reserved chars\", () =\u003E {\n      const template = new UriTemplate(\"X{#var}\");\n      expect(template.expand({ var: \"/test\" })).toBe(\"X#/test\");\n      expect(template.variableNames).toEqual(['var'])\n    });\n  });\n\n  describe(\"label expansion\", () =\u003E {\n    it(\"should add . prefix\", () =\u003E {\n      const template = new UriTemplate(\"X{.var}\");\n      expect(template.expand({ var: \"test\" })).toBe(\"X.test\");\n      expect(template.variableNames).toEqual(['var'])\n    });\n  });\n\n  describe(\"path expansion\", () =\u003E {\n    it(\"should add / prefix\", () =\u003E {\n      const template = new UriTemplate(\"X{/var}\");\n      expect(template.expand({ var: \"test\" })).toBe(\"X/test\");\n      expect(template.variableNames).toEqual(['var'])\n    });\n  });\n\n  describe(\"query expansion\", () =\u003E {\n    it(\"should add ? prefix and name=value format\", () =\u003E {\n      const template = new UriTemplate(\"X{?var}\");\n      expect(template.expand({ var: \"test\" })).toBe(\"X?var=test\");\n      expect(template.variableNames).toEqual(['var'])\n    });\n  });\n\n  describe(\"form continuation expansion\", () =\u003E {\n    it(\"should add & prefix and name=value format\", () =\u003E {\n      const template = new UriTemplate(\"X{&var}\");\n      expect(template.expand({ var: \"test\" })).toBe(\"X&var=test\");\n      expect(template.variableNames).toEqual(['var'])\n    });\n  });\n\n  describe(\"matching\", () =\u003E {\n    it(\"should match simple strings and extract variables\", () =\u003E {\n      const template = new UriTemplate(\"http://example.com/users/{username}\");\n      const match = template.match(\"http://example.com/users/fred\");\n      expect(match).toEqual({ username: \"fred\" });\n    });\n\n    it(\"should match multiple variables\", () =\u003E {\n      const template = new UriTemplate(\"/users/{username}/posts/{postId}\");\n      const match = template.match(\"/users/fred/posts/123\");\n      expect(match).toEqual({ username: \"fred\", postId: \"123\" });\n    });\n\n    it(\"should return null for non-matching URIs\", () =\u003E {\n      const template = new UriTemplate(\"/users/{username}\");\n      const match = template.match(\"/posts/123\");\n      expect(match).toBeNull();\n    });\n\n    it(\"should handle exploded arrays\", () =\u003E {\n      const template = new UriTemplate(\"{/list*}\");\n      const match = template.match(\"/red,green,blue\");\n      expect(match).toEqual({ list: [\"red\", \"green\", \"blue\"] });\n    });\n  });\n\n  describe(\"edge cases\", () =\u003E {\n    it(\"should handle empty variables\", () =\u003E {\n      const template = new UriTemplate(\"{empty}\");\n      expect(template.expand({})).toBe(\"\");\n      expect(template.expand({ empty: \"\" })).toBe(\"\");\n    });\n\n    it(\"should handle undefined variables\", () =\u003E {\n      const template = new UriTemplate(\"{a}{b}{c}\");\n      expect(template.expand({ b: \"2\" })).toBe(\"2\");\n    });\n\n    it(\"should handle special characters in variable names\", () =\u003E {\n      const template = new UriTemplate(\"{$var_name}\");\n      expect(template.expand({ \"$var_name\": \"value\" })).toBe(\"value\");\n    });\n  });\n\n  describe(\"complex patterns\", () =\u003E {\n    it(\"should handle nested path segments\", () =\u003E {\n      const template = new UriTemplate(\"/api/{version}/{resource}/{id}\");\n      expect(template.expand({\n        version: \"v1\",\n        resource: \"users\",\n        id: \"123\"\n      })).toBe(\"/api/v1/users/123\");\n      expect(template.variableNames).toEqual(['version', 'resource', 'id'])\n    });\n\n    it(\"should handle query parameters with arrays\", () =\u003E {\n      const template = new UriTemplate(\"/search{?tags*}\");\n      expect(template.expand({\n        tags: [\"nodejs\", \"typescript\", \"testing\"]\n      })).toBe(\"/search?tags=nodejs,typescript,testing\");\n      expect(template.variableNames).toEqual(['tags'])\n    });\n\n    it(\"should handle multiple query parameters\", () =\u003E {\n      const template = new UriTemplate(\"/search{?q,page,limit}\");\n      expect(template.expand({\n        q: \"test\",\n        page: \"1\",\n        limit: \"10\"\n      })).toBe(\"/search?q=test&page=1&limit=10\");\n      expect(template.variableNames).toEqual(['q', 'page', 'limit'])\n    });\n  });\n\n  describe(\"matching complex patterns\", () =\u003E {\n    it(\"should match nested path segments\", () =\u003E {\n      const template = new UriTemplate(\"/api/{version}/{resource}/{id}\");\n      const match = template.match(\"/api/v1/users/123\");\n      expect(match).toEqual({\n        version: \"v1\",\n        resource: \"users\",\n        id: \"123\"\n      });\n      expect(template.variableNames).toEqual(['version', 'resource', 'id'])\n    });\n\n    it(\"should match query parameters\", () =\u003E {\n      const template = new UriTemplate(\"/search{?q}\");\n      const match = template.match(\"/search?q=test\");\n      expect(match).toEqual({ q: \"test\" });\n      expect(template.variableNames).toEqual(['q'])\n    });\n\n    it(\"should match multiple query parameters\", () =\u003E {\n      const template = new UriTemplate(\"/search{?q,page}\");\n      const match = template.match(\"/search?q=test&page=1\");\n      expect(match).toEqual({ q: \"test\", page: \"1\" });\n      expect(template.variableNames).toEqual(['q', 'page'])\n    });\n\n    it(\"should handle partial matches correctly\", () =\u003E {\n      const template = new UriTemplate(\"/users/{id}\");\n      expect(template.match(\"/users/123/extra\")).toBeNull();\n      expect(template.match(\"/users\")).toBeNull();\n    });\n  });\n\n  describe(\"security and edge cases\", () =\u003E {\n    it(\"should handle extremely long input strings\", () =\u003E {\n      const longString = \"x\".repeat(100000);\n      const template = new UriTemplate(`/api/{param}`);\n      expect(template.expand({ param: longString })).toBe(`/api/${longString}`);\n      expect(template.match(`/api/${longString}`)).toEqual({ param: longString });\n    });\n\n    it(\"should handle deeply nested template expressions\", () =\u003E {\n      const template = new UriTemplate(\"{a}{b}{c}{d}{e}{f}{g}{h}{i}{j}\".repeat(1000));\n      expect(() =\u003E template.expand({\n        a: \"1\", b: \"2\", c: \"3\", d: \"4\", e: \"5\",\n        f: \"6\", g: \"7\", h: \"8\", i: \"9\", j: \"0\"\n      })).not.toThrow();\n    });\n\n    it(\"should handle malformed template expressions\", () =\u003E {\n      expect(() =\u003E new UriTemplate(\"{unclosed\")).toThrow();\n      expect(() =\u003E new UriTemplate(\"{}\")).not.toThrow();\n      expect(() =\u003E new UriTemplate(\"{,}\")).not.toThrow();\n      expect(() =\u003E new UriTemplate(\"{a}{\")).toThrow();\n    });\n\n    it(\"should handle pathological regex patterns\", () =\u003E {\n      const template = new UriTemplate(\"/api/{param}\");\n      // Create a string that could cause catastrophic backtracking\n      const input = \"/api/\" + \"a\".repeat(100000);\n      expect(() =\u003E template.match(input)).not.toThrow();\n    });\n\n    it(\"should handle invalid UTF-8 sequences\", () =\u003E {\n      const template = new UriTemplate(\"/api/{param}\");\n      const invalidUtf8 = \"���\";\n      expect(() =\u003E template.expand({ param: invalidUtf8 })).not.toThrow();\n      expect(() =\u003E template.match(`/api/${invalidUtf8}`)).not.toThrow();\n    });\n\n    it(\"should handle template/URI length mismatches\", () =\u003E {\n      const template = new UriTemplate(\"/api/{param}\");\n      expect(template.match(\"/api/\")).toBeNull();\n      expect(template.match(\"/api\")).toBeNull();\n      expect(template.match(\"/api/value/extra\")).toBeNull();\n    });\n\n    it(\"should handle repeated operators\", () =\u003E {\n      const template = new UriTemplate(\"{?a}{?b}{?c}\");\n      expect(template.expand({ a: \"1\", b: \"2\", c: \"3\" })).toBe(\"?a=1&b=2&c=3\");\n      expect(template.variableNames).toEqual(['a', 'b', 'c'])\n    });\n\n    it(\"should handle overlapping variable names\", () =\u003E {\n      const template = new UriTemplate(\"{var}{vara}\");\n      expect(template.expand({ var: \"1\", vara: \"2\" })).toBe(\"12\");\n      expect(template.variableNames).toEqual(['var', 'vara'])\n    });\n\n    it(\"should handle empty segments\", () =\u003E {\n      const template = new UriTemplate(\"///{a}////{b}////\");\n      expect(template.expand({ a: \"1\", b: \"2\" })).toBe(\"///1////2////\");\n      expect(template.match(\"///1////2////\")).toEqual({ a: \"1\", b: \"2\" });\n      expect(template.variableNames).toEqual(['a', 'b'])\n    });\n\n    it(\"should handle maximum template expression limit\", () =\u003E {\n      // Create a template with many expressions\n      const expressions = Array(10000).fill(\"{param}\").join(\"\");\n      expect(() =\u003E new UriTemplate(expressions)).not.toThrow();\n    });\n\n    it(\"should handle maximum variable name length\", () =\u003E {\n      const longName = \"a\".repeat(10000);\n      const template = new UriTemplate(`{${longName}}`);\n      const vars: Record\u003Cstring, string\u003E = {};\n      vars[longName] = \"value\";\n      expect(() =\u003E template.expand(vars)).not.toThrow();\n    });\n  });\n});\n",
      "hash": "89b5f841fd0eb8b8995cb463814dac22e57cb9412ff57d0e866a4f88cc0ffc43",
      "size": 10691
    },
    "/src/shared/uriTemplate.ts": {
      "type": "content",
      "content": "// Claude-authored implementation of RFC 6570 URI Templates\n\nexport type Variables = Record\u003Cstring, string | string[]\u003E;\n\nconst MAX_TEMPLATE_LENGTH = 1000000; // 1MB\nconst MAX_VARIABLE_LENGTH = 1000000; // 1MB\nconst MAX_TEMPLATE_EXPRESSIONS = 10000;\nconst MAX_REGEX_LENGTH = 1000000; // 1MB\n\nexport class UriTemplate {\n  /**\n   * Returns true if the given string contains any URI template expressions.\n   * A template expression is a sequence of characters enclosed in curly braces,\n   * like {foo} or {?bar}.\n   */\n  static isTemplate(str: string): boolean {\n    // Look for any sequence of characters between curly braces\n    // that isn't just whitespace\n    return /\\{[^}\\s]+\\}/.test(str);\n  }\n\n  private static validateLength(\n    str: string,\n    max: number,\n    context: string,\n  ): void {\n    if (str.length \u003E max) {\n      throw new Error(\n        `${context} exceeds maximum length of ${max} characters (got ${str.length})`,\n      );\n    }\n  }\n  private readonly template: string;\n  private readonly parts: Array\u003C\n    | string\n    | { name: string; operator: string; names: string[]; exploded: boolean }\n  \u003E;\n\n  get variableNames(): string[] {\n    return this.parts.flatMap((part) =\u003E typeof part === 'string' ? [] : part.names);\n  }\n\n  constructor(template: string) {\n    UriTemplate.validateLength(template, MAX_TEMPLATE_LENGTH, \"Template\");\n    this.template = template;\n    this.parts = this.parse(template);\n  }\n\n  toString(): string {\n    return this.template;\n  }\n\n  private parse(\n    template: string,\n  ): Array\u003C\n    | string\n    | { name: string; operator: string; names: string[]; exploded: boolean }\n  \u003E {\n    const parts: Array\u003C\n      | string\n      | { name: string; operator: string; names: string[]; exploded: boolean }\n    \u003E = [];\n    let currentText = \"\";\n    let i = 0;\n    let expressionCount = 0;\n\n    while (i \u003C template.length) {\n      if (template[i] === \"{\") {\n        if (currentText) {\n          parts.push(currentText);\n          currentText = \"\";\n        }\n        const end = template.indexOf(\"}\", i);\n        if (end === -1) throw new Error(\"Unclosed template expression\");\n\n        expressionCount++;\n        if (expressionCount \u003E MAX_TEMPLATE_EXPRESSIONS) {\n          throw new Error(\n            `Template contains too many expressions (max ${MAX_TEMPLATE_EXPRESSIONS})`,\n          );\n        }\n\n        const expr = template.slice(i + 1, end);\n        const operator = this.getOperator(expr);\n        const exploded = expr.includes(\"*\");\n        const names = this.getNames(expr);\n        const name = names[0];\n\n        // Validate variable name length\n        for (const name of names) {\n          UriTemplate.validateLength(\n            name,\n            MAX_VARIABLE_LENGTH,\n            \"Variable name\",\n          );\n        }\n\n        parts.push({ name, operator, names, exploded });\n        i = end + 1;\n      } else {\n        currentText += template[i];\n        i++;\n      }\n    }\n\n    if (currentText) {\n      parts.push(currentText);\n    }\n\n    return parts;\n  }\n\n  private getOperator(expr: string): string {\n    const operators = [\"+\", \"#\", \".\", \"/\", \"?\", \"&\"];\n    return operators.find((op) =\u003E expr.startsWith(op)) || \"\";\n  }\n\n  private getNames(expr: string): string[] {\n    const operator = this.getOperator(expr);\n    return expr\n      .slice(operator.length)\n      .split(\",\")\n      .map((name) =\u003E name.replace(\"*\", \"\").trim())\n      .filter((name) =\u003E name.length \u003E 0);\n  }\n\n  private encodeValue(value: string, operator: string): string {\n    UriTemplate.validateLength(value, MAX_VARIABLE_LENGTH, \"Variable value\");\n    if (operator === \"+\" || operator === \"#\") {\n      return encodeURI(value);\n    }\n    return encodeURIComponent(value);\n  }\n\n  private expandPart(\n    part: {\n      name: string;\n      operator: string;\n      names: string[];\n      exploded: boolean;\n    },\n    variables: Variables,\n  ): string {\n    if (part.operator === \"?\" || part.operator === \"&\") {\n      const pairs = part.names\n        .map((name) =\u003E {\n          const value = variables[name];\n          if (value === undefined) return \"\";\n          const encoded = Array.isArray(value)\n            ? value.map((v) =\u003E this.encodeValue(v, part.operator)).join(\",\")\n            : this.encodeValue(value.toString(), part.operator);\n          return `${name}=${encoded}`;\n        })\n        .filter((pair) =\u003E pair.length \u003E 0);\n\n      if (pairs.length === 0) return \"\";\n      const separator = part.operator === \"?\" ? \"?\" : \"&\";\n      return separator + pairs.join(\"&\");\n    }\n\n    if (part.names.length \u003E 1) {\n      const values = part.names\n        .map((name) =\u003E variables[name])\n        .filter((v) =\u003E v !== undefined);\n      if (values.length === 0) return \"\";\n      return values.map((v) =\u003E (Array.isArray(v) ? v[0] : v)).join(\",\");\n    }\n\n    const value = variables[part.name];\n    if (value === undefined) return \"\";\n\n    const values = Array.isArray(value) ? value : [value];\n    const encoded = values.map((v) =\u003E this.encodeValue(v, part.operator));\n\n    switch (part.operator) {\n      case \"\":\n        return encoded.join(\",\");\n      case \"+\":\n        return encoded.join(\",\");\n      case \"#\":\n        return \"#\" + encoded.join(\",\");\n      case \".\":\n        return \".\" + encoded.join(\".\");\n      case \"/\":\n        return \"/\" + encoded.join(\"/\");\n      default:\n        return encoded.join(\",\");\n    }\n  }\n\n  expand(variables: Variables): string {\n    let result = \"\";\n    let hasQueryParam = false;\n\n    for (const part of this.parts) {\n      if (typeof part === \"string\") {\n        result += part;\n        continue;\n      }\n\n      const expanded = this.expandPart(part, variables);\n      if (!expanded) continue;\n\n      // Convert ? to & if we already have a query parameter\n      if ((part.operator === \"?\" || part.operator === \"&\") && hasQueryParam) {\n        result += expanded.replace(\"?\", \"&\");\n      } else {\n        result += expanded;\n      }\n\n      if (part.operator === \"?\" || part.operator === \"&\") {\n        hasQueryParam = true;\n      }\n    }\n\n    return result;\n  }\n\n  private escapeRegExp(str: string): string {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n\n  private partToRegExp(part: {\n    name: string;\n    operator: string;\n    names: string[];\n    exploded: boolean;\n  }): Array\u003C{ pattern: string; name: string }\u003E {\n    const patterns: Array\u003C{ pattern: string; name: string }\u003E = [];\n\n    // Validate variable name length for matching\n    for (const name of part.names) {\n      UriTemplate.validateLength(name, MAX_VARIABLE_LENGTH, \"Variable name\");\n    }\n\n    if (part.operator === \"?\" || part.operator === \"&\") {\n      for (let i = 0; i \u003C part.names.length; i++) {\n        const name = part.names[i];\n        const prefix = i === 0 ? \"\\\\\" + part.operator : \"&\";\n        patterns.push({\n          pattern: prefix + this.escapeRegExp(name) + \"=([^&]+)\",\n          name,\n        });\n      }\n      return patterns;\n    }\n\n    let pattern: string;\n    const name = part.name;\n\n    switch (part.operator) {\n      case \"\":\n        pattern = part.exploded ? \"([^/]+(?:,[^/]+)*)\" : \"([^/,]+)\";\n        break;\n      case \"+\":\n      case \"#\":\n        pattern = \"(.+)\";\n        break;\n      case \".\":\n        pattern = \"\\\\.([^/,]+)\";\n        break;\n      case \"/\":\n        pattern = \"/\" + (part.exploded ? \"([^/]+(?:,[^/]+)*)\" : \"([^/,]+)\");\n        break;\n      default:\n        pattern = \"([^/]+)\";\n    }\n\n    patterns.push({ pattern, name });\n    return patterns;\n  }\n\n  match(uri: string): Variables | null {\n    UriTemplate.validateLength(uri, MAX_TEMPLATE_LENGTH, \"URI\");\n    let pattern = \"^\";\n    const names: Array\u003C{ name: string; exploded: boolean }\u003E = [];\n\n    for (const part of this.parts) {\n      if (typeof part === \"string\") {\n        pattern += this.escapeRegExp(part);\n      } else {\n        const patterns = this.partToRegExp(part);\n        for (const { pattern: partPattern, name } of patterns) {\n          pattern += partPattern;\n          names.push({ name, exploded: part.exploded });\n        }\n      }\n    }\n\n    pattern += \"$\";\n    UriTemplate.validateLength(\n      pattern,\n      MAX_REGEX_LENGTH,\n      \"Generated regex pattern\",\n    );\n    const regex = new RegExp(pattern);\n    const match = uri.match(regex);\n\n    if (!match) return null;\n\n    const result: Variables = {};\n    for (let i = 0; i \u003C names.length; i++) {\n      const { name, exploded } = names[i];\n      const value = match[i + 1];\n      const cleanName = name.replace(\"*\", \"\");\n\n      if (exploded && value.includes(\",\")) {\n        result[cleanName] = value.split(\",\");\n      } else {\n        result[cleanName] = value;\n      }\n    }\n\n    return result;\n  }\n}\n",
      "hash": "5bae6eff367d2fa5442ac92200c67a366984a8652fafc42c0db77bb3555d2f02",
      "size": 8629
    },
    "/src/spec.types.test.ts": {
      "type": "content",
      "content": "/**\n * This contains:\n * - Static type checks to verify the Spec's types are compatible with the SDK's types\n *   (mutually assignable, w/ slight affordances to get rid of ZodObject.passthrough() index signatures, etc)\n * - Runtime checks to verify each Spec type has a static check\n *   (note: a few don't have SDK types, see MISSING_SDK_TYPES below)\n */\nimport * as SDKTypes from \"./types.js\";\nimport * as SpecTypes from \"../spec.types.js\";\nimport fs from \"node:fs\";\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-unsafe-function-type */\n\n// Removes index signatures added by ZodObject.passthrough().\ntype RemovePassthrough\u003CT\u003E = T extends object\n  ? T extends Array\u003Cinfer U\u003E\n    ? Array\u003CRemovePassthrough\u003CU\u003E\u003E\n    : T extends Function\n        ? T\n        : {[K in keyof T as string extends K ? never : K]: RemovePassthrough\u003CT[K]\u003E}\n    : T;\n\ntype IsUnknown\u003CT\u003E = [unknown] extends [T] ? [T] extends [unknown] ? true : false : false;\n\n// Turns {x?: unknown} into {x: unknown} but keeps {_meta?: unknown} unchanged (and leaves other optional properties unchanged, e.g. {x?: string}).\n// This works around an apparent quirk of ZodObject.unknown() (makes fields optional)\ntype MakeUnknownsNotOptional\u003CT\u003E =\n  IsUnknown\u003CT\u003E extends true\n    ? unknown\n    : (T extends object\n      ? (T extends Array\u003Cinfer U\u003E\n        ? Array\u003CMakeUnknownsNotOptional\u003CU\u003E\u003E\n        : (T extends Function\n          ? T\n          : Pick\u003CT, never\u003E & {\n            // Start with empty object to avoid duplicates\n            // Make unknown properties required (except _meta)\n            [K in keyof T as '_meta' extends K ? never : IsUnknown\u003CT[K]\u003E extends true ? K : never]-?: unknown;\n          } &\n          Pick\u003CT, {\n            // Pick all _meta and non-unknown properties with original modifiers\n            [K in keyof T]: '_meta' extends K ? K : IsUnknown\u003CT[K]\u003E extends true ? never : K\n          }[keyof T]\u003E & {\n            // Recurse on the picked properties\n            [K in keyof Pick\u003CT, {[K in keyof T]: '_meta' extends K ? K : IsUnknown\u003CT[K]\u003E extends true ? never : K}[keyof T]\u003E]: MakeUnknownsNotOptional\u003CT[K]\u003E\n          }))\n      : T);\n\nfunction checkCancelledNotification(\n  sdk: SDKTypes.CancelledNotification,\n  spec: SpecTypes.CancelledNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkBaseMetadata(\n  sdk: RemovePassthrough\u003CSDKTypes.BaseMetadata\u003E,\n  spec: SpecTypes.BaseMetadata\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkImplementation(\n  sdk: RemovePassthrough\u003CSDKTypes.Implementation\u003E,\n  spec: SpecTypes.Implementation\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkProgressNotification(\n  sdk: SDKTypes.ProgressNotification,\n  spec: SpecTypes.ProgressNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\n\nfunction checkSubscribeRequest(\n  sdk: SDKTypes.SubscribeRequest,\n  spec: SpecTypes.SubscribeRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkUnsubscribeRequest(\n  sdk: SDKTypes.UnsubscribeRequest,\n  spec: SpecTypes.UnsubscribeRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPaginatedRequest(\n  sdk: SDKTypes.PaginatedRequest,\n  spec: SpecTypes.PaginatedRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPaginatedResult(\n  sdk: SDKTypes.PaginatedResult,\n  spec: SpecTypes.PaginatedResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListRootsRequest(\n  sdk: SDKTypes.ListRootsRequest,\n  spec: SpecTypes.ListRootsRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListRootsResult(\n  sdk: RemovePassthrough\u003CSDKTypes.ListRootsResult\u003E,\n  spec: SpecTypes.ListRootsResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkRoot(\n  sdk: RemovePassthrough\u003CSDKTypes.Root\u003E,\n  spec: SpecTypes.Root\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkElicitRequest(\n  sdk: RemovePassthrough\u003CSDKTypes.ElicitRequest\u003E,\n  spec: SpecTypes.ElicitRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkElicitResult(\n  sdk: RemovePassthrough\u003CSDKTypes.ElicitResult\u003E,\n  spec: SpecTypes.ElicitResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkCompleteRequest(\n  sdk: RemovePassthrough\u003CSDKTypes.CompleteRequest\u003E,\n  spec: SpecTypes.CompleteRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkCompleteResult(\n  sdk: SDKTypes.CompleteResult,\n  spec: SpecTypes.CompleteResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkProgressToken(\n  sdk: SDKTypes.ProgressToken,\n  spec: SpecTypes.ProgressToken\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkCursor(\n  sdk: SDKTypes.Cursor,\n  spec: SpecTypes.Cursor\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkRequest(\n  sdk: SDKTypes.Request,\n  spec: SpecTypes.Request\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkResult(\n  sdk: SDKTypes.Result,\n  spec: SpecTypes.Result\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkRequestId(\n  sdk: SDKTypes.RequestId,\n  spec: SpecTypes.RequestId\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkJSONRPCRequest(\n  sdk: SDKTypes.JSONRPCRequest,\n  spec: SpecTypes.JSONRPCRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkJSONRPCNotification(\n  sdk: SDKTypes.JSONRPCNotification,\n  spec: SpecTypes.JSONRPCNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkJSONRPCResponse(\n  sdk: SDKTypes.JSONRPCResponse,\n  spec: SpecTypes.JSONRPCResponse\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkEmptyResult(\n  sdk: SDKTypes.EmptyResult,\n  spec: SpecTypes.EmptyResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkNotification(\n  sdk: SDKTypes.Notification,\n  spec: SpecTypes.Notification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkClientResult(\n  sdk: SDKTypes.ClientResult,\n  spec: SpecTypes.ClientResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkClientNotification(\n  sdk: SDKTypes.ClientNotification,\n  spec: SpecTypes.ClientNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkServerResult(\n  sdk: SDKTypes.ServerResult,\n  spec: SpecTypes.ServerResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkResourceTemplateReference(\n  sdk: RemovePassthrough\u003CSDKTypes.ResourceTemplateReference\u003E,\n  spec: SpecTypes.ResourceTemplateReference\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPromptReference(\n  sdk: RemovePassthrough\u003CSDKTypes.PromptReference\u003E,\n  spec: SpecTypes.PromptReference\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkToolAnnotations(\n  sdk: RemovePassthrough\u003CSDKTypes.ToolAnnotations\u003E,\n  spec: SpecTypes.ToolAnnotations\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkTool(\n  sdk: RemovePassthrough\u003CSDKTypes.Tool\u003E,\n  spec: SpecTypes.Tool\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListToolsRequest(\n  sdk: SDKTypes.ListToolsRequest,\n  spec: SpecTypes.ListToolsRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListToolsResult(\n  sdk: RemovePassthrough\u003CSDKTypes.ListToolsResult\u003E,\n  spec: SpecTypes.ListToolsResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkCallToolResult(\n  sdk: RemovePassthrough\u003CSDKTypes.CallToolResult\u003E,\n  spec: SpecTypes.CallToolResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkCallToolRequest(\n  sdk: SDKTypes.CallToolRequest,\n  spec: SpecTypes.CallToolRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkToolListChangedNotification(\n  sdk: SDKTypes.ToolListChangedNotification,\n  spec: SpecTypes.ToolListChangedNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkResourceListChangedNotification(\n  sdk: SDKTypes.ResourceListChangedNotification,\n  spec: SpecTypes.ResourceListChangedNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPromptListChangedNotification(\n  sdk: SDKTypes.PromptListChangedNotification,\n  spec: SpecTypes.PromptListChangedNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkRootsListChangedNotification(\n  sdk: SDKTypes.RootsListChangedNotification,\n  spec: SpecTypes.RootsListChangedNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkResourceUpdatedNotification(\n  sdk: SDKTypes.ResourceUpdatedNotification,\n  spec: SpecTypes.ResourceUpdatedNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkSamplingMessage(\n  sdk: RemovePassthrough\u003CSDKTypes.SamplingMessage\u003E,\n  spec: SpecTypes.SamplingMessage\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkCreateMessageResult(\n  sdk: RemovePassthrough\u003CSDKTypes.CreateMessageResult\u003E,\n  spec: SpecTypes.CreateMessageResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkSetLevelRequest(\n  sdk: SDKTypes.SetLevelRequest,\n  spec: SpecTypes.SetLevelRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPingRequest(\n  sdk: SDKTypes.PingRequest,\n  spec: SpecTypes.PingRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkInitializedNotification(\n  sdk: SDKTypes.InitializedNotification,\n  spec: SpecTypes.InitializedNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListResourcesRequest(\n  sdk: SDKTypes.ListResourcesRequest,\n  spec: SpecTypes.ListResourcesRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListResourcesResult(\n  sdk: RemovePassthrough\u003CSDKTypes.ListResourcesResult\u003E,\n  spec: SpecTypes.ListResourcesResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListResourceTemplatesRequest(\n  sdk: SDKTypes.ListResourceTemplatesRequest,\n  spec: SpecTypes.ListResourceTemplatesRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListResourceTemplatesResult(\n  sdk: RemovePassthrough\u003CSDKTypes.ListResourceTemplatesResult\u003E,\n  spec: SpecTypes.ListResourceTemplatesResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkReadResourceRequest(\n  sdk: SDKTypes.ReadResourceRequest,\n  spec: SpecTypes.ReadResourceRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkReadResourceResult(\n  sdk: RemovePassthrough\u003CSDKTypes.ReadResourceResult\u003E,\n  spec: SpecTypes.ReadResourceResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkResourceContents(\n  sdk: RemovePassthrough\u003CSDKTypes.ResourceContents\u003E,\n  spec: SpecTypes.ResourceContents\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkTextResourceContents(\n  sdk: RemovePassthrough\u003CSDKTypes.TextResourceContents\u003E,\n  spec: SpecTypes.TextResourceContents\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkBlobResourceContents(\n  sdk: RemovePassthrough\u003CSDKTypes.BlobResourceContents\u003E,\n  spec: SpecTypes.BlobResourceContents\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkResource(\n  sdk: RemovePassthrough\u003CSDKTypes.Resource\u003E,\n  spec: SpecTypes.Resource\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkResourceTemplate(\n  sdk: RemovePassthrough\u003CSDKTypes.ResourceTemplate\u003E,\n  spec: SpecTypes.ResourceTemplate\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPromptArgument(\n  sdk: RemovePassthrough\u003CSDKTypes.PromptArgument\u003E,\n  spec: SpecTypes.PromptArgument\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPrompt(\n  sdk: RemovePassthrough\u003CSDKTypes.Prompt\u003E,\n  spec: SpecTypes.Prompt\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListPromptsRequest(\n  sdk: SDKTypes.ListPromptsRequest,\n  spec: SpecTypes.ListPromptsRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkListPromptsResult(\n  sdk: RemovePassthrough\u003CSDKTypes.ListPromptsResult\u003E,\n  spec: SpecTypes.ListPromptsResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkGetPromptRequest(\n  sdk: SDKTypes.GetPromptRequest,\n  spec: SpecTypes.GetPromptRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkTextContent(\n  sdk: RemovePassthrough\u003CSDKTypes.TextContent\u003E,\n  spec: SpecTypes.TextContent\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkImageContent(\n  sdk: RemovePassthrough\u003CSDKTypes.ImageContent\u003E,\n  spec: SpecTypes.ImageContent\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkAudioContent(\n  sdk: RemovePassthrough\u003CSDKTypes.AudioContent\u003E,\n  spec: SpecTypes.AudioContent\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkEmbeddedResource(\n  sdk: RemovePassthrough\u003CSDKTypes.EmbeddedResource\u003E,\n  spec: SpecTypes.EmbeddedResource\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkResourceLink(\n  sdk: RemovePassthrough\u003CSDKTypes.ResourceLink\u003E,\n  spec: SpecTypes.ResourceLink\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkContentBlock(\n  sdk: RemovePassthrough\u003CSDKTypes.ContentBlock\u003E,\n  spec: SpecTypes.ContentBlock\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPromptMessage(\n  sdk: RemovePassthrough\u003CSDKTypes.PromptMessage\u003E,\n  spec: SpecTypes.PromptMessage\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkGetPromptResult(\n  sdk: RemovePassthrough\u003CSDKTypes.GetPromptResult\u003E,\n  spec: SpecTypes.GetPromptResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkBooleanSchema(\n  sdk: RemovePassthrough\u003CSDKTypes.BooleanSchema\u003E,\n  spec: SpecTypes.BooleanSchema\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkStringSchema(\n  sdk: RemovePassthrough\u003CSDKTypes.StringSchema\u003E,\n  spec: SpecTypes.StringSchema\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkNumberSchema(\n  sdk: RemovePassthrough\u003CSDKTypes.NumberSchema\u003E,\n  spec: SpecTypes.NumberSchema\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkEnumSchema(\n  sdk: RemovePassthrough\u003CSDKTypes.EnumSchema\u003E,\n  spec: SpecTypes.EnumSchema\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkPrimitiveSchemaDefinition(\n  sdk: RemovePassthrough\u003CSDKTypes.PrimitiveSchemaDefinition\u003E,\n  spec: SpecTypes.PrimitiveSchemaDefinition\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkJSONRPCError(\n  sdk: SDKTypes.JSONRPCError,\n  spec: SpecTypes.JSONRPCError\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkJSONRPCMessage(\n  sdk: SDKTypes.JSONRPCMessage,\n  spec: SpecTypes.JSONRPCMessage\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkCreateMessageRequest(\n  sdk: RemovePassthrough\u003CSDKTypes.CreateMessageRequest\u003E,\n  spec: SpecTypes.CreateMessageRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkInitializeRequest(\n  sdk: RemovePassthrough\u003CSDKTypes.InitializeRequest\u003E,\n  spec: SpecTypes.InitializeRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkInitializeResult(\n  sdk: RemovePassthrough\u003CSDKTypes.InitializeResult\u003E,\n  spec: SpecTypes.InitializeResult\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkClientCapabilities(\n  sdk: RemovePassthrough\u003CSDKTypes.ClientCapabilities\u003E,\n  spec: SpecTypes.ClientCapabilities\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkServerCapabilities(\n  sdk: RemovePassthrough\u003CSDKTypes.ServerCapabilities\u003E,\n  spec: SpecTypes.ServerCapabilities\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkClientRequest(\n  sdk: RemovePassthrough\u003CSDKTypes.ClientRequest\u003E,\n  spec: SpecTypes.ClientRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkServerRequest(\n  sdk: RemovePassthrough\u003CSDKTypes.ServerRequest\u003E,\n  spec: SpecTypes.ServerRequest\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkLoggingMessageNotification(\n  sdk: MakeUnknownsNotOptional\u003CSDKTypes.LoggingMessageNotification\u003E,\n  spec: SpecTypes.LoggingMessageNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkServerNotification(\n  sdk: MakeUnknownsNotOptional\u003CSDKTypes.ServerNotification\u003E,\n  spec: SpecTypes.ServerNotification\n) {\n  sdk = spec;\n  spec = sdk;\n}\nfunction checkLoggingLevel(\n  sdk: SDKTypes.LoggingLevel,\n  spec: SpecTypes.LoggingLevel\n) {\n  sdk = spec;\n  spec = sdk;\n}\n\n// This file is .gitignore'd, and fetched by `npm run fetch:spec-types` (called by `npm run test`)\nconst SPEC_TYPES_FILE  = 'spec.types.ts';\nconst SDK_TYPES_FILE  = 'src/types.ts';\n\nconst MISSING_SDK_TYPES = [\n  // These are inlined in the SDK:\n  'Role',\n\n  // These aren't supported by the SDK yet:\n  // TODO: Add definitions to the SDK\n  'Annotations',\n  'ModelHint',\n  'ModelPreferences',\n]\n\nfunction extractExportedTypes(source: string): string[] {\n  return [...source.matchAll(/export\\s+(?:interface|class|type)\\s+(\\w+)\\b/g)].map(m =\u003E m[1]);\n}\n\ndescribe('Spec Types', () =\u003E {\n  const specTypes = extractExportedTypes(fs.readFileSync(SPEC_TYPES_FILE, 'utf-8'));\n  const sdkTypes = extractExportedTypes(fs.readFileSync(SDK_TYPES_FILE, 'utf-8'));\n  const testSource = fs.readFileSync(__filename, 'utf-8');\n\n  it('should define some expected types', () =\u003E {\n    expect(specTypes).toContain('JSONRPCNotification');\n    expect(specTypes).toContain('ElicitResult');\n    expect(specTypes).toHaveLength(91);\n  });\n\n  it('should have up to date list of missing sdk types', () =\u003E {\n    for (const typeName of MISSING_SDK_TYPES) {\n      expect(sdkTypes).not.toContain(typeName);\n    }\n  });\n\n  for (const type of specTypes) {\n    if (MISSING_SDK_TYPES.includes(type)) {\n      continue; // Skip missing SDK types\n    }\n    it(`${type} should have a compatibility test`, () =\u003E {\n      expect(testSource).toContain(`function check${type}(`);\n    });\n  }\n});\n",
      "hash": "4b4a46bffd035aea3fcade4c1a9161cfdc7d60daeb19e425d3323152c9bc26cd",
      "size": 16230
    },
    "/src/types.test.ts": {
      "type": "content",
      "content": "import {\n    LATEST_PROTOCOL_VERSION,\n    SUPPORTED_PROTOCOL_VERSIONS,\n    ResourceLinkSchema,\n    ContentBlockSchema,\n    PromptMessageSchema,\n    CallToolResultSchema,\n    CompleteRequestSchema\n} from \"./types.js\";\n\ndescribe(\"Types\", () =\u003E {\n\n    test(\"should have correct latest protocol version\", () =\u003E {\n        expect(LATEST_PROTOCOL_VERSION).toBeDefined();\n        expect(LATEST_PROTOCOL_VERSION).toBe(\"2025-06-18\");\n    });\n    test(\"should have correct supported protocol versions\", () =\u003E {\n        expect(SUPPORTED_PROTOCOL_VERSIONS).toBeDefined();\n        expect(SUPPORTED_PROTOCOL_VERSIONS).toBeInstanceOf(Array);\n        expect(SUPPORTED_PROTOCOL_VERSIONS).toContain(LATEST_PROTOCOL_VERSION);\n        expect(SUPPORTED_PROTOCOL_VERSIONS).toContain(\"2024-11-05\");\n        expect(SUPPORTED_PROTOCOL_VERSIONS).toContain(\"2024-10-07\");\n        expect(SUPPORTED_PROTOCOL_VERSIONS).toContain(\"2025-03-26\");\n    });\n\n    describe(\"ResourceLink\", () =\u003E {\n        test(\"should validate a minimal ResourceLink\", () =\u003E {\n            const resourceLink = {\n                type: \"resource_link\",\n                uri: \"file:///path/to/file.txt\",\n                name: \"file.txt\"\n            };\n\n            const result = ResourceLinkSchema.safeParse(resourceLink);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.type).toBe(\"resource_link\");\n                expect(result.data.uri).toBe(\"file:///path/to/file.txt\");\n                expect(result.data.name).toBe(\"file.txt\");\n            }\n        });\n\n        test(\"should validate a ResourceLink with all optional fields\", () =\u003E {\n            const resourceLink = {\n                type: \"resource_link\",\n                uri: \"https://example.com/resource\",\n                name: \"Example Resource\",\n                title: \"A comprehensive example resource\",\n                description: \"This resource demonstrates all fields\",\n                mimeType: \"text/plain\",\n                _meta: { custom: \"metadata\" }\n            };\n\n            const result = ResourceLinkSchema.safeParse(resourceLink);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.title).toBe(\"A comprehensive example resource\");\n                expect(result.data.description).toBe(\"This resource demonstrates all fields\");\n                expect(result.data.mimeType).toBe(\"text/plain\");\n                expect(result.data._meta).toEqual({ custom: \"metadata\" });\n            }\n        });\n\n        test(\"should fail validation for invalid type\", () =\u003E {\n            const invalidResourceLink = {\n                type: \"invalid_type\",\n                uri: \"file:///path/to/file.txt\",\n                name: \"file.txt\"\n            };\n\n            const result = ResourceLinkSchema.safeParse(invalidResourceLink);\n            expect(result.success).toBe(false);\n        });\n\n        test(\"should fail validation for missing required fields\", () =\u003E {\n            const invalidResourceLink = {\n                type: \"resource_link\",\n                uri: \"file:///path/to/file.txt\"\n                // missing name\n            };\n\n            const result = ResourceLinkSchema.safeParse(invalidResourceLink);\n            expect(result.success).toBe(false);\n        });\n    });\n\n    describe(\"ContentBlock\", () =\u003E {\n        test(\"should validate text content\", () =\u003E {\n            const textContent = {\n                type: \"text\",\n                text: \"Hello, world!\"\n            };\n\n            const result = ContentBlockSchema.safeParse(textContent);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.type).toBe(\"text\");\n            }\n        });\n\n        test(\"should validate image content\", () =\u003E {\n            const imageContent = {\n                type: \"image\",\n                data: \"aGVsbG8=\", // base64 encoded \"hello\"\n                mimeType: \"image/png\"\n            };\n\n            const result = ContentBlockSchema.safeParse(imageContent);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.type).toBe(\"image\");\n            }\n        });\n\n        test(\"should validate audio content\", () =\u003E {\n            const audioContent = {\n                type: \"audio\",\n                data: \"aGVsbG8=\", // base64 encoded \"hello\"\n                mimeType: \"audio/mp3\"\n            };\n\n            const result = ContentBlockSchema.safeParse(audioContent);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.type).toBe(\"audio\");\n            }\n        });\n\n        test(\"should validate resource link content\", () =\u003E {\n            const resourceLink = {\n                type: \"resource_link\",\n                uri: \"file:///path/to/file.txt\",\n                name: \"file.txt\",\n                mimeType: \"text/plain\"\n            };\n\n            const result = ContentBlockSchema.safeParse(resourceLink);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.type).toBe(\"resource_link\");\n            }\n        });\n\n        test(\"should validate embedded resource content\", () =\u003E {\n            const embeddedResource = {\n                type: \"resource\",\n                resource: {\n                    uri: \"file:///path/to/file.txt\",\n                    mimeType: \"text/plain\",\n                    text: \"File contents\"\n                }\n            };\n\n            const result = ContentBlockSchema.safeParse(embeddedResource);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.type).toBe(\"resource\");\n            }\n        });\n    });\n\n    describe(\"PromptMessage with ContentBlock\", () =\u003E {\n        test(\"should validate prompt message with resource link\", () =\u003E {\n            const promptMessage = {\n                role: \"assistant\",\n                content: {\n                    type: \"resource_link\",\n                    uri: \"file:///project/src/main.rs\",\n                    name: \"main.rs\",\n                    description: \"Primary application entry point\",\n                    mimeType: \"text/x-rust\"\n                }\n            };\n\n            const result = PromptMessageSchema.safeParse(promptMessage);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.content.type).toBe(\"resource_link\");\n            }\n        });\n    });\n\n    describe(\"CallToolResult with ContentBlock\", () =\u003E {\n        test(\"should validate tool result with resource links\", () =\u003E {\n            const toolResult = {\n                content: [\n                    {\n                        type: \"text\",\n                        text: \"Found the following files:\"\n                    },\n                    {\n                        type: \"resource_link\",\n                        uri: \"file:///project/src/main.rs\",\n                        name: \"main.rs\",\n                        description: \"Primary application entry point\",\n                        mimeType: \"text/x-rust\"\n                    },\n                    {\n                        type: \"resource_link\",\n                        uri: \"file:///project/src/lib.rs\",\n                        name: \"lib.rs\",\n                        description: \"Library exports\",\n                        mimeType: \"text/x-rust\"\n                    }\n                ]\n            };\n\n            const result = CallToolResultSchema.safeParse(toolResult);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.content).toHaveLength(3);\n                expect(result.data.content[0].type).toBe(\"text\");\n                expect(result.data.content[1].type).toBe(\"resource_link\");\n                expect(result.data.content[2].type).toBe(\"resource_link\");\n            }\n        });\n\n        test(\"should validate empty content array with default\", () =\u003E {\n            const toolResult = {};\n\n            const result = CallToolResultSchema.safeParse(toolResult);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.content).toEqual([]);\n            }\n        });\n    });\n\n    describe(\"CompleteRequest\", () =\u003E {\n        test(\"should validate a CompleteRequest without resolved field\", () =\u003E {\n            const request = {\n                method: \"completion/complete\",\n                params: {\n                    ref: { type: \"ref/prompt\", name: \"greeting\" },\n                    argument: { name: \"name\", value: \"A\" }\n                }\n            };\n\n            const result = CompleteRequestSchema.safeParse(request);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.method).toBe(\"completion/complete\");\n                expect(result.data.params.ref.type).toBe(\"ref/prompt\");\n                expect(result.data.params.context).toBeUndefined();\n            }\n        });\n\n        test(\"should validate a CompleteRequest with resolved field\", () =\u003E {\n            const request = {\n                method: \"completion/complete\",\n                params: {\n                    ref: { type: \"ref/resource\", uri: \"github://repos/{owner}/{repo}\" },\n                    argument: { name: \"repo\", value: \"t\" },\n                    context: {\n                        arguments: {\n                            \"{owner}\": \"microsoft\"\n                        }\n                    }\n                }\n            };\n\n            const result = CompleteRequestSchema.safeParse(request);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.params.context?.arguments).toEqual({\n                    \"{owner}\": \"microsoft\"\n                });\n            }\n        });\n\n        test(\"should validate a CompleteRequest with empty resolved field\", () =\u003E {\n            const request = {\n                method: \"completion/complete\",\n                params: {\n                    ref: { type: \"ref/prompt\", name: \"test\" },\n                    argument: { name: \"arg\", value: \"\" },\n                    context: {\n                        arguments: {}\n                    }\n                }\n            };\n\n            const result = CompleteRequestSchema.safeParse(request);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.params.context?.arguments).toEqual({});\n            }\n        });\n\n        test(\"should validate a CompleteRequest with multiple resolved variables\", () =\u003E {\n            const request = {\n                method: \"completion/complete\",\n                params: {\n                    ref: { type: \"ref/resource\", uri: \"api://v1/{tenant}/{resource}/{id}\" },\n                    argument: { name: \"id\", value: \"123\" },\n                    context: {\n                        arguments: {\n                            \"{tenant}\": \"acme-corp\",\n                            \"{resource}\": \"users\"\n                        }\n                    }\n                }\n            };\n\n            const result = CompleteRequestSchema.safeParse(request);\n            expect(result.success).toBe(true);\n            if (result.success) {\n                expect(result.data.params.context?.arguments).toEqual({\n                    \"{tenant}\": \"acme-corp\",\n                    \"{resource}\": \"users\"\n                });\n            }\n        });\n    });\n});\n",
      "hash": "86ec92cca63a1fd0a2c5446dfcde5d748b50c8f0ef560e4d47edf69ea3b206cb",
      "size": 11634
    },
    "/src/types.ts": {
      "type": "content",
      "content": "import { z, ZodTypeAny } from \"zod\";\nimport { AuthInfo } from \"./server/auth/types.js\";\n\nexport const LATEST_PROTOCOL_VERSION = \"2025-06-18\";\nexport const DEFAULT_NEGOTIATED_PROTOCOL_VERSION = \"2025-03-26\";\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  \"2025-03-26\",\n  \"2024-11-05\",\n  \"2024-10-07\",\n];\n\n/* JSON-RPC types */\nexport const JSONRPC_VERSION = \"2.0\";\n\n/**\n * A progress token, used to associate progress notifications with the original request.\n */\nexport const ProgressTokenSchema = z.union([z.string(), z.number().int()]);\n\n/**\n * An opaque token used to represent a cursor for pagination.\n */\nexport const CursorSchema = z.string();\n\nconst RequestMetaSchema = z\n  .object({\n    /**\n     * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\n     */\n    progressToken: z.optional(ProgressTokenSchema),\n  })\n  .passthrough();\n\nconst BaseRequestParamsSchema = z\n  .object({\n    _meta: z.optional(RequestMetaSchema),\n  })\n  .passthrough();\n\nexport const RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseRequestParamsSchema),\n});\n\nconst BaseNotificationParamsSchema = z\n  .object({\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\n\nexport const NotificationSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseNotificationParamsSchema),\n});\n\nexport const ResultSchema = z\n  .object({\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\n\n/**\n * A uniquely identifying ID for a request in JSON-RPC.\n */\nexport const RequestIdSchema = z.union([z.string(), z.number().int()]);\n\n/**\n * A request that expects a response.\n */\nexport const JSONRPCRequestSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: RequestIdSchema,\n  })\n  .merge(RequestSchema)\n  .strict();\n\nexport const isJSONRPCRequest = (value: unknown): value is JSONRPCRequest =\u003E\n  JSONRPCRequestSchema.safeParse(value).success;\n\n/**\n * A notification which does not expect a response.\n */\nexport const JSONRPCNotificationSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n  })\n  .merge(NotificationSchema)\n  .strict();\n\nexport const isJSONRPCNotification = (\n  value: unknown\n): value is JSONRPCNotification =\u003E\n  JSONRPCNotificationSchema.safeParse(value).success;\n\n/**\n * A successful (non-error) response to a request.\n */\nexport const JSONRPCResponseSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: RequestIdSchema,\n    result: ResultSchema,\n  })\n  .strict();\n\nexport const isJSONRPCResponse = (value: unknown): value is JSONRPCResponse =\u003E\n  JSONRPCResponseSchema.safeParse(value).success;\n\n/**\n * Error codes defined by the JSON-RPC specification.\n */\nexport enum ErrorCode {\n  // SDK error codes\n  ConnectionClosed = -32000,\n  RequestTimeout = -32001,\n\n  // Standard JSON-RPC error codes\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603,\n}\n\n/**\n * A response to a request that indicates an error occurred.\n */\nexport const JSONRPCErrorSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: RequestIdSchema,\n    error: z.object({\n      /**\n       * The error type that occurred.\n       */\n      code: z.number().int(),\n      /**\n       * A short description of the error. The message SHOULD be limited to a concise single sentence.\n       */\n      message: z.string(),\n      /**\n       * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).\n       */\n      data: z.optional(z.unknown()),\n    }),\n  })\n  .strict();\n\nexport const isJSONRPCError = (value: unknown): value is JSONRPCError =\u003E\n  JSONRPCErrorSchema.safeParse(value).success;\n\nexport const JSONRPCMessageSchema = z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema,\n]);\n\n/* Empty result */\n/**\n * A response that indicates success but carries no data.\n */\nexport const EmptyResultSchema = ResultSchema.strict();\n\n/* Cancellation */\n/**\n * This notification can be sent by either side to indicate that it is cancelling a previously-issued request.\n *\n * The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.\n *\n * This notification indicates that the result will be unused, so any associated processing SHOULD cease.\n *\n * A client MUST NOT attempt to cancel its `initialize` request.\n */\nexport const CancelledNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/cancelled\"),\n  params: BaseNotificationParamsSchema.extend({\n    /**\n     * The ID of the request to cancel.\n     *\n     * This MUST correspond to the ID of a request previously issued in the same direction.\n     */\n    requestId: RequestIdSchema,\n\n    /**\n     * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.\n     */\n    reason: z.string().optional(),\n  }),\n});\n\n/* Base Metadata */\n/**\n * Base metadata interface for common properties across resources, tools, prompts, and implementations.\n */\nexport const BaseMetadataSchema = z\n  .object({\n    /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */\n    name: z.string(),\n    /**\n    * Intended for UI and end-user contexts — optimized to be human-readable and easily understood,\n    * even by those unfamiliar with domain-specific terminology.\n    *\n    * If not provided, the name should be used for display (except for Tool,\n    * where `annotations.title` should be given precedence over using `name`,\n    * if present).\n    */\n    title: z.optional(z.string()),\n  })\n  .passthrough();\n\n/* Initialization */\n/**\n * Describes the name and version of an MCP implementation.\n */\nexport const ImplementationSchema = BaseMetadataSchema.extend({\n  version: z.string(),\n});\n\n/**\n * Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.\n */\nexport const ClientCapabilitiesSchema = z\n  .object({\n    /**\n     * Experimental, non-standard capabilities that the client supports.\n     */\n    experimental: z.optional(z.object({}).passthrough()),\n    /**\n     * Present if the client supports sampling from an LLM.\n     */\n    sampling: z.optional(z.object({}).passthrough()),\n    /**\n     * Present if the client supports eliciting user input.\n     */\n    elicitation: z.optional(z.object({}).passthrough()),\n    /**\n     * Present if the client supports listing roots.\n     */\n    roots: z.optional(\n      z\n        .object({\n          /**\n           * Whether the client supports issuing notifications for changes to the roots list.\n           */\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\n\n/**\n * This request is sent from the client to the server when it first connects, asking it to begin initialization.\n */\nexport const InitializeRequestSchema = RequestSchema.extend({\n  method: z.literal(\"initialize\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.\n     */\n    protocolVersion: z.string(),\n    capabilities: ClientCapabilitiesSchema,\n    clientInfo: ImplementationSchema,\n  }),\n});\n\nexport const isInitializeRequest = (value: unknown): value is InitializeRequest =\u003E\n  InitializeRequestSchema.safeParse(value).success;\n\n\n/**\n * Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.\n */\nexport const ServerCapabilitiesSchema = z\n  .object({\n    /**\n     * Experimental, non-standard capabilities that the server supports.\n     */\n    experimental: z.optional(z.object({}).passthrough()),\n    /**\n     * Present if the server supports sending log messages to the client.\n     */\n    logging: z.optional(z.object({}).passthrough()),\n    /**\n     * Present if the server supports sending completions to the client.\n     */\n    completions: z.optional(z.object({}).passthrough()),\n    /**\n     * Present if the server offers any prompt templates.\n     */\n    prompts: z.optional(\n      z\n        .object({\n          /**\n           * Whether this server supports issuing notifications for changes to the prompt list.\n           */\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    /**\n     * Present if the server offers any resources to read.\n     */\n    resources: z.optional(\n      z\n        .object({\n          /**\n           * Whether this server supports clients subscribing to resource updates.\n           */\n          subscribe: z.optional(z.boolean()),\n\n          /**\n           * Whether this server supports issuing notifications for changes to the resource list.\n           */\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    /**\n     * Present if the server offers any tools to call.\n     */\n    tools: z.optional(\n      z\n        .object({\n          /**\n           * Whether this server supports issuing notifications for changes to the tool list.\n           */\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\n\n/**\n * After receiving an initialize request from the client, the server sends this response.\n */\nexport const InitializeResultSchema = ResultSchema.extend({\n  /**\n   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.\n   */\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ImplementationSchema,\n  /**\n   * Instructions describing how to use the server and its features.\n   *\n   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a \"hint\" to the model. For example, this information MAY be added to the system prompt.\n   */\n  instructions: z.optional(z.string()),\n});\n\n/**\n * This notification is sent from the client to the server after initialization has finished.\n */\nexport const InitializedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/initialized\"),\n});\n\nexport const isInitializedNotification = (value: unknown): value is InitializedNotification =\u003E\n  InitializedNotificationSchema.safeParse(value).success;\n\n/* Ping */\n/**\n * A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.\n */\nexport const PingRequestSchema = RequestSchema.extend({\n  method: z.literal(\"ping\"),\n});\n\n/* Progress notifications */\nexport const ProgressSchema = z\n  .object({\n    /**\n     * The progress thus far. This should increase every time progress is made, even if the total is unknown.\n     */\n    progress: z.number(),\n    /**\n     * Total number of items to process (or total progress required), if known.\n     */\n    total: z.optional(z.number()),\n    /**\n     * An optional message describing the current progress.\n     */\n    message: z.optional(z.string()),\n  })\n  .passthrough();\n\n/**\n * An out-of-band notification used to inform the receiver of a progress update for a long-running request.\n */\nexport const ProgressNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/progress\"),\n  params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({\n    /**\n     * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.\n     */\n    progressToken: ProgressTokenSchema,\n  }),\n});\n\n/* Pagination */\nexport const PaginatedRequestSchema = RequestSchema.extend({\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * An opaque token representing the current pagination position.\n     * If provided, the server should return results starting after this cursor.\n     */\n    cursor: z.optional(CursorSchema),\n  }).optional(),\n});\n\nexport const PaginatedResultSchema = ResultSchema.extend({\n  /**\n   * An opaque token representing the pagination position after the last returned result.\n   * If present, there may be more results available.\n   */\n  nextCursor: z.optional(CursorSchema),\n});\n\n/* Resources */\n/**\n * The contents of a specific resource or sub-resource.\n */\nexport const ResourceContentsSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\n\nexport const TextResourceContentsSchema = ResourceContentsSchema.extend({\n  /**\n   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).\n   */\n  text: z.string(),\n});\n\n\n/**\n * A Zod schema for validating Base64 strings that is more performant and\n * robust for very large inputs than the default regex-based check. It avoids\n * stack overflows by using the native `atob` function for validation.\n */\nconst Base64Schema = z.string().refine(\n    (val) =\u003E {\n        try {\n            // atob throws a DOMException if the string contains characters\n            // that are not part of the Base64 character set.\n            atob(val);\n            return true;\n        } catch {\n            return false;\n        }\n    },\n    { message: \"Invalid Base64 string\" },\n);\n\nexport const BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  /**\n   * A base64-encoded string representing the binary data of the item.\n   */\n  blob: Base64Schema,\n});\n\n/**\n * A known resource that the server is capable of reading.\n */\nexport const ResourceSchema = BaseMetadataSchema.extend({\n  /**\n   * The URI of this resource.\n   */\n  uri: z.string(),\n\n  /**\n   * A description of what this resource represents.\n   *\n   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model.\n   */\n  description: z.optional(z.string()),\n\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: z.optional(z.string()),\n\n  /**\n   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n   * for notes on _meta usage.\n   */\n  _meta: z.optional(z.object({}).passthrough()),\n});\n\n/**\n * A template description for resources available on the server.\n */\nexport const ResourceTemplateSchema = BaseMetadataSchema.extend({\n  /**\n   * A URI template (according to RFC 6570) that can be used to construct resource URIs.\n   */\n  uriTemplate: z.string(),\n\n  /**\n   * A description of what this template is for.\n   *\n   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model.\n   */\n  description: z.optional(z.string()),\n\n  /**\n   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.\n   */\n  mimeType: z.optional(z.string()),\n\n  /**\n   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n   * for notes on _meta usage.\n   */\n  _meta: z.optional(z.object({}).passthrough()),\n});\n\n/**\n * Sent from the client to request a list of resources the server has.\n */\nexport const ListResourcesRequestSchema = PaginatedRequestSchema.extend({\n  method: z.literal(\"resources/list\"),\n});\n\n/**\n * The server's response to a resources/list request from the client.\n */\nexport const ListResourcesResultSchema = PaginatedResultSchema.extend({\n  resources: z.array(ResourceSchema),\n});\n\n/**\n * Sent from the client to request a list of resource templates the server has.\n */\nexport const ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend(\n  {\n    method: z.literal(\"resources/templates/list\"),\n  },\n);\n\n/**\n * The server's response to a resources/templates/list request from the client.\n */\nexport const ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({\n  resourceTemplates: z.array(ResourceTemplateSchema),\n});\n\n/**\n * Sent from the client to the server, to read a specific resource URI.\n */\nexport const ReadResourceRequestSchema = RequestSchema.extend({\n  method: z.literal(\"resources/read\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.\n     */\n    uri: z.string(),\n  }),\n});\n\n/**\n * The server's response to a resources/read request from the client.\n */\nexport const ReadResourceResultSchema = ResultSchema.extend({\n  contents: z.array(\n    z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  ),\n});\n\n/**\n * An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const ResourceListChangedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/resources/list_changed\"),\n});\n\n/**\n * Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.\n */\nexport const SubscribeRequestSchema = RequestSchema.extend({\n  method: z.literal(\"resources/subscribe\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.\n     */\n    uri: z.string(),\n  }),\n});\n\n/**\n * Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.\n */\nexport const UnsubscribeRequestSchema = RequestSchema.extend({\n  method: z.literal(\"resources/unsubscribe\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to unsubscribe from.\n     */\n    uri: z.string(),\n  }),\n});\n\n/**\n * A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.\n */\nexport const ResourceUpdatedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/resources/updated\"),\n  params: BaseNotificationParamsSchema.extend({\n    /**\n     * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\n     */\n    uri: z.string(),\n  }),\n});\n\n/* Prompts */\n/**\n * Describes an argument that a prompt can accept.\n */\nexport const PromptArgumentSchema = z\n  .object({\n    /**\n     * The name of the argument.\n     */\n    name: z.string(),\n    /**\n     * A human-readable description of the argument.\n     */\n    description: z.optional(z.string()),\n    /**\n     * Whether this argument must be provided.\n     */\n    required: z.optional(z.boolean()),\n  })\n  .passthrough();\n\n/**\n * A prompt or prompt template that the server offers.\n */\nexport const PromptSchema = BaseMetadataSchema.extend({\n  /**\n   * An optional description of what this prompt provides\n   */\n  description: z.optional(z.string()),\n  /**\n   * A list of arguments to use for templating the prompt.\n   */\n  arguments: z.optional(z.array(PromptArgumentSchema)),\n  /**\n   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n   * for notes on _meta usage.\n   */\n  _meta: z.optional(z.object({}).passthrough()),\n});\n\n/**\n * Sent from the client to request a list of prompts and prompt templates the server has.\n */\nexport const ListPromptsRequestSchema = PaginatedRequestSchema.extend({\n  method: z.literal(\"prompts/list\"),\n});\n\n/**\n * The server's response to a prompts/list request from the client.\n */\nexport const ListPromptsResultSchema = PaginatedResultSchema.extend({\n  prompts: z.array(PromptSchema),\n});\n\n/**\n * Used by the client to get a prompt provided by the server.\n */\nexport const GetPromptRequestSchema = RequestSchema.extend({\n  method: z.literal(\"prompts/get\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The name of the prompt or prompt template.\n     */\n    name: z.string(),\n    /**\n     * Arguments to use for templating the prompt.\n     */\n    arguments: z.optional(z.record(z.string())),\n  }),\n});\n\n/**\n * Text provided to or from an LLM.\n */\nexport const TextContentSchema = z\n  .object({\n    type: z.literal(\"text\"),\n    /**\n     * The text content of the message.\n     */\n    text: z.string(),\n\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\n\n/**\n * An image provided to or from an LLM.\n */\nexport const ImageContentSchema = z\n  .object({\n    type: z.literal(\"image\"),\n    /**\n     * The base64-encoded image data.\n     */\n    data: Base64Schema,\n    /**\n     * The MIME type of the image. Different providers may support different image types.\n     */\n    mimeType: z.string(),\n\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\n\n/**\n * An Audio provided to or from an LLM.\n */\nexport const AudioContentSchema = z\n  .object({\n    type: z.literal(\"audio\"),\n    /**\n     * The base64-encoded audio data.\n     */\n    data: Base64Schema,\n    /**\n     * The MIME type of the audio. Different providers may support different audio types.\n     */\n    mimeType: z.string(),\n\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\n\n/**\n * The contents of a resource, embedded into a prompt or tool call result.\n */\nexport const EmbeddedResourceSchema = z\n  .object({\n    type: z.literal(\"resource\"),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\n\n/**\n * A resource that the server is capable of reading, included in a prompt or tool call result.\n *\n * Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.\n */\nexport const ResourceLinkSchema = ResourceSchema.extend({\n  type: z.literal(\"resource_link\"),\n});\n\n/**\n * A content block that can be used in prompts and tool results.\n */\nexport const ContentBlockSchema = z.union([\n  TextContentSchema,\n  ImageContentSchema,\n  AudioContentSchema,\n  ResourceLinkSchema,\n  EmbeddedResourceSchema,\n]);\n\n/**\n * Describes a message returned as part of a prompt.\n */\nexport const PromptMessageSchema = z\n  .object({\n    role: z.enum([\"user\", \"assistant\"]),\n    content: ContentBlockSchema,\n  })\n  .passthrough();\n\n/**\n * The server's response to a prompts/get request from the client.\n */\nexport const GetPromptResultSchema = ResultSchema.extend({\n  /**\n   * An optional description for the prompt.\n   */\n  description: z.optional(z.string()),\n  messages: z.array(PromptMessageSchema),\n});\n\n/**\n * An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const PromptListChangedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/prompts/list_changed\"),\n});\n\n/* Tools */\n/**\n * Additional properties describing a Tool to clients.\n *\n * NOTE: all properties in ToolAnnotations are **hints**.\n * They are not guaranteed to provide a faithful description of\n * tool behavior (including descriptive properties like `title`).\n *\n * Clients should never make tool use decisions based on ToolAnnotations\n * received from untrusted servers.\n */\nexport const ToolAnnotationsSchema = z\n  .object({\n    /**\n     * A human-readable title for the tool.\n     */\n    title: z.optional(z.string()),\n\n    /**\n     * If true, the tool does not modify its environment.\n     *\n     * Default: false\n     */\n    readOnlyHint: z.optional(z.boolean()),\n\n    /**\n     * If true, the tool may perform destructive updates to its environment.\n     * If false, the tool performs only additive updates.\n     *\n     * (This property is meaningful only when `readOnlyHint == false`)\n     *\n     * Default: true\n     */\n    destructiveHint: z.optional(z.boolean()),\n\n    /**\n     * If true, calling the tool repeatedly with the same arguments\n     * will have no additional effect on the its environment.\n     *\n     * (This property is meaningful only when `readOnlyHint == false`)\n     *\n     * Default: false\n     */\n    idempotentHint: z.optional(z.boolean()),\n\n    /**\n     * If true, this tool may interact with an \"open world\" of external\n     * entities. If false, the tool's domain of interaction is closed.\n     * For example, the world of a web search tool is open, whereas that\n     * of a memory tool is not.\n     *\n     * Default: true\n     */\n    openWorldHint: z.optional(z.boolean()),\n  })\n  .passthrough();\n\n/**\n * Definition for a tool the client can call.\n */\nexport const ToolSchema = BaseMetadataSchema.extend({\n  /**\n   * A human-readable description of the tool.\n   */\n  description: z.optional(z.string()),\n  /**\n   * A JSON Schema object defining the expected parameters for the tool.\n   */\n  inputSchema: z\n    .object({\n      type: z.literal(\"object\"),\n      properties: z.optional(z.object({}).passthrough()),\n      required: z.optional(z.array(z.string())),\n    })\n    .passthrough(),\n  /**\n   * An optional JSON Schema object defining the structure of the tool's output returned in\n   * the structuredContent field of a CallToolResult.\n   */\n  outputSchema: z.optional(\n    z.object({\n      type: z.literal(\"object\"),\n      properties: z.optional(z.object({}).passthrough()),\n      required: z.optional(z.array(z.string())),\n    })\n      .passthrough()\n  ),\n  /**\n   * Optional additional tool information.\n   */\n  annotations: z.optional(ToolAnnotationsSchema),\n\n  /**\n   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n   * for notes on _meta usage.\n   */\n  _meta: z.optional(z.object({}).passthrough()),\n});\n\n/**\n * Sent from the client to request a list of tools the server has.\n */\nexport const ListToolsRequestSchema = PaginatedRequestSchema.extend({\n  method: z.literal(\"tools/list\"),\n});\n\n/**\n * The server's response to a tools/list request from the client.\n */\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema),\n});\n\n/**\n * The server's response to a tool call.\n */\nexport const CallToolResultSchema = ResultSchema.extend({\n  /**\n   * A list of content objects that represent the result of the tool call.\n   *\n   * If the Tool does not define an outputSchema, this field MUST be present in the result.\n   * For backwards compatibility, this field is always present, but it may be empty.\n   */\n  content: z.array(ContentBlockSchema).default([]),\n\n  /**\n   * An object containing structured tool output.\n   *\n   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.\n   */\n  structuredContent: z.object({}).passthrough().optional(),\n\n  /**\n   * Whether the tool call ended in an error.\n   *\n   * If not set, this is assumed to be false (the call was successful).\n   *\n   * Any errors that originate from the tool SHOULD be reported inside the result\n   * object, with `isError` set to true, _not_ as an MCP protocol-level error\n   * response. Otherwise, the LLM would not be able to see that an error occurred\n   * and self-correct.\n   *\n   * However, any errors in _finding_ the tool, an error indicating that the\n   * server does not support tool calls, or any other exceptional conditions,\n   * should be reported as an MCP error response.\n   */\n  isError: z.optional(z.boolean()),\n});\n\n/**\n * CallToolResultSchema extended with backwards compatibility to protocol version 2024-10-07.\n */\nexport const CompatibilityCallToolResultSchema = CallToolResultSchema.or(\n  ResultSchema.extend({\n    toolResult: z.unknown(),\n  }),\n);\n\n/**\n * Used by the client to invoke a tool provided by the server.\n */\nexport const CallToolRequestSchema = RequestSchema.extend({\n  method: z.literal(\"tools/call\"),\n  params: BaseRequestParamsSchema.extend({\n    name: z.string(),\n    arguments: z.optional(z.record(z.unknown())),\n  }),\n});\n\n/**\n * An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const ToolListChangedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/tools/list_changed\"),\n});\n\n/* Logging */\n/**\n * The severity of a log message.\n */\nexport const LoggingLevelSchema = z.enum([\n  \"debug\",\n  \"info\",\n  \"notice\",\n  \"warning\",\n  \"error\",\n  \"critical\",\n  \"alert\",\n  \"emergency\",\n]);\n\n/**\n * A request from the client to the server, to enable or adjust logging.\n */\nexport const SetLevelRequestSchema = RequestSchema.extend({\n  method: z.literal(\"logging/setLevel\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.\n     */\n    level: LoggingLevelSchema,\n  }),\n});\n\n/**\n * Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.\n */\nexport const LoggingMessageNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/message\"),\n  params: BaseNotificationParamsSchema.extend({\n    /**\n     * The severity of this log message.\n     */\n    level: LoggingLevelSchema,\n    /**\n     * An optional name of the logger issuing this message.\n     */\n    logger: z.optional(z.string()),\n    /**\n     * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.\n     */\n    data: z.unknown(),\n  }),\n});\n\n/* Sampling */\n/**\n * Hints to use for model selection.\n */\nexport const ModelHintSchema = z\n  .object({\n    /**\n     * A hint for a model name.\n     */\n    name: z.string().optional(),\n  })\n  .passthrough();\n\n/**\n * The server's preferences for model selection, requested of the client during sampling.\n */\nexport const ModelPreferencesSchema = z\n  .object({\n    /**\n     * Optional hints to use for model selection.\n     */\n    hints: z.optional(z.array(ModelHintSchema)),\n    /**\n     * How much to prioritize cost when selecting a model.\n     */\n    costPriority: z.optional(z.number().min(0).max(1)),\n    /**\n     * How much to prioritize sampling speed (latency) when selecting a model.\n     */\n    speedPriority: z.optional(z.number().min(0).max(1)),\n    /**\n     * How much to prioritize intelligence and capabilities when selecting a model.\n     */\n    intelligencePriority: z.optional(z.number().min(0).max(1)),\n  })\n  .passthrough();\n\n/**\n * Describes a message issued to or received from an LLM API.\n */\nexport const SamplingMessageSchema = z\n  .object({\n    role: z.enum([\"user\", \"assistant\"]),\n    content: z.union([TextContentSchema, ImageContentSchema, AudioContentSchema]),\n  })\n  .passthrough();\n\n/**\n * A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.\n */\nexport const CreateMessageRequestSchema = RequestSchema.extend({\n  method: z.literal(\"sampling/createMessage\"),\n  params: BaseRequestParamsSchema.extend({\n    messages: z.array(SamplingMessageSchema),\n    /**\n     * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.\n     */\n    systemPrompt: z.optional(z.string()),\n    /**\n     * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.\n     */\n    includeContext: z.optional(z.enum([\"none\", \"thisServer\", \"allServers\"])),\n    temperature: z.optional(z.number()),\n    /**\n     * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.\n     */\n    maxTokens: z.number().int(),\n    stopSequences: z.optional(z.array(z.string())),\n    /**\n     * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.\n     */\n    metadata: z.optional(z.object({}).passthrough()),\n    /**\n     * The server's preferences for which model to select.\n     */\n    modelPreferences: z.optional(ModelPreferencesSchema),\n  }),\n});\n\n/**\n * The client's response to a sampling/create_message request from the server. The client should inform the user before returning the sampled message, to allow them to inspect the response (human in the loop) and decide whether to allow the server to see it.\n */\nexport const CreateMessageResultSchema = ResultSchema.extend({\n  /**\n   * The name of the model that generated the message.\n   */\n  model: z.string(),\n  /**\n   * The reason why sampling stopped.\n   */\n  stopReason: z.optional(\n    z.enum([\"endTurn\", \"stopSequence\", \"maxTokens\"]).or(z.string()),\n  ),\n  role: z.enum([\"user\", \"assistant\"]),\n  content: z.discriminatedUnion(\"type\", [\n    TextContentSchema,\n    ImageContentSchema,\n    AudioContentSchema\n  ]),\n});\n\n/* Elicitation */\n/**\n * Primitive schema definition for boolean fields.\n */\nexport const BooleanSchemaSchema = z\n  .object({\n    type: z.literal(\"boolean\"),\n    title: z.optional(z.string()),\n    description: z.optional(z.string()),\n    default: z.optional(z.boolean()),\n  })\n  .passthrough();\n\n/**\n * Primitive schema definition for string fields.\n */\nexport const StringSchemaSchema = z\n  .object({\n    type: z.literal(\"string\"),\n    title: z.optional(z.string()),\n    description: z.optional(z.string()),\n    minLength: z.optional(z.number()),\n    maxLength: z.optional(z.number()),\n    format: z.optional(z.enum([\"email\", \"uri\", \"date\", \"date-time\"])),\n  })\n  .passthrough();\n\n/**\n * Primitive schema definition for number fields.\n */\nexport const NumberSchemaSchema = z\n  .object({\n    type: z.enum([\"number\", \"integer\"]),\n    title: z.optional(z.string()),\n    description: z.optional(z.string()),\n    minimum: z.optional(z.number()),\n    maximum: z.optional(z.number()),\n  })\n  .passthrough();\n\n/**\n * Primitive schema definition for enum fields.\n */\nexport const EnumSchemaSchema = z\n  .object({\n    type: z.literal(\"string\"),\n    title: z.optional(z.string()),\n    description: z.optional(z.string()),\n    enum: z.array(z.string()),\n    enumNames: z.optional(z.array(z.string())),\n  })\n  .passthrough();\n\n/**\n * Union of all primitive schema definitions.\n */\nexport const PrimitiveSchemaDefinitionSchema = z.union([\n  BooleanSchemaSchema,\n  StringSchemaSchema,\n  NumberSchemaSchema,\n  EnumSchemaSchema,\n]);\n\n/**\n * A request from the server to elicit user input via the client.\n * The client should present the message and form fields to the user.\n */\nexport const ElicitRequestSchema = RequestSchema.extend({\n  method: z.literal(\"elicitation/create\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The message to present to the user.\n     */\n    message: z.string(),\n    /**\n     * The schema for the requested user input.\n     */\n    requestedSchema: z\n      .object({\n        type: z.literal(\"object\"),\n        properties: z.record(z.string(), PrimitiveSchemaDefinitionSchema),\n        required: z.optional(z.array(z.string())),\n      })\n      .passthrough(),\n  }),\n});\n\n/**\n * The client's response to an elicitation/create request from the server.\n */\nexport const ElicitResultSchema = ResultSchema.extend({\n  /**\n   * The user's response action.\n   */\n  action: z.enum([\"accept\", \"decline\", \"cancel\"]),\n  /**\n   * The collected user input content (only present if action is \"accept\").\n   */\n  content: z.optional(z.record(z.string(), z.unknown())),\n});\n\n/* Autocomplete */\n/**\n * A reference to a resource or resource template definition.\n */\nexport const ResourceTemplateReferenceSchema = z\n  .object({\n    type: z.literal(\"ref/resource\"),\n    /**\n     * The URI or URI template of the resource.\n     */\n    uri: z.string(),\n  })\n  .passthrough();\n\n/**\n * @deprecated Use ResourceTemplateReferenceSchema instead\n */\nexport const ResourceReferenceSchema = ResourceTemplateReferenceSchema;\n\n/**\n * Identifies a prompt.\n */\nexport const PromptReferenceSchema = z\n  .object({\n    type: z.literal(\"ref/prompt\"),\n    /**\n     * The name of the prompt or prompt template\n     */\n    name: z.string(),\n  })\n  .passthrough();\n\n/**\n * A request from the client to the server, to ask for completion options.\n */\nexport const CompleteRequestSchema = RequestSchema.extend({\n  method: z.literal(\"completion/complete\"),\n  params: BaseRequestParamsSchema.extend({\n    ref: z.union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),\n    /**\n     * The argument's information\n     */\n    argument: z\n      .object({\n        /**\n         * The name of the argument\n         */\n        name: z.string(),\n        /**\n         * The value of the argument to use for completion matching.\n         */\n        value: z.string(),\n      })\n      .passthrough(),\n    context: z.optional(\n      z.object({\n        /**\n         * Previously-resolved variables in a URI template or prompt.\n         */\n        arguments: z.optional(z.record(z.string(), z.string())),\n      })\n    ),\n  }),\n});\n\n/**\n * The server's response to a completion/complete request\n */\nexport const CompleteResultSchema = ResultSchema.extend({\n  completion: z\n    .object({\n      /**\n       * An array of completion values. Must not exceed 100 items.\n       */\n      values: z.array(z.string()).max(100),\n      /**\n       * The total number of completion options available. This can exceed the number of values actually sent in the response.\n       */\n      total: z.optional(z.number().int()),\n      /**\n       * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\n       */\n      hasMore: z.optional(z.boolean()),\n    })\n    .passthrough(),\n});\n\n/* Roots */\n/**\n * Represents a root directory or file that the server can operate on.\n */\nexport const RootSchema = z\n  .object({\n    /**\n     * The URI identifying the root. This *must* start with file:// for now.\n     */\n    uri: z.string().startsWith(\"file://\"),\n    /**\n     * An optional name for the root.\n     */\n    name: z.optional(z.string()),\n\n    /**\n     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n     * for notes on _meta usage.\n     */\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\n\n/**\n * Sent from the server to request a list of root URIs from the client.\n */\nexport const ListRootsRequestSchema = RequestSchema.extend({\n  method: z.literal(\"roots/list\"),\n});\n\n/**\n * The client's response to a roots/list request from the server.\n */\nexport const ListRootsResultSchema = ResultSchema.extend({\n  roots: z.array(RootSchema),\n});\n\n/**\n * A notification from the client to the server, informing it that the list of roots has changed.\n */\nexport const RootsListChangedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/roots/list_changed\"),\n});\n\n/* Client messages */\nexport const ClientRequestSchema = z.union([\n  PingRequestSchema,\n  InitializeRequestSchema,\n  CompleteRequestSchema,\n  SetLevelRequestSchema,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ReadResourceRequestSchema,\n  SubscribeRequestSchema,\n  UnsubscribeRequestSchema,\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n]);\n\nexport const ClientNotificationSchema = z.union([\n  CancelledNotificationSchema,\n  ProgressNotificationSchema,\n  InitializedNotificationSchema,\n  RootsListChangedNotificationSchema,\n]);\n\nexport const ClientResultSchema = z.union([\n  EmptyResultSchema,\n  CreateMessageResultSchema,\n  ElicitResultSchema,\n  ListRootsResultSchema,\n]);\n\n/* Server messages */\nexport const ServerRequestSchema = z.union([\n  PingRequestSchema,\n  CreateMessageRequestSchema,\n  ElicitRequestSchema,\n  ListRootsRequestSchema,\n]);\n\nexport const ServerNotificationSchema = z.union([\n  CancelledNotificationSchema,\n  ProgressNotificationSchema,\n  LoggingMessageNotificationSchema,\n  ResourceUpdatedNotificationSchema,\n  ResourceListChangedNotificationSchema,\n  ToolListChangedNotificationSchema,\n  PromptListChangedNotificationSchema,\n]);\n\nexport const ServerResultSchema = z.union([\n  EmptyResultSchema,\n  InitializeResultSchema,\n  CompleteResultSchema,\n  GetPromptResultSchema,\n  ListPromptsResultSchema,\n  ListResourcesResultSchema,\n  ListResourceTemplatesResultSchema,\n  ReadResourceResultSchema,\n  CallToolResultSchema,\n  ListToolsResultSchema,\n]);\n\nexport class McpError extends Error {\n  constructor(\n    public readonly code: number,\n    message: string,\n    public readonly data?: unknown,\n  ) {\n    super(`MCP error ${code}: ${message}`);\n    this.name = \"McpError\";\n  }\n}\n\ntype Primitive = string | number | boolean | bigint | null | undefined;\ntype Flatten\u003CT\u003E = T extends Primitive\n  ? T\n  : T extends Array\u003Cinfer U\u003E\n  ? Array\u003CFlatten\u003CU\u003E\u003E\n  : T extends Set\u003Cinfer U\u003E\n  ? Set\u003CFlatten\u003CU\u003E\u003E\n  : T extends Map\u003Cinfer K, infer V\u003E\n  ? Map\u003CFlatten\u003CK\u003E, Flatten\u003CV\u003E\u003E\n  : T extends object\n  ? { [K in keyof T]: Flatten\u003CT[K]\u003E }\n  : T;\n\ntype Infer\u003CSchema extends ZodTypeAny\u003E = Flatten\u003Cz.infer\u003CSchema\u003E\u003E;\n\n/**\n * Headers that are compatible with both Node.js and the browser.\n */\nexport type IsomorphicHeaders = Record\u003Cstring, string | string[] | undefined\u003E;\n\n/**\n * Information about the incoming request.\n */\nexport interface RequestInfo {\n  /**\n   * The headers of the request.\n   */\n  headers: IsomorphicHeaders;\n}\n\n/**\n * Extra information about a message.\n */\nexport interface MessageExtraInfo {\n  /**\n   * The request information.\n   */\n  requestInfo?: RequestInfo;\n\n  /**\n   * The authentication information.\n   */\n  authInfo?: AuthInfo;\n}\n\n/* JSON-RPC types */\nexport type ProgressToken = Infer\u003Ctypeof ProgressTokenSchema\u003E;\nexport type Cursor = Infer\u003Ctypeof CursorSchema\u003E;\nexport type Request = Infer\u003Ctypeof RequestSchema\u003E;\nexport type RequestMeta = Infer\u003Ctypeof RequestMetaSchema\u003E;\nexport type Notification = Infer\u003Ctypeof NotificationSchema\u003E;\nexport type Result = Infer\u003Ctypeof ResultSchema\u003E;\nexport type RequestId = Infer\u003Ctypeof RequestIdSchema\u003E;\nexport type JSONRPCRequest = Infer\u003Ctypeof JSONRPCRequestSchema\u003E;\nexport type JSONRPCNotification = Infer\u003Ctypeof JSONRPCNotificationSchema\u003E;\nexport type JSONRPCResponse = Infer\u003Ctypeof JSONRPCResponseSchema\u003E;\nexport type JSONRPCError = Infer\u003Ctypeof JSONRPCErrorSchema\u003E;\nexport type JSONRPCMessage = Infer\u003Ctypeof JSONRPCMessageSchema\u003E;\n\n/* Empty result */\nexport type EmptyResult = Infer\u003Ctypeof EmptyResultSchema\u003E;\n\n/* Cancellation */\nexport type CancelledNotification = Infer\u003Ctypeof CancelledNotificationSchema\u003E;\n\n/* Base Metadata */\nexport type BaseMetadata = Infer\u003Ctypeof BaseMetadataSchema\u003E;\n\n/* Initialization */\nexport type Implementation = Infer\u003Ctypeof ImplementationSchema\u003E;\nexport type ClientCapabilities = Infer\u003Ctypeof ClientCapabilitiesSchema\u003E;\nexport type InitializeRequest = Infer\u003Ctypeof InitializeRequestSchema\u003E;\nexport type ServerCapabilities = Infer\u003Ctypeof ServerCapabilitiesSchema\u003E;\nexport type InitializeResult = Infer\u003Ctypeof InitializeResultSchema\u003E;\nexport type InitializedNotification = Infer\u003Ctypeof InitializedNotificationSchema\u003E;\n\n/* Ping */\nexport type PingRequest = Infer\u003Ctypeof PingRequestSchema\u003E;\n\n/* Progress notifications */\nexport type Progress = Infer\u003Ctypeof ProgressSchema\u003E;\nexport type ProgressNotification = Infer\u003Ctypeof ProgressNotificationSchema\u003E;\n\n/* Pagination */\nexport type PaginatedRequest = Infer\u003Ctypeof PaginatedRequestSchema\u003E;\nexport type PaginatedResult = Infer\u003Ctypeof PaginatedResultSchema\u003E;\n\n/* Resources */\nexport type ResourceContents = Infer\u003Ctypeof ResourceContentsSchema\u003E;\nexport type TextResourceContents = Infer\u003Ctypeof TextResourceContentsSchema\u003E;\nexport type BlobResourceContents = Infer\u003Ctypeof BlobResourceContentsSchema\u003E;\nexport type Resource = Infer\u003Ctypeof ResourceSchema\u003E;\nexport type ResourceTemplate = Infer\u003Ctypeof ResourceTemplateSchema\u003E;\nexport type ListResourcesRequest = Infer\u003Ctypeof ListResourcesRequestSchema\u003E;\nexport type ListResourcesResult = Infer\u003Ctypeof ListResourcesResultSchema\u003E;\nexport type ListResourceTemplatesRequest = Infer\u003Ctypeof ListResourceTemplatesRequestSchema\u003E;\nexport type ListResourceTemplatesResult = Infer\u003Ctypeof ListResourceTemplatesResultSchema\u003E;\nexport type ReadResourceRequest = Infer\u003Ctypeof ReadResourceRequestSchema\u003E;\nexport type ReadResourceResult = Infer\u003Ctypeof ReadResourceResultSchema\u003E;\nexport type ResourceListChangedNotification = Infer\u003Ctypeof ResourceListChangedNotificationSchema\u003E;\nexport type SubscribeRequest = Infer\u003Ctypeof SubscribeRequestSchema\u003E;\nexport type UnsubscribeRequest = Infer\u003Ctypeof UnsubscribeRequestSchema\u003E;\nexport type ResourceUpdatedNotification = Infer\u003Ctypeof ResourceUpdatedNotificationSchema\u003E;\n\n/* Prompts */\nexport type PromptArgument = Infer\u003Ctypeof PromptArgumentSchema\u003E;\nexport type Prompt = Infer\u003Ctypeof PromptSchema\u003E;\nexport type ListPromptsRequest = Infer\u003Ctypeof ListPromptsRequestSchema\u003E;\nexport type ListPromptsResult = Infer\u003Ctypeof ListPromptsResultSchema\u003E;\nexport type GetPromptRequest = Infer\u003Ctypeof GetPromptRequestSchema\u003E;\nexport type TextContent = Infer\u003Ctypeof TextContentSchema\u003E;\nexport type ImageContent = Infer\u003Ctypeof ImageContentSchema\u003E;\nexport type AudioContent = Infer\u003Ctypeof AudioContentSchema\u003E;\nexport type EmbeddedResource = Infer\u003Ctypeof EmbeddedResourceSchema\u003E;\nexport type ResourceLink = Infer\u003Ctypeof ResourceLinkSchema\u003E;\nexport type ContentBlock = Infer\u003Ctypeof ContentBlockSchema\u003E;\nexport type PromptMessage = Infer\u003Ctypeof PromptMessageSchema\u003E;\nexport type GetPromptResult = Infer\u003Ctypeof GetPromptResultSchema\u003E;\nexport type PromptListChangedNotification = Infer\u003Ctypeof PromptListChangedNotificationSchema\u003E;\n\n/* Tools */\nexport type ToolAnnotations = Infer\u003Ctypeof ToolAnnotationsSchema\u003E;\nexport type Tool = Infer\u003Ctypeof ToolSchema\u003E;\nexport type ListToolsRequest = Infer\u003Ctypeof ListToolsRequestSchema\u003E;\nexport type ListToolsResult = Infer\u003Ctypeof ListToolsResultSchema\u003E;\nexport type CallToolResult = Infer\u003Ctypeof CallToolResultSchema\u003E;\nexport type CompatibilityCallToolResult = Infer\u003Ctypeof CompatibilityCallToolResultSchema\u003E;\nexport type CallToolRequest = Infer\u003Ctypeof CallToolRequestSchema\u003E;\nexport type ToolListChangedNotification = Infer\u003Ctypeof ToolListChangedNotificationSchema\u003E;\n\n/* Logging */\nexport type LoggingLevel = Infer\u003Ctypeof LoggingLevelSchema\u003E;\nexport type SetLevelRequest = Infer\u003Ctypeof SetLevelRequestSchema\u003E;\nexport type LoggingMessageNotification = Infer\u003Ctypeof LoggingMessageNotificationSchema\u003E;\n\n/* Sampling */\nexport type SamplingMessage = Infer\u003Ctypeof SamplingMessageSchema\u003E;\nexport type CreateMessageRequest = Infer\u003Ctypeof CreateMessageRequestSchema\u003E;\nexport type CreateMessageResult = Infer\u003Ctypeof CreateMessageResultSchema\u003E;\n\n/* Elicitation */\nexport type BooleanSchema = Infer\u003Ctypeof BooleanSchemaSchema\u003E;\nexport type StringSchema = Infer\u003Ctypeof StringSchemaSchema\u003E;\nexport type NumberSchema = Infer\u003Ctypeof NumberSchemaSchema\u003E;\nexport type EnumSchema = Infer\u003Ctypeof EnumSchemaSchema\u003E;\nexport type PrimitiveSchemaDefinition = Infer\u003Ctypeof PrimitiveSchemaDefinitionSchema\u003E;\nexport type ElicitRequest = Infer\u003Ctypeof ElicitRequestSchema\u003E;\nexport type ElicitResult = Infer\u003Ctypeof ElicitResultSchema\u003E;\n\n/* Autocomplete */\nexport type ResourceTemplateReference = Infer\u003Ctypeof ResourceTemplateReferenceSchema\u003E;\n/**\n * @deprecated Use ResourceTemplateReference instead\n */\nexport type ResourceReference = ResourceTemplateReference;\nexport type PromptReference = Infer\u003Ctypeof PromptReferenceSchema\u003E;\nexport type CompleteRequest = Infer\u003Ctypeof CompleteRequestSchema\u003E;\nexport type CompleteResult = Infer\u003Ctypeof CompleteResultSchema\u003E;\n\n/* Roots */\nexport type Root = Infer\u003Ctypeof RootSchema\u003E;\nexport type ListRootsRequest = Infer\u003Ctypeof ListRootsRequestSchema\u003E;\nexport type ListRootsResult = Infer\u003Ctypeof ListRootsResultSchema\u003E;\nexport type RootsListChangedNotification = Infer\u003Ctypeof RootsListChangedNotificationSchema\u003E;\n\n/* Client messages */\nexport type ClientRequest = Infer\u003Ctypeof ClientRequestSchema\u003E;\nexport type ClientNotification = Infer\u003Ctypeof ClientNotificationSchema\u003E;\nexport type ClientResult = Infer\u003Ctypeof ClientResultSchema\u003E;\n\n/* Server messages */\nexport type ServerRequest = Infer\u003Ctypeof ServerRequestSchema\u003E;\nexport type ServerNotification = Infer\u003Ctypeof ServerNotificationSchema\u003E;\nexport type ServerResult = Infer\u003Ctypeof ServerResultSchema\u003E;\n",
      "hash": "36eccf5533b972c33f4eeb48b9c6f203303b1eea92b7926a13003f940e19628c",
      "size": 51619
    },
    "/tsconfig.cjs.json": {
      "type": "content",
      "content": "{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"outDir\": \"./dist/cjs\"\n  },\n  \"exclude\": [\"**/*.test.ts\", \"src/__mocks__/**/*\"]\n}\n",
      "hash": "ca6b4836a467046804b2ec38167d7b41ad580f7729aeffc254e34560fbe8a05c",
      "size": 201,
      "json": {
        "extends": "./tsconfig.json",
        "compilerOptions": {
          "module": "commonjs",
          "moduleResolution": "node",
          "outDir": "./dist/cjs"
        },
        "exclude": [
          "**/*.test.ts",
          "src/__mocks__/**/*"
        ]
      }
    },
    "/tsconfig.json": {
      "type": "content",
      "content": "{\n  \"compilerOptions\": {\n    \"target\": \"es2018\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"skipLibCheck\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"pkce-challenge\": [\"node_modules/pkce-challenge/dist/index.node\"]\n    }\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n",
      "hash": "4bb96c78fdb92af28df2d3c434d6a2161f0bde70f2030c0d34007717ac0420cb",
      "size": 573,
      "json": {
        "compilerOptions": {
          "target": "es2018",
          "module": "Node16",
          "moduleResolution": "Node16",
          "declaration": true,
          "declarationMap": true,
          "sourceMap": true,
          "outDir": "./dist",
          "strict": true,
          "esModuleInterop": true,
          "forceConsistentCasingInFileNames": true,
          "resolveJsonModule": true,
          "isolatedModules": true,
          "skipLibCheck": true,
          "baseUrl": ".",
          "paths": {
            "pkce-challenge": [
              "node_modules/pkce-challenge/dist/index.node"
            ]
          }
        },
        "include": [
          "src/**/*"
        ],
        "exclude": [
          "node_modules",
          "dist"
        ]
      }
    },
    "/tsconfig.prod.json": {
      "type": "content",
      "content": "{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist/esm\"\n  },\n  \"exclude\": [\"**/*.test.ts\", \"src/__mocks__/**/*\"]\n}\n",
      "hash": "b7b7e318d5f260e17048d82ed99cea19849f01465cfab24d94b094e6335f4554",
      "size": 143,
      "json": {
        "extends": "./tsconfig.json",
        "compilerOptions": {
          "outDir": "./dist/esm"
        },
        "exclude": [
          "**/*.test.ts",
          "src/__mocks__/**/*"
        ]
      }
    }
  }
}